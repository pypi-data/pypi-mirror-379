Metadata-Version: 2.4
Name: powerbin
Version: 1.1.1
Summary: PowerBin: Fast Adaptive Data Binning with Centroidal Power Diagrams
Home-page: https://pypi.org/project/powerbin/
Author: Michele Cappellari
Author-email: michele.cappellari@physics.ox.ac.uk
License: Other/Proprietary License
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: Science/Research
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3
Description-Content-Type: text/x-rst
Requires-Dist: plotbin
Requires-Dist: numpy
Requires-Dist: scipy
Requires-Dist: matplotlib
Dynamic: author
Dynamic: author-email
Dynamic: classifier
Dynamic: description
Dynamic: description-content-type
Dynamic: home-page
Dynamic: license
Dynamic: requires-dist
Dynamic: summary

The PowerBin Package
====================

**PowerBin: Fast Adaptive Data Binning with Centroidal Power Diagrams**

.. image:: https://users.physics.ox.ac.uk/~cappellari/images/powerbin-logo.svg
    :target: https://users.physics.ox.ac.uk/~cappellari/software/#sec:powerbin
    :width: 100
.. image:: https://img.shields.io/pypi/v/powerbin.svg
    :target: https://pypi.org/project/powerbin/
.. image:: https://img.shields.io/badge/arXiv-2509.06903-orange.svg
    :target: https://arxiv.org/abs/2509.06903
.. image:: https://img.shields.io/badge/DOI-10.48550/arXiv.2509.06903-green.svg
    :target: https://doi.org/10.48550/arXiv.2509.06903
    
This `PowerBin` package provides a Python implementation of the **PowerBin** algorithm — a modern alternative to the classic Voronoi binning method. Like Voronoi binning, it performs 2D adaptive spatial binning to achieve a nearly constant value per bin of a chosen *capacity* (e.g., signal‑to‑noise ratio or any other user‑defined function of the bin spaxels).

**Key advances over the classic method include:**

-   **Centroidal Power Diagram:** Produces bins that are nearly round, convex, and connected, and eliminates the disconnected or nested bins that could occur with earlier approaches.

-   **Scalability:** The entire algorithm scales with **O(N log N)** complexity, removing the **O(N^2)** bottleneck previously present in both the bin-accretion and regularization steps. This makes processing million‑pixel datasets practical.

-   **Stable CPD construction:** Generates the tessellation via a heuristic inspired by packed soap bubbles, avoiding the numerical fragility of formal CPD solvers with realistic non-additive capacities (e.g., correlated noise).

The algorithm combines a fast initial bin-accretion phase with iterative regularization, and is described in detail in `Cappellari (2025) <https://arxiv.org/abs/2509.06903>`_.

.. contents:: :depth: 2

Attribution
-----------

If you use this software for your research, please cite `Cappellari (2025)`_.
The BibTeX entry for the paper is::

    @ARTICLE{Cappellari2025,
        author = {{Cappellari}, M.},
        title = "{PowerBin: Fast adaptive data binning with Centroidal Power Diagrams}",
        journal = {MNRAS},
        eprint = {2509.06903},
        year = 2025,
        note = {submitted}
    }

Installation
------------

install with::

    pip install powerbin

Without write access to the global ``site-packages`` directory, use::

    pip install --user powerbin

To upgrade ``PowerBin`` to the latest version use::

    pip install --upgrade powerbin

Usage Examples
--------------

To learn how to use the ``PowerBin`` package, copy, modify and run
the example programs in the ``powerbin/examples`` directory.
It can be found within the main ``powerbin`` package installation folder
inside `site-packages <https://stackoverflow.com/a/46071447>`_.
The detailed documentation is contained in the docstring of the file
``powerbin/powerbin.py``, or on `PyPi <https://pypi.org/project/powerbin/>`_.

Minimal example
---------------

Below is a minimal usage example you can copy into a script (or run the
provided example in ``powerbin/examples/powerbin_example.py``).

This example demonstrates the two ways to specify the bin capacity:

1.  **As an array** (if ``additive=True``): For simple, additive capacities
    (e.g., when noise is Poissonian), where the bin capacity is the sum of
    pixel capacities. This is the fastest and recommended method for this case.
2.  **As a function** (if ``additive=False``): For complex, non-additive
    capacities (e.g., to model correlated noise), where the bin capacity is a
    custom function of its member pixels.

.. code-block:: python

    from importlib import resources
    import numpy as np
    import matplotlib.pyplot as plt
    from powerbin import PowerBin

    data_path = resources.files('powerbin') / 'examples/sample_data_ngc2273.txt'
    x, y, signal, noise = np.loadtxt(data_path).T
    xy = np.column_stack([x, y])

    target_sn = 50

    # This flag toggles between the two capacity specification methods.
    # Set to True for the additive array, False for the non-additive function.
    additive = True

    if additive:
        # ADDITIVE CASE: Use a pre-calculated array for efficiency.
        # The capacity (S/N)^2 is additive when noise is Poissonian.
        # This is the recommended approach for the additive case.
        capacity_spec = (signal / noise)**2

    else:
        # NON-ADDITIVE CASE: Define a function for custom capacity logic.
        # This example models correlated noise, where S/N does not improve as
        # fast as sqrt(N_pixels). We penalize the S/N by a factor that grows
        # with the number of pixels in the bin (`len(index)`).
        def capacity_spec(index):
            """
            Calculates a non-additive S/N, penalized for bin size to model
            the effect of correlated noise. The result is squared to maintain
            the (S/N)^2 capacity definition.
            """
            # Standard S/N for the bin
            sn = np.sum(signal[index]) / np.sqrt(np.sum(noise[index]**2))
            # Apply penalty for correlated noise
            sn /= 1 + 1.07 * np.log10(len(index))
            return sn**2

    pow = PowerBin(xy, capacity_spec, target_capacity=target_sn**2, verbose=1)

    # The binning was performed on (S/N)^2, but for plotting we want S/N.
    # Apply a square-root scaling to the capacity before plotting.
    pow.plot(capacity_scale='sqrt', ylabel='S/N')

    plt.show()

###########################################################################

PowerBin Class
==============

PowerBin Purpose
----------------

Performs 2D adaptive spatial binning using Centroidal Power Diagrams.

This class implements the **PowerBin** algorithm described in
`Cappellari (2025) <https://arxiv.org/abs/2509.06903>`_. It partitions
a set of 2D points (pixels) into bins, aiming for a nearly constant
*capacity* per bin (e.g., signal-to-noise squared).

Key advances over classic Voronoi binning include:

- **Centroidal Power Diagram:** Produces nearly round, convex, and
  connected bins, avoiding issues like disconnected or nested bins.

- **Scalability:** Uses O(N log N) algorithms, making it practical for
  datasets with millions of pixels.

- **Stable Construction:** Employs a robust heuristic for building the
  diagram, avoiding numerical fragility.

The algorithm has two main stages:

1. **Bin Accretion:** Generates an initial set of bin centers.

2. **Regularization:** Iteratively adjusts bin shapes to equalize their
   capacities.

Parameters
----------
xy: array_like of shape (npix, 2)
    Coordinates of the pixels to be binned.

capacity_spec: callable or array_like of shape (npix,)
    The rule for calculating capacity, given in one of two forms:

    - **Callable:** A function ``fun(indices, *args) -> float`` that returns
      the total capacity of a bin containing the pixels at ``indices``.
      This allows for non-additive capacity definitions (for example with
      correlated noise).

    - **Array-like:** A 1D array ``dens`` of length ``npix``, where
      ``dens[j]`` is the additive capacity of pixel ``j``. The capacity of
      a bin is the sum of ``dens`` over its member pixels. This is faster.

target_capacity: float
    The target capacity value for each bin.

pixelsize: float, optional
    The size of a pixel in the input coordinate units. This is used to
    internally work in pixel units for numerical stability. If ``None``,
    it is estimated as the median distance to the second-nearest neighbor.

verbose: int, optional
    Controls the level of printed output:

    - 0: No output.
    - 1: Basic summary (default).
    - 2: Detailed iteration-by-iteration progress.
    - 3: Same as 2, but also plots the binning at each iteration.

regul: bool, optional
    If ``True`` (default), performs the iterative regularization step after
    the initial accretion. If ``False``, only accretion is performed.

args: tuple, optional
    Additional positional arguments passed to ``capacity_spec`` when it is
    a callable function.

maxiter: int, optional
    Maximum number of iterations for the regularization step (default: 50).

Attributes
----------
xy: ndarray of shape (npix, 2)
    The original input pixel coordinates.

bin_num: ndarray of int of shape (npix,)
    An array where ``bin_num[j]`` gives the index of the bin containing
    pixel ``j``. This is the primary output for mapping pixels to bins.

pixel_capacity: ndarray of shape (npix,)
    The capacity of each individual input pixel, derived from
    ``capacity_spec``.

bin_capacity: ndarray of shape (nbin,)
    The final calculated capacity for each output bin.

xybin: ndarray of shape (nbin, 2)
    The coordinates of the Power Diagram generators (bin centers), in the
    same units as the input ``xy``.

rbin: ndarray of shape (nbin,)
    The radii of the Power Diagram generators, in the same units as ``xy``.

npix: ndarray of int of shape (nbin,)
    The number of pixels in each bin.

single: ndarray of bool of shape (nbin,)
    A boolean array indicating which bins contain one or zero pixels.

rms_frac: float
    The fractional root-mean-square scatter of the ``bin_capacity`` values,
    calculated as a percentage for non-single bins.

target_capacity, pixelsize, verbose, args :
    Stored values of the corresponding input parameters.

References
----------
.. [1] Cappellari, M. 2025, MNRAS submitted, https://arxiv.org/abs/2509.06903

License
=======

Copyright (C) 2025 Michele Cappellari  
E-mail: michele.cappellari_at_physics.ox.ac.uk  

Updated versions of this software are available at:  
https://pypi.org/project/powerbin/  

If you use this software in published research, please acknowledge it as:  
“PowerBin method by Cappellari (2025, MNRAS submitted)”  
https://arxiv.org/abs/2509.06903  

This software is provided “as is”, without any warranty of any kind,  
express or implied.  

Permission is granted for:  
 - Non-commercial use.  
 - Modification for personal or internal use, provided that this  
   copyright notice and disclaimer remain intact and unaltered  
   at the beginning of the file.  

All other rights are reserved. Redistribution of the code, in whole or in part,  
is strictly prohibited without prior written permission from the author.

###########################################################################

Changelog
---------

V1.1.1: Oxford, 25 September 2025
+++++++++++++++++++++++++++++++++

- Added a fast, vectorized code path for additive (array) capacities; callable
  capacities remain supported.
- Improved bin‑accretion (incremental centroid and r^2 updates) for lower
  runtime and memory use.
- Renamed and clarified key attributes (capacity_spec, pixel_capacity,
  bin_capacity) and updated docs/examples.
- Miscellaneous bug fixes and robustness improvements.

V1.0.6: Oxford, 17 September 2025
+++++++++++++++++++++++++++++++++

- Initial release.

