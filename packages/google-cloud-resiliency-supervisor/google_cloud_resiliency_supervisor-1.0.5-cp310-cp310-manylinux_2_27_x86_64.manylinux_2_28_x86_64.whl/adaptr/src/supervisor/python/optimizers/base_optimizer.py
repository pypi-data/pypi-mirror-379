"""Abstract definition of optimizer class."""

import abc
from adaptr.src.supervisor.python.elastic_strategies.base_strategy import (
    BaseStrategy,
    ScaleDirection,
)
from adaptr.src.core.python.mesh import Mesh
import adaptr.src.core.python.device_info as device_info
import adaptr_core


class BaseOptimizer(abc.ABC):
    """Base class for optimizing best strategy to apply in response to scaling event."""

    def __init__(
        self, mesh: Mesh, elastic_strategies: list[BaseStrategy] | None = None
    ):
        self.mesh = mesh
        self.strategy_registry = {}
        if elastic_strategies is not None:
            for strategy in elastic_strategies:
                strategy.update_mesh(self.mesh)
                self.strategy_registry[strategy.name] = strategy

    def register_starting_hosts(self, state: adaptr_core.SupervisorState) -> None:
        """Registers starting hosts in the optimizer.

        Args:
            events (adaptr_core.EventReports): The supervisor events containing the new hosts to register.
        """
        # Iterate through each host in the events and register them.
        for host_info_proto in state.host_info:
            host_info = device_info.host_info_from_proto(host_info_proto)
            self.mesh.add_physical_host_info(host_info)

        # Generate coordinates for the mesh.
        self.mesh.generate_coords()
        if not self.mesh.ready_to_use():
            raise RuntimeError("Mesh is not ready to use.")

        # Update strategies with the new mesh and perform deferred initialization.
        for strategy in self.strategy_registry.values():
            strategy.update_mesh(self.mesh)
            strategy.deferred_init()

    def register_elastic_strategy(self, strategy: BaseStrategy) -> None:
        """Register an elastic strategy.

        Args:
            strategy (BaseStrategy): The elastic strategy to register.
        """
        self.strategy_registry[strategy.name] = strategy
        strategy.update_mesh(self.mesh)

    def update(self, updated_mesh: Mesh) -> None:
        """Updates strategies."""
        for strategy in self.strategy_registry.values():
            strategy.update_mesh(updated_mesh)
        self.mesh = updated_mesh

    def remap(
        self, scale_direction: ScaleDirection, target_hosts: list[device_info.HostInfo]
    ) -> tuple[adaptr_core.CommandSet, Mesh]:
        """Remaps the training workload based on the scaling event.

        Args:
            scale_direction (ScaleDirection): The scale direction to optimize for.
            target_hosts (list[device_info.HostInfo]): List of hosts that have new updates.

        Returns:
            tuple[adaptr_core.CommandSet, Mesh]: A tuple containing the host commands and the updated mesh.
        """
        # Determine and apply the best strategy.
        best_strategy, updated_mesh = self.optimize(scale_direction, target_hosts)
        if best_strategy is not None:
            host_commands = best_strategy.generate_commands(
                scale_direction, updated_mesh
            )
        return host_commands, updated_mesh

    def optimize(
        self, scale_direction: ScaleDirection, target_hosts: list[device_info.HostInfo]
    ) -> tuple[BaseStrategy, Mesh]:
        """
        Optimizes the scale direction and target worker IDs by generating and evaluating strategies.

        Args:
            scale_direction (ScaleDirection): The scale direction to optimize.
            target_hosts (list[device_info.HostInfo]): List of hosts that have new updates.

        Returns:
            tuple[BaseStrategy, Any]: A tuple containing the best strategy and the updated mesh generated by the strategy.
        """
        generated_results = {}
        for strategy in self.strategy_registry.values():
            if strategy.can_apply_strategy(scale_direction, target_hosts):
                updated_mesh = strategy.generate_mesh(scale_direction, target_hosts)
                generated_results[strategy.name] = updated_mesh
        best_strategy = self.get_best_strategy(generated_results)
        return best_strategy, generated_results[best_strategy.name]

    @abc.abstractmethod
    def get_best_strategy(self, generated_results: dict[str, Mesh]) -> BaseStrategy:
        """Returns the best strategy based on the generated results.

        Args:
            generated_results (dict[BaseStrategy, Mesh]): A dictionary containing the generated results,

        Returns:
            BaseStrategy: The best strategy.
        """
        pass
