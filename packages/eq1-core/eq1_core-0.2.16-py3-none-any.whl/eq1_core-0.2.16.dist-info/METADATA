Metadata-Version: 2.4
Name: eq1-core
Version: 0.2.16
Summary: EQ1 ê²€ì‚¬ ì‹œìŠ¤í…œ í•µì‹¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ - ì¹´ë©”ë¼ ì œì–´, í†µì‹ , I/O ì²˜ë¦¬, ë”¥ëŸ¬ë‹ ì¶”ë¡  ê¸°ëŠ¥ ì œê³µ
Project-URL: Homepage, https://github.com/crefle/eq1-core
Project-URL: Documentation, https://github.com/crefle/eq1-core#readme
Project-URL: Repository, https://github.com/crefle/eq1-core.git
Project-URL: Issues, https://github.com/crefle/eq1-core/issues
Author-email: "CREFLE INC." <dev@crefle.com>
License: MIT
Keywords: camera,deep-learning,industrial,inspection,quality-control,vision
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.12
Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Requires-Python: >=3.12
Requires-Dist: onnxruntime>=1.22.1
Requires-Dist: opencv-python>=4.11.0.86
Requires-Dist: passlib>=1.7.4
Requires-Dist: pillow>=10.0.0
Requires-Dist: pymysql>=1.1.1
Requires-Dist: sqlalchemy>=2.0.41
Requires-Dist: torch>=2.0.0
Requires-Dist: torchvision>=0.15.0
Provides-Extra: dev
Requires-Dist: black>=23.0.0; extra == 'dev'
Requires-Dist: flake8>=6.0.0; extra == 'dev'
Requires-Dist: pylint>=2.17.0; extra == 'dev'
Requires-Dist: pytest-cov>=4.0.0; extra == 'dev'
Requires-Dist: pytest>=7.0.0; extra == 'dev'
Provides-Extra: plotting
Requires-Dist: matplotlib<4.0.0,>=3.0.0; extra == 'plotting'
Provides-Extra: test
Requires-Dist: pytest-cov>=4.0.0; extra == 'test'
Requires-Dist: pytest-mock>=3.10.0; extra == 'test'
Requires-Dist: pytest>=7.0.0; extra == 'test'
Description-Content-Type: text/markdown

# EQ1 Core

EQ1 ê²€ì‚¬ ì‹œìŠ¤í…œì˜ í•µì‹¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ, ì¹´ë©”ë¼ ì œì–´, í†µì‹ , I/O ì²˜ë¦¬, ë”¥ëŸ¬ë‹ ì¶”ë¡  ë“±ì˜ ê²€ì‚¬ ì‹œìŠ¤í…œ í•µì‹¬ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.

## ğŸ“¦ íŒ¨í‚¤ì§€ ì„¤ì¹˜

### ğŸš¨ ì¤‘ìš”: TestPyPI ì˜ì¡´ì„± ë¬¸ì œë¡œ ì¸í•´ ë¡œì»¬ ì„¤ì¹˜ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤

TestPyPIì˜ ì˜ì¡´ì„± ì¶©ëŒ ë¬¸ì œë¡œ ì¸í•´ ì˜¨ë¼ì¸ ì„¤ì¹˜ê°€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤. ë°˜ë“œì‹œ ë¡œì»¬ ì„¤ì¹˜ íŒŒì¼ì„ ì‚¬ìš©í•´ì£¼ì„¸ìš”.

### ë¡œì»¬ ì„¤ì¹˜ ë°©ë²•

```bash
# 1. eq1-core í”„ë¡œì íŠ¸ì—ì„œ ë¹Œë“œ
cd /path/to/eq1-core
uv run python -m build

# 2. ë‹¤ë¥¸ í”„ë¡œì íŠ¸ì—ì„œ ë¡œì»¬ ì„¤ì¹˜
cd /path/to/your-project
uv pip install /path/to/eq1-core/dist/eq1_core-0.1.8-py3-none-any.whl
```

### ìƒëŒ€ ê²½ë¡œ ì„¤ì¹˜ (ê¶Œì¥)

```bash
# eq1-coreì™€ ê°™ì€ ë ˆë²¨ì˜ ë‹¤ë¥¸ í”„ë¡œì íŠ¸ì—ì„œ
uv pip install ../eq1-core/dist/eq1_core-0.1.8-py3-none-any.whl
```

### ì„¤ì¹˜ í™•ì¸

```bash
# ì„¤ì¹˜ í™•ì¸
python -c "import eq1core; print('EQ1 Core ì„¤ì¹˜ ì„±ê³µ!')"
```

## ğŸš€ ë¹ ë¥¸ ì‹œì‘

### í™˜ê²½ ì„¤ì •

```python
import os

# ë°ì´í„°ë² ì´ìŠ¤ ë° ë¡œê·¸ ê²½ë¡œ ì„¤ì •
os.environ["DB_URL"] = "mysql+pymysql://crefle:passwd@localhost:3307/eq1"
os.environ["LOG_PATH"] = "./public/logs"
```

### ê¸°ë³¸ ì‚¬ìš©ë²•

```python
from eq1core.core import Core
from eq1core.logger import AppLogger
from eq1core.signal import CustomEvent, InspectionEvents
from eq1core.engines.sample import SampleEngine
from eq1core.infrastructure.factory import DataServiceFactory
from eq1core.data import InspectionMode, InspectionPartResultData

# Core ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
core = Core(
    uuid="unique_id", 
    group_name="inspection_group", 
    data_service=DataServiceFactory.get_service('db'), 
    mode=InspectionMode.MULTI_SHOT
)

# ê²€ì‚¬ ì—”ì§„ ë“±ë¡
core.register_engine(SampleEngine)

# ê²€ì‚¬ ì‹œì‘
core.start()
```

## ğŸ“‹ ì£¼ìš” ê¸°ëŠ¥

- **ì¹´ë©”ë¼ ì œì–´**: ë‹¤ì–‘í•œ ì¹´ë©”ë¼ ì œì¡°ì‚¬ì˜ SDK ì§€ì›
- **í†µì‹  ì‹œìŠ¤í…œ**: TCP/UDP, ì‹œë¦¬ì–¼ í†µì‹  í”„ë¡œí† ì½œ
- **I/O ì²˜ë¦¬**: EZI I/O ë³´ë“œ ì œì–´ ë° ì‹ í˜¸ ì²˜ë¦¬
- **ë”¥ëŸ¬ë‹ ì¶”ë¡ **: ONNX, PyTorch ëª¨ë¸ ì§€ì›
- **ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ**: ë¹„ë™ê¸° ì´ë²¤íŠ¸ ì²˜ë¦¬ ë° ê´€ë¦¬
- **ë°ì´í„° ê´€ë¦¬**: ê²€ì‚¬ ê²°ê³¼ ë° ë¡œê·¸ ê´€ë¦¬

## ğŸ”§ ê°œë°œ í™˜ê²½ ì„¤ì •

### í•„ìˆ˜ ìš”êµ¬ì‚¬í•­

- Python 3.12 ì´ìƒ
- UV Package Manager (ê¶Œì¥)

### ë¡œì»¬ ê°œë°œ ì„¤ì¹˜

```bash
# ì €ì¥ì†Œ í´ë¡ 
git clone https://github.com/crefle/eq1-core.git
cd eq1-core

# UVë¥¼ ì‚¬ìš©í•œ ê°œë°œ í™˜ê²½ ì„¤ì •
uv sync --dev

# ê°œë°œ ëª¨ë“œë¡œ íŒ¨í‚¤ì§€ ì„¤ì¹˜
uv pip install -e .
```

### ì˜ì¡´ì„± ê´€ë¦¬

```bash
# ìƒˆë¡œìš´ ì˜ì¡´ì„± ì¶”ê°€
uv add package-name

# ê°œë°œ ì˜ì¡´ì„± ì¶”ê°€
uv add --dev package-name

# ì˜ì¡´ì„± ì œê±°
uv remove package-name
```

## ğŸ—ï¸ í”„ë¡œì íŠ¸ êµ¬ì¡°

```
src/eq1core/
â”œâ”€â”€ __init__.py          # íŒ¨í‚¤ì§€ ì´ˆê¸°í™”
â”œâ”€â”€ core.py              # í•µì‹¬ ì‹œìŠ¤í…œ í´ë˜ìŠ¤
â”œâ”€â”€ signal.py            # ì‹œê·¸ë„ ì‹œìŠ¤í…œ
â”œâ”€â”€ data.py              # ë°ì´í„° ëª¨ë¸
â”œâ”€â”€ dto.py               # ë°ì´í„° ì „ì†¡ ê°ì²´
â”œâ”€â”€ utils.py             # ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
â”œâ”€â”€ logger.py            # ë¡œê¹… ì‹œìŠ¤í…œ
â”œâ”€â”€ configure.py         # ì„¤ì • ê´€ë¦¬
â”œâ”€â”€ lib/                 # í•˜ìœ„ ë¼ì´ë¸ŒëŸ¬ë¦¬
â”‚   â”œâ”€â”€ camera/          # ì¹´ë©”ë¼ ì œì–´
â”‚   â”œâ”€â”€ communication/   # í†µì‹  ì‹œìŠ¤í…œ
â”‚   â”œâ”€â”€ ezi_io/          # I/O ì²˜ë¦¬
â”‚   â””â”€â”€ disk/            # ë””ìŠ¤í¬ ìœ í‹¸ë¦¬í‹°
â”œâ”€â”€ domain/              # ë„ë©”ì¸ ë¡œì§
â”‚   â”œâ”€â”€ entities/        # ì—”í‹°í‹°
â”‚   â”œâ”€â”€ ports/           # í¬íŠ¸ ì¸í„°í˜ì´ìŠ¤
â”‚   â””â”€â”€ services/        # ë„ë©”ì¸ ì„œë¹„ìŠ¤
â”œâ”€â”€ infrastructure/      # ì¸í”„ë¼ìŠ¤íŠ¸ëŸ­ì²˜
â”‚   â”œâ”€â”€ db/              # ë°ì´í„°ë² ì´ìŠ¤
â”‚   â””â”€â”€ api/             # API ì„œë¹„ìŠ¤
â”œâ”€â”€ engines/             # ê²€ì‚¬ ì—”ì§„
â”œâ”€â”€ predictors/          # ì˜ˆì¸¡ ëª¨ë¸
â”œâ”€â”€ inspection/          # ê²€ì‚¬ ì›Œì»¤
â”œâ”€â”€ dl/                  # ë”¥ëŸ¬ë‹ ëª¨ë¸
â””â”€â”€ mock/                # ëª©ì—… ê°ì²´
```

## ğŸ“š ì‚¬ìš©ë²•

### ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ ì‚¬ìš©ë²•

```python
from eq1core.signal import CustomEvent, InspectionEvents

# ì»¤ìŠ¤í…€ ì´ë²¤íŠ¸ ì •ì˜
class MyCustomEvent(CustomEvent):
    def __init__(self):
        super().__init__(
            name="my_custom_event",
            description="ì‚¬ìš©ì ì •ì˜ ì´ë²¤íŠ¸",
            hook=lambda: print("ì´ë²¤íŠ¸ í›… ì‹¤í–‰")
        )

# ì´ë²¤íŠ¸ í›… ë“±ë¡
def on_inspection_finished(*args, **kwargs):
    data = args[0] if args else kwargs.get("inspection_part_result_data")
    print(f"ê²€ì‚¬ ì™„ë£Œ: ì¹´ë©”ë¼ {data.camera_number}, ê²°ê³¼ {data.result}")

core.register_hook(
    event_name=InspectionEvents.InspectionPartFinished().name,
    hook=on_inspection_finished
)

# ì´ë²¤íŠ¸ ë°œìƒ
core.emit(InspectionEvents.NewGroup().name, "PRODUCT-SERIAL-001")
```

### CLI ëª…ë ¹ì–´ ì‚¬ìš©ë²•

```python
from eq1core.decorators import cli_command

@cli_command("trigger")
def trigger_inspection(core: Core) -> bool:
    """ê²€ì‚¬ íŠ¸ë¦¬ê±° ëª…ë ¹ì–´"""
    # ì¹´ë©”ë¼ íŠ¸ë¦¬ê±° ë¡œì§
    return True

@cli_command("next")
def next_product(core) -> bool:
    """ë‹¤ìŒ ì œí’ˆ ì²˜ë¦¬ ëª…ë ¹ì–´"""
    serial = f"PRODUCT-{int(time.time())}"
    core.emit("next_signal", serial)
    return True
```

### ì¹´ë©”ë¼ ì œì–´

```python
from eq1core.lib.camera.frame_grabber.worker import ImageGrabber

# ì¹´ë©”ë¼ ì›Œì»¤ì—ì„œ ì†Œí”„íŠ¸ì›¨ì–´ íŠ¸ë¦¬ê±° ì‹¤í–‰
camera_serial = "DUMMY-CAM-SERIAL"
for worker in core._workers:
    if isinstance(worker, ImageGrabber):
        if worker.camera_serial == camera_serial:
            worker.execute_stream_software_trigger()
            break
```

### ë¡œê¹… ì‹œìŠ¤í…œ

```python
from eq1core.logger import AppLogger

# ì •ë³´ ë¡œê·¸
AppLogger.write_info(self, "ê²€ì‚¬ ì‹œìŠ¤í…œ ì‹œì‘", print_to_terminal=True)

# ë””ë²„ê·¸ ë¡œê·¸
AppLogger.write_debug(self, f"ì¹´ë©”ë¼ {camera_number} í”„ë ˆì„ {frame_number}", print_to_terminal=True)

# ì—ëŸ¬ ë¡œê·¸
AppLogger.write_error(self, f"ì˜¤ë¥˜ ë°œìƒ: {error_message}", print_to_terminal=True)
```

### Signal ì‹œìŠ¤í…œ ì‚¬ìš©ë²•

EQ1 CoreëŠ” PySide6ì™€ ì™„ì „íˆ í˜¸í™˜ë˜ëŠ” Signal/Slot ì‹œìŠ¤í…œì„ ì œê³µí•©ë‹ˆë‹¤.

#### 1. ê¸°ë³¸ Signal ì‚¬ìš©ë²•

```python
from eq1core.signal import Signal

# íƒ€ì…ì´ ì§€ì •ëœ Signal ìƒì„±
data_signal = Signal(str)
status_signal = Signal(str, int)
complex_signal = Signal(dict, list)

# í•¸ë“¤ëŸ¬ ì—°ê²°
def on_data_received(data):
    print(f"Data received: {data}")

def on_status_changed(status, code):
    print(f"Status: {status}, Code: {code}")

def on_complex_event(data_dict, data_list):
    print(f"Complex event: {data_dict}, {data_list}")

data_signal.connect(on_data_received)
status_signal.connect(on_status_changed)
complex_signal.connect(on_complex_event)

# Signal ë°œìƒ
data_signal.emit("Hello World")
status_signal.emit("Processing", 200)
complex_signal.emit({"key": "value"}, [1, 2, 3])
```

#### 2. Custom Signal ì‚¬ìš©ë²• (Core í†µí•©)

```python
from eq1core.core import Core

# Custom signal ìƒì„± (PySide6 ìŠ¤íƒ€ì¼ - ë°ì´í„° íƒ€ì…ë§Œ ì§€ì •)
core.create_custom_signal("my_signal", str)
core.create_custom_signal("status_update", str, str)
core.create_custom_signal("data_update", dict)

# í•¸ë“¤ëŸ¬ ì—°ê²°
def on_custom_event(data):
    print(f"Custom event received: {data}")

def on_status_update(status, timestamp):
    print(f"Status update: {status} at {timestamp}")

def on_data_update(data):
    print(f"Data update: {data}")

core.my_signal.connect(on_custom_event)
core.status_update.connect(on_status_update)
core.data_update.connect(on_data_update)

# âœ… core.my_signal.emit í˜•íƒœë¡œ ì‚¬ìš©
core.my_signal.emit("Hello from custom signal!")
core.status_update.emit("Processing", "2024-01-01 12:00:00")
core.data_update.emit({"message": "Complex data", "count": 42})

# ë™ì  signal ìƒì„± ë° ì‚¬ìš©
core.create_custom_signal("new_signal", str)
core.new_signal.connect(lambda x: print(f"New signal: {x}"))
core.new_signal.emit("Dynamic signal works!")

# Signal ì¡´ì¬ ì—¬ë¶€ í™•ì¸
print(f"my_signal exists: {hasattr(core, 'my_signal')}")

# ëª¨ë“  custom signal ì¡°íšŒ
all_signals = core.get_all_custom_signals()
for name, signal in all_signals.items():
    print(f"{name}: {signal}")
```

### íƒ€ì… ê²€ì¦ ê¸°ëŠ¥

Signalì€ PySide6ì™€ ìœ ì‚¬í•˜ê²Œ íƒ€ì… ê²€ì¦ì„ ì œê³µí•©ë‹ˆë‹¤:

```python
# íƒ€ì… ê²€ì¦ í™œì„±í™” (ê¸°ë³¸ê°’)
signal = Signal(str, int)
signal.emit("hello", 42)  # âœ… ì •ìƒ
signal.emit("hello", "world")  # âš ï¸ ê²½ê³ : int ëŒ€ì‹  str ì „ë‹¬

# íƒ€ì… ê²€ì¦ ë¹„í™œì„±í™” (ì„±ëŠ¥ ìµœì í™”)
signal.disable_type_checking()
signal.emit("hello", "world")  # âœ… ê²½ê³  ì—†ìŒ

# íƒ€ì… ê²€ì¦ ë‹¤ì‹œ í™œì„±í™”
signal.enable_type_checking()
```

### SignalEmitter ì‚¬ìš©ë²•

SignalEmitterë¥¼ ì‚¬ìš©í•˜ì—¬ ë™ì ìœ¼ë¡œ Signalì„ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```python
from eq1core.signal import SignalEmitter, create_signal, connect_signal, emit_signal

# SignalEmitter ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
emitter = SignalEmitter()

# íƒ€ì…ì´ ì§€ì •ëœ Signal ìƒì„±
user_signal = emitter.create_signal("user_signal", str)
status_signal = emitter.create_signal("status_signal", str, int)

# í•¸ë“¤ëŸ¬ ì—°ê²°
user_signal.connect(lambda data: print(f"User: {data}"))
status_signal.connect(lambda status, code: print(f"Status: {status} ({code})"))

# Signal ë°œìƒ
emitter.emit("user_signal", "User logged in")
emitter.emit("status_signal", "processing", 200)

# ì „ì—­ í¸ì˜ í•¨ìˆ˜ ì‚¬ìš©
global_signal = create_signal("global_signal", str)
connect_signal("global_signal", lambda msg: print(f"Global: {msg}"))
emit_signal("global_signal", "Hello from global")
```

### ë¹„ë™ê¸° Signal ì²˜ë¦¬

Signalì€ ë™ê¸° ë° ë¹„ë™ê¸° ìŠ¬ë¡¯ì„ ëª¨ë‘ ì§€ì›í•©ë‹ˆë‹¤:

```python
import asyncio
from eq1core.signal import Signal

# ë¹„ë™ê¸° ìŠ¬ë¡¯ì„ ê°€ì§„ Signal ìƒì„±
async def async_handler(data):
    await asyncio.sleep(0.1)  # ë¹„ë™ê¸° ì‘ì—… ì‹œë®¬ë ˆì´ì…˜
    print(f"Async processed: {data}")

def sync_handler(data):
    print(f"Sync processed: {data}")

# Signal ìƒì„± ë° ìŠ¬ë¡¯ ì—°ê²°
signal = Signal(str)
signal.connect(sync_handler)           # ë™ê¸° ìŠ¬ë¡¯
signal.connect(async_handler, is_async=True)  # ë¹„ë™ê¸° ìŠ¬ë¡¯

# ë™ê¸° ì‹¤í–‰
signal.emit("Hello")

# ë¹„ë™ê¸° ì‹¤í–‰ (ëª¨ë“  ìŠ¬ë¡¯ í¬í•¨)
await signal.emit_async("Hello Async")
```

### ì „ì—­ Signal ê´€ë¦¬

ì „ì—­ í•¨ìˆ˜ë“¤ì„ ì‚¬ìš©í•˜ì—¬ ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ì²´ì—ì„œ Signalì„ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```python
from eq1core.signal import create_signal, connect_signal, emit_signal, emit_signal_async

# ì „ì—­ Signal ìƒì„±
create_signal("app_status", str)
create_signal("data_update", dict)

# í•¸ë“¤ëŸ¬ ì—°ê²°
def on_status_change(status):
    print(f"App status: {status}")

def on_data_change(data):
    print(f"Data changed: {data}")

connect_signal("app_status", on_status_change)
connect_signal("data_update", on_data_change)

# Signal ë°œìƒ
emit_signal("app_status", "Running")
emit_signal("data_update", {"key": "value"})

# ë¹„ë™ê¸° Signal ë°œìƒ
await emit_signal_async("app_status", "Processing")
```

### Signalê³¼ SignalEmitterì˜ ì°¨ì´ì 

**Signal í´ë˜ìŠ¤**: ê°œë³„ Signal ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ê³  ê´€ë¦¬
- íƒ€ì…ì´ ì§€ì •ëœ Signal ìƒì„±
- ìŠ¬ë¡¯ ì—°ê²°/í•´ì œ
- ë™ê¸°/ë¹„ë™ê¸° emit ì§€ì›
- íƒ€ì… ê²€ì¦ ê¸°ëŠ¥

**SignalEmitter í´ë˜ìŠ¤**: ì—¬ëŸ¬ Signalì„ ê·¸ë£¹ìœ¼ë¡œ ê´€ë¦¬
- ë™ì  Signal ìƒì„± ë° ê´€ë¦¬
- ì´ë¦„ ê¸°ë°˜ Signal ì ‘ê·¼
- ì¼ê´„ Signal ê´€ë¦¬
- ì „ì—­ Signal ë„¤ì„ìŠ¤í˜ì´ìŠ¤

### PySide6ì™€ì˜ ì™„ì „í•œ í˜¸í™˜ì„±

EQ1 Coreì˜ Signal/Slot ì‹œìŠ¤í…œì€ PySide6ì™€ ì™„ì „íˆ ë™ì¼í•œ APIë¥¼ ì œê³µí•©ë‹ˆë‹¤:

```python
# PySide6 Signal
from PySide6.QtCore import Signal

class MyClass:
    data_changed = Signal(str)
    status_updated = Signal(str, int)

# EQ1 Core Signal (ì™„ì „íˆ ë™ì¼!)
from eq1core.signal import Signal

class MyClass:
    data_changed = Signal(str)
    status_updated = Signal(str, int)
```

**ì¶”ê°€ ê¸°ëŠ¥**:
- íƒ€ì… ê²€ì¦ ë° íŒíŠ¸ ì œê³µ
- ë¹„ë™ê¸° Signal/Slot ì§€ì›
- ë™ì  Signal ìƒì„± ë° ê´€ë¦¬
- ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•œ íƒ€ì… ê²€ì¦ ì œì–´
- ì „ì—­ Signal ê´€ë¦¬ ì‹œìŠ¤í…œ

### ì™„ì „í•œ ì• í”Œë¦¬ì¼€ì´ì…˜ ì˜ˆì œ

```python
class InspectionApp:
    def __init__(self, uuid: str, group_name: str):
        self._core = Core(
            uuid=uuid, 
            group_name=group_name, 
            data_service=DataServiceFactory.get_service('db'), 
            mode=InspectionMode.MULTI_SHOT
        )
        
        # ì´ë²¤íŠ¸ í›… ë“±ë¡
        self._core.register_hook(
            event_name=InspectionEvents.InspectionPartFinished().name,
            hook=self.on_finished_inspection_part
        )
        
        # ê²€ì‚¬ ì—”ì§„ ë“±ë¡
        self._core.register_engine(SampleEngine)
        
        # Custom Signal ìƒì„± ë° ì—°ê²°
        self._core.create_custom_signal("inspection_status", str)
        self._core.create_custom_signal("data_processed", dict)
        
        # Signal í•¸ë“¤ëŸ¬ ì—°ê²°
        self._core.inspection_status.connect(self.on_inspection_status_change)
        self._core.data_processed.connect(self.on_data_processed)
    
    def on_finished_inspection_part(self, *args, **kwargs):
        data = args[0] if args else kwargs.get("inspection_part_result_data")
        if data:
            AppLogger.write_info(self, f"ê²€ì‚¬ ì™„ë£Œ: {data.part_name} - {data.result}")
            
            # Custom Signal ë°œìƒ
            self._core.inspection_status.emit(f"ê²€ì‚¬ ì™„ë£Œ: {data.result}")
            self._core.data_processed.emit({
                "part_name": data.part_name,
                "result": data.result,
                "timestamp": data.timestamp
            })
    
    def on_inspection_status_change(self, status):
        print(f"ê²€ì‚¬ ìƒíƒœ ë³€ê²½: {status}")
    
    def on_data_processed(self, data):
        print(f"ë°ì´í„° ì²˜ë¦¬ ì™„ë£Œ: {data}")
    
    def run(self):
        AppLogger.write_info(self, "ê²€ì‚¬ ì‹œìŠ¤í…œ ì‹œì‘...", print_to_terminal=True)
        self._core.start()

# ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
if __name__ == "__main__":
    app = InspectionApp(uuid="-", group_name="PRODUCT-SAMPLE")
    app.run()
```

### Signal ì‹œìŠ¤í…œ í™œìš© ì˜ˆì œ

```python
from eq1core.signal import Signal, SignalEmitter

class DataProcessor:
    def __init__(self):
        # ê°œë³„ Signal ìƒì„±
        self.data_received = Signal(dict)
        self.processing_complete = Signal(dict, bool)
        
        # SignalEmitterë¥¼ ì‚¬ìš©í•œ ë™ì  Signal ê´€ë¦¬
        self.emitter = SignalEmitter()
        self.emitter.create_signal("status_update", str)
        self.emitter.create_signal("error_occurred", str, str)
    
    def process_data(self, data):
        # ìƒíƒœ ì—…ë°ì´íŠ¸ Signal ë°œìƒ
        self.emitter.emit("status_update", "Processing started")
        
        try:
            # ë°ì´í„° ìˆ˜ì‹  Signal ë°œìƒ
            self.data_received.emit(data)
            
            # ë°ì´í„° ì²˜ë¦¬ ë¡œì§...
            result = {"processed": True, "data": data}
            
            # ì²˜ë¦¬ ì™„ë£Œ Signal ë°œìƒ
            self.processing_complete.emit(result, True)
            self.emitter.emit("status_update", "Processing completed")
            
        except Exception as e:
            # ì˜¤ë¥˜ ë°œìƒ Signal ë°œìƒ
            self.emitter.emit("error_occurred", "Processing failed", str(e))
            self.processing_complete.emit({}, False)

# ì‚¬ìš© ì˜ˆì œ
processor = DataProcessor()

# Signal í•¸ë“¤ëŸ¬ ì—°ê²°
processor.data_received.connect(lambda data: print(f"ë°ì´í„° ìˆ˜ì‹ : {data}"))
processor.processing_complete.connect(lambda result, success: print(f"ì²˜ë¦¬ ì™„ë£Œ: {result}, ì„±ê³µ: {success}"))

# SignalEmitter Signal í•¸ë“¤ëŸ¬ ì—°ê²°
processor.emitter.get_signal("status_update").connect(lambda status: print(f"ìƒíƒœ: {status}"))
processor.emitter.get_signal("error_occurred").connect(lambda error, details: print(f"ì˜¤ë¥˜: {error} - {details}"))

# ë°ì´í„° ì²˜ë¦¬ ì‹¤í–‰
processor.process_data({"id": 1, "value": "test"})
```

## ğŸ§ª í…ŒìŠ¤íŠ¸

```bash
# í…ŒìŠ¤íŠ¸ ì‹¤í–‰
uv run pytest

# ì»¤ë²„ë¦¬ì§€ì™€ í•¨ê»˜ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
uv run pytest --cov=src/eq1core

# íŠ¹ì • í…ŒìŠ¤íŠ¸ íŒŒì¼ ì‹¤í–‰
uv run pytest tests/test_core.py
```

## ğŸ“¦ íŒ¨í‚¤ì§€ ë°°í¬

### ë¡œì»¬ ë¹Œë“œ

```bash
# íŒ¨í‚¤ì§€ ë¹Œë“œ
uv run python -m build

# ë¹Œë“œëœ íŒŒì¼ í™•ì¸
ls dist/
```

### PyPI ë°°í¬

```bash
# TestPyPIì— ë°°í¬ (í…ŒìŠ¤íŠ¸ìš©)
uv run python -m twine upload --repository testpypi dist/*

# PyPIì— ë°°í¬ (ì‹¤ì œ ë°°í¬)
uv run python -m twine upload dist/*
```

## ğŸ¤ ê¸°ì—¬ ê°€ì´ë“œë¼ì¸

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

### ì½”ë“œ ìŠ¤íƒ€ì¼

- Black í¬ë§¤í„° ì‚¬ìš©
- Flake8 ë¦°í„° ì¤€ìˆ˜
- Type hints ì‚¬ìš©
- Docstring ì‘ì„±

```bash
# ì½”ë“œ í¬ë§·íŒ…
uv run black src/eq1core/

# ë¦°íŒ…
uv run flake8 src/eq1core/

# íƒ€ì… ì²´í¬
uv run mypy src/eq1core/
```

## ğŸ“„ ë¼ì´ì„ ìŠ¤

ì´ í”„ë¡œì íŠ¸ëŠ” MIT ë¼ì´ì„ ìŠ¤ í•˜ì— ë°°í¬ë©ë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ [LICENSE](LICENSE) íŒŒì¼ì„ ì°¸ì¡°í•˜ì„¸ìš”.

## ğŸ“ ì§€ì›

- ì´ìŠˆ ë¦¬í¬íŠ¸: [GitHub Issues](https://github.com/crefle/eq1-core/issues)
- ë¬¸ì„œ: [GitHub Wiki](https://github.com/crefle/eq1-core/wiki)
- ì´ë©”ì¼: dev@crefle.com

## ğŸ”„ ë²„ì „ íˆìŠ¤í† ë¦¬

- **0.1.8**: ê²½ë¡œ êµ¬ì¡° ê°œì„  ë° ì˜ì¡´ì„± ë¬¸ì œ í•´ê²°
  - src ê²½ë¡œ ì™„ì „ ì œê±° ë° ìƒëŒ€ê²½ë¡œë¡œ ë³€ê²½
  - numpy ì˜ì¡´ì„± ì œê±°ë¡œ ì˜ì¡´ì„± ì¶©ëŒ í•´ê²°
  - example ë””ë ‰í† ë¦¬ import ê²½ë¡œ ìˆ˜ì •
  - multishot mode ë™ì‘ í™•ì¸ ì™„ë£Œ

- **0.1.7**: ì˜ì¡´ì„± ìµœì í™”
  - numpy ì˜ì¡´ì„± ì œê±°
  - TestPyPI í˜¸í™˜ì„± ê°œì„ 

- **0.1.6**: numpy ë²„ì „ í˜¸í™˜ì„± ê°œì„ 
  - numpy>=1.9.3ìœ¼ë¡œ ë²„ì „ ìš”êµ¬ì‚¬í•­ ì™„í™”

- **0.1.5**: numpy ë²„ì „ ì—…ë°ì´íŠ¸
  - numpy>=1.26.0ìœ¼ë¡œ í˜„ëŒ€ì  ë²„ì „ ì‚¬ìš©

- **0.1.4**: numpy ì˜ì¡´ì„± ì™„í™”
  - numpy>=1.24.0ìœ¼ë¡œ ì„¤ì •

- **0.1.3**: numpy ë²„ì „ ì¡°ì •
  - numpy>=1.21.0ìœ¼ë¡œ ì„¤ì •

- **0.1.2**: numpy ì˜ì¡´ì„± ì œê±°
  - numpy ì™„ì „ ì œê±°ë¡œ ì˜ì¡´ì„± ì¶©ëŒ í•´ê²°

- **0.1.1**: ì´ˆê¸° TestPyPI ë°°í¬
  - numpy>=2.3.1 (ì˜ì¡´ì„± ì¶©ëŒ ë°œìƒ)

- **0.1.0**: ì´ˆê¸° PyPI ë°°í¬ ë²„ì „
  - í•µì‹¬ ê²€ì‚¬ ì‹œìŠ¤í…œ ê¸°ëŠ¥
  - ì¹´ë©”ë¼ ì œì–´ ë° í†µì‹  ì‹œìŠ¤í…œ
  - ë”¥ëŸ¬ë‹ ì¶”ë¡  ì—”ì§„
  - ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ

