---
alwaysApply: true
---

## CREFLE INC.의 EQ-1 Core Python 기반 SW 개발 프로젝트의 기반 규칙입니다.

## README.md 작성 규칙
### 필수 섹션 구조
모든 README.md 파일은 다음 섹션들을 포함해야 합니다:

1. **프로젝트 제목** (H1)
2. **프로젝트 개요** (H2)
3. **기술 스택** (H2)
4. **설치 및 실행 방법** (H2)
5. **사용법** (H2)
6. **개발 환경 설정** (H2)
7. **프로젝트 구조** (H2)
8. **기여 가이드라인** (H2)
9. **라이선스** (H2)

### 작성 스타일 가이드
- 모든 제목은 한글로 작성
- 코드 블록은 언어별 하이라이팅 적용
- 이미지나 다이어그램은 가능한 한 포함
- 링크는 상대 경로 사용
- 이모지 사용으로 가독성 향상

## 코드 스타일 및 명명 규칙

- Python 변수, 함수, 모듈명은 PEP 8에 따라 snake_case를 사용하세요.
- 사용자 정의 클래스명은 PascalCase를 사용하세요. 예: CameraController, NetworkManager, IoProcessor
- 상수는 대문자와 언더스코어를 사용하세요. 예: MAX_FRAME_RATE, DEFAULT_TIMEOUT
- 카메라, 통신, I/O 관련 클래스는 명확한 접미사를 사용하세요. 예: CameraController, NetworkManager, IoProcessor

## 임포트 가이드라인

- 와일드카드 임포트는 피하고, 필요한 클래스나 모듈만 구체적으로 임포트하세요.
- 임포트 순서: 표준 라이브러리, 서드파티 라이브러리, 로컬 모듈 순으로 그룹화하세요.
- 카메라 및 딥러닝 관련 라이브러리 임포트 예시:
  ```python
  import cv2
  import numpy as np
  import torch
  from MvCameraControl_class import *
  ```

## 메모리 관리 및 리소스 처리

- 이미지 데이터는 사용 후 명시적으로 해제하세요. 예: del frame_data
- 카메라 연결이나 네트워크 연결 작업 시 컨텍스트 매니저나 try/finally 블록을 사용하세요.
- 대용량 이미지 처리 시 메모리 효율성을 고려하여 청크 단위로 처리하세요.
- GPU 메모리를 사용하는 경우 적절한 해제를 보장하세요.

## 성능 최적화

- 이미지 처리 알고리즘은 벡터화된 연산을 우선 사용하세요 (NumPy, OpenCV 활용).
- 반복적인 연산은 캐싱을 고려하세요.
- 멀티스레딩을 활용하여 병렬 처리를 구현하세요.
- 실시간 카메라 처리가 필요한 경우 알고리즘 최적화를 우선시하세요.

## 오류 처리 및 로깅

- 모든 카메라, 통신, I/O 함수는 try-except 블록으로 래핑하여 안정성을 보장하세요.
- 구조화된 로깅을 구현하여 시스템 동작과 오류를 체계적으로 기록하세요.
- 로그 레벨을 적절히 구분하여 사용하세요:
  1. DEBUG: 개발/디버깅용 상세 정보 (카메라 설정, 통신 패킷, 변수 값 등)
  2. INFO: 일반적인 시스템 동작 정보 (카메라 연결/해제, 통신 시작/종료 등)
  3. WARNING: 문제가 될 수 있는 상황이지만 계속 실행 가능한 경우
  4. ERROR: 카메라 연결 실패, 통신 오류, I/O 오류 등
  5. CRITICAL: 시스템 전체에 영향을 주는 심각한 오류

- 모든 로그는 `public/logs/` 디렉토리에 저장하여 사후 분석이 가능하도록 구현하세요.
- 시스템 상태와 결과는 데이터베이스에 체계적으로 저장하세요.
- 프로덕션 환경에서는 DEBUG 레벨 로그를 비활성화하여 성능을 최적화하세요.

## 아키텍처 패턴

- **Domain-Driven Design (DDD)** 패턴을 기반으로 계층별 의존성 방향을 관리하세요:

  1. Presentation Layer: 사용자 인터페이스, 결과 표시 (프레임워크 종속)
  2. Application Layer: 카메라 워크플로우, 통신 관리, 비즈니스 로직 (프레임워크 독립적)
  3. Domain Layer: 카메라 제어, 통신 프로토콜, I/O 처리, 엔티티, 도메인 서비스 (외부 종속성 없음)
  4. Infrastructure Layer: 카메라 SDK, 네트워크 통신, 데이터베이스, 외부 시스템 접근

- 의존성 역전 원칙(DIP)을 적용하여 상위 계층이 하위 계층에 의존하지 않도록 인터페이스(Protocol/ABC)를 사용하세요.
- 도메인 로직은 외부 라이브러리에 의존하지 않도록 순수한 Python으로 구현하세요.
- 각 계층 간 데이터 전달은 DTO(Data Transfer Object)나 도메인 엔티티를 사용하세요.

## 파일 구조 및 모듈 설계

- **카메라 관련**: `lib/camera/` - 카메라 제어, 프레임 그랩, 이미지 처리
- **통신 관련**: `lib/communication/` - 네트워크 통신, 프로토콜 처리
- **I/O 관련**: `lib/ezi_io/` - I/O 보드 제어, 신호 처리
- **딥러닝 관련**: `src/dl/` - AI 모델, 추론 엔진
- **데이터베이스**: `src/infrastructure/db/` - 데이터 저장, 조회
- **도메인**: `src/domain/` - 엔티티, 포트, 서비스
- **인프라**: `src/infrastructure/` - 외부 시스템 연동

## 카메라 및 통신 시스템 설계

- 모듈화된 설계를 통해 각 카메라와 통신 기능을 독립적으로 구현하세요.
- 카메라 설정은 설정 가능한 파라미터를 통해 유연성을 제공하세요.
- 통신 프로토콜은 표준화된 형식으로 구현하세요.
- 시스템 성능을 지속적으로 모니터링하고 최적화하세요.

## 이미지 처리 및 딥러닝

- 이미지 전처리 단계를 명확히 분리하세요 (노이즈 제거, 정규화, 필터링 등).
- 검사 영역(ROI)을 명확히 정의하고 관리하세요.
- 딥러닝 모델은 다양한 이미지 형식과 해상도를 지원하세요.
- 모델 추론 결과는 표준화된 형식으로 반환하세요.

## 데이터 관리

- 카메라 설정, 통신 로그, 검사 결과 데이터는 구조화된 형태로 저장하세요.
- 이미지 메타데이터와 검사 결과를 연관하여 관리하세요.
- 데이터 백업 및 복구 전략을 구현하세요.
- 시스템 이력 조회 및 통계 기능을 제공하세요.

## 개발 환경

- UV Package Management를 사용하여 프로젝트 의존성을 관리하세요:

  1. uv init 명령으로 프로젝트 초기화
  2. uv add opencv-python numpy torch pillow matplotlib 명령으로 라이브러리 설치
  3. uv.lock 파일을 통한 재현 가능한 의존성 관리
  4. uv run 명령으로 스크립트 실행

- Python 3.12 버전에서 개발하여 최신 언어 기능과 성능 향상을 활용하세요.
- 실행 환경의 최소 지원 버전을 Python 3.12로 설정하고, 그 이하의 하위 호환성은 보장하지 않습니다.
- pyproject.toml에 requires-python = ">=3.12"를 명시하여 버전 요구사항을 명확히 하세요.
- 린터(flake8, pylint)와 포매터(black)를 사용하여 프로젝트 전반에서 일관된 코딩 스타일을 유지하세요:

  1. uv add --dev black flake8 pylint 명령으로 개발 의존성 설치

- 더 나은 코드 문서화와 IDE 지원을 위해 타입 힌트를 사용하세요.

## 개발 계획 및 이슈 관리

- GitHub Issues를 통한 체계적인 이슈 관리 (개발자 직접 관리):

  1. 이슈 생성 시 명확한 제목과 상세한 설명을 포함하세요
  2. 라벨(label)을 활용하여 이슈 유형을 분류하세요: feature, bug, enhancement, documentation, camera, communication, io, dl
  3. 마일스톤(milestone)을 설정하여 릴리즈 계획과 연동하세요
  4. 이슈 템플릿을 활용하여 일관된 형식의 이슈 작성을 유도하세요

- AI-Driven Development 방법론을 적용하여 개발을 진행하세요:

  1. 기존에 생성된 GitHub Issue의 내용을 읽어와서 개발 계획 수립
  2. AI 도구(Claude, GitHub Copilot 등)와 협업하여 코드 설계 및 구현
  3. 반복적인 AI 피드백을 통한 코드 품질 개선
  4. AI 제안을 검토하고 적절히 수용/거부하는 개발자 판단력 유지

- TaskMaster (https://github.com/eyaltoledano/claude-task-master)를 활용한 개발 계획 수립 및 관리:

  1. GitHub Issue 정보를 자동으로 읽어와서 구조화된 개발 계획 생성
  2. 작업 단위별 세분화 및 우선순위 설정
  3. 진행 상황 추적 및 계획 조정

- 개발 완료 후 Pull Request 워크플로우:

  1. 이슈 번호를 포함한 브랜치 생성: feature/issue-123-add-camera-control
  2. Pull Request 생성 시 이슈 번호 연결: Closes #123
  3. AI 도구를 활용한 코드 리뷰 사전 검토
  4. 개발자 최종 검토 후 메인 브랜치에 병합

- 커밋 메시지는 Conventional Commits 형식을 따르세요:

  - feature: 새로운 기능 추가
  - fix: 버그 수정
  - docs: 문서 업데이트
  - test: 테스트 코드 추가/수정
  - refactor: 코드 리팩토링
  - perf: 성능 개선
  - camera: 카메라 관련 변경
  - communication: 통신 관련 변경
  - io: I/O 관련 변경
  - dl: 딥러닝 관련 변경

## 테스트 주도 개발 (TDD)

- 모든 개발 작업은 테스트 우선(Test-First) 원칙을 따르세요:

  1. Red: 실패하는 테스트 코드를 먼저 작성
  2. Green: 테스트를 통과하는 최소한의 코드 구현
  3. Refactor: 코드 품질 개선 및 최적화

- 단위 테스트는 모든 계획 단계의 가장 처음에 작성되어야 합니다.
- 테스트 범위 및 작성 가이드라인:

  1. 필수 테스트: Domain Layer의 모든 카메라 제어, 통신 프로토콜, I/O 처리
  2. 필수 테스트: Application Layer의 워크플로우와 서비스
  3. 선택적 테스트: Presentation Layer의 컨트롤러 로직
  4. 생략 가능: 순수 UI 코드 (레이아웃, 스타일, 단순 위젯 배치)

- 카메라 및 통신 시스템 테스트:

  1. 다양한 카메라 설정에서의 동작 검증
  2. 네트워크 통신 안정성 및 성능 측정
  3. I/O 신호 처리 정확도 검증
  4. 엣지 케이스 및 오류 상황 처리 검증

- 테스트 코드 구조화:

  1. tests/unit/: 단위 테스트
  2. tests/integration/: 통합 테스트
  3. tests/camera/: 카메라 관련 테스트
  4. tests/communication/: 통신 관련 테스트
  5. tests/io/: I/O 관련 테스트
  6. tests/fixtures/: 테스트 이미지 및 데이터

## 패키징 및 배포

- 독립 실행 파일 생성을 위해 PyInstaller 또는 Nuitka를 사용하세요.
- 배포 패키지에 필요한 모든 라이브러리와 모델 파일을 포함시키세요.
- 카메라 SDK 라이브러리와 딥러닝 모델 파일이 포함되었는지 확인하세요.
- 호환성을 보장하기 위해 릴리즈 전에 대상 환경에서 테스트하세요.
- 고객사 환경에 맞는 설치 가이드와 사용자 매뉴얼을 제공하세요.
- 시스템 설정 및 결과 데이터의 백업/복구 기능을 포함하세요.

## 주의사항

- 카메라 SDK (MvImport) 관련 코드는 주의해서 수정합니다
- 네트워크 통신 코드는 에러 처리를 철저히 합니다
- 딥러닝 모델 관련 코드는 성능을 고려합니다
- I/O 보드 제어는 안전성을 우선시합니다
- 실시간 시스템의 경우 지연 시간을 최소화합니다
description:
globs:
alwaysApply: false
---
