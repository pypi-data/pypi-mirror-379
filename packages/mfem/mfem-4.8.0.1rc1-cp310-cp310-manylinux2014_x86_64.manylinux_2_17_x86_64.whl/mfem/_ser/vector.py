# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _vector
else:
    import _vector

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _vector.SWIG_PyInstanceMethod_New
_swig_new_static_method = _vector.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import mfem._ser.array
import mfem._ser.mem_manager
import mfem._ser.globals

def add_vector(*args):
    r"""
    add_vector(Vector v1, Vector v2, Vector v)
    add_vector(Vector v1, double alpha, Vector v2, Vector v)
    add_vector(double const a, Vector x, Vector y, Vector z)
    add_vector(double const a, Vector x, double const b, Vector y, Vector z)
    """
    return _vector.add_vector(*args)
add_vector = _vector.add_vector

def subtract_vector(*args):
    r"""
    subtract_vector(Vector v1, Vector v2, Vector v)
    subtract_vector(double const a, Vector x, Vector y, Vector z)
    """
    return _vector.subtract_vector(*args)
subtract_vector = _vector.subtract_vector
class VectorArray(object):
    r"""Proxy of C++ mfem::Array< mfem::Vector * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vector.delete_VectorArray

    def GetData(self, *args):
        r"""
        GetData(VectorArray self) -> Vector
        GetData(VectorArray self) -> mfem::Vector *const *
        """
        return _vector.VectorArray_GetData(self, *args)
    GetData = _swig_new_instance_method(_vector.VectorArray_GetData)

    def GetMemory(self, *args):
        r"""
        GetMemory(VectorArray self) -> mfem::Memory< mfem::Vector * >
        GetMemory(VectorArray self) -> mfem::Memory< mfem::Vector * > const &
        """
        return _vector.VectorArray_GetMemory(self, *args)
    GetMemory = _swig_new_instance_method(_vector.VectorArray_GetMemory)

    def UseDevice(self):
        r"""UseDevice(VectorArray self) -> bool"""
        return _vector.VectorArray_UseDevice(self)
    UseDevice = _swig_new_instance_method(_vector.VectorArray_UseDevice)

    def OwnsData(self):
        r"""OwnsData(VectorArray self) -> bool"""
        return _vector.VectorArray_OwnsData(self)
    OwnsData = _swig_new_instance_method(_vector.VectorArray_OwnsData)

    def StealData(self, p):
        r"""StealData(VectorArray self, mfem::Vector *** p)"""
        return _vector.VectorArray_StealData(self, p)
    StealData = _swig_new_instance_method(_vector.VectorArray_StealData)

    def LoseData(self):
        r"""LoseData(VectorArray self)"""
        return _vector.VectorArray_LoseData(self)
    LoseData = _swig_new_instance_method(_vector.VectorArray_LoseData)

    def MakeDataOwner(self):
        r"""MakeDataOwner(VectorArray self)"""
        return _vector.VectorArray_MakeDataOwner(self)
    MakeDataOwner = _swig_new_instance_method(_vector.VectorArray_MakeDataOwner)

    def Size(self):
        r"""Size(VectorArray self) -> int"""
        return _vector.VectorArray_Size(self)
    Size = _swig_new_instance_method(_vector.VectorArray_Size)

    def SetSize(self, *args):
        r"""
        SetSize(VectorArray self, int nsize)
        SetSize(VectorArray self, int nsize, Vector initval)
        SetSize(VectorArray self, int nsize, mfem::MemoryType mt)
        """
        return _vector.VectorArray_SetSize(self, *args)
    SetSize = _swig_new_instance_method(_vector.VectorArray_SetSize)

    def Capacity(self):
        r"""Capacity(VectorArray self) -> int"""
        return _vector.VectorArray_Capacity(self)
    Capacity = _swig_new_instance_method(_vector.VectorArray_Capacity)

    def Reserve(self, capacity):
        r"""Reserve(VectorArray self, int capacity)"""
        return _vector.VectorArray_Reserve(self, capacity)
    Reserve = _swig_new_instance_method(_vector.VectorArray_Reserve)

    def Append(self, *args):
        r"""
        Append(VectorArray self, Vector el) -> int
        Append(VectorArray self, mfem::Vector *const * els, int nels) -> int
        Append(VectorArray self, VectorArray els) -> int
        """

        if isinstance(args[0], list):
           return self.Append(self.__class__(args[0]))
        if isinstance(args[0], tuple):
           return self.Append(self.__class__(args[0]))


        return _vector.VectorArray_Append(self, *args)


    def Prepend(self, el):
        r"""Prepend(VectorArray self, Vector el) -> int"""
        return _vector.VectorArray_Prepend(self, el)
    Prepend = _swig_new_instance_method(_vector.VectorArray_Prepend)

    def Last(self, *args):
        r"""
        Last(VectorArray self) -> Vector
        Last(VectorArray self) -> Vector
        """
        return _vector.VectorArray_Last(self, *args)
    Last = _swig_new_instance_method(_vector.VectorArray_Last)

    def DeleteLast(self):
        r"""DeleteLast(VectorArray self)"""
        return _vector.VectorArray_DeleteLast(self)
    DeleteLast = _swig_new_instance_method(_vector.VectorArray_DeleteLast)

    def DeleteAll(self):
        r"""DeleteAll(VectorArray self)"""
        return _vector.VectorArray_DeleteAll(self)
    DeleteAll = _swig_new_instance_method(_vector.VectorArray_DeleteAll)

    def ShrinkToFit(self):
        r"""ShrinkToFit(VectorArray self)"""
        return _vector.VectorArray_ShrinkToFit(self)
    ShrinkToFit = _swig_new_instance_method(_vector.VectorArray_ShrinkToFit)

    def Copy(self, copy):
        r"""Copy(VectorArray self, VectorArray copy)"""
        return _vector.VectorArray_Copy(self, copy)
    Copy = _swig_new_instance_method(_vector.VectorArray_Copy)

    def MakeRef(self, *args):
        r"""
        MakeRef(VectorArray self, mfem::Vector ** data_, int size_, bool own_data=False)
        MakeRef(VectorArray self, mfem::Vector ** data_, int size, mfem::MemoryType mt, bool own_data)
        MakeRef(VectorArray self, VectorArray master)
        """
        return _vector.VectorArray_MakeRef(self, *args)
    MakeRef = _swig_new_instance_method(_vector.VectorArray_MakeRef)

    def GetSubArray(self, offset, sa_size, sa):
        r"""GetSubArray(VectorArray self, int offset, int sa_size, VectorArray sa)"""
        return _vector.VectorArray_GetSubArray(self, offset, sa_size, sa)
    GetSubArray = _swig_new_instance_method(_vector.VectorArray_GetSubArray)

    def IsEmpty(self):
        r"""IsEmpty(VectorArray self) -> bool"""
        return _vector.VectorArray_IsEmpty(self)
    IsEmpty = _swig_new_instance_method(_vector.VectorArray_IsEmpty)

    def begin(self, *args):
        r"""
        begin(VectorArray self) -> Vector
        begin(VectorArray self) -> mfem::Vector *const *
        """
        return _vector.VectorArray_begin(self, *args)
    begin = _swig_new_instance_method(_vector.VectorArray_begin)

    def end(self, *args):
        r"""
        end(VectorArray self) -> Vector
        end(VectorArray self) -> mfem::Vector *const *
        """
        return _vector.VectorArray_end(self, *args)
    end = _swig_new_instance_method(_vector.VectorArray_end)

    def MemoryUsage(self):
        r"""MemoryUsage(VectorArray self) -> std::size_t"""
        return _vector.VectorArray_MemoryUsage(self)
    MemoryUsage = _swig_new_instance_method(_vector.VectorArray_MemoryUsage)

    def Read(self, on_dev=True):
        r"""Read(VectorArray self, bool on_dev=True) -> mfem::Vector *const *"""
        return _vector.VectorArray_Read(self, on_dev)
    Read = _swig_new_instance_method(_vector.VectorArray_Read)

    def HostRead(self):
        r"""HostRead(VectorArray self) -> mfem::Vector *const *"""
        return _vector.VectorArray_HostRead(self)
    HostRead = _swig_new_instance_method(_vector.VectorArray_HostRead)

    def Write(self, on_dev=True):
        r"""Write(VectorArray self, bool on_dev=True) -> mfem::Vector **"""
        return _vector.VectorArray_Write(self, on_dev)
    Write = _swig_new_instance_method(_vector.VectorArray_Write)

    def HostWrite(self):
        r"""HostWrite(VectorArray self) -> mfem::Vector **"""
        return _vector.VectorArray_HostWrite(self)
    HostWrite = _swig_new_instance_method(_vector.VectorArray_HostWrite)

    def ReadWrite(self, on_dev=True):
        r"""ReadWrite(VectorArray self, bool on_dev=True) -> mfem::Vector **"""
        return _vector.VectorArray_ReadWrite(self, on_dev)
    ReadWrite = _swig_new_instance_method(_vector.VectorArray_ReadWrite)

    def HostReadWrite(self):
        r"""HostReadWrite(VectorArray self) -> mfem::Vector **"""
        return _vector.VectorArray_HostReadWrite(self)
    HostReadWrite = _swig_new_instance_method(_vector.VectorArray_HostReadWrite)

    def __init__(self, *args):
        r"""
        __init__(VectorArray self) -> VectorArray
        __init__(VectorArray self, mfem::MemoryType mt) -> VectorArray
        __init__(VectorArray self, int asize) -> VectorArray
        __init__(VectorArray self, int asize, mfem::MemoryType mt) -> VectorArray
        __init__(VectorArray self, mfem::Vector ** data_, bool own_data=False) -> VectorArray
        __init__(VectorArray self, VectorArray src) -> VectorArray
        __init__(VectorArray self, VectorArray src) -> VectorArray
        __init__(VectorArray self, void * List_or_Tuple) -> VectorArray
        """
        _vector.VectorArray_swiginit(self, _vector.new_VectorArray(*args))

    def __setitem__(self, i, v):
        r"""__setitem__(VectorArray self, int i, Vector v)"""

        i = int(i)
        if hasattr(v, "thisown"):
            v.thisown = False


        return _vector.VectorArray___setitem__(self, i, v)


    def Assign(self, *args):
        r"""
        Assign(VectorArray self, mfem::Vector *const * arg2)
        Assign(VectorArray self, Vector a)
        """
        return _vector.VectorArray_Assign(self, *args)
    Assign = _swig_new_instance_method(_vector.VectorArray_Assign)

    def ToList(self):
        return [self[i] for i in range(self.Size())]



    def __iter__(self):
        class iter_array:
            def __init__(self, obj):
                self.obj = obj
                self.idx = 0
                self.size = obj.Size()
            def __iter__(self):
                self.idx = 0
            def __next__(self):
                if self.idx < self.size:
                    res = self.obj[self.idx]
                    self.idx += 1
                    return res
                else:
                    raise StopIteration
        return iter_array(self)



    def __getitem__(self, param):
        r"""__getitem__(VectorArray self, PyObject * param) -> PyObject *"""
        return _vector.VectorArray___getitem__(self, param)
    __getitem__ = _swig_new_instance_method(_vector.VectorArray___getitem__)

# Register VectorArray in _vector:
_vector.VectorArray_swigregister(VectorArray)

def Swap(*args):
    r"""
    Swap(intArray arg1, intArray arg2)
    Swap(doubleArray arg1, doubleArray arg2)
    Swap(int8Array arg1, int8Array arg2)
    Swap(int64Array arg1, int64Array arg2)
    Swap(boolArray arg1, boolArray arg2)
    Swap(uintArray arg1, uintArray arg2)
    Swap(intArrayArray arg1, intArrayArray arg2)
    Swap(intArray2D arg1, intArray2D arg2)
    Swap(doubleArray2D arg1, doubleArray2D arg2)
    Swap(DenseMatrixArray2D arg1, DenseMatrixArray2D arg2)
    Swap(SparseMatrixArray2D arg1, SparseMatrixArray2D arg2)
    Swap(VectorArray arg1, VectorArray arg2)
    """
    return _vector.Swap(*args)
Swap = _vector.Swap


def CheckFinite(v, n):
    r"""CheckFinite(mfem::real_t const * v, int const n) -> int"""
    return _vector.CheckFinite(v, n)
CheckFinite = _vector.CheckFinite

def infinity():
    r"""infinity() -> mfem::real_t"""
    return _vector.infinity()
infinity = _vector.infinity

def rand_real():
    r"""rand_real() -> mfem::real_t"""
    return _vector.rand_real()
rand_real = _vector.rand_real
class Vector(object):
    r"""Proxy of C++ mfem::Vector class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def UseDevice(self, *args):
        r"""
        UseDevice(Vector self, bool use_dev)
        UseDevice(Vector self) -> bool
        """
        return _vector.Vector_UseDevice(self, *args)
    UseDevice = _swig_new_instance_method(_vector.Vector_UseDevice)

    def Load(self, *args):
        r"""
        Load(Vector self, std::istream ** _in, int np, int * dim)
        Load(Vector self, std::istream & _in, int Size)
        Load(Vector self, std::istream & _in)
        """
        return _vector.Vector_Load(self, *args)
    Load = _swig_new_instance_method(_vector.Vector_Load)

    def SetSize(self, *args):
        r"""
        SetSize(Vector self, int s)
        SetSize(Vector self, int s, mfem::MemoryType mt)
        SetSize(Vector self, int s, Vector v)
        """
        return _vector.Vector_SetSize(self, *args)
    SetSize = _swig_new_instance_method(_vector.Vector_SetSize)

    def SetData(self, d):
        r"""SetData(Vector self, mfem::real_t * d)"""
        return _vector.Vector_SetData(self, d)
    SetData = _swig_new_instance_method(_vector.Vector_SetData)

    def SetDataAndSize(self, d, s):
        r"""SetDataAndSize(Vector self, mfem::real_t * d, int s)"""
        return _vector.Vector_SetDataAndSize(self, d, s)
    SetDataAndSize = _swig_new_instance_method(_vector.Vector_SetDataAndSize)

    def NewDataAndSize(self, d, s):
        r"""NewDataAndSize(Vector self, mfem::real_t * d, int s)"""
        return _vector.Vector_NewDataAndSize(self, d, s)
    NewDataAndSize = _swig_new_instance_method(_vector.Vector_NewDataAndSize)

    def NewMemoryAndSize(self, mem, s, own_mem):
        r"""NewMemoryAndSize(Vector self, mfem::Memory< mfem::real_t > const & mem, int s, bool own_mem)"""
        return _vector.Vector_NewMemoryAndSize(self, mem, s, own_mem)
    NewMemoryAndSize = _swig_new_instance_method(_vector.Vector_NewMemoryAndSize)

    def MakeRef(self, *args):
        r"""
        MakeRef(Vector self, Vector base, int offset, int size)
        MakeRef(Vector self, Vector base, int offset)
        """
        return _vector.Vector_MakeRef(self, *args)
    MakeRef = _swig_new_instance_method(_vector.Vector_MakeRef)

    def MakeDataOwner(self):
        r"""MakeDataOwner(Vector self)"""
        return _vector.Vector_MakeDataOwner(self)
    MakeDataOwner = _swig_new_instance_method(_vector.Vector_MakeDataOwner)

    def Destroy(self):
        r"""Destroy(Vector self)"""
        return _vector.Vector_Destroy(self)
    Destroy = _swig_new_instance_method(_vector.Vector_Destroy)

    def DeleteDevice(self, copy_to_host=True):
        r"""DeleteDevice(Vector self, bool copy_to_host=True)"""
        return _vector.Vector_DeleteDevice(self, copy_to_host)
    DeleteDevice = _swig_new_instance_method(_vector.Vector_DeleteDevice)

    def Size(self):
        r"""Size(Vector self) -> int"""
        return _vector.Vector_Size(self)
    Size = _swig_new_instance_method(_vector.Vector_Size)

    def Capacity(self):
        r"""Capacity(Vector self) -> int"""
        return _vector.Vector_Capacity(self)
    Capacity = _swig_new_instance_method(_vector.Vector_Capacity)

    def GetData(self):
        r"""GetData(Vector self) -> mfem::real_t *"""
        return _vector.Vector_GetData(self)
    GetData = _swig_new_instance_method(_vector.Vector_GetData)

    def begin(self, *args):
        r"""
        begin(Vector self) -> mfem::real_t
        begin(Vector self) -> mfem::real_t const *
        """
        return _vector.Vector_begin(self, *args)
    begin = _swig_new_instance_method(_vector.Vector_begin)

    def end(self, *args):
        r"""
        end(Vector self) -> mfem::real_t
        end(Vector self) -> mfem::real_t const *
        """
        return _vector.Vector_end(self, *args)
    end = _swig_new_instance_method(_vector.Vector_end)

    def GetMemory(self, *args):
        r"""
        GetMemory(Vector self) -> mfem::Memory< mfem::real_t >
        GetMemory(Vector self) -> mfem::Memory< mfem::real_t > const &
        """
        return _vector.Vector_GetMemory(self, *args)
    GetMemory = _swig_new_instance_method(_vector.Vector_GetMemory)

    def SyncMemory(self, v):
        r"""SyncMemory(Vector self, Vector v)"""
        return _vector.Vector_SyncMemory(self, v)
    SyncMemory = _swig_new_instance_method(_vector.Vector_SyncMemory)

    def SyncAliasMemory(self, v):
        r"""SyncAliasMemory(Vector self, Vector v)"""
        return _vector.Vector_SyncAliasMemory(self, v)
    SyncAliasMemory = _swig_new_instance_method(_vector.Vector_SyncAliasMemory)

    def OwnsData(self):
        r"""OwnsData(Vector self) -> bool"""
        return _vector.Vector_OwnsData(self)
    OwnsData = _swig_new_instance_method(_vector.Vector_OwnsData)

    def StealData(self, *args):
        r"""
        StealData(Vector self, mfem::real_t ** p)
        StealData(Vector self) -> mfem::real_t *
        """
        return _vector.Vector_StealData(self, *args)
    StealData = _swig_new_instance_method(_vector.Vector_StealData)

    def Elem(self, *args):
        r"""
        Elem(Vector self, int i) -> mfem::real_t
        Elem(Vector self, int i) -> mfem::real_t const &
        """
        return _vector.Vector_Elem(self, *args)
    Elem = _swig_new_instance_method(_vector.Vector_Elem)

    def __call__(self, *args):
        r"""
        __call__(Vector self, int i) -> mfem::real_t
        __call__(Vector self, int i) -> mfem::real_t const &
        """
        return _vector.Vector___call__(self, *args)
    __call__ = _swig_new_instance_method(_vector.Vector___call__)

    def __mul__(self, *args):
        r"""
        __mul__(Vector self, mfem::real_t const * v) -> mfem::real_t
        __mul__(Vector self, Vector v) -> mfem::real_t
        """
        return _vector.Vector___mul__(self, *args)
    __mul__ = _swig_new_instance_method(_vector.Vector___mul__)

    def __imul__(self, v):
        ret = _vector.Vector___imul__(self, v)
    #ret.thisown = self.thisown
        ret.thisown = 0
        return self



    def __itruediv__(self, v):
        ret = _vector.Vector___itruediv__(self, v)
    #ret.thisown = self.thisown
        ret.thisown = 0
        return self



    def __isub__(self, v):
        ret = _vector.Vector___isub__(self, v)
    #ret.thisown = self.thisown
        ret.thisown = 0
        return self



    def __iadd__(self, v):
        ret = _vector.Vector___iadd__(self, v)
    #ret.thisown = self.thisown
        ret.thisown = 0
        return self



    def Add(self, a, Va):
        r"""Add(Vector self, mfem::real_t const a, Vector Va) -> Vector"""
        return _vector.Vector_Add(self, a, Va)
    Add = _swig_new_instance_method(_vector.Vector_Add)

    def Set(self, a, x):
        r"""Set(Vector self, mfem::real_t const a, Vector x) -> Vector"""
        return _vector.Vector_Set(self, a, x)
    Set = _swig_new_instance_method(_vector.Vector_Set)

    def SetVector(self, v, offset):
        r"""SetVector(Vector self, Vector v, int offset)"""
        return _vector.Vector_SetVector(self, v, offset)
    SetVector = _swig_new_instance_method(_vector.Vector_SetVector)

    def AddSubVector(self, v, offset):
        r"""AddSubVector(Vector self, Vector v, int offset)"""
        return _vector.Vector_AddSubVector(self, v, offset)
    AddSubVector = _swig_new_instance_method(_vector.Vector_AddSubVector)

    def Neg(self):
        r"""Neg(Vector self)"""
        return _vector.Vector_Neg(self)
    Neg = _swig_new_instance_method(_vector.Vector_Neg)

    def Reciprocal(self):
        r"""Reciprocal(Vector self)"""
        return _vector.Vector_Reciprocal(self)
    Reciprocal = _swig_new_instance_method(_vector.Vector_Reciprocal)

    def Swap(self, other):
        r"""Swap(Vector self, Vector other)"""
        return _vector.Vector_Swap(self, other)
    Swap = _swig_new_instance_method(_vector.Vector_Swap)

    def cross3D(self, vin, vout):
        r"""cross3D(Vector self, Vector vin, Vector vout)"""
        return _vector.Vector_cross3D(self, vin, vout)
    cross3D = _swig_new_instance_method(_vector.Vector_cross3D)

    def median(self, lo, hi):
        r"""median(Vector self, Vector lo, Vector hi)"""
        return _vector.Vector_median(self, lo, hi)
    median = _swig_new_instance_method(_vector.Vector_median)

    def GetSubVector(self, *args):
        r"""
        GetSubVector(Vector self, intArray dofs, Vector elemvect)
        GetSubVector(Vector self, intArray dofs, mfem::real_t * elem_data)
        """
        return _vector.Vector_GetSubVector(self, *args)
    GetSubVector = _swig_new_instance_method(_vector.Vector_GetSubVector)

    def SetSubVector(self, *args):
        r"""
        SetSubVector(Vector self, intArray dofs, mfem::real_t const value)
        SetSubVector(Vector self, intArray dofs, Vector elemvect)
        SetSubVector(Vector self, intArray dofs, mfem::real_t * elem_data)
        """
        return _vector.Vector_SetSubVector(self, *args)
    SetSubVector = _swig_new_instance_method(_vector.Vector_SetSubVector)

    def AddElementVector(self, *args):
        r"""
        AddElementVector(Vector self, intArray dofs, Vector elemvect)
        AddElementVector(Vector self, intArray dofs, mfem::real_t * elem_data)
        AddElementVector(Vector self, intArray dofs, mfem::real_t const a, Vector elemvect)
        """
        return _vector.Vector_AddElementVector(self, *args)
    AddElementVector = _swig_new_instance_method(_vector.Vector_AddElementVector)

    def SetSubVectorComplement(self, dofs, val):
        r"""SetSubVectorComplement(Vector self, intArray dofs, mfem::real_t const val)"""
        return _vector.Vector_SetSubVectorComplement(self, dofs, val)
    SetSubVectorComplement = _swig_new_instance_method(_vector.Vector_SetSubVectorComplement)

    def PrintMathematica(self, *args, **kwargs):
        r"""PrintMathematica(Vector self, std::ostream & out=out)"""
        return _vector.Vector_PrintMathematica(self, *args, **kwargs)
    PrintMathematica = _swig_new_instance_method(_vector.Vector_PrintMathematica)

    def PrintHash(self, out):
        r"""PrintHash(Vector self, std::ostream & out)"""
        return _vector.Vector_PrintHash(self, out)
    PrintHash = _swig_new_instance_method(_vector.Vector_PrintHash)

    def Randomize(self, seed=0):
        r"""Randomize(Vector self, int seed=0)"""
        return _vector.Vector_Randomize(self, seed)
    Randomize = _swig_new_instance_method(_vector.Vector_Randomize)

    def Norml2(self):
        r"""Norml2(Vector self) -> mfem::real_t"""
        return _vector.Vector_Norml2(self)
    Norml2 = _swig_new_instance_method(_vector.Vector_Norml2)

    def Normlinf(self):
        r"""Normlinf(Vector self) -> mfem::real_t"""
        return _vector.Vector_Normlinf(self)
    Normlinf = _swig_new_instance_method(_vector.Vector_Normlinf)

    def Norml1(self):
        r"""Norml1(Vector self) -> mfem::real_t"""
        return _vector.Vector_Norml1(self)
    Norml1 = _swig_new_instance_method(_vector.Vector_Norml1)

    def Normlp(self, p):
        r"""Normlp(Vector self, mfem::real_t p) -> mfem::real_t"""
        return _vector.Vector_Normlp(self, p)
    Normlp = _swig_new_instance_method(_vector.Vector_Normlp)

    def Max(self):
        r"""Max(Vector self) -> mfem::real_t"""
        return _vector.Vector_Max(self)
    Max = _swig_new_instance_method(_vector.Vector_Max)

    def Min(self):
        r"""Min(Vector self) -> mfem::real_t"""
        return _vector.Vector_Min(self)
    Min = _swig_new_instance_method(_vector.Vector_Min)

    def Sum(self):
        r"""Sum(Vector self) -> mfem::real_t"""
        return _vector.Vector_Sum(self)
    Sum = _swig_new_instance_method(_vector.Vector_Sum)

    def DistanceSquaredTo(self, *args):
        r"""
        DistanceSquaredTo(Vector self, mfem::real_t const * p) -> mfem::real_t
        DistanceSquaredTo(Vector self, Vector p) -> mfem::real_t
        """
        return _vector.Vector_DistanceSquaredTo(self, *args)
    DistanceSquaredTo = _swig_new_instance_method(_vector.Vector_DistanceSquaredTo)

    def DistanceTo(self, *args):
        r"""
        DistanceTo(Vector self, mfem::real_t const * p) -> mfem::real_t
        DistanceTo(Vector self, Vector p) -> mfem::real_t
        """
        return _vector.Vector_DistanceTo(self, *args)
    DistanceTo = _swig_new_instance_method(_vector.Vector_DistanceTo)

    def CheckFinite(self):
        r"""CheckFinite(Vector self) -> int"""
        return _vector.Vector_CheckFinite(self)
    CheckFinite = _swig_new_instance_method(_vector.Vector_CheckFinite)
    __swig_destroy__ = _vector.delete_Vector

    def Read(self, on_dev=True):
        r"""Read(Vector self, bool on_dev=True) -> mfem::real_t const *"""
        return _vector.Vector_Read(self, on_dev)
    Read = _swig_new_instance_method(_vector.Vector_Read)

    def HostRead(self):
        r"""HostRead(Vector self) -> mfem::real_t const *"""
        return _vector.Vector_HostRead(self)
    HostRead = _swig_new_instance_method(_vector.Vector_HostRead)

    def Write(self, on_dev=True):
        r"""Write(Vector self, bool on_dev=True) -> mfem::real_t *"""
        return _vector.Vector_Write(self, on_dev)
    Write = _swig_new_instance_method(_vector.Vector_Write)

    def HostWrite(self):
        r"""HostWrite(Vector self) -> mfem::real_t *"""
        return _vector.Vector_HostWrite(self)
    HostWrite = _swig_new_instance_method(_vector.Vector_HostWrite)

    def ReadWrite(self, on_dev=True):
        r"""ReadWrite(Vector self, bool on_dev=True) -> mfem::real_t *"""
        return _vector.Vector_ReadWrite(self, on_dev)
    ReadWrite = _swig_new_instance_method(_vector.Vector_ReadWrite)

    def HostReadWrite(self):
        r"""HostReadWrite(Vector self) -> mfem::real_t *"""
        return _vector.Vector_HostReadWrite(self)
    HostReadWrite = _swig_new_instance_method(_vector.Vector_HostReadWrite)

    def __init__(self, *args):
        r"""
        __init__(Vector self) -> Vector
        __init__(Vector self, Vector arg2) -> Vector
        __init__(Vector self, Vector v) -> Vector
        __init__(Vector self, int s) -> Vector
        __init__(Vector self, mfem::real_t * data_, int size_) -> Vector
        __init__(Vector self, Vector base, int base_offset, int size_) -> Vector
        __init__(Vector self, int size_, mfem::MemoryType mt) -> Vector
        __init__(Vector self, int size_, mfem::MemoryType h_mt, mfem::MemoryType d_mt) -> Vector
        __init__(Vector self, Vector v, int offset, int size) -> Vector
        """

        from numpy import ndarray, ascontiguousarray
        keep_link = False
        own_data = False
        if len(args) == 1:
            if isinstance(args[0], list):
                args = (args[0], len(args[0]))
                own_data = True
            elif isinstance(args[0], ndarray):
                if args[0].dtype != 'float64':
                    raise ValueError('Must be float64 array ' + str(args[0].dtype) +
        			     ' is given')
                else:
                    args = (ascontiguousarray(args[0]), args[0].shape[0])
        # in this case, args[0] need to be maintained
        # in this object.
                    keep_link = True


        _vector.Vector_swiginit(self, _vector.new_Vector(*args))

        if keep_link:
           self._link_to_data = args[0]
        if own_data:
           self.MakeDataOwner()




    def Assign(self, *args):
        r"""
        Assign(Vector self, double const v)
        Assign(Vector self, Vector v)
        Assign(Vector self, PyObject * param)
        """

        from numpy import ndarray, ascontiguousarray, array
        keep_link = False
        if len(args) == 1:
            if isinstance(args[0], ndarray):
                if args[0].dtype != 'float64':
                    raise ValueError('Must be float64 array ' + str(args[0].dtype) +
        		   ' is given')
                elif args[0].ndim != 1:
                    raise ValueError('Ndim must be one')
                elif args[0].shape[0] != self.Size():
                    raise ValueError('Length does not match')
                else:
                    args = (ascontiguousarray(args[0]),)
            elif isinstance(args[0], tuple):
                args = (array(args[0], dtype = float),)
            elif isinstance(args[0], list):
                args = (array(args[0], dtype = float),)
            else:
                pass


        val = _vector.Vector_Assign(self, *args)

        return self


        return val


    def __setitem__(self, i, v):
        r"""__setitem__(Vector self, int i, double const v)"""
        return _vector.Vector___setitem__(self, i, v)
    __setitem__ = _swig_new_instance_method(_vector.Vector___setitem__)

    def __getitem__(self, param):
        r"""__getitem__(Vector self, PyObject * param) -> PyObject *"""
        return _vector.Vector___getitem__(self, param)
    __getitem__ = _swig_new_instance_method(_vector.Vector___getitem__)

    def GetDataArray(self):
        r"""GetDataArray(Vector self) -> PyObject *"""
        return _vector.Vector_GetDataArray(self)
    GetDataArray = _swig_new_instance_method(_vector.Vector_GetDataArray)

    def WriteToStream(self, StringIO, width=8):
        r"""WriteToStream(Vector self, PyObject * StringIO, int width=8) -> PyObject *"""
        return _vector.Vector_WriteToStream(self, StringIO, width)
    WriteToStream = _swig_new_instance_method(_vector.Vector_WriteToStream)

    def Print(self, *args):
        r"""
        Print(Vector self, std::ostream & out=out, int width=8)
        Print(Vector self, char const * file, int precision=16)
        """
        return _vector.Vector_Print(self, *args)
    Print = _swig_new_instance_method(_vector.Vector_Print)

    def PrintGZ(self, file, precision=16):
        r"""PrintGZ(Vector self, char const * file, int precision=16)"""
        return _vector.Vector_PrintGZ(self, file, precision)
    PrintGZ = _swig_new_instance_method(_vector.Vector_PrintGZ)

    def Print_HYPREGZ(self, file, precision=16):
        r"""Print_HYPREGZ(Vector self, char const * file, int precision=16)"""
        return _vector.Vector_Print_HYPREGZ(self, file, precision)
    Print_HYPREGZ = _swig_new_instance_method(_vector.Vector_Print_HYPREGZ)

    def Print_HYPRE(self, *args):
        r"""
        Print_HYPRE(Vector self, std::ostream & out)
        Print_HYPRE(Vector self, char const * file, int precision=16)
        Print_HYPRE(Vector self)
        """
        return _vector.Vector_Print_HYPRE(self, *args)
    Print_HYPRE = _swig_new_instance_method(_vector.Vector_Print_HYPRE)

# Register Vector in _vector:
_vector.Vector_swigregister(Vector)

def IsFinite(val):
    r"""IsFinite(mfem::real_t const & val) -> bool"""
    return _vector.IsFinite(val)
IsFinite = _vector.IsFinite

def DistanceSquared(x, y, n):
    r"""DistanceSquared(mfem::real_t const * x, mfem::real_t const * y, int const n) -> mfem::real_t"""
    return _vector.DistanceSquared(x, y, n)
DistanceSquared = _vector.DistanceSquared

def Distance(*args):
    r"""
    Distance(mfem::real_t const * x, mfem::real_t const * y, int const n) -> mfem::real_t
    Distance(Vector x, Vector y) -> mfem::real_t
    """
    return _vector.Distance(*args)
Distance = _vector.Distance

Vector.__idiv__ = Vector.__itruediv__


