# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _fe_base
else:
    import _fe_base

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _fe_base.SWIG_PyInstanceMethod_New
_swig_new_static_method = _fe_base.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

import mfem._ser.intrules
import mfem._ser.array
import mfem._ser.mem_manager
import mfem._ser.globals
import mfem._ser.geom
import mfem._ser.densemat
import mfem._ser.vector
import mfem._ser.operators
import mfem._ser.matrix
import mfem._ser.doftrans
class BasisType(object):
    r"""Proxy of C++ mfem::BasisType class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Invalid = _fe_base.BasisType_Invalid
    
    GaussLegendre = _fe_base.BasisType_GaussLegendre
    
    GaussLobatto = _fe_base.BasisType_GaussLobatto
    
    Positive = _fe_base.BasisType_Positive
    
    OpenUniform = _fe_base.BasisType_OpenUniform
    
    ClosedUniform = _fe_base.BasisType_ClosedUniform
    
    OpenHalfUniform = _fe_base.BasisType_OpenHalfUniform
    
    Serendipity = _fe_base.BasisType_Serendipity
    
    ClosedGL = _fe_base.BasisType_ClosedGL
    
    IntegratedGLL = _fe_base.BasisType_IntegratedGLL
    
    NumBasisTypes = _fe_base.BasisType_NumBasisTypes
    

    @staticmethod
    def Check(b_type):
        r"""Check(int b_type) -> int"""
        return _fe_base.BasisType_Check(b_type)
    Check = _swig_new_static_method(_fe_base.BasisType_Check)

    @staticmethod
    def CheckNodal(b_type):
        r"""CheckNodal(int b_type) -> int"""
        return _fe_base.BasisType_CheckNodal(b_type)
    CheckNodal = _swig_new_static_method(_fe_base.BasisType_CheckNodal)

    @staticmethod
    def GetQuadrature1D(b_type):
        r"""GetQuadrature1D(int b_type) -> int"""
        return _fe_base.BasisType_GetQuadrature1D(b_type)
    GetQuadrature1D = _swig_new_static_method(_fe_base.BasisType_GetQuadrature1D)

    @staticmethod
    def GetNodalBasis(qpt_type):
        r"""GetNodalBasis(int qpt_type) -> int"""
        return _fe_base.BasisType_GetNodalBasis(qpt_type)
    GetNodalBasis = _swig_new_static_method(_fe_base.BasisType_GetNodalBasis)

    @staticmethod
    def Name(b_type):
        r"""Name(int b_type) -> char const *"""
        return _fe_base.BasisType_Name(b_type)
    Name = _swig_new_static_method(_fe_base.BasisType_Name)

    @staticmethod
    def GetChar(b_type):
        r"""GetChar(int b_type) -> char"""
        return _fe_base.BasisType_GetChar(b_type)
    GetChar = _swig_new_static_method(_fe_base.BasisType_GetChar)

    @staticmethod
    def GetType(b_ident):
        r"""GetType(char b_ident) -> int"""
        return _fe_base.BasisType_GetType(b_ident)
    GetType = _swig_new_static_method(_fe_base.BasisType_GetType)

    def __init__(self):
        r"""__init__(BasisType self) -> BasisType"""
        _fe_base.BasisType_swiginit(self, _fe_base.new_BasisType())
    __swig_destroy__ = _fe_base.delete_BasisType

# Register BasisType in _fe_base:
_fe_base.BasisType_swigregister(BasisType)
class DofToQuad(object):
    r"""Proxy of C++ mfem::DofToQuad class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    FE = property(_fe_base.DofToQuad_FE_get, _fe_base.DofToQuad_FE_set, doc=r"""FE : p.q(const).mfem::FiniteElement""")
    IntRule = property(_fe_base.DofToQuad_IntRule_get, _fe_base.DofToQuad_IntRule_set, doc=r"""IntRule : p.q(const).mfem::IntegrationRule""")
    FULL = _fe_base.DofToQuad_FULL
    
    TENSOR = _fe_base.DofToQuad_TENSOR
    
    LEXICOGRAPHIC_FULL = _fe_base.DofToQuad_LEXICOGRAPHIC_FULL
    
    mode = property(_fe_base.DofToQuad_mode_get, _fe_base.DofToQuad_mode_set, doc=r"""mode : mfem::DofToQuad::Mode""")
    ndof = property(_fe_base.DofToQuad_ndof_get, _fe_base.DofToQuad_ndof_set, doc=r"""ndof : int""")
    nqpt = property(_fe_base.DofToQuad_nqpt_get, _fe_base.DofToQuad_nqpt_set, doc=r"""nqpt : int""")
    B = property(_fe_base.DofToQuad_B_get, _fe_base.DofToQuad_B_set, doc=r"""B : mfem::Array<(mfem::real_t)>""")
    Bt = property(_fe_base.DofToQuad_Bt_get, _fe_base.DofToQuad_Bt_set, doc=r"""Bt : mfem::Array<(mfem::real_t)>""")
    G = property(_fe_base.DofToQuad_G_get, _fe_base.DofToQuad_G_set, doc=r"""G : mfem::Array<(mfem::real_t)>""")
    Gt = property(_fe_base.DofToQuad_Gt_get, _fe_base.DofToQuad_Gt_set, doc=r"""Gt : mfem::Array<(mfem::real_t)>""")

    def __init__(self):
        r"""__init__(DofToQuad self) -> DofToQuad"""
        _fe_base.DofToQuad_swiginit(self, _fe_base.new_DofToQuad())
    __swig_destroy__ = _fe_base.delete_DofToQuad

# Register DofToQuad in _fe_base:
_fe_base.DofToQuad_swigregister(DofToQuad)
class FunctionSpace(object):
    r"""Proxy of C++ mfem::FunctionSpace class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Pk = _fe_base.FunctionSpace_Pk
    
    Qk = _fe_base.FunctionSpace_Qk
    
    rQk = _fe_base.FunctionSpace_rQk
    
    Uk = _fe_base.FunctionSpace_Uk
    

    def __init__(self):
        r"""__init__(FunctionSpace self) -> FunctionSpace"""
        _fe_base.FunctionSpace_swiginit(self, _fe_base.new_FunctionSpace())
    __swig_destroy__ = _fe_base.delete_FunctionSpace

# Register FunctionSpace in _fe_base:
_fe_base.FunctionSpace_swigregister(FunctionSpace)
class FiniteElement(object):
    r"""Proxy of C++ mfem::FiniteElement class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    UNKNOWN_RANGE_TYPE = _fe_base.FiniteElement_UNKNOWN_RANGE_TYPE
    
    SCALAR = _fe_base.FiniteElement_SCALAR
    
    VECTOR = _fe_base.FiniteElement_VECTOR
    
    UNKNOWN_MAP_TYPE = _fe_base.FiniteElement_UNKNOWN_MAP_TYPE
    
    VALUE = _fe_base.FiniteElement_VALUE
    
    INTEGRAL = _fe_base.FiniteElement_INTEGRAL
    
    H_DIV = _fe_base.FiniteElement_H_DIV
    
    H_CURL = _fe_base.FiniteElement_H_CURL
    
    NONE = _fe_base.FiniteElement_NONE
    
    GRAD = _fe_base.FiniteElement_GRAD
    
    DIV = _fe_base.FiniteElement_DIV
    
    CURL = _fe_base.FiniteElement_CURL
    

    def GetDim(self):
        r"""GetDim(FiniteElement self) -> int"""
        return _fe_base.FiniteElement_GetDim(self)
    GetDim = _swig_new_instance_method(_fe_base.FiniteElement_GetDim)

    def GetRangeDim(self):
        r"""GetRangeDim(FiniteElement self) -> int"""
        return _fe_base.FiniteElement_GetRangeDim(self)
    GetRangeDim = _swig_new_instance_method(_fe_base.FiniteElement_GetRangeDim)

    def GetCurlDim(self):
        r"""GetCurlDim(FiniteElement self) -> int"""
        return _fe_base.FiniteElement_GetCurlDim(self)
    GetCurlDim = _swig_new_instance_method(_fe_base.FiniteElement_GetCurlDim)

    def GetGeomType(self):
        r"""GetGeomType(FiniteElement self) -> mfem::Geometry::Type"""
        return _fe_base.FiniteElement_GetGeomType(self)
    GetGeomType = _swig_new_instance_method(_fe_base.FiniteElement_GetGeomType)

    def GetDof(self):
        r"""GetDof(FiniteElement self) -> int"""
        return _fe_base.FiniteElement_GetDof(self)
    GetDof = _swig_new_instance_method(_fe_base.FiniteElement_GetDof)

    def GetOrder(self):
        r"""GetOrder(FiniteElement self) -> int"""
        return _fe_base.FiniteElement_GetOrder(self)
    GetOrder = _swig_new_instance_method(_fe_base.FiniteElement_GetOrder)

    def HasAnisotropicOrders(self):
        r"""HasAnisotropicOrders(FiniteElement self) -> bool"""
        return _fe_base.FiniteElement_HasAnisotropicOrders(self)
    HasAnisotropicOrders = _swig_new_instance_method(_fe_base.FiniteElement_HasAnisotropicOrders)

    def GetAnisotropicOrders(self):
        r"""GetAnisotropicOrders(FiniteElement self) -> int const *"""
        return _fe_base.FiniteElement_GetAnisotropicOrders(self)
    GetAnisotropicOrders = _swig_new_instance_method(_fe_base.FiniteElement_GetAnisotropicOrders)

    def Space(self):
        r"""Space(FiniteElement self) -> int"""
        return _fe_base.FiniteElement_Space(self)
    Space = _swig_new_instance_method(_fe_base.FiniteElement_Space)

    def GetRangeType(self):
        r"""GetRangeType(FiniteElement self) -> int"""
        return _fe_base.FiniteElement_GetRangeType(self)
    GetRangeType = _swig_new_instance_method(_fe_base.FiniteElement_GetRangeType)

    def GetDerivRangeType(self):
        r"""GetDerivRangeType(FiniteElement self) -> int"""
        return _fe_base.FiniteElement_GetDerivRangeType(self)
    GetDerivRangeType = _swig_new_instance_method(_fe_base.FiniteElement_GetDerivRangeType)

    def GetMapType(self):
        r"""GetMapType(FiniteElement self) -> int"""
        return _fe_base.FiniteElement_GetMapType(self)
    GetMapType = _swig_new_instance_method(_fe_base.FiniteElement_GetMapType)

    def GetDerivType(self):
        r"""GetDerivType(FiniteElement self) -> int"""
        return _fe_base.FiniteElement_GetDerivType(self)
    GetDerivType = _swig_new_instance_method(_fe_base.FiniteElement_GetDerivType)

    def GetDerivMapType(self):
        r"""GetDerivMapType(FiniteElement self) -> int"""
        return _fe_base.FiniteElement_GetDerivMapType(self)
    GetDerivMapType = _swig_new_instance_method(_fe_base.FiniteElement_GetDerivMapType)

    def CalcShape(self, ip, shape):
        r"""CalcShape(FiniteElement self, IntegrationPoint ip, Vector shape)"""
        return _fe_base.FiniteElement_CalcShape(self, ip, shape)
    CalcShape = _swig_new_instance_method(_fe_base.FiniteElement_CalcShape)

    def CalcPhysShape(self, Trans, shape):
        r"""CalcPhysShape(FiniteElement self, mfem::ElementTransformation & Trans, Vector shape)"""
        return _fe_base.FiniteElement_CalcPhysShape(self, Trans, shape)
    CalcPhysShape = _swig_new_instance_method(_fe_base.FiniteElement_CalcPhysShape)

    def CalcDShape(self, ip, dshape):
        r"""CalcDShape(FiniteElement self, IntegrationPoint ip, DenseMatrix dshape)"""
        return _fe_base.FiniteElement_CalcDShape(self, ip, dshape)
    CalcDShape = _swig_new_instance_method(_fe_base.FiniteElement_CalcDShape)

    def CalcPhysDShape(self, Trans, dshape):
        r"""CalcPhysDShape(FiniteElement self, mfem::ElementTransformation & Trans, DenseMatrix dshape)"""
        return _fe_base.FiniteElement_CalcPhysDShape(self, Trans, dshape)
    CalcPhysDShape = _swig_new_instance_method(_fe_base.FiniteElement_CalcPhysDShape)

    def GetNodes(self):
        r"""GetNodes(FiniteElement self) -> IntegrationRule"""
        return _fe_base.FiniteElement_GetNodes(self)
    GetNodes = _swig_new_instance_method(_fe_base.FiniteElement_GetNodes)

    def CalcHessian(self, ip, Hessian):
        r"""CalcHessian(FiniteElement self, IntegrationPoint ip, DenseMatrix Hessian)"""
        return _fe_base.FiniteElement_CalcHessian(self, ip, Hessian)
    CalcHessian = _swig_new_instance_method(_fe_base.FiniteElement_CalcHessian)

    def CalcPhysHessian(self, Trans, Hessian):
        r"""CalcPhysHessian(FiniteElement self, mfem::ElementTransformation & Trans, DenseMatrix Hessian)"""
        return _fe_base.FiniteElement_CalcPhysHessian(self, Trans, Hessian)
    CalcPhysHessian = _swig_new_instance_method(_fe_base.FiniteElement_CalcPhysHessian)

    def CalcPhysLaplacian(self, Trans, Laplacian):
        r"""CalcPhysLaplacian(FiniteElement self, mfem::ElementTransformation & Trans, Vector Laplacian)"""
        return _fe_base.FiniteElement_CalcPhysLaplacian(self, Trans, Laplacian)
    CalcPhysLaplacian = _swig_new_instance_method(_fe_base.FiniteElement_CalcPhysLaplacian)

    def CalcPhysLinLaplacian(self, Trans, Laplacian):
        r"""CalcPhysLinLaplacian(FiniteElement self, mfem::ElementTransformation & Trans, Vector Laplacian)"""
        return _fe_base.FiniteElement_CalcPhysLinLaplacian(self, Trans, Laplacian)
    CalcPhysLinLaplacian = _swig_new_instance_method(_fe_base.FiniteElement_CalcPhysLinLaplacian)

    def CalcVShape(self, *args):
        r"""
        CalcVShape(FiniteElement self, IntegrationPoint ip, DenseMatrix shape)
        CalcVShape(FiniteElement self, mfem::ElementTransformation & Trans, DenseMatrix shape)
        """
        return _fe_base.FiniteElement_CalcVShape(self, *args)
    CalcVShape = _swig_new_instance_method(_fe_base.FiniteElement_CalcVShape)

    def CalcPhysVShape(self, Trans, shape):
        r"""CalcPhysVShape(FiniteElement self, mfem::ElementTransformation & Trans, DenseMatrix shape)"""
        return _fe_base.FiniteElement_CalcPhysVShape(self, Trans, shape)
    CalcPhysVShape = _swig_new_instance_method(_fe_base.FiniteElement_CalcPhysVShape)

    def CalcDivShape(self, ip, divshape):
        r"""CalcDivShape(FiniteElement self, IntegrationPoint ip, Vector divshape)"""
        return _fe_base.FiniteElement_CalcDivShape(self, ip, divshape)
    CalcDivShape = _swig_new_instance_method(_fe_base.FiniteElement_CalcDivShape)

    def CalcPhysDivShape(self, Trans, divshape):
        r"""CalcPhysDivShape(FiniteElement self, mfem::ElementTransformation & Trans, Vector divshape)"""
        return _fe_base.FiniteElement_CalcPhysDivShape(self, Trans, divshape)
    CalcPhysDivShape = _swig_new_instance_method(_fe_base.FiniteElement_CalcPhysDivShape)

    def CalcCurlShape(self, ip, curl_shape):
        r"""CalcCurlShape(FiniteElement self, IntegrationPoint ip, DenseMatrix curl_shape)"""
        return _fe_base.FiniteElement_CalcCurlShape(self, ip, curl_shape)
    CalcCurlShape = _swig_new_instance_method(_fe_base.FiniteElement_CalcCurlShape)

    def CalcPhysCurlShape(self, Trans, curl_shape):
        r"""CalcPhysCurlShape(FiniteElement self, mfem::ElementTransformation & Trans, DenseMatrix curl_shape)"""
        return _fe_base.FiniteElement_CalcPhysCurlShape(self, Trans, curl_shape)
    CalcPhysCurlShape = _swig_new_instance_method(_fe_base.FiniteElement_CalcPhysCurlShape)

    def GetFaceDofs(self, face, dofs, ndofs):
        r"""GetFaceDofs(FiniteElement self, int face, int ** dofs, int * ndofs)"""
        return _fe_base.FiniteElement_GetFaceDofs(self, face, dofs, ndofs)
    GetFaceDofs = _swig_new_instance_method(_fe_base.FiniteElement_GetFaceDofs)

    def GetLocalInterpolation(self, Trans, I):
        r"""GetLocalInterpolation(FiniteElement self, mfem::ElementTransformation & Trans, DenseMatrix I)"""
        return _fe_base.FiniteElement_GetLocalInterpolation(self, Trans, I)
    GetLocalInterpolation = _swig_new_instance_method(_fe_base.FiniteElement_GetLocalInterpolation)

    def GetLocalRestriction(self, Trans, R):
        r"""GetLocalRestriction(FiniteElement self, mfem::ElementTransformation & Trans, DenseMatrix R)"""
        return _fe_base.FiniteElement_GetLocalRestriction(self, Trans, R)
    GetLocalRestriction = _swig_new_instance_method(_fe_base.FiniteElement_GetLocalRestriction)

    def GetTransferMatrix(self, fe, Trans, I):
        r"""GetTransferMatrix(FiniteElement self, FiniteElement fe, mfem::ElementTransformation & Trans, DenseMatrix I)"""
        return _fe_base.FiniteElement_GetTransferMatrix(self, fe, Trans, I)
    GetTransferMatrix = _swig_new_instance_method(_fe_base.FiniteElement_GetTransferMatrix)

    def ProjectFromNodes(self, vc, Trans, dofs):
        r"""ProjectFromNodes(FiniteElement self, Vector vc, mfem::ElementTransformation & Trans, Vector dofs)"""
        return _fe_base.FiniteElement_ProjectFromNodes(self, vc, Trans, dofs)
    ProjectFromNodes = _swig_new_instance_method(_fe_base.FiniteElement_ProjectFromNodes)

    def ProjectMatrixCoefficient(self, mc, T, dofs):
        r"""ProjectMatrixCoefficient(FiniteElement self, mfem::MatrixCoefficient & mc, mfem::ElementTransformation & T, Vector dofs)"""
        return _fe_base.FiniteElement_ProjectMatrixCoefficient(self, mc, T, dofs)
    ProjectMatrixCoefficient = _swig_new_instance_method(_fe_base.FiniteElement_ProjectMatrixCoefficient)

    def ProjectDelta(self, vertex, dofs):
        r"""ProjectDelta(FiniteElement self, int vertex, Vector dofs)"""
        return _fe_base.FiniteElement_ProjectDelta(self, vertex, dofs)
    ProjectDelta = _swig_new_instance_method(_fe_base.FiniteElement_ProjectDelta)

    def Project(self, *args):
        r"""
        Project(FiniteElement self, mfem::Coefficient & coeff, mfem::ElementTransformation & Trans, Vector dofs)
        Project(FiniteElement self, mfem::VectorCoefficient & vc, mfem::ElementTransformation & Trans, Vector dofs)
        Project(FiniteElement self, FiniteElement fe, mfem::ElementTransformation & Trans, DenseMatrix I)
        """
        return _fe_base.FiniteElement_Project(self, *args)
    Project = _swig_new_instance_method(_fe_base.FiniteElement_Project)

    def ProjectGrad(self, fe, Trans, grad):
        r"""ProjectGrad(FiniteElement self, FiniteElement fe, mfem::ElementTransformation & Trans, DenseMatrix grad)"""
        return _fe_base.FiniteElement_ProjectGrad(self, fe, Trans, grad)
    ProjectGrad = _swig_new_instance_method(_fe_base.FiniteElement_ProjectGrad)

    def ProjectCurl(self, fe, Trans, curl):
        r"""ProjectCurl(FiniteElement self, FiniteElement fe, mfem::ElementTransformation & Trans, DenseMatrix curl)"""
        return _fe_base.FiniteElement_ProjectCurl(self, fe, Trans, curl)
    ProjectCurl = _swig_new_instance_method(_fe_base.FiniteElement_ProjectCurl)

    def ProjectDiv(self, fe, Trans, div):
        r"""ProjectDiv(FiniteElement self, FiniteElement fe, mfem::ElementTransformation & Trans, DenseMatrix div)"""
        return _fe_base.FiniteElement_ProjectDiv(self, fe, Trans, div)
    ProjectDiv = _swig_new_instance_method(_fe_base.FiniteElement_ProjectDiv)

    def GetDofToQuad(self, ir, mode):
        r"""GetDofToQuad(FiniteElement self, IntegrationRule ir, mfem::DofToQuad::Mode mode) -> DofToQuad"""
        return _fe_base.FiniteElement_GetDofToQuad(self, ir, mode)
    GetDofToQuad = _swig_new_instance_method(_fe_base.FiniteElement_GetDofToQuad)

    def GetFaceMap(self, face_id, face_map):
        r"""GetFaceMap(FiniteElement self, int const face_id, intArray face_map)"""
        return _fe_base.FiniteElement_GetFaceMap(self, face_id, face_map)
    GetFaceMap = _swig_new_instance_method(_fe_base.FiniteElement_GetFaceMap)

    def GetDofTransformation(self):
        r"""GetDofTransformation(FiniteElement self) -> StatelessDofTransformation"""
        return _fe_base.FiniteElement_GetDofTransformation(self)
    GetDofTransformation = _swig_new_instance_method(_fe_base.FiniteElement_GetDofTransformation)
    __swig_destroy__ = _fe_base.delete_FiniteElement

    @staticmethod
    def IsClosedType(b_type):
        r"""IsClosedType(int b_type) -> bool"""
        return _fe_base.FiniteElement_IsClosedType(b_type)
    IsClosedType = _swig_new_static_method(_fe_base.FiniteElement_IsClosedType)

    @staticmethod
    def IsOpenType(b_type):
        r"""IsOpenType(int b_type) -> bool"""
        return _fe_base.FiniteElement_IsOpenType(b_type)
    IsOpenType = _swig_new_static_method(_fe_base.FiniteElement_IsOpenType)

    @staticmethod
    def VerifyClosed(b_type):
        r"""VerifyClosed(int b_type) -> int"""
        return _fe_base.FiniteElement_VerifyClosed(b_type)
    VerifyClosed = _swig_new_static_method(_fe_base.FiniteElement_VerifyClosed)

    @staticmethod
    def VerifyOpen(b_type):
        r"""VerifyOpen(int b_type) -> int"""
        return _fe_base.FiniteElement_VerifyOpen(b_type)
    VerifyOpen = _swig_new_static_method(_fe_base.FiniteElement_VerifyOpen)

    @staticmethod
    def VerifyNodal(b_type):
        r"""VerifyNodal(int b_type) -> int"""
        return _fe_base.FiniteElement_VerifyNodal(b_type)
    VerifyNodal = _swig_new_static_method(_fe_base.FiniteElement_VerifyNodal)

# Register FiniteElement in _fe_base:
_fe_base.FiniteElement_swigregister(FiniteElement)
class ScalarFiniteElement(FiniteElement):
    r"""Proxy of C++ mfem::ScalarFiniteElement class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetMapType(self, M):
        r"""SetMapType(ScalarFiniteElement self, int M)"""
        return _fe_base.ScalarFiniteElement_SetMapType(self, M)
    SetMapType = _swig_new_instance_method(_fe_base.ScalarFiniteElement_SetMapType)

    def NodalLocalInterpolation(self, Trans, I, fine_fe):
        r"""NodalLocalInterpolation(ScalarFiniteElement self, mfem::ElementTransformation & Trans, DenseMatrix I, ScalarFiniteElement fine_fe)"""
        return _fe_base.ScalarFiniteElement_NodalLocalInterpolation(self, Trans, I, fine_fe)
    NodalLocalInterpolation = _swig_new_instance_method(_fe_base.ScalarFiniteElement_NodalLocalInterpolation)

    def ScalarLocalInterpolation(self, Trans, I, fine_fe):
        r"""ScalarLocalInterpolation(ScalarFiniteElement self, mfem::ElementTransformation & Trans, DenseMatrix I, ScalarFiniteElement fine_fe)"""
        return _fe_base.ScalarFiniteElement_ScalarLocalInterpolation(self, Trans, I, fine_fe)
    ScalarLocalInterpolation = _swig_new_instance_method(_fe_base.ScalarFiniteElement_ScalarLocalInterpolation)

    def ScalarLocalL2Restriction(self, Trans, R, coarse_fe):
        r"""ScalarLocalL2Restriction(ScalarFiniteElement self, mfem::ElementTransformation & Trans, DenseMatrix R, ScalarFiniteElement coarse_fe)"""
        return _fe_base.ScalarFiniteElement_ScalarLocalL2Restriction(self, Trans, R, coarse_fe)
    ScalarLocalL2Restriction = _swig_new_instance_method(_fe_base.ScalarFiniteElement_ScalarLocalL2Restriction)
    __swig_destroy__ = _fe_base.delete_ScalarFiniteElement

# Register ScalarFiniteElement in _fe_base:
_fe_base.ScalarFiniteElement_swigregister(ScalarFiniteElement)
class NodalFiniteElement(ScalarFiniteElement):
    r"""Proxy of C++ mfem::NodalFiniteElement class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetDofToQuad(self, ir, mode):
        r"""GetDofToQuad(NodalFiniteElement self, IntegrationRule ir, mfem::DofToQuad::Mode mode) -> DofToQuad"""
        return _fe_base.NodalFiniteElement_GetDofToQuad(self, ir, mode)
    GetDofToQuad = _swig_new_instance_method(_fe_base.NodalFiniteElement_GetDofToQuad)

    def GetLocalInterpolation(self, Trans, I):
        r"""GetLocalInterpolation(NodalFiniteElement self, mfem::ElementTransformation & Trans, DenseMatrix I)"""
        return _fe_base.NodalFiniteElement_GetLocalInterpolation(self, Trans, I)
    GetLocalInterpolation = _swig_new_instance_method(_fe_base.NodalFiniteElement_GetLocalInterpolation)

    def GetLocalRestriction(self, Trans, R):
        r"""GetLocalRestriction(NodalFiniteElement self, mfem::ElementTransformation & Trans, DenseMatrix R)"""
        return _fe_base.NodalFiniteElement_GetLocalRestriction(self, Trans, R)
    GetLocalRestriction = _swig_new_instance_method(_fe_base.NodalFiniteElement_GetLocalRestriction)

    def GetTransferMatrix(self, fe, Trans, I):
        r"""GetTransferMatrix(NodalFiniteElement self, FiniteElement fe, mfem::ElementTransformation & Trans, DenseMatrix I)"""
        return _fe_base.NodalFiniteElement_GetTransferMatrix(self, fe, Trans, I)
    GetTransferMatrix = _swig_new_instance_method(_fe_base.NodalFiniteElement_GetTransferMatrix)

    def ProjectMatrixCoefficient(self, mc, T, dofs):
        r"""ProjectMatrixCoefficient(NodalFiniteElement self, mfem::MatrixCoefficient & mc, mfem::ElementTransformation & T, Vector dofs)"""
        return _fe_base.NodalFiniteElement_ProjectMatrixCoefficient(self, mc, T, dofs)
    ProjectMatrixCoefficient = _swig_new_instance_method(_fe_base.NodalFiniteElement_ProjectMatrixCoefficient)

    def Project(self, *args):
        r"""
        Project(NodalFiniteElement self, mfem::Coefficient & coeff, mfem::ElementTransformation & Trans, Vector dofs)
        Project(NodalFiniteElement self, mfem::VectorCoefficient & vc, mfem::ElementTransformation & Trans, Vector dofs)
        Project(NodalFiniteElement self, FiniteElement fe, mfem::ElementTransformation & Trans, DenseMatrix I)
        """
        return _fe_base.NodalFiniteElement_Project(self, *args)
    Project = _swig_new_instance_method(_fe_base.NodalFiniteElement_Project)

    def ProjectGrad(self, fe, Trans, grad):
        r"""ProjectGrad(NodalFiniteElement self, FiniteElement fe, mfem::ElementTransformation & Trans, DenseMatrix grad)"""
        return _fe_base.NodalFiniteElement_ProjectGrad(self, fe, Trans, grad)
    ProjectGrad = _swig_new_instance_method(_fe_base.NodalFiniteElement_ProjectGrad)

    def ProjectDiv(self, fe, Trans, div):
        r"""ProjectDiv(NodalFiniteElement self, FiniteElement fe, mfem::ElementTransformation & Trans, DenseMatrix div)"""
        return _fe_base.NodalFiniteElement_ProjectDiv(self, fe, Trans, div)
    ProjectDiv = _swig_new_instance_method(_fe_base.NodalFiniteElement_ProjectDiv)

    def GetLexicographicOrdering(self):
        r"""GetLexicographicOrdering(NodalFiniteElement self) -> intArray"""
        return _fe_base.NodalFiniteElement_GetLexicographicOrdering(self)
    GetLexicographicOrdering = _swig_new_instance_method(_fe_base.NodalFiniteElement_GetLexicographicOrdering)

    def ReorderLexToNative(self, ncomp, dofs):
        r"""ReorderLexToNative(NodalFiniteElement self, int ncomp, Vector dofs)"""
        return _fe_base.NodalFiniteElement_ReorderLexToNative(self, ncomp, dofs)
    ReorderLexToNative = _swig_new_instance_method(_fe_base.NodalFiniteElement_ReorderLexToNative)
    __swig_destroy__ = _fe_base.delete_NodalFiniteElement

# Register NodalFiniteElement in _fe_base:
_fe_base.NodalFiniteElement_swigregister(NodalFiniteElement)
class VectorFiniteElement(FiniteElement):
    r"""Proxy of C++ mfem::VectorFiniteElement class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(VectorFiniteElement self, int D, mfem::Geometry::Type G, int Do, int O, int M, int F=Pk) -> VectorFiniteElement"""
        _fe_base.VectorFiniteElement_swiginit(self, _fe_base.new_VectorFiniteElement(*args, **kwargs))
    __swig_destroy__ = _fe_base.delete_VectorFiniteElement

# Register VectorFiniteElement in _fe_base:
_fe_base.VectorFiniteElement_swigregister(VectorFiniteElement)
class Poly_1D(object):
    r"""Proxy of C++ mfem::Poly_1D class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ChangeOfBasis = _fe_base.Poly_1D_ChangeOfBasis
    
    Barycentric = _fe_base.Poly_1D_Barycentric
    
    Positive = _fe_base.Poly_1D_Positive
    
    Integrated = _fe_base.Poly_1D_Integrated
    
    NumEvalTypes = _fe_base.Poly_1D_NumEvalTypes
    

    def __init__(self):
        r"""__init__(Poly_1D self) -> Poly_1D"""
        _fe_base.Poly_1D_swiginit(self, _fe_base.new_Poly_1D())

    @staticmethod
    def Binom(p):
        r"""Binom(int const p) -> int const *"""
        return _fe_base.Poly_1D_Binom(p)
    Binom = _swig_new_static_method(_fe_base.Poly_1D_Binom)

    def GetPointsArray(self, p, btype):
        r"""GetPointsArray(Poly_1D self, int const p, int const btype) -> doubleArray"""
        return _fe_base.Poly_1D_GetPointsArray(self, p, btype)
    GetPointsArray = _swig_new_instance_method(_fe_base.Poly_1D_GetPointsArray)

    def GetPoints(self, p, btype, on_device=False):
        r"""GetPoints(Poly_1D self, int const p, int const btype, bool on_device=False) -> mfem::real_t const *"""
        return _fe_base.Poly_1D_GetPoints(self, p, btype, on_device)
    GetPoints = _swig_new_instance_method(_fe_base.Poly_1D_GetPoints)

    def OpenPoints(self, *args, **kwargs):
        r"""OpenPoints(Poly_1D self, int const p, int const btype=GaussLegendre, bool on_device=False) -> mfem::real_t const *"""
        return _fe_base.Poly_1D_OpenPoints(self, *args, **kwargs)
    OpenPoints = _swig_new_instance_method(_fe_base.Poly_1D_OpenPoints)

    def ClosedPoints(self, *args, **kwargs):
        r"""ClosedPoints(Poly_1D self, int const p, int const btype=GaussLobatto, bool on_device=False) -> mfem::real_t const *"""
        return _fe_base.Poly_1D_ClosedPoints(self, *args, **kwargs)
    ClosedPoints = _swig_new_instance_method(_fe_base.Poly_1D_ClosedPoints)

    def GetBasis(self, p, btype):
        r"""GetBasis(Poly_1D self, int const p, int const btype) -> mfem::Poly_1D::Basis &"""
        return _fe_base.Poly_1D_GetBasis(self, p, btype)
    GetBasis = _swig_new_instance_method(_fe_base.Poly_1D_GetBasis)

    @staticmethod
    def CalcBasis(*args):
        r"""
        CalcBasis(int const p, mfem::real_t const x, mfem::real_t * u)
        CalcBasis(int const p, mfem::real_t const x, Vector u)
        CalcBasis(int const p, mfem::real_t const x, mfem::real_t * u, mfem::real_t * d)
        CalcBasis(int const p, mfem::real_t const x, Vector u, Vector d)
        CalcBasis(int const p, mfem::real_t const x, mfem::real_t * u, mfem::real_t * d, mfem::real_t * dd)
        CalcBasis(int const p, mfem::real_t const x, Vector u, Vector d, Vector dd)
        """
        return _fe_base.Poly_1D_CalcBasis(*args)
    CalcBasis = _swig_new_static_method(_fe_base.Poly_1D_CalcBasis)

    @staticmethod
    def CalcDelta(p, x):
        r"""CalcDelta(int const p, mfem::real_t const x) -> mfem::real_t"""
        return _fe_base.Poly_1D_CalcDelta(p, x)
    CalcDelta = _swig_new_static_method(_fe_base.Poly_1D_CalcDelta)

    @staticmethod
    def ChebyshevPoints(p, x):
        r"""ChebyshevPoints(int const p, mfem::real_t * x)"""
        return _fe_base.Poly_1D_ChebyshevPoints(p, x)
    ChebyshevPoints = _swig_new_static_method(_fe_base.Poly_1D_ChebyshevPoints)

    @staticmethod
    def CalcBinomTerms(*args):
        r"""
        CalcBinomTerms(int const p, mfem::real_t const x, mfem::real_t const y, mfem::real_t * u)
        CalcBinomTerms(int const p, mfem::real_t const x, mfem::real_t const y, mfem::real_t * u, mfem::real_t * d)
        """
        return _fe_base.Poly_1D_CalcBinomTerms(*args)
    CalcBinomTerms = _swig_new_static_method(_fe_base.Poly_1D_CalcBinomTerms)

    @staticmethod
    def CalcDBinomTerms(p, x, y, d):
        r"""CalcDBinomTerms(int const p, mfem::real_t const x, mfem::real_t const y, mfem::real_t * d)"""
        return _fe_base.Poly_1D_CalcDBinomTerms(p, x, y, d)
    CalcDBinomTerms = _swig_new_static_method(_fe_base.Poly_1D_CalcDBinomTerms)

    @staticmethod
    def CalcDxBinomTerms(p, x, y, d):
        r"""CalcDxBinomTerms(int const p, mfem::real_t const x, mfem::real_t const y, mfem::real_t * d)"""
        return _fe_base.Poly_1D_CalcDxBinomTerms(p, x, y, d)
    CalcDxBinomTerms = _swig_new_static_method(_fe_base.Poly_1D_CalcDxBinomTerms)

    @staticmethod
    def CalcDyBinomTerms(p, x, y, d):
        r"""CalcDyBinomTerms(int const p, mfem::real_t const x, mfem::real_t const y, mfem::real_t * d)"""
        return _fe_base.Poly_1D_CalcDyBinomTerms(p, x, y, d)
    CalcDyBinomTerms = _swig_new_static_method(_fe_base.Poly_1D_CalcDyBinomTerms)

    @staticmethod
    def CalcBernstein(*args):
        r"""
        CalcBernstein(int const p, mfem::real_t const x, mfem::real_t * u)
        CalcBernstein(int const p, mfem::real_t const x, Vector u)
        CalcBernstein(int const p, mfem::real_t const x, mfem::real_t * u, mfem::real_t * d)
        CalcBernstein(int const p, mfem::real_t const x, Vector u, Vector d)
        """
        return _fe_base.Poly_1D_CalcBernstein(*args)
    CalcBernstein = _swig_new_static_method(_fe_base.Poly_1D_CalcBernstein)

    @staticmethod
    def CalcLegendre(*args):
        r"""
        CalcLegendre(int const p, mfem::real_t const x, mfem::real_t * u)
        CalcLegendre(int const p, mfem::real_t const x, mfem::real_t * u, mfem::real_t * d)
        """
        return _fe_base.Poly_1D_CalcLegendre(*args)
    CalcLegendre = _swig_new_static_method(_fe_base.Poly_1D_CalcLegendre)
    __swig_destroy__ = _fe_base.delete_Poly_1D

# Register Poly_1D in _fe_base:
_fe_base.Poly_1D_swigregister(Poly_1D)
class TensorBasisElement(object):
    r"""Proxy of C++ mfem::TensorBasisElement class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    L2_DOF_MAP = _fe_base.TensorBasisElement_L2_DOF_MAP
    
    H1_DOF_MAP = _fe_base.TensorBasisElement_H1_DOF_MAP
    
    Sr_DOF_MAP = _fe_base.TensorBasisElement_Sr_DOF_MAP
    

    def __init__(self, dims, p, btype, dmtype):
        r"""__init__(TensorBasisElement self, int const dims, int const p, int const btype, mfem::TensorBasisElement::DofMapType const dmtype) -> TensorBasisElement"""
        _fe_base.TensorBasisElement_swiginit(self, _fe_base.new_TensorBasisElement(dims, p, btype, dmtype))

    def GetBasisType(self):
        r"""GetBasisType(TensorBasisElement self) -> int"""
        return _fe_base.TensorBasisElement_GetBasisType(self)
    GetBasisType = _swig_new_instance_method(_fe_base.TensorBasisElement_GetBasisType)

    def GetBasis1D(self):
        r"""GetBasis1D(TensorBasisElement self) -> mfem::Poly_1D::Basis const &"""
        return _fe_base.TensorBasisElement_GetBasis1D(self)
    GetBasis1D = _swig_new_instance_method(_fe_base.TensorBasisElement_GetBasis1D)

    def GetDofMap(self):
        r"""GetDofMap(TensorBasisElement self) -> intArray"""
        return _fe_base.TensorBasisElement_GetDofMap(self)
    GetDofMap = _swig_new_instance_method(_fe_base.TensorBasisElement_GetDofMap)

    @staticmethod
    def GetTensorProductGeometry(dim):
        r"""GetTensorProductGeometry(int dim) -> mfem::Geometry::Type"""
        return _fe_base.TensorBasisElement_GetTensorProductGeometry(dim)
    GetTensorProductGeometry = _swig_new_static_method(_fe_base.TensorBasisElement_GetTensorProductGeometry)

    @staticmethod
    def Pow(base, dim):
        r"""Pow(int base, int dim) -> int"""
        return _fe_base.TensorBasisElement_Pow(base, dim)
    Pow = _swig_new_static_method(_fe_base.TensorBasisElement_Pow)

    @staticmethod
    def GetTensorDofToQuad(fe, ir, mode, basis, closed, dof2quad_array):
        r"""GetTensorDofToQuad(FiniteElement fe, IntegrationRule ir, mfem::DofToQuad::Mode mode, mfem::Poly_1D::Basis const & basis, bool closed, mfem::Array< mfem::DofToQuad * > & dof2quad_array) -> DofToQuad"""
        return _fe_base.TensorBasisElement_GetTensorDofToQuad(fe, ir, mode, basis, closed, dof2quad_array)
    GetTensorDofToQuad = _swig_new_static_method(_fe_base.TensorBasisElement_GetTensorDofToQuad)
    __swig_destroy__ = _fe_base.delete_TensorBasisElement

# Register TensorBasisElement in _fe_base:
_fe_base.TensorBasisElement_swigregister(TensorBasisElement)
class NodalTensorFiniteElement(NodalFiniteElement, TensorBasisElement):
    r"""Proxy of C++ mfem::NodalTensorFiniteElement class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetDofToQuad(self, ir, mode):
        r"""GetDofToQuad(NodalTensorFiniteElement self, IntegrationRule ir, mfem::DofToQuad::Mode mode) -> DofToQuad"""
        return _fe_base.NodalTensorFiniteElement_GetDofToQuad(self, ir, mode)
    GetDofToQuad = _swig_new_instance_method(_fe_base.NodalTensorFiniteElement_GetDofToQuad)

    def SetMapType(self, map_type_):
        r"""SetMapType(NodalTensorFiniteElement self, int const map_type_)"""
        return _fe_base.NodalTensorFiniteElement_SetMapType(self, map_type_)
    SetMapType = _swig_new_instance_method(_fe_base.NodalTensorFiniteElement_SetMapType)

    def GetTransferMatrix(self, fe, Trans, I):
        r"""GetTransferMatrix(NodalTensorFiniteElement self, FiniteElement fe, mfem::ElementTransformation & Trans, DenseMatrix I)"""
        return _fe_base.NodalTensorFiniteElement_GetTransferMatrix(self, fe, Trans, I)
    GetTransferMatrix = _swig_new_instance_method(_fe_base.NodalTensorFiniteElement_GetTransferMatrix)

    def GetFaceMap(self, face_id, face_map):
        r"""GetFaceMap(NodalTensorFiniteElement self, int const face_id, intArray face_map)"""
        return _fe_base.NodalTensorFiniteElement_GetFaceMap(self, face_id, face_map)
    GetFaceMap = _swig_new_instance_method(_fe_base.NodalTensorFiniteElement_GetFaceMap)
    __swig_destroy__ = _fe_base.delete_NodalTensorFiniteElement

# Register NodalTensorFiniteElement in _fe_base:
_fe_base.NodalTensorFiniteElement_swigregister(NodalTensorFiniteElement)
class VectorTensorFiniteElement(VectorFiniteElement, TensorBasisElement):
    r"""Proxy of C++ mfem::VectorTensorFiniteElement class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(VectorTensorFiniteElement self, int const dims, int const d, int const p, int const cbtype, int const obtype, int const M, mfem::TensorBasisElement::DofMapType const dmtype) -> VectorTensorFiniteElement
        __init__(VectorTensorFiniteElement self, int const dims, int const d, int const p, int const obtype, int const M, mfem::TensorBasisElement::DofMapType const dmtype) -> VectorTensorFiniteElement
        """
        _fe_base.VectorTensorFiniteElement_swiginit(self, _fe_base.new_VectorTensorFiniteElement(*args))

    def GetDofToQuad(self, ir, mode):
        r"""GetDofToQuad(VectorTensorFiniteElement self, IntegrationRule ir, mfem::DofToQuad::Mode mode) -> DofToQuad"""
        return _fe_base.VectorTensorFiniteElement_GetDofToQuad(self, ir, mode)
    GetDofToQuad = _swig_new_instance_method(_fe_base.VectorTensorFiniteElement_GetDofToQuad)

    def GetDofToQuadOpen(self, ir, mode):
        r"""GetDofToQuadOpen(VectorTensorFiniteElement self, IntegrationRule ir, mfem::DofToQuad::Mode mode) -> DofToQuad"""
        return _fe_base.VectorTensorFiniteElement_GetDofToQuadOpen(self, ir, mode)
    GetDofToQuadOpen = _swig_new_instance_method(_fe_base.VectorTensorFiniteElement_GetDofToQuadOpen)
    __swig_destroy__ = _fe_base.delete_VectorTensorFiniteElement

# Register VectorTensorFiniteElement in _fe_base:
_fe_base.VectorTensorFiniteElement_swigregister(VectorTensorFiniteElement)

def InvertLinearTrans(trans, pt, x):
    r"""InvertLinearTrans(mfem::ElementTransformation & trans, IntegrationPoint pt, Vector x)"""
    return _fe_base.InvertLinearTrans(trans, pt, x)
InvertLinearTrans = _fe_base.InvertLinearTrans

