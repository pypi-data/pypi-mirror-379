# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _intrules
else:
    import _intrules

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _intrules.SWIG_PyInstanceMethod_New
_swig_new_static_method = _intrules.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import mfem._ser.array
import mfem._ser.mem_manager
import mfem._ser.globals
class IntegrationPointArray(object):
    r"""Proxy of C++ mfem::Array< mfem::IntegrationPoint > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _intrules.delete_IntegrationPointArray

    def GetData(self, *args):
        r"""
        GetData(IntegrationPointArray self) -> IntegrationPoint
        GetData(IntegrationPointArray self) -> IntegrationPoint
        """
        return _intrules.IntegrationPointArray_GetData(self, *args)
    GetData = _swig_new_instance_method(_intrules.IntegrationPointArray_GetData)

    def GetMemory(self, *args):
        r"""
        GetMemory(IntegrationPointArray self) -> mfem::Memory< mfem::IntegrationPoint >
        GetMemory(IntegrationPointArray self) -> mfem::Memory< mfem::IntegrationPoint > const &
        """
        return _intrules.IntegrationPointArray_GetMemory(self, *args)
    GetMemory = _swig_new_instance_method(_intrules.IntegrationPointArray_GetMemory)

    def UseDevice(self):
        r"""UseDevice(IntegrationPointArray self) -> bool"""
        return _intrules.IntegrationPointArray_UseDevice(self)
    UseDevice = _swig_new_instance_method(_intrules.IntegrationPointArray_UseDevice)

    def OwnsData(self):
        r"""OwnsData(IntegrationPointArray self) -> bool"""
        return _intrules.IntegrationPointArray_OwnsData(self)
    OwnsData = _swig_new_instance_method(_intrules.IntegrationPointArray_OwnsData)

    def StealData(self, p):
        r"""StealData(IntegrationPointArray self, mfem::IntegrationPoint ** p)"""
        return _intrules.IntegrationPointArray_StealData(self, p)
    StealData = _swig_new_instance_method(_intrules.IntegrationPointArray_StealData)

    def LoseData(self):
        r"""LoseData(IntegrationPointArray self)"""
        return _intrules.IntegrationPointArray_LoseData(self)
    LoseData = _swig_new_instance_method(_intrules.IntegrationPointArray_LoseData)

    def MakeDataOwner(self):
        r"""MakeDataOwner(IntegrationPointArray self)"""
        return _intrules.IntegrationPointArray_MakeDataOwner(self)
    MakeDataOwner = _swig_new_instance_method(_intrules.IntegrationPointArray_MakeDataOwner)

    def Size(self):
        r"""Size(IntegrationPointArray self) -> int"""
        return _intrules.IntegrationPointArray_Size(self)
    Size = _swig_new_instance_method(_intrules.IntegrationPointArray_Size)

    def SetSize(self, *args):
        r"""
        SetSize(IntegrationPointArray self, int nsize)
        SetSize(IntegrationPointArray self, int nsize, IntegrationPoint initval)
        SetSize(IntegrationPointArray self, int nsize, mfem::MemoryType mt)
        """
        return _intrules.IntegrationPointArray_SetSize(self, *args)
    SetSize = _swig_new_instance_method(_intrules.IntegrationPointArray_SetSize)

    def Capacity(self):
        r"""Capacity(IntegrationPointArray self) -> int"""
        return _intrules.IntegrationPointArray_Capacity(self)
    Capacity = _swig_new_instance_method(_intrules.IntegrationPointArray_Capacity)

    def Reserve(self, capacity):
        r"""Reserve(IntegrationPointArray self, int capacity)"""
        return _intrules.IntegrationPointArray_Reserve(self, capacity)
    Reserve = _swig_new_instance_method(_intrules.IntegrationPointArray_Reserve)

    def Append(self, *args):
        r"""
        Append(IntegrationPointArray self, IntegrationPoint el) -> int
        Append(IntegrationPointArray self, IntegrationPoint els, int nels) -> int
        Append(IntegrationPointArray self, IntegrationPointArray els) -> int
        """

        if isinstance(args[0], list):
           return self.Append(self.__class__(args[0]))
        if isinstance(args[0], tuple):
           return self.Append(self.__class__(args[0]))


        return _intrules.IntegrationPointArray_Append(self, *args)


    def Prepend(self, el):
        r"""Prepend(IntegrationPointArray self, IntegrationPoint el) -> int"""
        return _intrules.IntegrationPointArray_Prepend(self, el)
    Prepend = _swig_new_instance_method(_intrules.IntegrationPointArray_Prepend)

    def Last(self, *args):
        r"""
        Last(IntegrationPointArray self) -> IntegrationPoint
        Last(IntegrationPointArray self) -> IntegrationPoint
        """
        return _intrules.IntegrationPointArray_Last(self, *args)
    Last = _swig_new_instance_method(_intrules.IntegrationPointArray_Last)

    def DeleteLast(self):
        r"""DeleteLast(IntegrationPointArray self)"""
        return _intrules.IntegrationPointArray_DeleteLast(self)
    DeleteLast = _swig_new_instance_method(_intrules.IntegrationPointArray_DeleteLast)

    def DeleteAll(self):
        r"""DeleteAll(IntegrationPointArray self)"""
        return _intrules.IntegrationPointArray_DeleteAll(self)
    DeleteAll = _swig_new_instance_method(_intrules.IntegrationPointArray_DeleteAll)

    def ShrinkToFit(self):
        r"""ShrinkToFit(IntegrationPointArray self)"""
        return _intrules.IntegrationPointArray_ShrinkToFit(self)
    ShrinkToFit = _swig_new_instance_method(_intrules.IntegrationPointArray_ShrinkToFit)

    def Copy(self, copy):
        r"""Copy(IntegrationPointArray self, IntegrationPointArray copy)"""
        return _intrules.IntegrationPointArray_Copy(self, copy)
    Copy = _swig_new_instance_method(_intrules.IntegrationPointArray_Copy)

    def MakeRef(self, *args):
        r"""
        MakeRef(IntegrationPointArray self, IntegrationPoint data_, int size_, bool own_data=False)
        MakeRef(IntegrationPointArray self, IntegrationPoint data_, int size, mfem::MemoryType mt, bool own_data)
        MakeRef(IntegrationPointArray self, IntegrationPointArray master)
        """
        return _intrules.IntegrationPointArray_MakeRef(self, *args)
    MakeRef = _swig_new_instance_method(_intrules.IntegrationPointArray_MakeRef)

    def GetSubArray(self, offset, sa_size, sa):
        r"""GetSubArray(IntegrationPointArray self, int offset, int sa_size, IntegrationPointArray sa)"""
        return _intrules.IntegrationPointArray_GetSubArray(self, offset, sa_size, sa)
    GetSubArray = _swig_new_instance_method(_intrules.IntegrationPointArray_GetSubArray)

    def IsEmpty(self):
        r"""IsEmpty(IntegrationPointArray self) -> bool"""
        return _intrules.IntegrationPointArray_IsEmpty(self)
    IsEmpty = _swig_new_instance_method(_intrules.IntegrationPointArray_IsEmpty)

    def begin(self, *args):
        r"""
        begin(IntegrationPointArray self) -> IntegrationPoint
        begin(IntegrationPointArray self) -> IntegrationPoint
        """
        return _intrules.IntegrationPointArray_begin(self, *args)
    begin = _swig_new_instance_method(_intrules.IntegrationPointArray_begin)

    def end(self, *args):
        r"""
        end(IntegrationPointArray self) -> IntegrationPoint
        end(IntegrationPointArray self) -> IntegrationPoint
        """
        return _intrules.IntegrationPointArray_end(self, *args)
    end = _swig_new_instance_method(_intrules.IntegrationPointArray_end)

    def MemoryUsage(self):
        r"""MemoryUsage(IntegrationPointArray self) -> std::size_t"""
        return _intrules.IntegrationPointArray_MemoryUsage(self)
    MemoryUsage = _swig_new_instance_method(_intrules.IntegrationPointArray_MemoryUsage)

    def Read(self, on_dev=True):
        r"""Read(IntegrationPointArray self, bool on_dev=True) -> IntegrationPoint"""
        return _intrules.IntegrationPointArray_Read(self, on_dev)
    Read = _swig_new_instance_method(_intrules.IntegrationPointArray_Read)

    def HostRead(self):
        r"""HostRead(IntegrationPointArray self) -> IntegrationPoint"""
        return _intrules.IntegrationPointArray_HostRead(self)
    HostRead = _swig_new_instance_method(_intrules.IntegrationPointArray_HostRead)

    def Write(self, on_dev=True):
        r"""Write(IntegrationPointArray self, bool on_dev=True) -> IntegrationPoint"""
        return _intrules.IntegrationPointArray_Write(self, on_dev)
    Write = _swig_new_instance_method(_intrules.IntegrationPointArray_Write)

    def HostWrite(self):
        r"""HostWrite(IntegrationPointArray self) -> IntegrationPoint"""
        return _intrules.IntegrationPointArray_HostWrite(self)
    HostWrite = _swig_new_instance_method(_intrules.IntegrationPointArray_HostWrite)

    def ReadWrite(self, on_dev=True):
        r"""ReadWrite(IntegrationPointArray self, bool on_dev=True) -> IntegrationPoint"""
        return _intrules.IntegrationPointArray_ReadWrite(self, on_dev)
    ReadWrite = _swig_new_instance_method(_intrules.IntegrationPointArray_ReadWrite)

    def HostReadWrite(self):
        r"""HostReadWrite(IntegrationPointArray self) -> IntegrationPoint"""
        return _intrules.IntegrationPointArray_HostReadWrite(self)
    HostReadWrite = _swig_new_instance_method(_intrules.IntegrationPointArray_HostReadWrite)

    def __init__(self, *args):
        r"""
        __init__(IntegrationPointArray self) -> IntegrationPointArray
        __init__(IntegrationPointArray self, mfem::MemoryType mt) -> IntegrationPointArray
        __init__(IntegrationPointArray self, int asize) -> IntegrationPointArray
        __init__(IntegrationPointArray self, int asize, mfem::MemoryType mt) -> IntegrationPointArray
        __init__(IntegrationPointArray self, IntegrationPoint data_, bool own_data=False) -> IntegrationPointArray
        __init__(IntegrationPointArray self, IntegrationPointArray src) -> IntegrationPointArray
        __init__(IntegrationPointArray self, IntegrationPointArray src) -> IntegrationPointArray
        __init__(IntegrationPointArray self, void * List_or_Tuple) -> IntegrationPointArray
        """
        _intrules.IntegrationPointArray_swiginit(self, _intrules.new_IntegrationPointArray(*args))

    def __setitem__(self, i, v):
        r"""__setitem__(IntegrationPointArray self, int i, IntegrationPoint v)"""

        i = int(i)
        if hasattr(v, "thisown"):
            v.thisown = False


        return _intrules.IntegrationPointArray___setitem__(self, i, v)


    def Assign(self, *args):
        r"""
        Assign(IntegrationPointArray self, IntegrationPoint arg2)
        Assign(IntegrationPointArray self, IntegrationPoint a)
        """
        return _intrules.IntegrationPointArray_Assign(self, *args)
    Assign = _swig_new_instance_method(_intrules.IntegrationPointArray_Assign)

    def ToList(self):
        return [self[i] for i in range(self.Size())]



    def __iter__(self):
        class iter_array:
            def __init__(self, obj):
                self.obj = obj
                self.idx = 0
                self.size = obj.Size()
            def __iter__(self):
                self.idx = 0
            def __next__(self):
                if self.idx < self.size:
                    res = self.obj[self.idx]
                    self.idx += 1
                    return res
                else:
                    raise StopIteration
        return iter_array(self)



    def __getitem__(self, param):
        r"""__getitem__(IntegrationPointArray self, PyObject * param) -> PyObject *"""
        return _intrules.IntegrationPointArray___getitem__(self, param)
    __getitem__ = _swig_new_instance_method(_intrules.IntegrationPointArray___getitem__)

# Register IntegrationPointArray in _intrules:
_intrules.IntegrationPointArray_swigregister(IntegrationPointArray)
class IntegrationRuleArray(object):
    r"""Proxy of C++ mfem::Array< mfem::IntegrationRule * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _intrules.delete_IntegrationRuleArray

    def GetData(self, *args):
        r"""
        GetData(IntegrationRuleArray self) -> IntegrationRule
        GetData(IntegrationRuleArray self) -> mfem::IntegrationRule *const *
        """
        return _intrules.IntegrationRuleArray_GetData(self, *args)
    GetData = _swig_new_instance_method(_intrules.IntegrationRuleArray_GetData)

    def GetMemory(self, *args):
        r"""
        GetMemory(IntegrationRuleArray self) -> mfem::Memory< mfem::IntegrationRule * >
        GetMemory(IntegrationRuleArray self) -> mfem::Memory< mfem::IntegrationRule * > const &
        """
        return _intrules.IntegrationRuleArray_GetMemory(self, *args)
    GetMemory = _swig_new_instance_method(_intrules.IntegrationRuleArray_GetMemory)

    def UseDevice(self):
        r"""UseDevice(IntegrationRuleArray self) -> bool"""
        return _intrules.IntegrationRuleArray_UseDevice(self)
    UseDevice = _swig_new_instance_method(_intrules.IntegrationRuleArray_UseDevice)

    def OwnsData(self):
        r"""OwnsData(IntegrationRuleArray self) -> bool"""
        return _intrules.IntegrationRuleArray_OwnsData(self)
    OwnsData = _swig_new_instance_method(_intrules.IntegrationRuleArray_OwnsData)

    def StealData(self, p):
        r"""StealData(IntegrationRuleArray self, mfem::IntegrationRule *** p)"""
        return _intrules.IntegrationRuleArray_StealData(self, p)
    StealData = _swig_new_instance_method(_intrules.IntegrationRuleArray_StealData)

    def LoseData(self):
        r"""LoseData(IntegrationRuleArray self)"""
        return _intrules.IntegrationRuleArray_LoseData(self)
    LoseData = _swig_new_instance_method(_intrules.IntegrationRuleArray_LoseData)

    def MakeDataOwner(self):
        r"""MakeDataOwner(IntegrationRuleArray self)"""
        return _intrules.IntegrationRuleArray_MakeDataOwner(self)
    MakeDataOwner = _swig_new_instance_method(_intrules.IntegrationRuleArray_MakeDataOwner)

    def Size(self):
        r"""Size(IntegrationRuleArray self) -> int"""
        return _intrules.IntegrationRuleArray_Size(self)
    Size = _swig_new_instance_method(_intrules.IntegrationRuleArray_Size)

    def SetSize(self, *args):
        r"""
        SetSize(IntegrationRuleArray self, int nsize)
        SetSize(IntegrationRuleArray self, int nsize, IntegrationRule initval)
        SetSize(IntegrationRuleArray self, int nsize, mfem::MemoryType mt)
        """
        return _intrules.IntegrationRuleArray_SetSize(self, *args)
    SetSize = _swig_new_instance_method(_intrules.IntegrationRuleArray_SetSize)

    def Capacity(self):
        r"""Capacity(IntegrationRuleArray self) -> int"""
        return _intrules.IntegrationRuleArray_Capacity(self)
    Capacity = _swig_new_instance_method(_intrules.IntegrationRuleArray_Capacity)

    def Reserve(self, capacity):
        r"""Reserve(IntegrationRuleArray self, int capacity)"""
        return _intrules.IntegrationRuleArray_Reserve(self, capacity)
    Reserve = _swig_new_instance_method(_intrules.IntegrationRuleArray_Reserve)

    def Append(self, *args):
        r"""
        Append(IntegrationRuleArray self, IntegrationRule el) -> int
        Append(IntegrationRuleArray self, mfem::IntegrationRule *const * els, int nels) -> int
        Append(IntegrationRuleArray self, IntegrationRuleArray els) -> int
        """

        if isinstance(args[0], list):
           return self.Append(self.__class__(args[0]))
        if isinstance(args[0], tuple):
           return self.Append(self.__class__(args[0]))


        return _intrules.IntegrationRuleArray_Append(self, *args)


    def Prepend(self, el):
        r"""Prepend(IntegrationRuleArray self, IntegrationRule el) -> int"""
        return _intrules.IntegrationRuleArray_Prepend(self, el)
    Prepend = _swig_new_instance_method(_intrules.IntegrationRuleArray_Prepend)

    def Last(self, *args):
        r"""
        Last(IntegrationRuleArray self) -> IntegrationRule
        Last(IntegrationRuleArray self) -> IntegrationRule
        """
        return _intrules.IntegrationRuleArray_Last(self, *args)
    Last = _swig_new_instance_method(_intrules.IntegrationRuleArray_Last)

    def DeleteLast(self):
        r"""DeleteLast(IntegrationRuleArray self)"""
        return _intrules.IntegrationRuleArray_DeleteLast(self)
    DeleteLast = _swig_new_instance_method(_intrules.IntegrationRuleArray_DeleteLast)

    def DeleteAll(self):
        r"""DeleteAll(IntegrationRuleArray self)"""
        return _intrules.IntegrationRuleArray_DeleteAll(self)
    DeleteAll = _swig_new_instance_method(_intrules.IntegrationRuleArray_DeleteAll)

    def ShrinkToFit(self):
        r"""ShrinkToFit(IntegrationRuleArray self)"""
        return _intrules.IntegrationRuleArray_ShrinkToFit(self)
    ShrinkToFit = _swig_new_instance_method(_intrules.IntegrationRuleArray_ShrinkToFit)

    def Copy(self, copy):
        r"""Copy(IntegrationRuleArray self, IntegrationRuleArray copy)"""
        return _intrules.IntegrationRuleArray_Copy(self, copy)
    Copy = _swig_new_instance_method(_intrules.IntegrationRuleArray_Copy)

    def MakeRef(self, *args):
        r"""
        MakeRef(IntegrationRuleArray self, mfem::IntegrationRule ** data_, int size_, bool own_data=False)
        MakeRef(IntegrationRuleArray self, mfem::IntegrationRule ** data_, int size, mfem::MemoryType mt, bool own_data)
        MakeRef(IntegrationRuleArray self, IntegrationRuleArray master)
        """
        return _intrules.IntegrationRuleArray_MakeRef(self, *args)
    MakeRef = _swig_new_instance_method(_intrules.IntegrationRuleArray_MakeRef)

    def GetSubArray(self, offset, sa_size, sa):
        r"""GetSubArray(IntegrationRuleArray self, int offset, int sa_size, IntegrationRuleArray sa)"""
        return _intrules.IntegrationRuleArray_GetSubArray(self, offset, sa_size, sa)
    GetSubArray = _swig_new_instance_method(_intrules.IntegrationRuleArray_GetSubArray)

    def IsEmpty(self):
        r"""IsEmpty(IntegrationRuleArray self) -> bool"""
        return _intrules.IntegrationRuleArray_IsEmpty(self)
    IsEmpty = _swig_new_instance_method(_intrules.IntegrationRuleArray_IsEmpty)

    def begin(self, *args):
        r"""
        begin(IntegrationRuleArray self) -> IntegrationRule
        begin(IntegrationRuleArray self) -> mfem::IntegrationRule *const *
        """
        return _intrules.IntegrationRuleArray_begin(self, *args)
    begin = _swig_new_instance_method(_intrules.IntegrationRuleArray_begin)

    def end(self, *args):
        r"""
        end(IntegrationRuleArray self) -> IntegrationRule
        end(IntegrationRuleArray self) -> mfem::IntegrationRule *const *
        """
        return _intrules.IntegrationRuleArray_end(self, *args)
    end = _swig_new_instance_method(_intrules.IntegrationRuleArray_end)

    def MemoryUsage(self):
        r"""MemoryUsage(IntegrationRuleArray self) -> std::size_t"""
        return _intrules.IntegrationRuleArray_MemoryUsage(self)
    MemoryUsage = _swig_new_instance_method(_intrules.IntegrationRuleArray_MemoryUsage)

    def Read(self, on_dev=True):
        r"""Read(IntegrationRuleArray self, bool on_dev=True) -> mfem::IntegrationRule *const *"""
        return _intrules.IntegrationRuleArray_Read(self, on_dev)
    Read = _swig_new_instance_method(_intrules.IntegrationRuleArray_Read)

    def HostRead(self):
        r"""HostRead(IntegrationRuleArray self) -> mfem::IntegrationRule *const *"""
        return _intrules.IntegrationRuleArray_HostRead(self)
    HostRead = _swig_new_instance_method(_intrules.IntegrationRuleArray_HostRead)

    def Write(self, on_dev=True):
        r"""Write(IntegrationRuleArray self, bool on_dev=True) -> mfem::IntegrationRule **"""
        return _intrules.IntegrationRuleArray_Write(self, on_dev)
    Write = _swig_new_instance_method(_intrules.IntegrationRuleArray_Write)

    def HostWrite(self):
        r"""HostWrite(IntegrationRuleArray self) -> mfem::IntegrationRule **"""
        return _intrules.IntegrationRuleArray_HostWrite(self)
    HostWrite = _swig_new_instance_method(_intrules.IntegrationRuleArray_HostWrite)

    def ReadWrite(self, on_dev=True):
        r"""ReadWrite(IntegrationRuleArray self, bool on_dev=True) -> mfem::IntegrationRule **"""
        return _intrules.IntegrationRuleArray_ReadWrite(self, on_dev)
    ReadWrite = _swig_new_instance_method(_intrules.IntegrationRuleArray_ReadWrite)

    def HostReadWrite(self):
        r"""HostReadWrite(IntegrationRuleArray self) -> mfem::IntegrationRule **"""
        return _intrules.IntegrationRuleArray_HostReadWrite(self)
    HostReadWrite = _swig_new_instance_method(_intrules.IntegrationRuleArray_HostReadWrite)

    def __init__(self, *args):
        r"""
        __init__(IntegrationRuleArray self) -> IntegrationRuleArray
        __init__(IntegrationRuleArray self, mfem::MemoryType mt) -> IntegrationRuleArray
        __init__(IntegrationRuleArray self, int asize) -> IntegrationRuleArray
        __init__(IntegrationRuleArray self, int asize, mfem::MemoryType mt) -> IntegrationRuleArray
        __init__(IntegrationRuleArray self, mfem::IntegrationRule ** data_, bool own_data=False) -> IntegrationRuleArray
        __init__(IntegrationRuleArray self, IntegrationRuleArray src) -> IntegrationRuleArray
        __init__(IntegrationRuleArray self, IntegrationRuleArray src) -> IntegrationRuleArray
        __init__(IntegrationRuleArray self, void * List_or_Tuple) -> IntegrationRuleArray
        """
        _intrules.IntegrationRuleArray_swiginit(self, _intrules.new_IntegrationRuleArray(*args))

    def __setitem__(self, i, v):
        r"""__setitem__(IntegrationRuleArray self, int i, IntegrationRule v)"""

        i = int(i)
        if hasattr(v, "thisown"):
            v.thisown = False


        return _intrules.IntegrationRuleArray___setitem__(self, i, v)


    def Assign(self, *args):
        r"""
        Assign(IntegrationRuleArray self, mfem::IntegrationRule *const * arg2)
        Assign(IntegrationRuleArray self, IntegrationRule a)
        """
        return _intrules.IntegrationRuleArray_Assign(self, *args)
    Assign = _swig_new_instance_method(_intrules.IntegrationRuleArray_Assign)

    def ToList(self):
        return [self[i] for i in range(self.Size())]



    def __iter__(self):
        class iter_array:
            def __init__(self, obj):
                self.obj = obj
                self.idx = 0
                self.size = obj.Size()
            def __iter__(self):
                self.idx = 0
            def __next__(self):
                if self.idx < self.size:
                    res = self.obj[self.idx]
                    self.idx += 1
                    return res
                else:
                    raise StopIteration
        return iter_array(self)



    def __getitem__(self, param):
        r"""__getitem__(IntegrationRuleArray self, PyObject * param) -> PyObject *"""
        return _intrules.IntegrationRuleArray___getitem__(self, param)
    __getitem__ = _swig_new_instance_method(_intrules.IntegrationRuleArray___getitem__)

# Register IntegrationRuleArray in _intrules:
_intrules.IntegrationRuleArray_swigregister(IntegrationRuleArray)

def Swap(*args):
    r"""
    Swap(intArray arg1, intArray arg2)
    Swap(doubleArray arg1, doubleArray arg2)
    Swap(int8Array arg1, int8Array arg2)
    Swap(int64Array arg1, int64Array arg2)
    Swap(boolArray arg1, boolArray arg2)
    Swap(uintArray arg1, uintArray arg2)
    Swap(intArrayArray arg1, intArrayArray arg2)
    Swap(intArray2D arg1, intArray2D arg2)
    Swap(doubleArray2D arg1, doubleArray2D arg2)
    Swap(DenseMatrixArray2D arg1, DenseMatrixArray2D arg2)
    Swap(SparseMatrixArray2D arg1, SparseMatrixArray2D arg2)
    Swap(IntegrationPointArray arg1, IntegrationPointArray arg2)
    Swap(IntegrationRuleArray arg1, IntegrationRuleArray arg2)
    """
    return _intrules.Swap(*args)
Swap = _intrules.Swap

class IntegrationPoint(object):
    r"""Proxy of C++ mfem::IntegrationPoint class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_intrules.IntegrationPoint_x_get, _intrules.IntegrationPoint_x_set, doc=r"""x : mfem::real_t""")
    y = property(_intrules.IntegrationPoint_y_get, _intrules.IntegrationPoint_y_set, doc=r"""y : mfem::real_t""")
    z = property(_intrules.IntegrationPoint_z_get, _intrules.IntegrationPoint_z_set, doc=r"""z : mfem::real_t""")
    weight = property(_intrules.IntegrationPoint_weight_get, _intrules.IntegrationPoint_weight_set, doc=r"""weight : mfem::real_t""")
    index = property(_intrules.IntegrationPoint_index_get, _intrules.IntegrationPoint_index_set, doc=r"""index : int""")

    def Init(self, i):
        r"""Init(IntegrationPoint self, int const i)"""
        return _intrules.IntegrationPoint_Init(self, i)
    Init = _swig_new_instance_method(_intrules.IntegrationPoint_Init)

    def Get(self, p, dim):
        r"""Get(IntegrationPoint self, mfem::real_t * p, int const dim)"""
        return _intrules.IntegrationPoint_Get(self, p, dim)
    Get = _swig_new_instance_method(_intrules.IntegrationPoint_Get)

    def Set(self, *args):
        r"""
        Set(IntegrationPoint self, mfem::real_t const * p, int const dim)
        Set(IntegrationPoint self, mfem::real_t const x1, mfem::real_t const x2, mfem::real_t const x3, mfem::real_t const w)
        """
        return _intrules.IntegrationPoint_Set(self, *args)
    Set = _swig_new_instance_method(_intrules.IntegrationPoint_Set)

    def Set3w(self, p):
        r"""Set3w(IntegrationPoint self, mfem::real_t const * p)"""
        return _intrules.IntegrationPoint_Set3w(self, p)
    Set3w = _swig_new_instance_method(_intrules.IntegrationPoint_Set3w)

    def Set3(self, *args):
        r"""
        Set3(IntegrationPoint self, mfem::real_t const x1, mfem::real_t const x2, mfem::real_t const x3)
        Set3(IntegrationPoint self, mfem::real_t const * p)
        """
        return _intrules.IntegrationPoint_Set3(self, *args)
    Set3 = _swig_new_instance_method(_intrules.IntegrationPoint_Set3)

    def Set2w(self, *args):
        r"""
        Set2w(IntegrationPoint self, mfem::real_t const x1, mfem::real_t const x2, mfem::real_t const w)
        Set2w(IntegrationPoint self, mfem::real_t const * p)
        """
        return _intrules.IntegrationPoint_Set2w(self, *args)
    Set2w = _swig_new_instance_method(_intrules.IntegrationPoint_Set2w)

    def Set2(self, *args):
        r"""
        Set2(IntegrationPoint self, mfem::real_t const x1, mfem::real_t const x2)
        Set2(IntegrationPoint self, mfem::real_t const * p)
        """
        return _intrules.IntegrationPoint_Set2(self, *args)
    Set2 = _swig_new_instance_method(_intrules.IntegrationPoint_Set2)

    def Set1w(self, *args):
        r"""
        Set1w(IntegrationPoint self, mfem::real_t const x1, mfem::real_t const w)
        Set1w(IntegrationPoint self, mfem::real_t const * p)
        """
        return _intrules.IntegrationPoint_Set1w(self, *args)
    Set1w = _swig_new_instance_method(_intrules.IntegrationPoint_Set1w)

    def __init__(self):
        r"""__init__(IntegrationPoint self) -> IntegrationPoint"""
        _intrules.IntegrationPoint_swiginit(self, _intrules.new_IntegrationPoint())
    __swig_destroy__ = _intrules.delete_IntegrationPoint

# Register IntegrationPoint in _intrules:
_intrules.IntegrationPoint_swigregister(IntegrationPoint)
class IntegrationRule(IntegrationPointArray):
    r"""Proxy of C++ mfem::IntegrationRule class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def SetPointIndices(self):
        r"""SetPointIndices(IntegrationRule self)"""
        return _intrules.IntegrationRule_SetPointIndices(self)
    SetPointIndices = _swig_new_instance_method(_intrules.IntegrationRule_SetPointIndices)

    def __init__(self, *args):
        r"""
        __init__(IntegrationRule self) -> IntegrationRule
        __init__(IntegrationRule self, int NP) -> IntegrationRule
        __init__(IntegrationRule self, IntegrationRule irx, IntegrationRule iry) -> IntegrationRule
        __init__(IntegrationRule self, IntegrationRule irx, IntegrationRule iry, IntegrationRule irz) -> IntegrationRule
        """
        _intrules.IntegrationRule_swiginit(self, _intrules.new_IntegrationRule(*args))

    def GetOrder(self):
        r"""GetOrder(IntegrationRule self) -> int"""
        return _intrules.IntegrationRule_GetOrder(self)
    GetOrder = _swig_new_instance_method(_intrules.IntegrationRule_GetOrder)

    def SetOrder(self, order):
        r"""SetOrder(IntegrationRule self, int const order)"""
        return _intrules.IntegrationRule_SetOrder(self, order)
    SetOrder = _swig_new_instance_method(_intrules.IntegrationRule_SetOrder)

    def GetNPoints(self):
        r"""GetNPoints(IntegrationRule self) -> int"""
        return _intrules.IntegrationRule_GetNPoints(self)
    GetNPoints = _swig_new_instance_method(_intrules.IntegrationRule_GetNPoints)

    def IntPoint(self, *args):
        r"""
        IntPoint(IntegrationRule self, int i) -> IntegrationPoint
        IntPoint(IntegrationRule self, int i) -> IntegrationPoint
        """
        return _intrules.IntegrationRule_IntPoint(self, *args)
    IntPoint = _swig_new_instance_method(_intrules.IntegrationRule_IntPoint)

    def GetWeights(self):
        r"""GetWeights(IntegrationRule self) -> doubleArray"""
        return _intrules.IntegrationRule_GetWeights(self)
    GetWeights = _swig_new_instance_method(_intrules.IntegrationRule_GetWeights)

    def ApplyToKnotIntervals(self, kv):
        r"""ApplyToKnotIntervals(IntegrationRule self, mfem::KnotVector const & kv) -> IntegrationRule"""
        return _intrules.IntegrationRule_ApplyToKnotIntervals(self, kv)
    ApplyToKnotIntervals = _swig_new_instance_method(_intrules.IntegrationRule_ApplyToKnotIntervals)
    __swig_destroy__ = _intrules.delete_IntegrationRule

# Register IntegrationRule in _intrules:
_intrules.IntegrationRule_swigregister(IntegrationRule)
class NURBSMeshRules(object):
    r"""Proxy of C++ mfem::NURBSMeshRules class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, numPatches, dim_):
        r"""__init__(NURBSMeshRules self, int const numPatches, int const dim_) -> NURBSMeshRules"""
        _intrules.NURBSMeshRules_swiginit(self, _intrules.new_NURBSMeshRules(numPatches, dim_))

    def GetElementRule(self, elem, patch, ijk, kv):
        r"""GetElementRule(NURBSMeshRules self, int const elem, int const patch, int const * ijk, mfem::Array< mfem::KnotVector const * > const & kv) -> IntegrationRule"""
        return _intrules.NURBSMeshRules_GetElementRule(self, elem, patch, ijk, kv)
    GetElementRule = _swig_new_instance_method(_intrules.NURBSMeshRules_GetElementRule)

    def AddElementRule(self, ir_element):
        r"""AddElementRule(NURBSMeshRules self, IntegrationRule ir_element) -> std::size_t"""
        return _intrules.NURBSMeshRules_AddElementRule(self, ir_element)
    AddElementRule = _swig_new_instance_method(_intrules.NURBSMeshRules_AddElementRule)

    def SetElementRule(self, element, elementRuleIndex):
        r"""SetElementRule(NURBSMeshRules self, std::size_t const element, std::size_t const elementRuleIndex)"""
        return _intrules.NURBSMeshRules_SetElementRule(self, element, elementRuleIndex)
    SetElementRule = _swig_new_instance_method(_intrules.NURBSMeshRules_SetElementRule)

    def SetPatchRules1D(self, patch, ir1D):
        r"""SetPatchRules1D(NURBSMeshRules self, int const patch, std::vector< mfem::IntegrationRule const * > & ir1D)"""
        return _intrules.NURBSMeshRules_SetPatchRules1D(self, patch, ir1D)
    SetPatchRules1D = _swig_new_instance_method(_intrules.NURBSMeshRules_SetPatchRules1D)

    def GetPatchRule1D(self, patch, dimension):
        r"""GetPatchRule1D(NURBSMeshRules self, int const patch, int const dimension) -> IntegrationRule"""
        return _intrules.NURBSMeshRules_GetPatchRule1D(self, patch, dimension)
    GetPatchRule1D = _swig_new_instance_method(_intrules.NURBSMeshRules_GetPatchRule1D)

    def GetIntegrationPointFrom1D(self, patch, i, j, k, ip):
        r"""GetIntegrationPointFrom1D(NURBSMeshRules self, int const patch, int i, int j, int k, IntegrationPoint ip)"""
        return _intrules.NURBSMeshRules_GetIntegrationPointFrom1D(self, patch, i, j, k, ip)
    GetIntegrationPointFrom1D = _swig_new_instance_method(_intrules.NURBSMeshRules_GetIntegrationPointFrom1D)

    def Finalize(self, mesh):
        r"""Finalize(NURBSMeshRules self, mfem::Mesh const & mesh)"""
        return _intrules.NURBSMeshRules_Finalize(self, mesh)
    Finalize = _swig_new_instance_method(_intrules.NURBSMeshRules_Finalize)

    def GetPointElement(self, patch, i, j, k):
        r"""GetPointElement(NURBSMeshRules self, int patch, int i, int j, int k) -> int"""
        return _intrules.NURBSMeshRules_GetPointElement(self, patch, i, j, k)
    GetPointElement = _swig_new_instance_method(_intrules.NURBSMeshRules_GetPointElement)

    def GetDim(self):
        r"""GetDim(NURBSMeshRules self) -> int"""
        return _intrules.NURBSMeshRules_GetDim(self)
    GetDim = _swig_new_instance_method(_intrules.NURBSMeshRules_GetDim)

    def GetPatchRule1D_KnotSpan(self, patch, dimension):
        r"""GetPatchRule1D_KnotSpan(NURBSMeshRules self, int const patch, int const dimension) -> intArray"""
        return _intrules.NURBSMeshRules_GetPatchRule1D_KnotSpan(self, patch, dimension)
    GetPatchRule1D_KnotSpan = _swig_new_instance_method(_intrules.NURBSMeshRules_GetPatchRule1D_KnotSpan)
    __swig_destroy__ = _intrules.delete_NURBSMeshRules

# Register NURBSMeshRules in _intrules:
_intrules.NURBSMeshRules_swigregister(NURBSMeshRules)
class QuadratureFunctions1D(object):
    r"""Proxy of C++ mfem::QuadratureFunctions1D class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def GaussLegendre(np, ir):
        r"""GaussLegendre(int const np, IntegrationRule ir)"""
        return _intrules.QuadratureFunctions1D_GaussLegendre(np, ir)
    GaussLegendre = _swig_new_static_method(_intrules.QuadratureFunctions1D_GaussLegendre)

    @staticmethod
    def GaussLobatto(np, ir):
        r"""GaussLobatto(int const np, IntegrationRule ir)"""
        return _intrules.QuadratureFunctions1D_GaussLobatto(np, ir)
    GaussLobatto = _swig_new_static_method(_intrules.QuadratureFunctions1D_GaussLobatto)

    @staticmethod
    def OpenUniform(np, ir):
        r"""OpenUniform(int const np, IntegrationRule ir)"""
        return _intrules.QuadratureFunctions1D_OpenUniform(np, ir)
    OpenUniform = _swig_new_static_method(_intrules.QuadratureFunctions1D_OpenUniform)

    @staticmethod
    def ClosedUniform(np, ir):
        r"""ClosedUniform(int const np, IntegrationRule ir)"""
        return _intrules.QuadratureFunctions1D_ClosedUniform(np, ir)
    ClosedUniform = _swig_new_static_method(_intrules.QuadratureFunctions1D_ClosedUniform)

    @staticmethod
    def OpenHalfUniform(np, ir):
        r"""OpenHalfUniform(int const np, IntegrationRule ir)"""
        return _intrules.QuadratureFunctions1D_OpenHalfUniform(np, ir)
    OpenHalfUniform = _swig_new_static_method(_intrules.QuadratureFunctions1D_OpenHalfUniform)

    @staticmethod
    def ClosedGL(np, ir):
        r"""ClosedGL(int const np, IntegrationRule ir)"""
        return _intrules.QuadratureFunctions1D_ClosedGL(np, ir)
    ClosedGL = _swig_new_static_method(_intrules.QuadratureFunctions1D_ClosedGL)

    @staticmethod
    def GivePolyPoints(np, pts, type):
        r"""GivePolyPoints(int const np, mfem::real_t * pts, int const type)"""
        return _intrules.QuadratureFunctions1D_GivePolyPoints(np, pts, type)
    GivePolyPoints = _swig_new_static_method(_intrules.QuadratureFunctions1D_GivePolyPoints)

    def __init__(self):
        r"""__init__(QuadratureFunctions1D self) -> QuadratureFunctions1D"""
        _intrules.QuadratureFunctions1D_swiginit(self, _intrules.new_QuadratureFunctions1D())
    __swig_destroy__ = _intrules.delete_QuadratureFunctions1D

# Register QuadratureFunctions1D in _intrules:
_intrules.QuadratureFunctions1D_swigregister(QuadratureFunctions1D)
class Quadrature1D(object):
    r"""Proxy of C++ mfem::Quadrature1D class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Invalid = _intrules.Quadrature1D_Invalid
    
    GaussLegendre = _intrules.Quadrature1D_GaussLegendre
    
    GaussLobatto = _intrules.Quadrature1D_GaussLobatto
    
    OpenUniform = _intrules.Quadrature1D_OpenUniform
    
    ClosedUniform = _intrules.Quadrature1D_ClosedUniform
    
    OpenHalfUniform = _intrules.Quadrature1D_OpenHalfUniform
    
    ClosedGL = _intrules.Quadrature1D_ClosedGL
    

    @staticmethod
    def CheckClosed(type):
        r"""CheckClosed(int type) -> int"""
        return _intrules.Quadrature1D_CheckClosed(type)
    CheckClosed = _swig_new_static_method(_intrules.Quadrature1D_CheckClosed)

    @staticmethod
    def CheckOpen(type):
        r"""CheckOpen(int type) -> int"""
        return _intrules.Quadrature1D_CheckOpen(type)
    CheckOpen = _swig_new_static_method(_intrules.Quadrature1D_CheckOpen)

    def __init__(self):
        r"""__init__(Quadrature1D self) -> Quadrature1D"""
        _intrules.Quadrature1D_swiginit(self, _intrules.new_Quadrature1D())
    __swig_destroy__ = _intrules.delete_Quadrature1D

# Register Quadrature1D in _intrules:
_intrules.Quadrature1D_swigregister(Quadrature1D)
class IntegrationRules(object):
    r"""Proxy of C++ mfem::IntegrationRules class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(IntegrationRules self, int ref=0, int type=GaussLegendre) -> IntegrationRules"""
        _intrules.IntegrationRules_swiginit(self, _intrules.new_IntegrationRules(*args, **kwargs))

    def Get(self, GeomType, Order):
        r"""Get(IntegrationRules self, int GeomType, int Order) -> IntegrationRule"""
        return _intrules.IntegrationRules_Get(self, GeomType, Order)
    Get = _swig_new_instance_method(_intrules.IntegrationRules_Get)

    def Set(self, GeomType, Order, IntRule):
        r"""Set(IntegrationRules self, int GeomType, int Order, IntegrationRule IntRule)"""
        return _intrules.IntegrationRules_Set(self, GeomType, Order, IntRule)
    Set = _swig_new_instance_method(_intrules.IntegrationRules_Set)

    def SetOwnRules(self, o):
        r"""SetOwnRules(IntegrationRules self, int o)"""
        return _intrules.IntegrationRules_SetOwnRules(self, o)
    SetOwnRules = _swig_new_instance_method(_intrules.IntegrationRules_SetOwnRules)
    __swig_destroy__ = _intrules.delete_IntegrationRules

# Register IntegrationRules in _intrules:
_intrules.IntegrationRules_swigregister(IntegrationRules)
class PyIntegrationRule(IntegrationRule):
    r"""Proxy of C++ mfem::PyIntegrationRule class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(PyIntegrationRule self) -> PyIntegrationRule"""
        _intrules.PyIntegrationRule_swiginit(self, _intrules.new_PyIntegrationRule())
    __swig_destroy__ = _intrules.delete_PyIntegrationRule

# Register PyIntegrationRule in _intrules:
_intrules.PyIntegrationRule_swigregister(PyIntegrationRule)
cvar = _intrules.cvar
IntRules = cvar.IntRules
RefinedIntRules = cvar.RefinedIntRules


