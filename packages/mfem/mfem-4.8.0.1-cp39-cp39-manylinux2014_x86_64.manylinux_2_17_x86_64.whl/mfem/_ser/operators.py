# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _operators
else:
    import _operators

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _operators.SWIG_PyInstanceMethod_New
_swig_new_static_method = _operators.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

import mfem._ser.mem_manager
import mfem._ser.globals
import mfem._ser.vector
import mfem._ser.array
class OperatorArray(object):
    r"""Proxy of C++ mfem::Array< mfem::Operator * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _operators.delete_OperatorArray

    def GetData(self, *args):
        r"""
        GetData(OperatorArray self) -> Operator
        GetData(OperatorArray self) -> mfem::Operator *const *
        """
        return _operators.OperatorArray_GetData(self, *args)
    GetData = _swig_new_instance_method(_operators.OperatorArray_GetData)

    def GetMemory(self, *args):
        r"""
        GetMemory(OperatorArray self) -> mfem::Memory< mfem::Operator * >
        GetMemory(OperatorArray self) -> mfem::Memory< mfem::Operator * > const &
        """
        return _operators.OperatorArray_GetMemory(self, *args)
    GetMemory = _swig_new_instance_method(_operators.OperatorArray_GetMemory)

    def UseDevice(self):
        r"""UseDevice(OperatorArray self) -> bool"""
        return _operators.OperatorArray_UseDevice(self)
    UseDevice = _swig_new_instance_method(_operators.OperatorArray_UseDevice)

    def OwnsData(self):
        r"""OwnsData(OperatorArray self) -> bool"""
        return _operators.OperatorArray_OwnsData(self)
    OwnsData = _swig_new_instance_method(_operators.OperatorArray_OwnsData)

    def StealData(self, p):
        r"""StealData(OperatorArray self, mfem::Operator *** p)"""
        return _operators.OperatorArray_StealData(self, p)
    StealData = _swig_new_instance_method(_operators.OperatorArray_StealData)

    def LoseData(self):
        r"""LoseData(OperatorArray self)"""
        return _operators.OperatorArray_LoseData(self)
    LoseData = _swig_new_instance_method(_operators.OperatorArray_LoseData)

    def MakeDataOwner(self):
        r"""MakeDataOwner(OperatorArray self)"""
        return _operators.OperatorArray_MakeDataOwner(self)
    MakeDataOwner = _swig_new_instance_method(_operators.OperatorArray_MakeDataOwner)

    def Size(self):
        r"""Size(OperatorArray self) -> int"""
        return _operators.OperatorArray_Size(self)
    Size = _swig_new_instance_method(_operators.OperatorArray_Size)

    def SetSize(self, *args):
        r"""
        SetSize(OperatorArray self, int nsize)
        SetSize(OperatorArray self, int nsize, Operator initval)
        SetSize(OperatorArray self, int nsize, mfem::MemoryType mt)
        """
        return _operators.OperatorArray_SetSize(self, *args)
    SetSize = _swig_new_instance_method(_operators.OperatorArray_SetSize)

    def Capacity(self):
        r"""Capacity(OperatorArray self) -> int"""
        return _operators.OperatorArray_Capacity(self)
    Capacity = _swig_new_instance_method(_operators.OperatorArray_Capacity)

    def Reserve(self, capacity):
        r"""Reserve(OperatorArray self, int capacity)"""
        return _operators.OperatorArray_Reserve(self, capacity)
    Reserve = _swig_new_instance_method(_operators.OperatorArray_Reserve)

    def Append(self, *args):
        r"""
        Append(OperatorArray self, Operator el) -> int
        Append(OperatorArray self, mfem::Operator *const * els, int nels) -> int
        Append(OperatorArray self, OperatorArray els) -> int
        """

        if isinstance(args[0], list):
           return self.Append(self.__class__(args[0]))
        if isinstance(args[0], tuple):
           return self.Append(self.__class__(args[0]))


        return _operators.OperatorArray_Append(self, *args)


    def Prepend(self, el):
        r"""Prepend(OperatorArray self, Operator el) -> int"""
        return _operators.OperatorArray_Prepend(self, el)
    Prepend = _swig_new_instance_method(_operators.OperatorArray_Prepend)

    def Last(self, *args):
        r"""
        Last(OperatorArray self) -> Operator
        Last(OperatorArray self) -> Operator
        """
        return _operators.OperatorArray_Last(self, *args)
    Last = _swig_new_instance_method(_operators.OperatorArray_Last)

    def DeleteLast(self):
        r"""DeleteLast(OperatorArray self)"""
        return _operators.OperatorArray_DeleteLast(self)
    DeleteLast = _swig_new_instance_method(_operators.OperatorArray_DeleteLast)

    def DeleteAll(self):
        r"""DeleteAll(OperatorArray self)"""
        return _operators.OperatorArray_DeleteAll(self)
    DeleteAll = _swig_new_instance_method(_operators.OperatorArray_DeleteAll)

    def ShrinkToFit(self):
        r"""ShrinkToFit(OperatorArray self)"""
        return _operators.OperatorArray_ShrinkToFit(self)
    ShrinkToFit = _swig_new_instance_method(_operators.OperatorArray_ShrinkToFit)

    def Copy(self, copy):
        r"""Copy(OperatorArray self, OperatorArray copy)"""
        return _operators.OperatorArray_Copy(self, copy)
    Copy = _swig_new_instance_method(_operators.OperatorArray_Copy)

    def MakeRef(self, *args):
        r"""
        MakeRef(OperatorArray self, mfem::Operator ** data_, int size_, bool own_data=False)
        MakeRef(OperatorArray self, mfem::Operator ** data_, int size, mfem::MemoryType mt, bool own_data)
        MakeRef(OperatorArray self, OperatorArray master)
        """
        return _operators.OperatorArray_MakeRef(self, *args)
    MakeRef = _swig_new_instance_method(_operators.OperatorArray_MakeRef)

    def GetSubArray(self, offset, sa_size, sa):
        r"""GetSubArray(OperatorArray self, int offset, int sa_size, OperatorArray sa)"""
        return _operators.OperatorArray_GetSubArray(self, offset, sa_size, sa)
    GetSubArray = _swig_new_instance_method(_operators.OperatorArray_GetSubArray)

    def IsEmpty(self):
        r"""IsEmpty(OperatorArray self) -> bool"""
        return _operators.OperatorArray_IsEmpty(self)
    IsEmpty = _swig_new_instance_method(_operators.OperatorArray_IsEmpty)

    def begin(self, *args):
        r"""
        begin(OperatorArray self) -> Operator
        begin(OperatorArray self) -> mfem::Operator *const *
        """
        return _operators.OperatorArray_begin(self, *args)
    begin = _swig_new_instance_method(_operators.OperatorArray_begin)

    def end(self, *args):
        r"""
        end(OperatorArray self) -> Operator
        end(OperatorArray self) -> mfem::Operator *const *
        """
        return _operators.OperatorArray_end(self, *args)
    end = _swig_new_instance_method(_operators.OperatorArray_end)

    def MemoryUsage(self):
        r"""MemoryUsage(OperatorArray self) -> std::size_t"""
        return _operators.OperatorArray_MemoryUsage(self)
    MemoryUsage = _swig_new_instance_method(_operators.OperatorArray_MemoryUsage)

    def Read(self, on_dev=True):
        r"""Read(OperatorArray self, bool on_dev=True) -> mfem::Operator *const *"""
        return _operators.OperatorArray_Read(self, on_dev)
    Read = _swig_new_instance_method(_operators.OperatorArray_Read)

    def HostRead(self):
        r"""HostRead(OperatorArray self) -> mfem::Operator *const *"""
        return _operators.OperatorArray_HostRead(self)
    HostRead = _swig_new_instance_method(_operators.OperatorArray_HostRead)

    def Write(self, on_dev=True):
        r"""Write(OperatorArray self, bool on_dev=True) -> mfem::Operator **"""
        return _operators.OperatorArray_Write(self, on_dev)
    Write = _swig_new_instance_method(_operators.OperatorArray_Write)

    def HostWrite(self):
        r"""HostWrite(OperatorArray self) -> mfem::Operator **"""
        return _operators.OperatorArray_HostWrite(self)
    HostWrite = _swig_new_instance_method(_operators.OperatorArray_HostWrite)

    def ReadWrite(self, on_dev=True):
        r"""ReadWrite(OperatorArray self, bool on_dev=True) -> mfem::Operator **"""
        return _operators.OperatorArray_ReadWrite(self, on_dev)
    ReadWrite = _swig_new_instance_method(_operators.OperatorArray_ReadWrite)

    def HostReadWrite(self):
        r"""HostReadWrite(OperatorArray self) -> mfem::Operator **"""
        return _operators.OperatorArray_HostReadWrite(self)
    HostReadWrite = _swig_new_instance_method(_operators.OperatorArray_HostReadWrite)

    def __init__(self, *args):
        r"""
        __init__(OperatorArray self) -> OperatorArray
        __init__(OperatorArray self, mfem::MemoryType mt) -> OperatorArray
        __init__(OperatorArray self, int asize) -> OperatorArray
        __init__(OperatorArray self, int asize, mfem::MemoryType mt) -> OperatorArray
        __init__(OperatorArray self, mfem::Operator ** data_, bool own_data=False) -> OperatorArray
        __init__(OperatorArray self, OperatorArray src) -> OperatorArray
        __init__(OperatorArray self, OperatorArray src) -> OperatorArray
        __init__(OperatorArray self, void * List_or_Tuple) -> OperatorArray
        """
        _operators.OperatorArray_swiginit(self, _operators.new_OperatorArray(*args))

    def __setitem__(self, i, v):
        r"""__setitem__(OperatorArray self, int i, Operator v)"""

        i = int(i)
        if hasattr(v, "thisown"):
            v.thisown = False


        return _operators.OperatorArray___setitem__(self, i, v)


    def Assign(self, *args):
        r"""
        Assign(OperatorArray self, mfem::Operator *const * arg2)
        Assign(OperatorArray self, Operator a)
        """
        return _operators.OperatorArray_Assign(self, *args)
    Assign = _swig_new_instance_method(_operators.OperatorArray_Assign)

    def ToList(self):
        return [self[i] for i in range(self.Size())]



    def __iter__(self):
        class iter_array:
            def __init__(self, obj):
                self.obj = obj
                self.idx = 0
                self.size = obj.Size()
            def __iter__(self):
                self.idx = 0
            def __next__(self):
                if self.idx < self.size:
                    res = self.obj[self.idx]
                    self.idx += 1
                    return res
                else:
                    raise StopIteration
        return iter_array(self)



    def __getitem__(self, param):
        r"""__getitem__(OperatorArray self, PyObject * param) -> PyObject *"""
        return _operators.OperatorArray___getitem__(self, param)
    __getitem__ = _swig_new_instance_method(_operators.OperatorArray___getitem__)

# Register OperatorArray in _operators:
_operators.OperatorArray_swigregister(OperatorArray)
class SolverArray(object):
    r"""Proxy of C++ mfem::Array< mfem::Solver * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _operators.delete_SolverArray

    def GetData(self, *args):
        r"""
        GetData(SolverArray self) -> Solver
        GetData(SolverArray self) -> mfem::Solver *const *
        """
        return _operators.SolverArray_GetData(self, *args)
    GetData = _swig_new_instance_method(_operators.SolverArray_GetData)

    def GetMemory(self, *args):
        r"""
        GetMemory(SolverArray self) -> mfem::Memory< mfem::Solver * >
        GetMemory(SolverArray self) -> mfem::Memory< mfem::Solver * > const &
        """
        return _operators.SolverArray_GetMemory(self, *args)
    GetMemory = _swig_new_instance_method(_operators.SolverArray_GetMemory)

    def UseDevice(self):
        r"""UseDevice(SolverArray self) -> bool"""
        return _operators.SolverArray_UseDevice(self)
    UseDevice = _swig_new_instance_method(_operators.SolverArray_UseDevice)

    def OwnsData(self):
        r"""OwnsData(SolverArray self) -> bool"""
        return _operators.SolverArray_OwnsData(self)
    OwnsData = _swig_new_instance_method(_operators.SolverArray_OwnsData)

    def StealData(self, p):
        r"""StealData(SolverArray self, mfem::Solver *** p)"""
        return _operators.SolverArray_StealData(self, p)
    StealData = _swig_new_instance_method(_operators.SolverArray_StealData)

    def LoseData(self):
        r"""LoseData(SolverArray self)"""
        return _operators.SolverArray_LoseData(self)
    LoseData = _swig_new_instance_method(_operators.SolverArray_LoseData)

    def MakeDataOwner(self):
        r"""MakeDataOwner(SolverArray self)"""
        return _operators.SolverArray_MakeDataOwner(self)
    MakeDataOwner = _swig_new_instance_method(_operators.SolverArray_MakeDataOwner)

    def Size(self):
        r"""Size(SolverArray self) -> int"""
        return _operators.SolverArray_Size(self)
    Size = _swig_new_instance_method(_operators.SolverArray_Size)

    def SetSize(self, *args):
        r"""
        SetSize(SolverArray self, int nsize)
        SetSize(SolverArray self, int nsize, Solver initval)
        SetSize(SolverArray self, int nsize, mfem::MemoryType mt)
        """
        return _operators.SolverArray_SetSize(self, *args)
    SetSize = _swig_new_instance_method(_operators.SolverArray_SetSize)

    def Capacity(self):
        r"""Capacity(SolverArray self) -> int"""
        return _operators.SolverArray_Capacity(self)
    Capacity = _swig_new_instance_method(_operators.SolverArray_Capacity)

    def Reserve(self, capacity):
        r"""Reserve(SolverArray self, int capacity)"""
        return _operators.SolverArray_Reserve(self, capacity)
    Reserve = _swig_new_instance_method(_operators.SolverArray_Reserve)

    def Append(self, *args):
        r"""
        Append(SolverArray self, Solver el) -> int
        Append(SolverArray self, mfem::Solver *const * els, int nels) -> int
        Append(SolverArray self, SolverArray els) -> int
        """

        if isinstance(args[0], list):
           return self.Append(self.__class__(args[0]))
        if isinstance(args[0], tuple):
           return self.Append(self.__class__(args[0]))


        return _operators.SolverArray_Append(self, *args)


    def Prepend(self, el):
        r"""Prepend(SolverArray self, Solver el) -> int"""
        return _operators.SolverArray_Prepend(self, el)
    Prepend = _swig_new_instance_method(_operators.SolverArray_Prepend)

    def Last(self, *args):
        r"""
        Last(SolverArray self) -> Solver
        Last(SolverArray self) -> Solver
        """
        return _operators.SolverArray_Last(self, *args)
    Last = _swig_new_instance_method(_operators.SolverArray_Last)

    def DeleteLast(self):
        r"""DeleteLast(SolverArray self)"""
        return _operators.SolverArray_DeleteLast(self)
    DeleteLast = _swig_new_instance_method(_operators.SolverArray_DeleteLast)

    def DeleteAll(self):
        r"""DeleteAll(SolverArray self)"""
        return _operators.SolverArray_DeleteAll(self)
    DeleteAll = _swig_new_instance_method(_operators.SolverArray_DeleteAll)

    def ShrinkToFit(self):
        r"""ShrinkToFit(SolverArray self)"""
        return _operators.SolverArray_ShrinkToFit(self)
    ShrinkToFit = _swig_new_instance_method(_operators.SolverArray_ShrinkToFit)

    def Copy(self, copy):
        r"""Copy(SolverArray self, SolverArray copy)"""
        return _operators.SolverArray_Copy(self, copy)
    Copy = _swig_new_instance_method(_operators.SolverArray_Copy)

    def MakeRef(self, *args):
        r"""
        MakeRef(SolverArray self, mfem::Solver ** data_, int size_, bool own_data=False)
        MakeRef(SolverArray self, mfem::Solver ** data_, int size, mfem::MemoryType mt, bool own_data)
        MakeRef(SolverArray self, SolverArray master)
        """
        return _operators.SolverArray_MakeRef(self, *args)
    MakeRef = _swig_new_instance_method(_operators.SolverArray_MakeRef)

    def GetSubArray(self, offset, sa_size, sa):
        r"""GetSubArray(SolverArray self, int offset, int sa_size, SolverArray sa)"""
        return _operators.SolverArray_GetSubArray(self, offset, sa_size, sa)
    GetSubArray = _swig_new_instance_method(_operators.SolverArray_GetSubArray)

    def IsEmpty(self):
        r"""IsEmpty(SolverArray self) -> bool"""
        return _operators.SolverArray_IsEmpty(self)
    IsEmpty = _swig_new_instance_method(_operators.SolverArray_IsEmpty)

    def begin(self, *args):
        r"""
        begin(SolverArray self) -> Solver
        begin(SolverArray self) -> mfem::Solver *const *
        """
        return _operators.SolverArray_begin(self, *args)
    begin = _swig_new_instance_method(_operators.SolverArray_begin)

    def end(self, *args):
        r"""
        end(SolverArray self) -> Solver
        end(SolverArray self) -> mfem::Solver *const *
        """
        return _operators.SolverArray_end(self, *args)
    end = _swig_new_instance_method(_operators.SolverArray_end)

    def MemoryUsage(self):
        r"""MemoryUsage(SolverArray self) -> std::size_t"""
        return _operators.SolverArray_MemoryUsage(self)
    MemoryUsage = _swig_new_instance_method(_operators.SolverArray_MemoryUsage)

    def Read(self, on_dev=True):
        r"""Read(SolverArray self, bool on_dev=True) -> mfem::Solver *const *"""
        return _operators.SolverArray_Read(self, on_dev)
    Read = _swig_new_instance_method(_operators.SolverArray_Read)

    def HostRead(self):
        r"""HostRead(SolverArray self) -> mfem::Solver *const *"""
        return _operators.SolverArray_HostRead(self)
    HostRead = _swig_new_instance_method(_operators.SolverArray_HostRead)

    def Write(self, on_dev=True):
        r"""Write(SolverArray self, bool on_dev=True) -> mfem::Solver **"""
        return _operators.SolverArray_Write(self, on_dev)
    Write = _swig_new_instance_method(_operators.SolverArray_Write)

    def HostWrite(self):
        r"""HostWrite(SolverArray self) -> mfem::Solver **"""
        return _operators.SolverArray_HostWrite(self)
    HostWrite = _swig_new_instance_method(_operators.SolverArray_HostWrite)

    def ReadWrite(self, on_dev=True):
        r"""ReadWrite(SolverArray self, bool on_dev=True) -> mfem::Solver **"""
        return _operators.SolverArray_ReadWrite(self, on_dev)
    ReadWrite = _swig_new_instance_method(_operators.SolverArray_ReadWrite)

    def HostReadWrite(self):
        r"""HostReadWrite(SolverArray self) -> mfem::Solver **"""
        return _operators.SolverArray_HostReadWrite(self)
    HostReadWrite = _swig_new_instance_method(_operators.SolverArray_HostReadWrite)

    def __init__(self, *args):
        r"""
        __init__(SolverArray self) -> SolverArray
        __init__(SolverArray self, mfem::MemoryType mt) -> SolverArray
        __init__(SolverArray self, int asize) -> SolverArray
        __init__(SolverArray self, int asize, mfem::MemoryType mt) -> SolverArray
        __init__(SolverArray self, mfem::Solver ** data_, bool own_data=False) -> SolverArray
        __init__(SolverArray self, SolverArray src) -> SolverArray
        __init__(SolverArray self, SolverArray src) -> SolverArray
        __init__(SolverArray self, void * List_or_Tuple) -> SolverArray
        """
        _operators.SolverArray_swiginit(self, _operators.new_SolverArray(*args))

    def __setitem__(self, i, v):
        r"""__setitem__(SolverArray self, int i, Solver v)"""

        i = int(i)
        if hasattr(v, "thisown"):
            v.thisown = False


        return _operators.SolverArray___setitem__(self, i, v)


    def Assign(self, *args):
        r"""
        Assign(SolverArray self, mfem::Solver *const * arg2)
        Assign(SolverArray self, Solver a)
        """
        return _operators.SolverArray_Assign(self, *args)
    Assign = _swig_new_instance_method(_operators.SolverArray_Assign)

    def ToList(self):
        return [self[i] for i in range(self.Size())]



    def __iter__(self):
        class iter_array:
            def __init__(self, obj):
                self.obj = obj
                self.idx = 0
                self.size = obj.Size()
            def __iter__(self):
                self.idx = 0
            def __next__(self):
                if self.idx < self.size:
                    res = self.obj[self.idx]
                    self.idx += 1
                    return res
                else:
                    raise StopIteration
        return iter_array(self)



    def __getitem__(self, param):
        r"""__getitem__(SolverArray self, PyObject * param) -> PyObject *"""
        return _operators.SolverArray___getitem__(self, param)
    __getitem__ = _swig_new_instance_method(_operators.SolverArray___getitem__)

# Register SolverArray in _operators:
_operators.SolverArray_swigregister(SolverArray)

def Swap(*args):
    r"""
    Swap(intArray arg1, intArray arg2)
    Swap(doubleArray arg1, doubleArray arg2)
    Swap(int8Array arg1, int8Array arg2)
    Swap(int64Array arg1, int64Array arg2)
    Swap(boolArray arg1, boolArray arg2)
    Swap(uintArray arg1, uintArray arg2)
    Swap(intArrayArray arg1, intArrayArray arg2)
    Swap(intArray2D arg1, intArray2D arg2)
    Swap(doubleArray2D arg1, doubleArray2D arg2)
    Swap(DenseMatrixArray2D arg1, DenseMatrixArray2D arg2)
    Swap(SparseMatrixArray2D arg1, SparseMatrixArray2D arg2)
    Swap(VectorArray arg1, VectorArray arg2)
    Swap(OperatorArray arg1, OperatorArray arg2)
    Swap(SolverArray arg1, SolverArray arg2)
    """
    return _operators.Swap(*args)
Swap = _operators.Swap

class Operator(object):
    r"""Proxy of C++ mfem::Operator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DIAG_ZERO = _operators.Operator_DIAG_ZERO
    
    DIAG_ONE = _operators.Operator_DIAG_ONE
    
    DIAG_KEEP = _operators.Operator_DIAG_KEEP
    

    def InitTVectors(self, Po, Ri, Pi, x, b, X, B):
        r"""InitTVectors(Operator self, Operator Po, Operator Ri, Operator Pi, Vector x, Vector b, Vector X, Vector B)"""
        return _operators.Operator_InitTVectors(self, Po, Ri, Pi, x, b, X, B)
    InitTVectors = _swig_new_instance_method(_operators.Operator_InitTVectors)

    def __init__(self, *args):
        r"""
        __init__(Operator self, int s=0) -> Operator
        __init__(Operator self, int h, int w) -> Operator
        """
        if self.__class__ == Operator:
            _self = None
        else:
            _self = self
        _operators.Operator_swiginit(self, _operators.new_Operator(_self, *args))

    def Height(self):
        r"""Height(Operator self) -> int"""
        return _operators.Operator_Height(self)
    Height = _swig_new_instance_method(_operators.Operator_Height)

    def NumRows(self):
        r"""NumRows(Operator self) -> int"""
        return _operators.Operator_NumRows(self)
    NumRows = _swig_new_instance_method(_operators.Operator_NumRows)

    def Width(self):
        r"""Width(Operator self) -> int"""
        return _operators.Operator_Width(self)
    Width = _swig_new_instance_method(_operators.Operator_Width)

    def NumCols(self):
        r"""NumCols(Operator self) -> int"""
        return _operators.Operator_NumCols(self)
    NumCols = _swig_new_instance_method(_operators.Operator_NumCols)

    def GetMemoryClass(self):
        r"""GetMemoryClass(Operator self) -> mfem::MemoryClass"""
        return _operators.Operator_GetMemoryClass(self)
    GetMemoryClass = _swig_new_instance_method(_operators.Operator_GetMemoryClass)

    def Mult(self, x, y):
        r"""Mult(Operator self, Vector x, Vector y)"""
        return _operators.Operator_Mult(self, x, y)
    Mult = _swig_new_instance_method(_operators.Operator_Mult)

    def MultTranspose(self, x, y):
        r"""MultTranspose(Operator self, Vector x, Vector y)"""
        return _operators.Operator_MultTranspose(self, x, y)
    MultTranspose = _swig_new_instance_method(_operators.Operator_MultTranspose)

    def AddMult(self, x, y, a=1.0):
        r"""AddMult(Operator self, Vector x, Vector y, mfem::real_t const a=1.0)"""
        return _operators.Operator_AddMult(self, x, y, a)
    AddMult = _swig_new_instance_method(_operators.Operator_AddMult)

    def AddMultTranspose(self, x, y, a=1.0):
        r"""AddMultTranspose(Operator self, Vector x, Vector y, mfem::real_t const a=1.0)"""
        return _operators.Operator_AddMultTranspose(self, x, y, a)
    AddMultTranspose = _swig_new_instance_method(_operators.Operator_AddMultTranspose)

    def ArrayMult(self, X, Y):
        r"""ArrayMult(Operator self, mfem::Array< mfem::Vector const * > const & X, VectorArray Y)"""
        return _operators.Operator_ArrayMult(self, X, Y)
    ArrayMult = _swig_new_instance_method(_operators.Operator_ArrayMult)

    def ArrayMultTranspose(self, X, Y):
        r"""ArrayMultTranspose(Operator self, mfem::Array< mfem::Vector const * > const & X, VectorArray Y)"""
        return _operators.Operator_ArrayMultTranspose(self, X, Y)
    ArrayMultTranspose = _swig_new_instance_method(_operators.Operator_ArrayMultTranspose)

    def ArrayAddMult(self, X, Y, a=1.0):
        r"""ArrayAddMult(Operator self, mfem::Array< mfem::Vector const * > const & X, VectorArray Y, mfem::real_t const a=1.0)"""
        return _operators.Operator_ArrayAddMult(self, X, Y, a)
    ArrayAddMult = _swig_new_instance_method(_operators.Operator_ArrayAddMult)

    def ArrayAddMultTranspose(self, X, Y, a=1.0):
        r"""ArrayAddMultTranspose(Operator self, mfem::Array< mfem::Vector const * > const & X, VectorArray Y, mfem::real_t const a=1.0)"""
        return _operators.Operator_ArrayAddMultTranspose(self, X, Y, a)
    ArrayAddMultTranspose = _swig_new_instance_method(_operators.Operator_ArrayAddMultTranspose)

    def GetGradient(self, x):
        r"""GetGradient(Operator self, Vector x) -> Operator"""
        return _operators.Operator_GetGradient(self, x)
    GetGradient = _swig_new_instance_method(_operators.Operator_GetGradient)

    def AssembleDiagonal(self, diag):
        r"""AssembleDiagonal(Operator self, Vector diag)"""
        return _operators.Operator_AssembleDiagonal(self, diag)
    AssembleDiagonal = _swig_new_instance_method(_operators.Operator_AssembleDiagonal)

    def GetProlongation(self):
        r"""GetProlongation(Operator self) -> Operator"""
        return _operators.Operator_GetProlongation(self)
    GetProlongation = _swig_new_instance_method(_operators.Operator_GetProlongation)

    def GetRestriction(self):
        r"""GetRestriction(Operator self) -> Operator"""
        return _operators.Operator_GetRestriction(self)
    GetRestriction = _swig_new_instance_method(_operators.Operator_GetRestriction)

    def GetOutputProlongation(self):
        r"""GetOutputProlongation(Operator self) -> Operator"""
        return _operators.Operator_GetOutputProlongation(self)
    GetOutputProlongation = _swig_new_instance_method(_operators.Operator_GetOutputProlongation)

    def GetOutputRestrictionTranspose(self):
        r"""GetOutputRestrictionTranspose(Operator self) -> Operator"""
        return _operators.Operator_GetOutputRestrictionTranspose(self)
    GetOutputRestrictionTranspose = _swig_new_instance_method(_operators.Operator_GetOutputRestrictionTranspose)

    def GetOutputRestriction(self):
        r"""GetOutputRestriction(Operator self) -> Operator"""
        return _operators.Operator_GetOutputRestriction(self)
    GetOutputRestriction = _swig_new_instance_method(_operators.Operator_GetOutputRestriction)

    def FormLinearSystem(self, ess_tdof_list, x, b, A, X, B, copy_interior=0):
        r"""FormLinearSystem(Operator self, intArray ess_tdof_list, Vector x, Vector b, mfem::Operator *& A, Vector X, Vector B, int copy_interior=0)"""
        return _operators.Operator_FormLinearSystem(self, ess_tdof_list, x, b, A, X, B, copy_interior)
    FormLinearSystem = _swig_new_instance_method(_operators.Operator_FormLinearSystem)

    def FormRectangularLinearSystem(self, trial_tdof_list, test_tdof_list, x, b, A, X, B):
        r"""FormRectangularLinearSystem(Operator self, intArray trial_tdof_list, intArray test_tdof_list, Vector x, Vector b, mfem::Operator *& A, Vector X, Vector B)"""
        return _operators.Operator_FormRectangularLinearSystem(self, trial_tdof_list, test_tdof_list, x, b, A, X, B)
    FormRectangularLinearSystem = _swig_new_instance_method(_operators.Operator_FormRectangularLinearSystem)

    def RecoverFEMSolution(self, X, b, x):
        r"""RecoverFEMSolution(Operator self, Vector X, Vector b, Vector x)"""
        return _operators.Operator_RecoverFEMSolution(self, X, b, x)
    RecoverFEMSolution = _swig_new_instance_method(_operators.Operator_RecoverFEMSolution)

    def FormSystemOperator(self, ess_tdof_list, A):
        r"""FormSystemOperator(Operator self, intArray ess_tdof_list, mfem::Operator *& A)"""
        return _operators.Operator_FormSystemOperator(self, ess_tdof_list, A)
    FormSystemOperator = _swig_new_instance_method(_operators.Operator_FormSystemOperator)

    def FormRectangularSystemOperator(self, trial_tdof_list, test_tdof_list, A):
        r"""FormRectangularSystemOperator(Operator self, intArray trial_tdof_list, intArray test_tdof_list, mfem::Operator *& A)"""
        return _operators.Operator_FormRectangularSystemOperator(self, trial_tdof_list, test_tdof_list, A)
    FormRectangularSystemOperator = _swig_new_instance_method(_operators.Operator_FormRectangularSystemOperator)

    def FormDiscreteOperator(self, A):
        r"""FormDiscreteOperator(Operator self, mfem::Operator *& A)"""
        return _operators.Operator_FormDiscreteOperator(self, A)
    FormDiscreteOperator = _swig_new_instance_method(_operators.Operator_FormDiscreteOperator)
    __swig_destroy__ = _operators.delete_Operator
    ANY_TYPE = _operators.Operator_ANY_TYPE
    
    MFEM_SPARSEMAT = _operators.Operator_MFEM_SPARSEMAT
    
    Hypre_ParCSR = _operators.Operator_Hypre_ParCSR
    
    PETSC_MATAIJ = _operators.Operator_PETSC_MATAIJ
    
    PETSC_MATIS = _operators.Operator_PETSC_MATIS
    
    PETSC_MATSHELL = _operators.Operator_PETSC_MATSHELL
    
    PETSC_MATNEST = _operators.Operator_PETSC_MATNEST
    
    PETSC_MATHYPRE = _operators.Operator_PETSC_MATHYPRE
    
    PETSC_MATGENERIC = _operators.Operator_PETSC_MATGENERIC
    
    Complex_Operator = _operators.Operator_Complex_Operator
    
    MFEM_ComplexSparseMat = _operators.Operator_MFEM_ComplexSparseMat
    
    Complex_Hypre_ParCSR = _operators.Operator_Complex_Hypre_ParCSR
    
    Complex_DenseMat = _operators.Operator_Complex_DenseMat
    
    MFEM_Block_Matrix = _operators.Operator_MFEM_Block_Matrix
    
    MFEM_Block_Operator = _operators.Operator_MFEM_Block_Operator
    

    def GetType(self):
        r"""GetType(Operator self) -> mfem::Operator::Type"""
        return _operators.Operator_GetType(self)
    GetType = _swig_new_instance_method(_operators.Operator_GetType)
    def __disown__(self):
        self.this.disown()
        _operators.disown_Operator(self)
        return weakref.proxy(self)

# Register Operator in _operators:
_operators.Operator_swigregister(Operator)
class TimeDependentOperator(Operator):
    r"""Proxy of C++ mfem::TimeDependentOperator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EXPLICIT = _operators.TimeDependentOperator_EXPLICIT
    
    IMPLICIT = _operators.TimeDependentOperator_IMPLICIT
    
    HOMOGENEOUS = _operators.TimeDependentOperator_HOMOGENEOUS
    
    NORMAL = _operators.TimeDependentOperator_NORMAL
    
    ADDITIVE_TERM_1 = _operators.TimeDependentOperator_ADDITIVE_TERM_1
    
    ADDITIVE_TERM_2 = _operators.TimeDependentOperator_ADDITIVE_TERM_2
    

    def __init__(self, *args):
        r"""
        __init__(TimeDependentOperator self, int n=0, mfem::real_t t_=0.0, mfem::TimeDependentOperator::Type type_=EXPLICIT) -> TimeDependentOperator
        __init__(TimeDependentOperator self, int h, int w, double t_=0.0, mfem::TimeDependentOperator::Type type_=EXPLICIT) -> TimeDependentOperator
        """
        if self.__class__ == TimeDependentOperator:
            _self = None
        else:
            _self = self
        _operators.TimeDependentOperator_swiginit(self, _operators.new_TimeDependentOperator(_self, *args))

    def GetTime(self):
        r"""GetTime(TimeDependentOperator self) -> mfem::real_t"""
        return _operators.TimeDependentOperator_GetTime(self)
    GetTime = _swig_new_instance_method(_operators.TimeDependentOperator_GetTime)

    def SetTime(self, t_):
        r"""SetTime(TimeDependentOperator self, mfem::real_t const t_)"""
        return _operators.TimeDependentOperator_SetTime(self, t_)
    SetTime = _swig_new_instance_method(_operators.TimeDependentOperator_SetTime)

    def isExplicit(self):
        r"""isExplicit(TimeDependentOperator self) -> bool"""
        return _operators.TimeDependentOperator_isExplicit(self)
    isExplicit = _swig_new_instance_method(_operators.TimeDependentOperator_isExplicit)

    def isImplicit(self):
        r"""isImplicit(TimeDependentOperator self) -> bool"""
        return _operators.TimeDependentOperator_isImplicit(self)
    isImplicit = _swig_new_instance_method(_operators.TimeDependentOperator_isImplicit)

    def isHomogeneous(self):
        r"""isHomogeneous(TimeDependentOperator self) -> bool"""
        return _operators.TimeDependentOperator_isHomogeneous(self)
    isHomogeneous = _swig_new_instance_method(_operators.TimeDependentOperator_isHomogeneous)

    def GetEvalMode(self):
        r"""GetEvalMode(TimeDependentOperator self) -> mfem::TimeDependentOperator::EvalMode"""
        return _operators.TimeDependentOperator_GetEvalMode(self)
    GetEvalMode = _swig_new_instance_method(_operators.TimeDependentOperator_GetEvalMode)

    def SetEvalMode(self, new_eval_mode):
        r"""SetEvalMode(TimeDependentOperator self, mfem::TimeDependentOperator::EvalMode const new_eval_mode)"""
        return _operators.TimeDependentOperator_SetEvalMode(self, new_eval_mode)
    SetEvalMode = _swig_new_instance_method(_operators.TimeDependentOperator_SetEvalMode)

    def ExplicitMult(self, u, v):
        r"""ExplicitMult(TimeDependentOperator self, Vector u, Vector v)"""
        return _operators.TimeDependentOperator_ExplicitMult(self, u, v)
    ExplicitMult = _swig_new_instance_method(_operators.TimeDependentOperator_ExplicitMult)

    def ImplicitMult(self, u, k, v):
        r"""ImplicitMult(TimeDependentOperator self, Vector u, Vector k, Vector v)"""
        return _operators.TimeDependentOperator_ImplicitMult(self, u, k, v)
    ImplicitMult = _swig_new_instance_method(_operators.TimeDependentOperator_ImplicitMult)

    def Mult(self, u, k):
        r"""Mult(TimeDependentOperator self, Vector u, Vector k)"""
        return _operators.TimeDependentOperator_Mult(self, u, k)
    Mult = _swig_new_instance_method(_operators.TimeDependentOperator_Mult)

    def ImplicitSolve(self, gamma, u, k):
        r"""ImplicitSolve(TimeDependentOperator self, mfem::real_t const gamma, Vector u, Vector k)"""
        return _operators.TimeDependentOperator_ImplicitSolve(self, gamma, u, k)
    ImplicitSolve = _swig_new_instance_method(_operators.TimeDependentOperator_ImplicitSolve)

    def GetImplicitGradient(self, u, k, shift):
        r"""GetImplicitGradient(TimeDependentOperator self, Vector u, Vector k, mfem::real_t shift) -> Operator"""
        return _operators.TimeDependentOperator_GetImplicitGradient(self, u, k, shift)
    GetImplicitGradient = _swig_new_instance_method(_operators.TimeDependentOperator_GetImplicitGradient)

    def GetExplicitGradient(self, u):
        r"""GetExplicitGradient(TimeDependentOperator self, Vector u) -> Operator"""
        return _operators.TimeDependentOperator_GetExplicitGradient(self, u)
    GetExplicitGradient = _swig_new_instance_method(_operators.TimeDependentOperator_GetExplicitGradient)

    def SUNImplicitSetup(self, y, v, jok, jcur, gamma):
        r"""SUNImplicitSetup(TimeDependentOperator self, Vector y, Vector v, int jok, int * jcur, mfem::real_t gamma) -> int"""
        return _operators.TimeDependentOperator_SUNImplicitSetup(self, y, v, jok, jcur, gamma)
    SUNImplicitSetup = _swig_new_instance_method(_operators.TimeDependentOperator_SUNImplicitSetup)

    def SUNImplicitSolve(self, r, dk, tol):
        r"""SUNImplicitSolve(TimeDependentOperator self, Vector r, Vector dk, mfem::real_t tol) -> int"""
        return _operators.TimeDependentOperator_SUNImplicitSolve(self, r, dk, tol)
    SUNImplicitSolve = _swig_new_instance_method(_operators.TimeDependentOperator_SUNImplicitSolve)

    def SUNMassSetup(self):
        r"""SUNMassSetup(TimeDependentOperator self) -> int"""
        return _operators.TimeDependentOperator_SUNMassSetup(self)
    SUNMassSetup = _swig_new_instance_method(_operators.TimeDependentOperator_SUNMassSetup)

    def SUNMassSolve(self, b, x, tol):
        r"""SUNMassSolve(TimeDependentOperator self, Vector b, Vector x, mfem::real_t tol) -> int"""
        return _operators.TimeDependentOperator_SUNMassSolve(self, b, x, tol)
    SUNMassSolve = _swig_new_instance_method(_operators.TimeDependentOperator_SUNMassSolve)

    def SUNMassMult(self, x, v):
        r"""SUNMassMult(TimeDependentOperator self, Vector x, Vector v) -> int"""
        return _operators.TimeDependentOperator_SUNMassMult(self, x, v)
    SUNMassMult = _swig_new_instance_method(_operators.TimeDependentOperator_SUNMassMult)
    __swig_destroy__ = _operators.delete_TimeDependentOperator
    def __disown__(self):
        self.this.disown()
        _operators.disown_TimeDependentOperator(self)
        return weakref.proxy(self)

# Register TimeDependentOperator in _operators:
_operators.TimeDependentOperator_swigregister(TimeDependentOperator)
class TimeDependentAdjointOperator(TimeDependentOperator):
    r"""Proxy of C++ mfem::TimeDependentAdjointOperator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(TimeDependentAdjointOperator self, int dim, int adjdim, mfem::real_t t=0., mfem::TimeDependentOperator::Type type=EXPLICIT) -> TimeDependentAdjointOperator"""
        if self.__class__ == TimeDependentAdjointOperator:
            _self = None
        else:
            _self = self
        _operators.TimeDependentAdjointOperator_swiginit(self, _operators.new_TimeDependentAdjointOperator(_self, *args, **kwargs))
    __swig_destroy__ = _operators.delete_TimeDependentAdjointOperator

    def QuadratureIntegration(self, y, qdot):
        r"""QuadratureIntegration(TimeDependentAdjointOperator self, Vector y, Vector qdot)"""
        return _operators.TimeDependentAdjointOperator_QuadratureIntegration(self, y, qdot)
    QuadratureIntegration = _swig_new_instance_method(_operators.TimeDependentAdjointOperator_QuadratureIntegration)

    def AdjointRateMult(self, y, yB, yBdot):
        r"""AdjointRateMult(TimeDependentAdjointOperator self, Vector y, Vector yB, Vector yBdot)"""
        return _operators.TimeDependentAdjointOperator_AdjointRateMult(self, y, yB, yBdot)
    AdjointRateMult = _swig_new_instance_method(_operators.TimeDependentAdjointOperator_AdjointRateMult)

    def QuadratureSensitivityMult(self, y, yB, qBdot):
        r"""QuadratureSensitivityMult(TimeDependentAdjointOperator self, Vector y, Vector yB, Vector qBdot)"""
        return _operators.TimeDependentAdjointOperator_QuadratureSensitivityMult(self, y, yB, qBdot)
    QuadratureSensitivityMult = _swig_new_instance_method(_operators.TimeDependentAdjointOperator_QuadratureSensitivityMult)

    def SUNImplicitSetupB(self, t, x, xB, fxB, jokB, jcurB, gammaB):
        r"""SUNImplicitSetupB(TimeDependentAdjointOperator self, mfem::real_t const t, Vector x, Vector xB, Vector fxB, int jokB, int * jcurB, mfem::real_t gammaB) -> int"""
        return _operators.TimeDependentAdjointOperator_SUNImplicitSetupB(self, t, x, xB, fxB, jokB, jcurB, gammaB)
    SUNImplicitSetupB = _swig_new_instance_method(_operators.TimeDependentAdjointOperator_SUNImplicitSetupB)

    def SUNImplicitSolveB(self, x, b, tol):
        r"""SUNImplicitSolveB(TimeDependentAdjointOperator self, Vector x, Vector b, mfem::real_t tol) -> int"""
        return _operators.TimeDependentAdjointOperator_SUNImplicitSolveB(self, x, b, tol)
    SUNImplicitSolveB = _swig_new_instance_method(_operators.TimeDependentAdjointOperator_SUNImplicitSolveB)

    def GetAdjointHeight(self):
        r"""GetAdjointHeight(TimeDependentAdjointOperator self) -> int"""
        return _operators.TimeDependentAdjointOperator_GetAdjointHeight(self)
    GetAdjointHeight = _swig_new_instance_method(_operators.TimeDependentAdjointOperator_GetAdjointHeight)
    def __disown__(self):
        self.this.disown()
        _operators.disown_TimeDependentAdjointOperator(self)
        return weakref.proxy(self)

# Register TimeDependentAdjointOperator in _operators:
_operators.TimeDependentAdjointOperator_swigregister(TimeDependentAdjointOperator)
class SecondOrderTimeDependentOperator(TimeDependentOperator):
    r"""Proxy of C++ mfem::SecondOrderTimeDependentOperator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(SecondOrderTimeDependentOperator self, int n=0, mfem::real_t t_=0.0, mfem::TimeDependentOperator::Type type_=EXPLICIT) -> SecondOrderTimeDependentOperator
        __init__(SecondOrderTimeDependentOperator self, int h, int w, mfem::real_t t_=0.0, mfem::TimeDependentOperator::Type type_=EXPLICIT) -> SecondOrderTimeDependentOperator
        """
        if self.__class__ == SecondOrderTimeDependentOperator:
            _self = None
        else:
            _self = self
        _operators.SecondOrderTimeDependentOperator_swiginit(self, _operators.new_SecondOrderTimeDependentOperator(_self, *args))

    def Mult(self, *args):
        r"""
        Mult(SecondOrderTimeDependentOperator self, Vector u, Vector k)
        Mult(SecondOrderTimeDependentOperator self, Vector x, Vector dxdt, Vector y)
        """
        return _operators.SecondOrderTimeDependentOperator_Mult(self, *args)
    Mult = _swig_new_instance_method(_operators.SecondOrderTimeDependentOperator_Mult)

    def ImplicitSolve(self, *args):
        r"""
        ImplicitSolve(SecondOrderTimeDependentOperator self, mfem::real_t const gamma, Vector u, Vector k)
        ImplicitSolve(SecondOrderTimeDependentOperator self, mfem::real_t const fac0, mfem::real_t const fac1, Vector x, Vector dxdt, Vector k)
        """
        return _operators.SecondOrderTimeDependentOperator_ImplicitSolve(self, *args)
    ImplicitSolve = _swig_new_instance_method(_operators.SecondOrderTimeDependentOperator_ImplicitSolve)
    __swig_destroy__ = _operators.delete_SecondOrderTimeDependentOperator
    def __disown__(self):
        self.this.disown()
        _operators.disown_SecondOrderTimeDependentOperator(self)
        return weakref.proxy(self)

# Register SecondOrderTimeDependentOperator in _operators:
_operators.SecondOrderTimeDependentOperator_swigregister(SecondOrderTimeDependentOperator)
class Solver(Operator):
    r"""Proxy of C++ mfem::Solver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterative_mode = property(_operators.Solver_iterative_mode_get, _operators.Solver_iterative_mode_set, doc=r"""iterative_mode : bool""")

    def __init__(self, *args):
        r"""
        __init__(Solver self, int s=0, bool iter_mode=False) -> Solver
        __init__(Solver self, int h, int w, bool iter_mode=False) -> Solver
        """
        if self.__class__ == Solver:
            _self = None
        else:
            _self = self
        _operators.Solver_swiginit(self, _operators.new_Solver(_self, *args))

    def SetOperator(self, op):
        r"""SetOperator(Solver self, Operator op)"""
        return _operators.Solver_SetOperator(self, op)
    SetOperator = _swig_new_instance_method(_operators.Solver_SetOperator)
    __swig_destroy__ = _operators.delete_Solver
    def __disown__(self):
        self.this.disown()
        _operators.disown_Solver(self)
        return weakref.proxy(self)

# Register Solver in _operators:
_operators.Solver_swigregister(Solver)
class IdentityOperator(Operator):
    r"""Proxy of C++ mfem::IdentityOperator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, n):
        r"""__init__(IdentityOperator self, int n) -> IdentityOperator"""
        _operators.IdentityOperator_swiginit(self, _operators.new_IdentityOperator(n))

    def Mult(self, x, y):
        r"""Mult(IdentityOperator self, Vector x, Vector y)"""
        return _operators.IdentityOperator_Mult(self, x, y)
    Mult = _swig_new_instance_method(_operators.IdentityOperator_Mult)

    def MultTranspose(self, x, y):
        r"""MultTranspose(IdentityOperator self, Vector x, Vector y)"""
        return _operators.IdentityOperator_MultTranspose(self, x, y)
    MultTranspose = _swig_new_instance_method(_operators.IdentityOperator_MultTranspose)
    __swig_destroy__ = _operators.delete_IdentityOperator

# Register IdentityOperator in _operators:
_operators.IdentityOperator_swigregister(IdentityOperator)

def IsIdentityProlongation(P):
    r"""IsIdentityProlongation(Operator P) -> bool"""
    return _operators.IsIdentityProlongation(P)
IsIdentityProlongation = _operators.IsIdentityProlongation
class ScaledOperator(Operator):
    r"""Proxy of C++ mfem::ScaledOperator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, A, a):
        r"""__init__(ScaledOperator self, Operator A, mfem::real_t a) -> ScaledOperator"""
        _operators.ScaledOperator_swiginit(self, _operators.new_ScaledOperator(A, a))

    def Mult(self, x, y):
        r"""Mult(ScaledOperator self, Vector x, Vector y)"""
        return _operators.ScaledOperator_Mult(self, x, y)
    Mult = _swig_new_instance_method(_operators.ScaledOperator_Mult)

    def MultTranspose(self, x, y):
        r"""MultTranspose(ScaledOperator self, Vector x, Vector y)"""
        return _operators.ScaledOperator_MultTranspose(self, x, y)
    MultTranspose = _swig_new_instance_method(_operators.ScaledOperator_MultTranspose)
    __swig_destroy__ = _operators.delete_ScaledOperator

# Register ScaledOperator in _operators:
_operators.ScaledOperator_swigregister(ScaledOperator)
class TransposeOperator(Operator):
    r"""Proxy of C++ mfem::TransposeOperator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(TransposeOperator self, Operator a) -> TransposeOperator
        __init__(TransposeOperator self, Operator a) -> TransposeOperator
        """
        _operators.TransposeOperator_swiginit(self, _operators.new_TransposeOperator(*args))

    def Mult(self, x, y):
        r"""Mult(TransposeOperator self, Vector x, Vector y)"""
        return _operators.TransposeOperator_Mult(self, x, y)
    Mult = _swig_new_instance_method(_operators.TransposeOperator_Mult)

    def MultTranspose(self, x, y):
        r"""MultTranspose(TransposeOperator self, Vector x, Vector y)"""
        return _operators.TransposeOperator_MultTranspose(self, x, y)
    MultTranspose = _swig_new_instance_method(_operators.TransposeOperator_MultTranspose)
    __swig_destroy__ = _operators.delete_TransposeOperator

# Register TransposeOperator in _operators:
_operators.TransposeOperator_swigregister(TransposeOperator)
class SumOperator(Operator):
    r"""Proxy of C++ mfem::SumOperator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, A, alpha, B, beta, ownA, ownB):
        r"""__init__(SumOperator self, Operator A, mfem::real_t const alpha, Operator B, mfem::real_t const beta, bool ownA, bool ownB) -> SumOperator"""
        _operators.SumOperator_swiginit(self, _operators.new_SumOperator(A, alpha, B, beta, ownA, ownB))

    def Mult(self, x, y):
        r"""Mult(SumOperator self, Vector x, Vector y)"""
        return _operators.SumOperator_Mult(self, x, y)
    Mult = _swig_new_instance_method(_operators.SumOperator_Mult)

    def MultTranspose(self, x, y):
        r"""MultTranspose(SumOperator self, Vector x, Vector y)"""
        return _operators.SumOperator_MultTranspose(self, x, y)
    MultTranspose = _swig_new_instance_method(_operators.SumOperator_MultTranspose)
    __swig_destroy__ = _operators.delete_SumOperator

# Register SumOperator in _operators:
_operators.SumOperator_swigregister(SumOperator)
class ProductOperator(Operator):
    r"""Proxy of C++ mfem::ProductOperator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, A, B, ownA, ownB):
        r"""__init__(ProductOperator self, Operator A, Operator B, bool ownA, bool ownB) -> ProductOperator"""
        _operators.ProductOperator_swiginit(self, _operators.new_ProductOperator(A, B, ownA, ownB))

    def Mult(self, x, y):
        r"""Mult(ProductOperator self, Vector x, Vector y)"""
        return _operators.ProductOperator_Mult(self, x, y)
    Mult = _swig_new_instance_method(_operators.ProductOperator_Mult)

    def MultTranspose(self, x, y):
        r"""MultTranspose(ProductOperator self, Vector x, Vector y)"""
        return _operators.ProductOperator_MultTranspose(self, x, y)
    MultTranspose = _swig_new_instance_method(_operators.ProductOperator_MultTranspose)
    __swig_destroy__ = _operators.delete_ProductOperator

# Register ProductOperator in _operators:
_operators.ProductOperator_swigregister(ProductOperator)
class RAPOperator(Operator):
    r"""Proxy of C++ mfem::RAPOperator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, Rt_, A_, P_):
        r"""__init__(RAPOperator self, Operator Rt_, Operator A_, Operator P_) -> RAPOperator"""
        _operators.RAPOperator_swiginit(self, _operators.new_RAPOperator(Rt_, A_, P_))

    def GetMemoryClass(self):
        r"""GetMemoryClass(RAPOperator self) -> mfem::MemoryClass"""
        return _operators.RAPOperator_GetMemoryClass(self)
    GetMemoryClass = _swig_new_instance_method(_operators.RAPOperator_GetMemoryClass)

    def Mult(self, x, y):
        r"""Mult(RAPOperator self, Vector x, Vector y)"""
        return _operators.RAPOperator_Mult(self, x, y)
    Mult = _swig_new_instance_method(_operators.RAPOperator_Mult)

    def AssembleDiagonal(self, diag):
        r"""AssembleDiagonal(RAPOperator self, Vector diag)"""
        return _operators.RAPOperator_AssembleDiagonal(self, diag)
    AssembleDiagonal = _swig_new_instance_method(_operators.RAPOperator_AssembleDiagonal)

    def MultTranspose(self, x, y):
        r"""MultTranspose(RAPOperator self, Vector x, Vector y)"""
        return _operators.RAPOperator_MultTranspose(self, x, y)
    MultTranspose = _swig_new_instance_method(_operators.RAPOperator_MultTranspose)
    __swig_destroy__ = _operators.delete_RAPOperator

# Register RAPOperator in _operators:
_operators.RAPOperator_swigregister(RAPOperator)
class TripleProductOperator(Operator):
    r"""Proxy of C++ mfem::TripleProductOperator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, A, B, C, ownA, ownB, ownC):
        r"""__init__(TripleProductOperator self, Operator A, Operator B, Operator C, bool ownA, bool ownB, bool ownC) -> TripleProductOperator"""
        _operators.TripleProductOperator_swiginit(self, _operators.new_TripleProductOperator(A, B, C, ownA, ownB, ownC))

    def GetMemoryClass(self):
        r"""GetMemoryClass(TripleProductOperator self) -> mfem::MemoryClass"""
        return _operators.TripleProductOperator_GetMemoryClass(self)
    GetMemoryClass = _swig_new_instance_method(_operators.TripleProductOperator_GetMemoryClass)

    def Mult(self, x, y):
        r"""Mult(TripleProductOperator self, Vector x, Vector y)"""
        return _operators.TripleProductOperator_Mult(self, x, y)
    Mult = _swig_new_instance_method(_operators.TripleProductOperator_Mult)

    def MultTranspose(self, x, y):
        r"""MultTranspose(TripleProductOperator self, Vector x, Vector y)"""
        return _operators.TripleProductOperator_MultTranspose(self, x, y)
    MultTranspose = _swig_new_instance_method(_operators.TripleProductOperator_MultTranspose)
    __swig_destroy__ = _operators.delete_TripleProductOperator

# Register TripleProductOperator in _operators:
_operators.TripleProductOperator_swigregister(TripleProductOperator)
class ConstrainedOperator(Operator):
    r"""Proxy of C++ mfem::ConstrainedOperator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(ConstrainedOperator self, Operator A, intArray list, bool own_A=False, mfem::Operator::DiagonalPolicy diag_policy=DIAG_ONE) -> ConstrainedOperator"""
        _operators.ConstrainedOperator_swiginit(self, _operators.new_ConstrainedOperator(*args, **kwargs))

    def GetMemoryClass(self):
        r"""GetMemoryClass(ConstrainedOperator self) -> mfem::MemoryClass"""
        return _operators.ConstrainedOperator_GetMemoryClass(self)
    GetMemoryClass = _swig_new_instance_method(_operators.ConstrainedOperator_GetMemoryClass)

    def SetDiagonalPolicy(self, diag_policy_):
        r"""SetDiagonalPolicy(ConstrainedOperator self, mfem::Operator::DiagonalPolicy const diag_policy_)"""
        return _operators.ConstrainedOperator_SetDiagonalPolicy(self, diag_policy_)
    SetDiagonalPolicy = _swig_new_instance_method(_operators.ConstrainedOperator_SetDiagonalPolicy)

    def AssembleDiagonal(self, diag):
        r"""AssembleDiagonal(ConstrainedOperator self, Vector diag)"""
        return _operators.ConstrainedOperator_AssembleDiagonal(self, diag)
    AssembleDiagonal = _swig_new_instance_method(_operators.ConstrainedOperator_AssembleDiagonal)

    def EliminateRHS(self, x, b):
        r"""EliminateRHS(ConstrainedOperator self, Vector x, Vector b)"""
        return _operators.ConstrainedOperator_EliminateRHS(self, x, b)
    EliminateRHS = _swig_new_instance_method(_operators.ConstrainedOperator_EliminateRHS)

    def Mult(self, x, y):
        r"""Mult(ConstrainedOperator self, Vector x, Vector y)"""
        return _operators.ConstrainedOperator_Mult(self, x, y)
    Mult = _swig_new_instance_method(_operators.ConstrainedOperator_Mult)

    def AddMult(self, x, y, a=1.0):
        r"""AddMult(ConstrainedOperator self, Vector x, Vector y, mfem::real_t const a=1.0)"""
        return _operators.ConstrainedOperator_AddMult(self, x, y, a)
    AddMult = _swig_new_instance_method(_operators.ConstrainedOperator_AddMult)

    def MultTranspose(self, x, y):
        r"""MultTranspose(ConstrainedOperator self, Vector x, Vector y)"""
        return _operators.ConstrainedOperator_MultTranspose(self, x, y)
    MultTranspose = _swig_new_instance_method(_operators.ConstrainedOperator_MultTranspose)

    def ConstrainedMult(self, x, y, transpose):
        r"""ConstrainedMult(ConstrainedOperator self, Vector x, Vector y, bool const transpose)"""
        return _operators.ConstrainedOperator_ConstrainedMult(self, x, y, transpose)
    ConstrainedMult = _swig_new_instance_method(_operators.ConstrainedOperator_ConstrainedMult)
    __swig_destroy__ = _operators.delete_ConstrainedOperator

# Register ConstrainedOperator in _operators:
_operators.ConstrainedOperator_swigregister(ConstrainedOperator)
class RectangularConstrainedOperator(Operator):
    r"""Proxy of C++ mfem::RectangularConstrainedOperator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, A, trial_list, test_list, own_A=False):
        r"""__init__(RectangularConstrainedOperator self, Operator A, intArray trial_list, intArray test_list, bool own_A=False) -> RectangularConstrainedOperator"""
        _operators.RectangularConstrainedOperator_swiginit(self, _operators.new_RectangularConstrainedOperator(A, trial_list, test_list, own_A))

    def GetMemoryClass(self):
        r"""GetMemoryClass(RectangularConstrainedOperator self) -> mfem::MemoryClass"""
        return _operators.RectangularConstrainedOperator_GetMemoryClass(self)
    GetMemoryClass = _swig_new_instance_method(_operators.RectangularConstrainedOperator_GetMemoryClass)

    def EliminateRHS(self, x, b):
        r"""EliminateRHS(RectangularConstrainedOperator self, Vector x, Vector b)"""
        return _operators.RectangularConstrainedOperator_EliminateRHS(self, x, b)
    EliminateRHS = _swig_new_instance_method(_operators.RectangularConstrainedOperator_EliminateRHS)

    def Mult(self, x, y):
        r"""Mult(RectangularConstrainedOperator self, Vector x, Vector y)"""
        return _operators.RectangularConstrainedOperator_Mult(self, x, y)
    Mult = _swig_new_instance_method(_operators.RectangularConstrainedOperator_Mult)

    def MultTranspose(self, x, y):
        r"""MultTranspose(RectangularConstrainedOperator self, Vector x, Vector y)"""
        return _operators.RectangularConstrainedOperator_MultTranspose(self, x, y)
    MultTranspose = _swig_new_instance_method(_operators.RectangularConstrainedOperator_MultTranspose)
    __swig_destroy__ = _operators.delete_RectangularConstrainedOperator

# Register RectangularConstrainedOperator in _operators:
_operators.RectangularConstrainedOperator_swigregister(RectangularConstrainedOperator)
class PowerMethod(object):
    r"""Proxy of C++ mfem::PowerMethod class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(PowerMethod self) -> PowerMethod"""
        _operators.PowerMethod_swiginit(self, _operators.new_PowerMethod())

    def EstimateLargestEigenvalue(self, opr, v0, numSteps=10, tolerance=1e-8, seed=12345):
        r"""EstimateLargestEigenvalue(PowerMethod self, Operator opr, Vector v0, int numSteps=10, mfem::real_t tolerance=1e-8, int seed=12345) -> mfem::real_t"""
        return _operators.PowerMethod_EstimateLargestEigenvalue(self, opr, v0, numSteps, tolerance, seed)
    EstimateLargestEigenvalue = _swig_new_instance_method(_operators.PowerMethod_EstimateLargestEigenvalue)
    __swig_destroy__ = _operators.delete_PowerMethod

# Register PowerMethod in _operators:
_operators.PowerMethod_swigregister(PowerMethod)
class PyOperatorBase(Operator):
    r"""Proxy of C++ mfem::PyOperatorBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(PyOperatorBase self, int s=0) -> PyOperatorBase
        __init__(PyOperatorBase self, int h, int w) -> PyOperatorBase
        """
        if self.__class__ == PyOperatorBase:
            _self = None
        else:
            _self = self
        _operators.PyOperatorBase_swiginit(self, _operators.new_PyOperatorBase(_self, *args))

    def Mult(self, x, y):
        r"""Mult(PyOperatorBase self, Vector x, Vector y)"""
        return _operators.PyOperatorBase_Mult(self, x, y)
    Mult = _swig_new_instance_method(_operators.PyOperatorBase_Mult)

    def _EvalMult(self, arg0):
        r"""_EvalMult(PyOperatorBase self, Vector arg0) -> Vector"""
        return _operators.PyOperatorBase__EvalMult(self, arg0)
    _EvalMult = _swig_new_instance_method(_operators.PyOperatorBase__EvalMult)
    __swig_destroy__ = _operators.delete_PyOperatorBase
    def __disown__(self):
        self.this.disown()
        _operators.disown_PyOperatorBase(self)
        return weakref.proxy(self)

# Register PyOperatorBase in _operators:
_operators.PyOperatorBase_swigregister(PyOperatorBase)
class PyTimeDependentOperatorBase(TimeDependentOperator):
    r"""Proxy of C++ mfem::PyTimeDependentOperatorBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(PyTimeDependentOperatorBase self, int n=0, double _t=0.0) -> PyTimeDependentOperatorBase
        __init__(PyTimeDependentOperatorBase self, int h, int w, double _t=0.0) -> PyTimeDependentOperatorBase
        """
        if self.__class__ == PyTimeDependentOperatorBase:
            _self = None
        else:
            _self = self
        _operators.PyTimeDependentOperatorBase_swiginit(self, _operators.new_PyTimeDependentOperatorBase(_self, *args))

    def Mult(self, x, y):
        r"""Mult(PyTimeDependentOperatorBase self, Vector x, Vector y)"""
        return _operators.PyTimeDependentOperatorBase_Mult(self, x, y)
    Mult = _swig_new_instance_method(_operators.PyTimeDependentOperatorBase_Mult)

    def _EvalMult(self, arg0):
        r"""_EvalMult(PyTimeDependentOperatorBase self, Vector arg0) -> Vector"""
        return _operators.PyTimeDependentOperatorBase__EvalMult(self, arg0)
    _EvalMult = _swig_new_instance_method(_operators.PyTimeDependentOperatorBase__EvalMult)
    __swig_destroy__ = _operators.delete_PyTimeDependentOperatorBase
    def __disown__(self):
        self.this.disown()
        _operators.disown_PyTimeDependentOperatorBase(self)
        return weakref.proxy(self)

# Register PyTimeDependentOperatorBase in _operators:
_operators.PyTimeDependentOperatorBase_swigregister(PyTimeDependentOperatorBase)

class PyOperator(PyOperatorBase):
   def __init__(self, *args):
       PyOperatorBase.__init__(self, *args)
   def _EvalMult(self, x):
       return self.EvalMult(x.GetDataArray())
   def EvalMult(self, x):
       raise NotImplementedError('you must specify this method')

class PyTimeDependentOperator(PyTimeDependentOperatorBase):
   def __init__(self, *args):
       PyTimeDependentOperatorBase.__init__(self, *args)
   def _EvalMult(self, x):
       return self.EvalMult(x.GetDataArray())
   def EvalMult(self, x):
       raise NotImplementedError('you must specify this method')



