# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.


import collections

from sys import version_info as _version_info
if _version_info < (3, 7, 0):
    raise RuntimeError("Python 3.7 or later required")

from . import _ITKCommonPython


from . import _ITKThresholdingPython



from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _itkIntermodesThresholdCalculatorPython
else:
    import _itkIntermodesThresholdCalculatorPython

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


if _swig_python_version_info[0:2] >= (3, 3):
    import collections.abc
else:
    import collections

import itk.itkHistogramThresholdCalculatorPython
import itk.itkHistogramPython
import itk.ITKCommonBasePython
import itk.itkMatrixPython
import itk.itkPointPython
import itk.itkVectorPython
import itk.vnl_vectorPython
import itk.stdcomplexPython
import itk.pyBasePython
import itk.vnl_matrixPython
import itk.itkFixedArrayPython
import itk.vnl_vector_refPython
import itk.vnl_matrix_fixedPython
import itk.itkCovariantVectorPython
import itk.itkArrayPython
import itk.itkSamplePython
import itk.itkSimpleDataObjectDecoratorPython
import itk.itkRGBPixelPython
import itk.itkRGBAPixelPython

def itkIntermodesThresholdCalculatorHDD_New():
    return itkIntermodesThresholdCalculatorHDD.New()

class itkIntermodesThresholdCalculatorHDD(itk.itkHistogramThresholdCalculatorPython.itkHistogramThresholdCalculatorHDD):
    r"""Proxy of C++ itkIntermodesThresholdCalculatorHDD class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def __New_orig__():
        r"""__New_orig__() -> itkIntermodesThresholdCalculatorHDD_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDD___New_orig__()

    def Clone(self):
        r"""Clone(self) -> itkIntermodesThresholdCalculatorHDD_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDD_Clone(self)

    def SetMaximumSmoothingIterations(self, _arg):
        r"""
        SetMaximumSmoothingIterations(self, _arg)

        Parameters
        ----------
        _arg: unsigned long

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDD_SetMaximumSmoothingIterations(self, _arg)

    def GetMaximumSmoothingIterations(self):
        r"""GetMaximumSmoothingIterations(self) -> unsigned long"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDD_GetMaximumSmoothingIterations(self)

    def SetUseInterMode(self, _arg):
        r"""
        SetUseInterMode(self, _arg)

        Parameters
        ----------
        _arg: bool

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDD_SetUseInterMode(self, _arg)

    def GetUseInterMode(self):
        r"""GetUseInterMode(self) -> bool"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDD_GetUseInterMode(self)

    def UseInterModeOn(self):
        r"""UseInterModeOn(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDD_UseInterModeOn(self)

    def UseInterModeOff(self):
        r"""UseInterModeOff(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDD_UseInterModeOff(self)
    __swig_destroy__ = _itkIntermodesThresholdCalculatorPython.delete_itkIntermodesThresholdCalculatorHDD

    @staticmethod
    def cast(obj):
        r"""
        cast(obj) -> itkIntermodesThresholdCalculatorHDD

        Parameters
        ----------
        obj: itkLightObject *

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDD_cast(obj)

    def New(*args, **kargs):
        """New() -> itkIntermodesThresholdCalculatorHDD

        Create a new object of the class itkIntermodesThresholdCalculatorHDD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkIntermodesThresholdCalculatorHDD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkIntermodesThresholdCalculatorHDD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkIntermodesThresholdCalculatorHDD.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkIntermodesThresholdCalculatorHDD in _itkIntermodesThresholdCalculatorPython:
_itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDD_swigregister(itkIntermodesThresholdCalculatorHDD)

def itkIntermodesThresholdCalculatorHDF_New():
    return itkIntermodesThresholdCalculatorHDF.New()

class itkIntermodesThresholdCalculatorHDF(itk.itkHistogramThresholdCalculatorPython.itkHistogramThresholdCalculatorHDF):
    r"""Proxy of C++ itkIntermodesThresholdCalculatorHDF class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def __New_orig__():
        r"""__New_orig__() -> itkIntermodesThresholdCalculatorHDF_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDF___New_orig__()

    def Clone(self):
        r"""Clone(self) -> itkIntermodesThresholdCalculatorHDF_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDF_Clone(self)

    def SetMaximumSmoothingIterations(self, _arg):
        r"""
        SetMaximumSmoothingIterations(self, _arg)

        Parameters
        ----------
        _arg: unsigned long

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDF_SetMaximumSmoothingIterations(self, _arg)

    def GetMaximumSmoothingIterations(self):
        r"""GetMaximumSmoothingIterations(self) -> unsigned long"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDF_GetMaximumSmoothingIterations(self)

    def SetUseInterMode(self, _arg):
        r"""
        SetUseInterMode(self, _arg)

        Parameters
        ----------
        _arg: bool

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDF_SetUseInterMode(self, _arg)

    def GetUseInterMode(self):
        r"""GetUseInterMode(self) -> bool"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDF_GetUseInterMode(self)

    def UseInterModeOn(self):
        r"""UseInterModeOn(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDF_UseInterModeOn(self)

    def UseInterModeOff(self):
        r"""UseInterModeOff(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDF_UseInterModeOff(self)
    __swig_destroy__ = _itkIntermodesThresholdCalculatorPython.delete_itkIntermodesThresholdCalculatorHDF

    @staticmethod
    def cast(obj):
        r"""
        cast(obj) -> itkIntermodesThresholdCalculatorHDF

        Parameters
        ----------
        obj: itkLightObject *

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDF_cast(obj)

    def New(*args, **kargs):
        """New() -> itkIntermodesThresholdCalculatorHDF

        Create a new object of the class itkIntermodesThresholdCalculatorHDF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkIntermodesThresholdCalculatorHDF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkIntermodesThresholdCalculatorHDF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkIntermodesThresholdCalculatorHDF.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkIntermodesThresholdCalculatorHDF in _itkIntermodesThresholdCalculatorPython:
_itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDF_swigregister(itkIntermodesThresholdCalculatorHDF)

def itkIntermodesThresholdCalculatorHDSS_New():
    return itkIntermodesThresholdCalculatorHDSS.New()

class itkIntermodesThresholdCalculatorHDSS(itk.itkHistogramThresholdCalculatorPython.itkHistogramThresholdCalculatorHDSS):
    r"""Proxy of C++ itkIntermodesThresholdCalculatorHDSS class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def __New_orig__():
        r"""__New_orig__() -> itkIntermodesThresholdCalculatorHDSS_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDSS___New_orig__()

    def Clone(self):
        r"""Clone(self) -> itkIntermodesThresholdCalculatorHDSS_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDSS_Clone(self)

    def SetMaximumSmoothingIterations(self, _arg):
        r"""
        SetMaximumSmoothingIterations(self, _arg)

        Parameters
        ----------
        _arg: unsigned long

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDSS_SetMaximumSmoothingIterations(self, _arg)

    def GetMaximumSmoothingIterations(self):
        r"""GetMaximumSmoothingIterations(self) -> unsigned long"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDSS_GetMaximumSmoothingIterations(self)

    def SetUseInterMode(self, _arg):
        r"""
        SetUseInterMode(self, _arg)

        Parameters
        ----------
        _arg: bool

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDSS_SetUseInterMode(self, _arg)

    def GetUseInterMode(self):
        r"""GetUseInterMode(self) -> bool"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDSS_GetUseInterMode(self)

    def UseInterModeOn(self):
        r"""UseInterModeOn(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDSS_UseInterModeOn(self)

    def UseInterModeOff(self):
        r"""UseInterModeOff(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDSS_UseInterModeOff(self)
    __swig_destroy__ = _itkIntermodesThresholdCalculatorPython.delete_itkIntermodesThresholdCalculatorHDSS

    @staticmethod
    def cast(obj):
        r"""
        cast(obj) -> itkIntermodesThresholdCalculatorHDSS

        Parameters
        ----------
        obj: itkLightObject *

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDSS_cast(obj)

    def New(*args, **kargs):
        """New() -> itkIntermodesThresholdCalculatorHDSS

        Create a new object of the class itkIntermodesThresholdCalculatorHDSS and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkIntermodesThresholdCalculatorHDSS.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkIntermodesThresholdCalculatorHDSS.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkIntermodesThresholdCalculatorHDSS.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkIntermodesThresholdCalculatorHDSS in _itkIntermodesThresholdCalculatorPython:
_itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDSS_swigregister(itkIntermodesThresholdCalculatorHDSS)

def itkIntermodesThresholdCalculatorHDUC_New():
    return itkIntermodesThresholdCalculatorHDUC.New()

class itkIntermodesThresholdCalculatorHDUC(itk.itkHistogramThresholdCalculatorPython.itkHistogramThresholdCalculatorHDUC):
    r"""Proxy of C++ itkIntermodesThresholdCalculatorHDUC class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def __New_orig__():
        r"""__New_orig__() -> itkIntermodesThresholdCalculatorHDUC_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUC___New_orig__()

    def Clone(self):
        r"""Clone(self) -> itkIntermodesThresholdCalculatorHDUC_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUC_Clone(self)

    def SetMaximumSmoothingIterations(self, _arg):
        r"""
        SetMaximumSmoothingIterations(self, _arg)

        Parameters
        ----------
        _arg: unsigned long

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUC_SetMaximumSmoothingIterations(self, _arg)

    def GetMaximumSmoothingIterations(self):
        r"""GetMaximumSmoothingIterations(self) -> unsigned long"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUC_GetMaximumSmoothingIterations(self)

    def SetUseInterMode(self, _arg):
        r"""
        SetUseInterMode(self, _arg)

        Parameters
        ----------
        _arg: bool

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUC_SetUseInterMode(self, _arg)

    def GetUseInterMode(self):
        r"""GetUseInterMode(self) -> bool"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUC_GetUseInterMode(self)

    def UseInterModeOn(self):
        r"""UseInterModeOn(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUC_UseInterModeOn(self)

    def UseInterModeOff(self):
        r"""UseInterModeOff(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUC_UseInterModeOff(self)
    __swig_destroy__ = _itkIntermodesThresholdCalculatorPython.delete_itkIntermodesThresholdCalculatorHDUC

    @staticmethod
    def cast(obj):
        r"""
        cast(obj) -> itkIntermodesThresholdCalculatorHDUC

        Parameters
        ----------
        obj: itkLightObject *

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUC_cast(obj)

    def New(*args, **kargs):
        """New() -> itkIntermodesThresholdCalculatorHDUC

        Create a new object of the class itkIntermodesThresholdCalculatorHDUC and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkIntermodesThresholdCalculatorHDUC.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkIntermodesThresholdCalculatorHDUC.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkIntermodesThresholdCalculatorHDUC.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkIntermodesThresholdCalculatorHDUC in _itkIntermodesThresholdCalculatorPython:
_itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUC_swigregister(itkIntermodesThresholdCalculatorHDUC)

def itkIntermodesThresholdCalculatorHDUS_New():
    return itkIntermodesThresholdCalculatorHDUS.New()

class itkIntermodesThresholdCalculatorHDUS(itk.itkHistogramThresholdCalculatorPython.itkHistogramThresholdCalculatorHDUS):
    r"""Proxy of C++ itkIntermodesThresholdCalculatorHDUS class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def __New_orig__():
        r"""__New_orig__() -> itkIntermodesThresholdCalculatorHDUS_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUS___New_orig__()

    def Clone(self):
        r"""Clone(self) -> itkIntermodesThresholdCalculatorHDUS_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUS_Clone(self)

    def SetMaximumSmoothingIterations(self, _arg):
        r"""
        SetMaximumSmoothingIterations(self, _arg)

        Parameters
        ----------
        _arg: unsigned long

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUS_SetMaximumSmoothingIterations(self, _arg)

    def GetMaximumSmoothingIterations(self):
        r"""GetMaximumSmoothingIterations(self) -> unsigned long"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUS_GetMaximumSmoothingIterations(self)

    def SetUseInterMode(self, _arg):
        r"""
        SetUseInterMode(self, _arg)

        Parameters
        ----------
        _arg: bool

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUS_SetUseInterMode(self, _arg)

    def GetUseInterMode(self):
        r"""GetUseInterMode(self) -> bool"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUS_GetUseInterMode(self)

    def UseInterModeOn(self):
        r"""UseInterModeOn(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUS_UseInterModeOn(self)

    def UseInterModeOff(self):
        r"""UseInterModeOff(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUS_UseInterModeOff(self)
    __swig_destroy__ = _itkIntermodesThresholdCalculatorPython.delete_itkIntermodesThresholdCalculatorHDUS

    @staticmethod
    def cast(obj):
        r"""
        cast(obj) -> itkIntermodesThresholdCalculatorHDUS

        Parameters
        ----------
        obj: itkLightObject *

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUS_cast(obj)

    def New(*args, **kargs):
        """New() -> itkIntermodesThresholdCalculatorHDUS

        Create a new object of the class itkIntermodesThresholdCalculatorHDUS and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkIntermodesThresholdCalculatorHDUS.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkIntermodesThresholdCalculatorHDUS.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkIntermodesThresholdCalculatorHDUS.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkIntermodesThresholdCalculatorHDUS in _itkIntermodesThresholdCalculatorPython:
_itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHDUS_swigregister(itkIntermodesThresholdCalculatorHDUS)

def itkIntermodesThresholdCalculatorHFD_New():
    return itkIntermodesThresholdCalculatorHFD.New()

class itkIntermodesThresholdCalculatorHFD(itk.itkHistogramThresholdCalculatorPython.itkHistogramThresholdCalculatorHFD):
    r"""Proxy of C++ itkIntermodesThresholdCalculatorHFD class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def __New_orig__():
        r"""__New_orig__() -> itkIntermodesThresholdCalculatorHFD_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFD___New_orig__()

    def Clone(self):
        r"""Clone(self) -> itkIntermodesThresholdCalculatorHFD_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFD_Clone(self)

    def SetMaximumSmoothingIterations(self, _arg):
        r"""
        SetMaximumSmoothingIterations(self, _arg)

        Parameters
        ----------
        _arg: unsigned long

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFD_SetMaximumSmoothingIterations(self, _arg)

    def GetMaximumSmoothingIterations(self):
        r"""GetMaximumSmoothingIterations(self) -> unsigned long"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFD_GetMaximumSmoothingIterations(self)

    def SetUseInterMode(self, _arg):
        r"""
        SetUseInterMode(self, _arg)

        Parameters
        ----------
        _arg: bool

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFD_SetUseInterMode(self, _arg)

    def GetUseInterMode(self):
        r"""GetUseInterMode(self) -> bool"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFD_GetUseInterMode(self)

    def UseInterModeOn(self):
        r"""UseInterModeOn(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFD_UseInterModeOn(self)

    def UseInterModeOff(self):
        r"""UseInterModeOff(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFD_UseInterModeOff(self)
    __swig_destroy__ = _itkIntermodesThresholdCalculatorPython.delete_itkIntermodesThresholdCalculatorHFD

    @staticmethod
    def cast(obj):
        r"""
        cast(obj) -> itkIntermodesThresholdCalculatorHFD

        Parameters
        ----------
        obj: itkLightObject *

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFD_cast(obj)

    def New(*args, **kargs):
        """New() -> itkIntermodesThresholdCalculatorHFD

        Create a new object of the class itkIntermodesThresholdCalculatorHFD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkIntermodesThresholdCalculatorHFD.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkIntermodesThresholdCalculatorHFD.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkIntermodesThresholdCalculatorHFD.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkIntermodesThresholdCalculatorHFD in _itkIntermodesThresholdCalculatorPython:
_itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFD_swigregister(itkIntermodesThresholdCalculatorHFD)

def itkIntermodesThresholdCalculatorHFF_New():
    return itkIntermodesThresholdCalculatorHFF.New()

class itkIntermodesThresholdCalculatorHFF(itk.itkHistogramThresholdCalculatorPython.itkHistogramThresholdCalculatorHFF):
    r"""Proxy of C++ itkIntermodesThresholdCalculatorHFF class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def __New_orig__():
        r"""__New_orig__() -> itkIntermodesThresholdCalculatorHFF_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFF___New_orig__()

    def Clone(self):
        r"""Clone(self) -> itkIntermodesThresholdCalculatorHFF_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFF_Clone(self)

    def SetMaximumSmoothingIterations(self, _arg):
        r"""
        SetMaximumSmoothingIterations(self, _arg)

        Parameters
        ----------
        _arg: unsigned long

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFF_SetMaximumSmoothingIterations(self, _arg)

    def GetMaximumSmoothingIterations(self):
        r"""GetMaximumSmoothingIterations(self) -> unsigned long"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFF_GetMaximumSmoothingIterations(self)

    def SetUseInterMode(self, _arg):
        r"""
        SetUseInterMode(self, _arg)

        Parameters
        ----------
        _arg: bool

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFF_SetUseInterMode(self, _arg)

    def GetUseInterMode(self):
        r"""GetUseInterMode(self) -> bool"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFF_GetUseInterMode(self)

    def UseInterModeOn(self):
        r"""UseInterModeOn(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFF_UseInterModeOn(self)

    def UseInterModeOff(self):
        r"""UseInterModeOff(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFF_UseInterModeOff(self)
    __swig_destroy__ = _itkIntermodesThresholdCalculatorPython.delete_itkIntermodesThresholdCalculatorHFF

    @staticmethod
    def cast(obj):
        r"""
        cast(obj) -> itkIntermodesThresholdCalculatorHFF

        Parameters
        ----------
        obj: itkLightObject *

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFF_cast(obj)

    def New(*args, **kargs):
        """New() -> itkIntermodesThresholdCalculatorHFF

        Create a new object of the class itkIntermodesThresholdCalculatorHFF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkIntermodesThresholdCalculatorHFF.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkIntermodesThresholdCalculatorHFF.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkIntermodesThresholdCalculatorHFF.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkIntermodesThresholdCalculatorHFF in _itkIntermodesThresholdCalculatorPython:
_itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFF_swigregister(itkIntermodesThresholdCalculatorHFF)

def itkIntermodesThresholdCalculatorHFSS_New():
    return itkIntermodesThresholdCalculatorHFSS.New()

class itkIntermodesThresholdCalculatorHFSS(itk.itkHistogramThresholdCalculatorPython.itkHistogramThresholdCalculatorHFSS):
    r"""Proxy of C++ itkIntermodesThresholdCalculatorHFSS class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def __New_orig__():
        r"""__New_orig__() -> itkIntermodesThresholdCalculatorHFSS_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFSS___New_orig__()

    def Clone(self):
        r"""Clone(self) -> itkIntermodesThresholdCalculatorHFSS_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFSS_Clone(self)

    def SetMaximumSmoothingIterations(self, _arg):
        r"""
        SetMaximumSmoothingIterations(self, _arg)

        Parameters
        ----------
        _arg: unsigned long

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFSS_SetMaximumSmoothingIterations(self, _arg)

    def GetMaximumSmoothingIterations(self):
        r"""GetMaximumSmoothingIterations(self) -> unsigned long"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFSS_GetMaximumSmoothingIterations(self)

    def SetUseInterMode(self, _arg):
        r"""
        SetUseInterMode(self, _arg)

        Parameters
        ----------
        _arg: bool

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFSS_SetUseInterMode(self, _arg)

    def GetUseInterMode(self):
        r"""GetUseInterMode(self) -> bool"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFSS_GetUseInterMode(self)

    def UseInterModeOn(self):
        r"""UseInterModeOn(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFSS_UseInterModeOn(self)

    def UseInterModeOff(self):
        r"""UseInterModeOff(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFSS_UseInterModeOff(self)
    __swig_destroy__ = _itkIntermodesThresholdCalculatorPython.delete_itkIntermodesThresholdCalculatorHFSS

    @staticmethod
    def cast(obj):
        r"""
        cast(obj) -> itkIntermodesThresholdCalculatorHFSS

        Parameters
        ----------
        obj: itkLightObject *

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFSS_cast(obj)

    def New(*args, **kargs):
        """New() -> itkIntermodesThresholdCalculatorHFSS

        Create a new object of the class itkIntermodesThresholdCalculatorHFSS and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkIntermodesThresholdCalculatorHFSS.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkIntermodesThresholdCalculatorHFSS.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkIntermodesThresholdCalculatorHFSS.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkIntermodesThresholdCalculatorHFSS in _itkIntermodesThresholdCalculatorPython:
_itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFSS_swigregister(itkIntermodesThresholdCalculatorHFSS)

def itkIntermodesThresholdCalculatorHFUC_New():
    return itkIntermodesThresholdCalculatorHFUC.New()

class itkIntermodesThresholdCalculatorHFUC(itk.itkHistogramThresholdCalculatorPython.itkHistogramThresholdCalculatorHFUC):
    r"""Proxy of C++ itkIntermodesThresholdCalculatorHFUC class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def __New_orig__():
        r"""__New_orig__() -> itkIntermodesThresholdCalculatorHFUC_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUC___New_orig__()

    def Clone(self):
        r"""Clone(self) -> itkIntermodesThresholdCalculatorHFUC_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUC_Clone(self)

    def SetMaximumSmoothingIterations(self, _arg):
        r"""
        SetMaximumSmoothingIterations(self, _arg)

        Parameters
        ----------
        _arg: unsigned long

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUC_SetMaximumSmoothingIterations(self, _arg)

    def GetMaximumSmoothingIterations(self):
        r"""GetMaximumSmoothingIterations(self) -> unsigned long"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUC_GetMaximumSmoothingIterations(self)

    def SetUseInterMode(self, _arg):
        r"""
        SetUseInterMode(self, _arg)

        Parameters
        ----------
        _arg: bool

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUC_SetUseInterMode(self, _arg)

    def GetUseInterMode(self):
        r"""GetUseInterMode(self) -> bool"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUC_GetUseInterMode(self)

    def UseInterModeOn(self):
        r"""UseInterModeOn(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUC_UseInterModeOn(self)

    def UseInterModeOff(self):
        r"""UseInterModeOff(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUC_UseInterModeOff(self)
    __swig_destroy__ = _itkIntermodesThresholdCalculatorPython.delete_itkIntermodesThresholdCalculatorHFUC

    @staticmethod
    def cast(obj):
        r"""
        cast(obj) -> itkIntermodesThresholdCalculatorHFUC

        Parameters
        ----------
        obj: itkLightObject *

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUC_cast(obj)

    def New(*args, **kargs):
        """New() -> itkIntermodesThresholdCalculatorHFUC

        Create a new object of the class itkIntermodesThresholdCalculatorHFUC and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkIntermodesThresholdCalculatorHFUC.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkIntermodesThresholdCalculatorHFUC.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkIntermodesThresholdCalculatorHFUC.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkIntermodesThresholdCalculatorHFUC in _itkIntermodesThresholdCalculatorPython:
_itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUC_swigregister(itkIntermodesThresholdCalculatorHFUC)

def itkIntermodesThresholdCalculatorHFUS_New():
    return itkIntermodesThresholdCalculatorHFUS.New()

class itkIntermodesThresholdCalculatorHFUS(itk.itkHistogramThresholdCalculatorPython.itkHistogramThresholdCalculatorHFUS):
    r"""Proxy of C++ itkIntermodesThresholdCalculatorHFUS class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def __New_orig__():
        r"""__New_orig__() -> itkIntermodesThresholdCalculatorHFUS_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUS___New_orig__()

    def Clone(self):
        r"""Clone(self) -> itkIntermodesThresholdCalculatorHFUS_Pointer"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUS_Clone(self)

    def SetMaximumSmoothingIterations(self, _arg):
        r"""
        SetMaximumSmoothingIterations(self, _arg)

        Parameters
        ----------
        _arg: unsigned long

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUS_SetMaximumSmoothingIterations(self, _arg)

    def GetMaximumSmoothingIterations(self):
        r"""GetMaximumSmoothingIterations(self) -> unsigned long"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUS_GetMaximumSmoothingIterations(self)

    def SetUseInterMode(self, _arg):
        r"""
        SetUseInterMode(self, _arg)

        Parameters
        ----------
        _arg: bool

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUS_SetUseInterMode(self, _arg)

    def GetUseInterMode(self):
        r"""GetUseInterMode(self) -> bool"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUS_GetUseInterMode(self)

    def UseInterModeOn(self):
        r"""UseInterModeOn(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUS_UseInterModeOn(self)

    def UseInterModeOff(self):
        r"""UseInterModeOff(self)"""
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUS_UseInterModeOff(self)
    __swig_destroy__ = _itkIntermodesThresholdCalculatorPython.delete_itkIntermodesThresholdCalculatorHFUS

    @staticmethod
    def cast(obj):
        r"""
        cast(obj) -> itkIntermodesThresholdCalculatorHFUS

        Parameters
        ----------
        obj: itkLightObject *

        """
        return _itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUS_cast(obj)

    def New(*args, **kargs):
        """New() -> itkIntermodesThresholdCalculatorHFUS

        Create a new object of the class itkIntermodesThresholdCalculatorHFUS and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkIntermodesThresholdCalculatorHFUS.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkIntermodesThresholdCalculatorHFUS.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkIntermodesThresholdCalculatorHFUS.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkIntermodesThresholdCalculatorHFUS in _itkIntermodesThresholdCalculatorPython:
_itkIntermodesThresholdCalculatorPython.itkIntermodesThresholdCalculatorHFUS_swigregister(itkIntermodesThresholdCalculatorHFUS)

from itk.support import helpers
import itk.support.types as itkt
from typing import Union
from collections.abc import Sequence

@helpers.accept_array_like_xarray_torch
def intermodes_threshold_calculator(*args,  maximum_smoothing_iterations: int=..., use_inter_mode: bool=...,**kwargs):
    """Functional interface for IntermodesThresholdCalculator"""
    import itk

    kwarg_typehints = { 'maximum_smoothing_iterations':maximum_smoothing_iterations,'use_inter_mode':use_inter_mode }
    specified_kwarg_typehints = { k:v for (k,v) in kwarg_typehints.items() if kwarg_typehints[k] is not ... }
    kwargs.update(specified_kwarg_typehints)


    instance = itk.IntermodesThresholdCalculator.New(*args, **kwargs)

    return instance.__internal_call__()

def intermodes_threshold_calculator_init_docstring():
    import itk
    from itk.support import template_class

    filter_class = itk.ITKThresholding.IntermodesThresholdCalculator
    intermodes_threshold_calculator.process_object = filter_class
    is_template = isinstance(filter_class, template_class.itkTemplate)
    if is_template:
        filter_object = filter_class.values()[0]
    else:
        filter_object = filter_class

    intermodes_threshold_calculator.__doc__ = filter_object.__doc__



