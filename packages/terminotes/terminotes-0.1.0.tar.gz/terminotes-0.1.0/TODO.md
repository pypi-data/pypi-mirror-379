# Implementation Plan

- **Stage 1**: Bootstrap uv-based packaging (pyproject, `uv init`, module skeleton, CLI entry point) and lay down `terminotes/` scaffolding plus starter Justfile.
- **Stage 2**: Implement configuration handling for allowed tags and optional git sync (accepting a remote URL when available).
- **Stage 3**: Build note creation flow (one-line command, editor template, SQLite persistence, ID generation) using the configured storage location.
- **Stage 4**: Git sync and interactive divergence resolution
  - Integrate sync into existing flows (no new command):
    - After `new` and `edit`, stage and commit the DB, then push to the current branch.
  - Handle divergence interactively (no merging of DB):
    - On push failure due to non-fast-forward/divergence, prompt the user to choose:
      - `local-wins` → `git push --force-with-lease origin <branch>` (keep local DB).
      - `remote-wins` → `git fetch --prune && git reset --hard origin/<branch>` (keep remote DB).
      - `abort` → stop without changes.
    - In non-interactive sessions, abort with guidance to re-run in a terminal.
  - Safety and fallbacks:
    - Skip sync if the path is not a functional git repo.
  - Testing/documentation:
    - Mock subprocess calls for push failure and verify prompt options drive the correct actions.
    - Document sync behavior, divergence choices, and safety notes.
- **Stage 5**: Implement `ls`, `update`, and `search` subcommands using SQLite queries.
- **Stage 6**: Establish testing/tooling setup (pytest fixtures, coverage hooks, uv-driven `ruff` lint/format tasks, docs updates).
- **Stage 7**: Final packaging polish—CLI help text, logging, release checklist, and CI readiness review.
