#include "../crypto.h"
#include <string.h>
#include <assert.h>

static uint8_t const base64_pr2six[256] = {
  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x3E,0x40,0x40,0x40,0x3F,
  0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,
  0x0F,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x40,0x40,0x40,0x40,0x40,
  0x40,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,
  0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,0x32,0x33,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
};

static char const base64_basis[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

size_t base64_dec_size(char const *in,bool nullterm){
  size_t      nbd;
  size_t      npr;
  char const *in2;

  in2 = in;
  while(base64_pr2six[(uint8_t)*(in2++)] < 0x40);
  npr = in2-in-1;
  nbd = ((npr+3)/4)*3;

  while(npr > 4) npr -= 4;
  nbd -= (4-npr) & 3;
  nbd += nullterm;
  return nbd;
}

size_t base64_dec(char const *in,uint8_t *out,size_t out_size,bool nullterm){
  size_t      nbd;
  char const *in2;
  size_t      npr;

  assert(out_size >= base64_dec_size(in,nullterm));
  (void)out_size;

  in2   = in;
  while(base64_pr2six[(uint8_t)*(in2++)] < 0x40);
  npr   = in2-in-1;
  nbd   = ((npr+3)/4)*3;
  in2   = in;

  while(npr > 4){
    *out++  = base64_pr2six[(uint8_t)*in2]   << 2 | base64_pr2six[(uint8_t)in2[1]]>>4;
    *out++  = base64_pr2six[(uint8_t)in2[1]] << 4 | base64_pr2six[(uint8_t)in2[2]]>>2;
    *out++  = base64_pr2six[(uint8_t)in2[2]] << 6 | base64_pr2six[(uint8_t)in2[3]];
    in2    += 4;
    npr    -= 4;
  }

  if(npr > 1) *out++ = base64_pr2six[(uint8_t)*in2]   << 2 | base64_pr2six[(uint8_t)in2[1]]>>4;
  if(npr > 2) *out++ = base64_pr2six[(uint8_t)in2[1]] << 4 | base64_pr2six[(uint8_t)in2[2]]>>2;
  if(npr > 3) *out++ = base64_pr2six[(uint8_t)in2[2]] << 6 | base64_pr2six[(uint8_t)in2[3]];

  if(nullterm) *out++ = 0;
  nbd -= (4-npr) & 3;
  nbd += nullterm;
  return nbd;
}

size_t base64_enc(uint8_t const *in,size_t in_size,char *out,size_t out_size){
  char   *p = out;
  size_t  i;

  assert(out_size >= BASE64_ENC_SIZE(in_size,1));
  (void)out_size;

  for(i = 0;i < in_size-2;i += 3){
    *p++ = base64_basis[in[i]>>2 & 0x3F];
    *p++ = base64_basis[(in[i]   & 0x03)<<4 | (int32_t)(in[i+1] & 0xF0)>>4];
    *p++ = base64_basis[(in[i+1] & 0x0F)<<2 | (int32_t)(in[i+2] & 0xC0)>>6];
    *p++ = base64_basis[in[i+2] & 0x3F];
  }

  if(i < in_size){
    *p++ = base64_basis[in[i]>>2 & 0x3F];
    if(i == in_size-1){
      *p++ = base64_basis[(in[i] & 0x03)<<4];
      *p++ = '=';
    }else{
      *p++ = base64_basis[(in[i] & 0x03)<<4 | (int32_t)(in[i+1] & 0xF0)>>4];
      *p++ = base64_basis[(in[i+1] & 0x0F)<<2];
    }
    *p++ = '=';
  }

  *p++ = 0;
  return p-out;
}

