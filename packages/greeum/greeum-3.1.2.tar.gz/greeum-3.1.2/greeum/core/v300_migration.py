#!/usr/bin/env python3
"""
Greeum v3.0.0 Migration System
Í∏∞Ï°¥ v2.6.4 Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Î•º v3.0.0 Ïä§ÌÇ§ÎßàÎ°ú ÏûêÎèô ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
"""

import os
import sqlite3
import time
import logging
from typing import Dict, List, Optional, Tuple
from datetime import datetime

logger = logging.getLogger(__name__)

class V300MigrationManager:
    """v2.6.4 ‚Üí v3.0.0 Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Í¥ÄÎ¶¨Ïûê"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.backup_path = f"{db_path}.v264_backup_{int(time.time())}"
        
    def migrate_to_v300(self) -> bool:
        """Ï†ÑÏ≤¥ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÌîÑÎ°úÏÑ∏Ïä§ Ïã§Ìñâ"""
        
        print("\n" + "="*70)
        print("üîÑ Greeum v2.6.4 ‚Üí v3.0.0 Migration")
        print("="*70)
        
        try:
            # 1. Î∞±ÏóÖ ÏÉùÏÑ±
            self._create_backup()
            
            # 2. v3.0.0 Ïä§ÌÇ§Îßà Ï∂îÍ∞Ä
            self._add_v300_schema()
            
            # 3. Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù
            migration_stats = self._analyze_existing_data()
            
            # 4. Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
            self._migrate_blocks_to_v300(migration_stats)
            
            # 5. Í≤ÄÏ¶ù
            success = self._verify_migration()
            
            if success:
                print(f"\n‚úÖ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏôÑÎ£å!")
                print(f"   Î∞±ÏóÖ: {self.backup_path}")
                print(f"   v3.0.0 Í∏∞Îä• ÏÇ¨Ïö© Ï§ÄÎπÑ ÏôÑÎ£å")
            else:
                print(f"\n‚ùå ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïã§Ìå® - Î∞±ÏóÖÏóêÏÑú Î≥µÏõêÌïòÏÑ∏Ïöî")
                
            return success
            
        except Exception as e:
            logger.error(f"Migration failed: {e}")
            print(f"\n‚ùå ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ï§ë Ïò§Î•ò: {e}")
            print(f"Î∞±ÏóÖ ÌååÏùº: {self.backup_path}")
            return False
    
    def _create_backup(self):
        """Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î∞±ÏóÖ"""
        print(f"\nüì¶ Creating backup...")
        
        if not os.path.exists(self.db_path):
            raise FileNotFoundError(f"Database not found: {self.db_path}")
        
        import shutil
        shutil.copy2(self.db_path, self.backup_path)
        print(f"   ‚úÖ Backup created: {self.backup_path}")
    
    def _add_v300_schema(self):
        """v3.0.0 Ïä§ÌÇ§Îßà Ï∂îÍ∞Ä (Í∏∞Ï°¥ ÌÖåÏù¥Î∏î Ïú†ÏßÄ)"""
        print(f"\nüèóÔ∏è  Adding v3.0.0 schema...")
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            # v3.0.0 ÏÉà ÌÖåÏù¥Î∏îÎì§ Ï∂îÍ∞Ä
            v300_tables = [
                '''
                CREATE TABLE IF NOT EXISTS contexts (
                    context_id TEXT PRIMARY KEY,
                    trigger TEXT,
                    start_time REAL,
                    end_time REAL,
                    memory_count INTEGER DEFAULT 0,
                    metadata TEXT
                )
                ''',
                '''
                CREATE TABLE IF NOT EXISTS memory_connections (
                    from_memory INTEGER,
                    to_memory INTEGER,
                    weight REAL DEFAULT 0.5,
                    connection_type TEXT,
                    created_at REAL,
                    context_id TEXT,
                    PRIMARY KEY (from_memory, to_memory)
                )
                ''',
                '''
                CREATE TABLE IF NOT EXISTS activation_log (
                    memory_id INTEGER,
                    activation_level REAL,
                    context_id TEXT,
                    timestamp REAL,
                    trigger_memory INTEGER
                )
                ''',
                '''
                CREATE TABLE IF NOT EXISTS tag_definitions (
                    tag_id INTEGER PRIMARY KEY AUTOINCREMENT,
                    tag_name TEXT UNIQUE NOT NULL,
                    tag_level INTEGER,
                    usage_count INTEGER DEFAULT 0,
                    last_used REAL,
                    created_at REAL DEFAULT (strftime('%s', 'now')),
                    is_active INTEGER DEFAULT 1
                )
                ''',
                '''
                CREATE TABLE IF NOT EXISTS memory_tags (
                    memory_id INTEGER,
                    tag_name TEXT,
                    tag_type TEXT,
                    confidence REAL DEFAULT 1.0,
                    added_by TEXT DEFAULT 'migration',
                    added_at REAL DEFAULT (strftime('%s', 'now')),
                    PRIMARY KEY (memory_id, tag_name, tag_type)
                )
                ''',
                '''
                CREATE TABLE IF NOT EXISTS tag_synonyms (
                    synonym TEXT PRIMARY KEY,
                    canonical TEXT NOT NULL
                )
                '''
            ]
            
            for table_sql in v300_tables:
                cursor.execute(table_sql)
            
            conn.commit()
            print(f"   ‚úÖ v3.0.0 schema added")
            
        finally:
            conn.close()
    
    def _analyze_existing_data(self) -> Dict:
        """Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù"""
        print(f"\nüìä Analyzing existing data...")
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        stats = {}
        
        try:
            # Í∏∞Ï°¥ Î∏îÎ°ù Ïàò
            cursor.execute("SELECT COUNT(*) FROM blocks")
            stats['total_blocks'] = cursor.fetchone()[0]
            
            # Í∏∞Ï°¥ ÌÇ§ÏõåÎìú Ïàò
            cursor.execute("SELECT COUNT(*) FROM keywords")
            stats['total_keywords'] = cursor.fetchone()[0]
            
            # Í∏∞Ï°¥ ÌÉúÍ∑∏ Ïàò (tags ÌÖåÏù¥Î∏îÏù¥ ÏûàÎã§Î©¥)
            try:
                cursor.execute("SELECT COUNT(*) FROM tags")
                stats['total_tags'] = cursor.fetchone()[0]
            except sqlite3.OperationalError:
                stats['total_tags'] = 0
            
            # Ï§ëÏöîÎèÑ Î∂ÑÌè¨
            cursor.execute("SELECT AVG(importance), MIN(importance), MAX(importance) FROM blocks")
            row = cursor.fetchone()
            stats['importance'] = {
                'avg': row[0] or 0,
                'min': row[1] or 0,
                'max': row[2] or 0
            }
            
            print(f"   üìà Found {stats['total_blocks']} blocks")
            print(f"   üî§ Found {stats['total_keywords']} keywords")
            print(f"   üè∑Ô∏è  Found {stats['total_tags']} tags")
            print(f"   ‚≠ê Importance range: {stats['importance']['min']:.1f} - {stats['importance']['max']:.1f}")
            
            return stats
            
        finally:
            conn.close()
    
    def _migrate_blocks_to_v300(self, stats: Dict):
        """Í∏∞Ï°¥ Î∏îÎ°ùÎì§ÏùÑ v3.0.0 Ïª®ÌÖçÏä§Ìä∏ ÏãúÏä§ÌÖúÏúºÎ°ú ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò"""
        print(f"\nüîÑ Migrating {stats['total_blocks']} blocks to v3.0.0...")
        
        if stats['total_blocks'] == 0:
            print("   ‚ÑπÔ∏è  No blocks to migrate")
            return
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            # 1. Í∏∞Î≥∏ Ïª®ÌÖçÏä§Ìä∏ ÏÉùÏÑ±
            migration_context_id = f"migration_v264_to_v300_{int(time.time())}"
            cursor.execute('''
                INSERT OR REPLACE INTO contexts (context_id, trigger, start_time, memory_count)
                VALUES (?, ?, ?, ?)
            ''', (migration_context_id, "v2.6.4 migration", time.time(), stats['total_blocks']))
            
            # 2. Í∏∞Ï°¥ Î∏îÎ°ùÎì§ Í∞ÄÏ†∏Ïò§Í∏∞
            cursor.execute('''
                SELECT block_index, context, importance, timestamp 
                FROM blocks 
                ORDER BY block_index
            ''')
            blocks = cursor.fetchall()
            
            # 3. Ïó∞Í≤∞ ÏÉùÏÑ± (ÏãúÍ∞Ñ ÏàúÏÑúÎåÄÎ°ú Ïó∞Í≤∞)
            connections_created = 0
            for i, (block_id, content, importance, timestamp) in enumerate(blocks):
                
                # Í∏∞Î≥∏ ÌÉúÍ∑∏ ÏÉùÏÑ± (content Í∏∞Î∞ò)
                self._create_basic_tags(cursor, block_id, content, importance)
                
                # Ïù∏Ï†ëÌïú Î∏îÎ°ùÎì§Í≥º Ïó∞Í≤∞ (ÏãúÍ∞Ñ Í∏∞Î∞ò)
                if i > 0:
                    prev_block = blocks[i-1]
                    weight = min(0.8, importance * 0.6)  # Ï§ëÏöîÎèÑ Í∏∞Î∞ò Ïó∞Í≤∞ Í∞ïÎèÑ
                    
                    # ÏñëÎ∞©Ìñ• Ïó∞Í≤∞
                    cursor.execute('''
                        INSERT OR REPLACE INTO memory_connections
                        (from_memory, to_memory, weight, connection_type, created_at, context_id)
                        VALUES (?, ?, ?, ?, ?, ?)
                    ''', (block_id, prev_block[0], weight, 'temporal', time.time(), migration_context_id))
                    
                    cursor.execute('''
                        INSERT OR REPLACE INTO memory_connections
                        (from_memory, to_memory, weight, connection_type, created_at, context_id)
                        VALUES (?, ?, ?, ?, ?, ?)
                    ''', (prev_block[0], block_id, weight * 0.7, 'temporal', time.time(), migration_context_id))
                    
                    connections_created += 2
                
                if (i + 1) % 50 == 0:
                    print(f"   üìà Progress: {i+1}/{len(blocks)} blocks processed")
            
            conn.commit()
            print(f"   ‚úÖ Created {connections_created} temporal connections")
            print(f"   ‚úÖ All blocks migrated to v3.0.0 context system")
            
        finally:
            conn.close()
    
    def _create_basic_tags(self, cursor, block_id: int, content: str, importance: float):
        """Í∏∞Ï°¥ Î∏îÎ°ùÏóê Í∏∞Î≥∏ ÌÉúÍ∑∏ ÏÉùÏÑ±"""
        
        # Ï§ëÏöîÎèÑ Í∏∞Î∞ò Ïπ¥ÌÖåÍ≥†Î¶¨
        if importance >= 0.8:
            category = "important"
        elif importance >= 0.5:
            category = "normal"
        else:
            category = "casual"
        
        # ÎÇ¥Ïö© Í∏∞Î∞ò Í∞ÑÎã®Ìïú ÌôúÎèô Ï∂îÎ°†
        content_lower = content.lower()
        if any(word in content_lower for word in ['bug', 'Î≤ÑÍ∑∏', 'fix', 'ÏàòÏ†ï', 'error', 'Ïò§Î•ò']):
            activity = "fix"
        elif any(word in content_lower for word in ['implement', 'Íµ¨ÌòÑ', 'add', 'Ï∂îÍ∞Ä', 'create', 'ÏÉùÏÑ±']):
            activity = "create"
        elif any(word in content_lower for word in ['test', 'ÌÖåÏä§Ìä∏', 'check', 'ÌôïÏù∏']):
            activity = "test"
        else:
            activity = "general"
        
        # ÌÉúÍ∑∏ Ï†ÄÏû•
        tags = [
            (block_id, category, 'category', 0.9),
            (block_id, activity, 'activity', 0.8),
            (block_id, 'migrated', 'domain', 1.0)
        ]
        
        for memory_id, tag_name, tag_type, confidence in tags:
            cursor.execute('''
                INSERT OR REPLACE INTO memory_tags
                (memory_id, tag_name, tag_type, confidence, added_by)
                VALUES (?, ?, ?, ?, ?)
            ''', (memory_id, tag_name, tag_type, confidence, 'migration'))
    
    def _verify_migration(self) -> bool:
        """ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Í≤ÄÏ¶ù"""
        print(f"\nüîç Verifying migration...")
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            # v3.0.0 ÌÖåÏù¥Î∏î Ï°¥Ïû¨ ÌôïÏù∏
            required_tables = ['contexts', 'memory_connections', 'memory_tags']
            for table in required_tables:
                cursor.execute(f"SELECT COUNT(*) FROM {table}")
                count = cursor.fetchone()[0]
                print(f"   ‚úÖ {table}: {count} records")
            
            # Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ Î≥¥Ï°¥ ÌôïÏù∏
            cursor.execute("SELECT COUNT(*) FROM blocks")
            blocks_count = cursor.fetchone()[0]
            
            # Ïó∞Í≤∞ ÏÉùÏÑ± ÌôïÏù∏
            cursor.execute("SELECT COUNT(*) FROM memory_connections")
            connections_count = cursor.fetchone()[0]
            
            print(f"   ‚úÖ Original blocks preserved: {blocks_count}")
            print(f"   ‚úÖ New connections created: {connections_count}")
            
            return blocks_count > 0  # Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Í∞Ä Î≥¥Ï°¥ÎêòÏóàÏúºÎ©¥ ÏÑ±Í≥µ
            
        finally:
            conn.close()


def auto_migrate_if_needed(db_path: str) -> bool:
    """ÌïÑÏöîÏãú ÏûêÎèô ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïã§Ìñâ"""
    
    if not os.path.exists(db_path):
        return True  # ÏÉà Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Îäî ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Î∂àÌïÑÏöî
    
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    try:
        # v3.0.0 ÌÖåÏù¥Î∏îÎì§Ïù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='contexts'")
        has_v300_schema = cursor.fetchone() is not None
        
        # Í∏∞Ï°¥ blocks ÌÖåÏù¥Î∏îÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='blocks'")
        has_v264_data = cursor.fetchone() is not None
        
        if has_v264_data and not has_v300_schema:
            print(f"\nüîÑ v2.6.4 database detected - migration required")
            migrator = V300MigrationManager(db_path)
            return migrator.migrate_to_v300()
        
        return True  # ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Î∂àÌïÑÏöî ÎòêÎäî Ïù¥ÎØ∏ ÏôÑÎ£å
        
    finally:
        conn.close()


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) != 2:
        print("Usage: python v300_migration.py <database_path>")
        sys.exit(1)
    
    db_path = sys.argv[1]
    success = auto_migrate_if_needed(db_path)
    
    if success:
        print("\n‚úÖ Ready for Greeum v3.0.0!")
    else:
        print("\n‚ùå Migration failed")
        sys.exit(1)