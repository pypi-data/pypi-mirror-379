# pylint: disable=too-many-lines
# coding=utf-8

import datetime
import json
import sys
from io import IOBase
from typing import (
    IO,
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    List,
    Optional,
    TypeVar,
    Union,
    overload,
)

from corehttp.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from corehttp.rest import AsyncHttpResponse, HttpRequest
from corehttp.runtime import AsyncPipelineClient
from corehttp.runtime.pipeline import PipelineResponse
from corehttp.utils import case_insensitive_dict

from ... import models as _models
from ..._model_base import SdkJSONEncoder, _deserialize, _failsafe_deserialize
from ..._serialization import Deserializer, Serializer
from ...operations._operations import (
    build_bond_future_price_request,
    build_bond_price_request,
    build_calendar_resource_compute_dates_request,
    build_calendar_resource_count_periods_request,
    build_calendar_resource_delete_request,
    build_calendar_resource_generate_date_schedule_request,
    build_calendar_resource_generate_holidays_request,
    build_calendar_resource_overwrite_request,
    build_calendar_resource_read_request,
    build_calendars_resource_compute_dates_request,
    build_calendars_resource_count_periods_request,
    build_calendars_resource_create_request,
    build_calendars_resource_generate_date_schedule_request,
    build_calendars_resource_generate_holidays_request,
    build_calendars_resource_list_request,
    build_cap_floor_price_request,
    build_cds_price_request,
    build_commodities_curves_calculate_by_id_request,
    build_commodities_curves_calculate_request,
    build_commodities_curves_create_request,
    build_commodities_curves_delete_request,
    build_commodities_curves_overwrite_request,
    build_commodities_curves_read_request,
    build_commodities_curves_search_request,
    build_credit_curves_calculate_by_id_request,
    build_credit_curves_calculate_request,
    build_credit_curves_create_request,
    build_credit_curves_delete_request,
    build_credit_curves_overwrite_request,
    build_credit_curves_read_request,
    build_credit_curves_search_request,
    build_eq_volatility_calculate_request,
    build_floating_rate_index_resource_delete_request,
    build_floating_rate_index_resource_overwrite_request,
    build_floating_rate_index_resource_read_request,
    build_floating_rate_indices_resource_create_request,
    build_floating_rate_indices_resource_list_request,
    build_forward_rate_agreement_price_request,
    build_fx_forward_curve_resource_calculate_request,
    build_fx_forward_curve_resource_delete_request,
    build_fx_forward_curve_resource_overwrite_request,
    build_fx_forward_curve_resource_read_request,
    build_fx_forward_curves_resource_build_from_deposits_request,
    build_fx_forward_curves_resource_build_from_fx_forwards_request,
    build_fx_forward_curves_resource_calculate_request,
    build_fx_forward_curves_resource_create_request,
    build_fx_forward_curves_resource_list_request,
    build_fx_forward_resource_delete_request,
    build_fx_forward_resource_overwrite_request,
    build_fx_forward_resource_price_request,
    build_fx_forward_resource_read_request,
    build_fx_forward_resource_value_request,
    build_fx_forwards_resource_build_fx_forward_from_template_request,
    build_fx_forwards_resource_create_request,
    build_fx_forwards_resource_list_request,
    build_fx_forwards_resource_price_request,
    build_fx_forwards_resource_value_request,
    build_fx_spot_resource_delete_request,
    build_fx_spot_resource_overwrite_request,
    build_fx_spot_resource_price_request,
    build_fx_spot_resource_read_request,
    build_fx_spot_resource_value_request,
    build_fx_spots_resource_build_fx_spot_from_template_request,
    build_fx_spots_resource_create_request,
    build_fx_spots_resource_list_request,
    build_fx_spots_resource_price_request,
    build_fx_spots_resource_value_request,
    build_fx_volatility_calculate_request,
    build_inflation_curves_calculate_by_id_request,
    build_inflation_curves_calculate_request,
    build_inflation_curves_create_request,
    build_inflation_curves_delete_request,
    build_inflation_curves_overwrite_request,
    build_inflation_curves_read_request,
    build_inflation_curves_search_request,
    build_instrument_template_resource_delete_request,
    build_instrument_template_resource_overwrite_request,
    build_instrument_template_resource_read_request,
    build_instrument_templates_resource_create_request,
    build_instrument_templates_resource_list_request,
    build_interest_rate_curve_service_calculate_request,
    build_interest_rate_curve_service_delete_request,
    build_interest_rate_curve_service_overwrite_request,
    build_interest_rate_curve_service_read_request,
    build_interest_rate_curves_service_calculate_request,
    build_interest_rate_curves_service_create_request,
    build_interest_rate_curves_service_list_request,
    build_ipa_interest_rate_curves_calculate_by_id_request,
    build_ipa_interest_rate_curves_calculate_request,
    build_ipa_interest_rate_curves_create_request,
    build_ipa_interest_rate_curves_delete_request,
    build_ipa_interest_rate_curves_overwrite_request,
    build_ipa_interest_rate_curves_read_request,
    build_ipa_interest_rate_curves_search_request,
    build_ir_swap_resource_delete_request,
    build_ir_swap_resource_overwrite_request,
    build_ir_swap_resource_read_request,
    build_ir_swap_resource_solve_request,
    build_ir_swap_resource_value_request,
    build_ir_swaps_resource_create_irs_from_cbs_template_request,
    build_ir_swaps_resource_create_irs_from_ccs_template_request,
    build_ir_swaps_resource_create_irs_from_leg_template_request,
    build_ir_swaps_resource_create_irs_from_tbs_template_request,
    build_ir_swaps_resource_create_irs_from_vanilla_irs_template_request,
    build_ir_swaps_resource_create_request,
    build_ir_swaps_resource_list_request,
    build_ir_swaps_resource_solve_request,
    build_ir_swaps_resource_value_request,
    build_ircaplet_volatility_calculate_request,
    build_irswaption_volatility_calculate_request,
    build_loan_resource_delete_request,
    build_loan_resource_overwrite_request,
    build_loan_resource_price_request,
    build_loan_resource_read_request,
    build_loan_resource_value_request,
    build_loans_resource_create_request,
    build_loans_resource_list_request,
    build_loans_resource_price_request,
    build_loans_resource_value_request,
    build_option_resource_delete_request,
    build_option_resource_overwrite_request,
    build_option_resource_read_request,
    build_option_resource_solve_request,
    build_option_resource_value_request,
    build_options_resource_create_asian_otc_option_from_template_request,
    build_options_resource_create_double_barrier_otc_option_from_template_request,
    build_options_resource_create_double_binary_otc_option_from_template_request,
    build_options_resource_create_request,
    build_options_resource_create_single_barrier_otc_option_from_template_request,
    build_options_resource_create_single_binary_otc_option_from_template_request,
    build_options_resource_create_vanilla_otc_option_from_template_request,
    build_options_resource_list_request,
    build_options_resource_solve_request,
    build_options_resource_value_request,
    build_repo_price_request,
    build_structured_products_price_request,
    build_swaption_price_request,
    build_term_deposit_price_request,
    build_yield_book_rest_abort_job_request,
    build_yield_book_rest_bulk_compact_request_request,
    build_yield_book_rest_bulk_composite_request_request,
    build_yield_book_rest_bulk_yb_port_udi_request_request,
    build_yield_book_rest_bulk_zip_request_request,
    build_yield_book_rest_close_job_request,
    build_yield_book_rest_create_job_request,
    build_yield_book_rest_get_cash_flow_async_request,
    build_yield_book_rest_get_cash_flow_sync_request,
    build_yield_book_rest_get_csv_bulk_result_request,
    build_yield_book_rest_get_formatted_result_request,
    build_yield_book_rest_get_job_data_request,
    build_yield_book_rest_get_job_object_meta_request,
    build_yield_book_rest_get_job_request,
    build_yield_book_rest_get_job_status_request,
    build_yield_book_rest_get_json_result_request,
    build_yield_book_rest_get_result_request,
    build_yield_book_rest_get_tba_pricing_sync_request,
    build_yield_book_rest_post_cash_flow_async_request,
    build_yield_book_rest_post_cash_flow_sync_request,
    build_yield_book_rest_post_csv_bulk_results_sync_request,
    build_yield_book_rest_post_json_bulk_request_sync_request,
    build_yield_book_rest_post_market_setting_sync_request,
    build_yield_book_rest_request_actual_vs_projected_async_get_request,
    build_yield_book_rest_request_actual_vs_projected_async_request,
    build_yield_book_rest_request_actual_vs_projected_sync_get_request,
    build_yield_book_rest_request_actual_vs_projected_sync_request,
    build_yield_book_rest_request_bond_indic_async_get_request,
    build_yield_book_rest_request_bond_indic_async_request,
    build_yield_book_rest_request_bond_indic_sync_get_request,
    build_yield_book_rest_request_bond_indic_sync_request,
    build_yield_book_rest_request_collateral_details_async_get_request,
    build_yield_book_rest_request_collateral_details_async_request,
    build_yield_book_rest_request_collateral_details_sync_get_request,
    build_yield_book_rest_request_collateral_details_sync_request,
    build_yield_book_rest_request_curve_async_request,
    build_yield_book_rest_request_curve_sync_request,
    build_yield_book_rest_request_curves_async_request,
    build_yield_book_rest_request_curves_sync_request,
    build_yield_book_rest_request_get_scen_calc_sys_scen_async_request,
    build_yield_book_rest_request_get_scen_calc_sys_scen_sync_request,
    build_yield_book_rest_request_historical_data_async_request,
    build_yield_book_rest_request_historical_data_sync_request,
    build_yield_book_rest_request_index_catalogue_info_async_request,
    build_yield_book_rest_request_index_catalogue_info_sync_request,
    build_yield_book_rest_request_index_data_by_ticker_async_request,
    build_yield_book_rest_request_index_data_by_ticker_sync_request,
    build_yield_book_rest_request_index_providers_async_request,
    build_yield_book_rest_request_index_providers_sync_request,
    build_yield_book_rest_request_mbs_history_async_request,
    build_yield_book_rest_request_mbs_history_sync_request,
    build_yield_book_rest_request_mortgage_model_async_request,
    build_yield_book_rest_request_mortgage_model_sync_request,
    build_yield_book_rest_request_py_calculation_async_by_id_request,
    build_yield_book_rest_request_py_calculation_async_request,
    build_yield_book_rest_request_py_calculation_sync_by_id_request,
    build_yield_book_rest_request_py_calculation_sync_request,
    build_yield_book_rest_request_return_attribution_async_request,
    build_yield_book_rest_request_return_attribution_sync_request,
    build_yield_book_rest_request_scenario_calculation_async_request,
    build_yield_book_rest_request_scenario_calculation_sync_request,
    build_yield_book_rest_request_volatility_async_request,
    build_yield_book_rest_request_volatility_sync_request,
    build_yield_book_rest_request_wal_sensitivity_asyn_get_request,
    build_yield_book_rest_request_wal_sensitivity_async_request,
    build_yield_book_rest_request_wal_sensitivity_sync_get_request,
    build_yield_book_rest_request_wal_sensitivity_sync_request,
    build_yield_book_rest_resubmit_job_request,
    build_yield_book_rest_upload_csv_job_data_async_request,
    build_yield_book_rest_upload_csv_job_data_sync_request,
    build_yield_book_rest_upload_csv_job_data_with_name_async_request,
    build_yield_book_rest_upload_csv_job_data_with_name_sync_request,
    build_yield_book_rest_upload_json_job_data_async_request,
    build_yield_book_rest_upload_json_job_data_sync_request,
    build_yield_book_rest_upload_json_job_data_with_name_async_request,
    build_yield_book_rest_upload_json_job_data_with_name_sync_request,
    build_yield_book_rest_upload_text_job_data_async_request,
    build_yield_book_rest_upload_text_job_data_sync_request,
    build_yield_book_rest_upload_text_job_data_with_name_async_request,
    build_yield_book_rest_upload_text_job_data_with_name_sync_request,
)
from .._configuration import AnalyticsAPIClientConfiguration

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore

if TYPE_CHECKING:
    from ... import _types
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
_Unset: Any = object()
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class calendarsResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`calendars_resource` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        page: Optional[int] = None,
        spaces: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        space_name_sort_order: Optional[Union[str, _models.SortingOrderEnum]] = None,
        tags: Optional[List[str]] = None,
        fields: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.CalendarCollectionResponse:
        """List the resources that exist in the platform.

        List the Calendars existing in the platform (depending on permissions).

        :keyword item_per_page: A parameter used to select the number of items allowed per page. The
         valid range is 1-500. If not provided, 50 will be used. Default value is None.
        :paramtype item_per_page: int
        :keyword page: A parameter used to define the page number to display. Default value is None.
        :paramtype page: int
        :keyword spaces: A parameter used to search for platform resources stored in a given space.
         Space is like a namespace where resources are stored. By default there are two spaces:
         LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space.
         If space is not specified, it will search within all spaces. Default value is None.
        :paramtype spaces: list[str]
        :keyword names: A parameter used to search for platform resources with given names. Default
         value is None.
        :paramtype names: list[str]
        :keyword space_name_sort_order: A parameter used to sort platform resources by name based on a
         defined order. Known values are: "Asc" and "Desc". Default value is None.
        :paramtype space_name_sort_order: str or ~analyticsapi.models.SortingOrderEnum
        :keyword tags: A parameter used to search for platform resources with given tags. Default value
         is None.
        :paramtype tags: list[str]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: CalendarCollectionResponse. The CalendarCollectionResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CalendarCollectionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CalendarCollectionResponse] = kwargs.pop("cls", None)

        _request = build_calendars_resource_list_request(
            item_per_page=item_per_page,
            page=page,
            spaces=spaces,
            names=names,
            space_name_sort_order=space_name_sort_order,
            tags=tags,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CalendarCollectionResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self,
        *,
        location: _models.Location,
        definition: _models.CalendarDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.CalendarResponse:
        """Create a new resource to be saved in the platform.

        Save a new Calendar in the platform.

        :keyword location: Object defining the location of the Calendar in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the Calendar. Required.
        :paramtype definition: ~analyticsapi.models.CalendarDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the Calendar. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CalendarResponse. The CalendarResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CalendarResponse:
        """Create a new resource to be saved in the platform.

        Save a new Calendar in the platform.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CalendarResponse. The CalendarResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CalendarResponse:
        """Create a new resource to be saved in the platform.

        Save a new Calendar in the platform.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CalendarResponse. The CalendarResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.CalendarDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.CalendarResponse:
        """Create a new resource to be saved in the platform.

        Save a new Calendar in the platform.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the Calendar in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the Calendar. Required.
        :paramtype definition: ~analyticsapi.models.CalendarDefinition
        :keyword description: Object defining metadata for the Calendar. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CalendarResponse. The CalendarResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CalendarResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendars_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CalendarResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def generate_holidays(
        self,
        *,
        end_date: datetime.date,
        calendars: List[str],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        start_date: Optional[datetime.date] = None,
        **kwargs: Any,
    ) -> _models.GenerateHolidaysResponse:
        """Gets the holidays for the calendar within a date range. Start and End Dates are included in the
        calculation. Only saved calendars are supported.

        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01). Required.
        :paramtype end_date: ~datetime.date
        :keyword calendars: An array of calendar defining objects for which the calculation should be
         done. Each string being composed of the space and name of a calendar. For example 'LSEG/UKG' is
         the string referencing the 'UKG' calendar stored in the 'LSEG' space. Required.
        :paramtype calendars: list[str]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Default is today. Default value is None.
        :paramtype start_date: ~datetime.date
        :return: GenerateHolidaysResponse. The GenerateHolidaysResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def generate_holidays(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.GenerateHolidaysResponse:
        """Gets the holidays for the calendar within a date range. Start and End Dates are included in the
        calculation. Only saved calendars are supported.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GenerateHolidaysResponse. The GenerateHolidaysResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def generate_holidays(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.GenerateHolidaysResponse:
        """Gets the holidays for the calendar within a date range. Start and End Dates are included in the
        calculation. Only saved calendars are supported.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GenerateHolidaysResponse. The GenerateHolidaysResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def generate_holidays(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        end_date: datetime.date = _Unset,
        calendars: List[str] = _Unset,
        fields: Optional[str] = None,
        start_date: Optional[datetime.date] = None,
        **kwargs: Any,
    ) -> _models.GenerateHolidaysResponse:
        """Gets the holidays for the calendar within a date range. Start and End Dates are included in the
        calculation. Only saved calendars are supported.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01). Required.
        :paramtype end_date: ~datetime.date
        :keyword calendars: An array of calendar defining objects for which the calculation should be
         done. Each string being composed of the space and name of a calendar. For example 'LSEG/UKG' is
         the string referencing the 'UKG' calendar stored in the 'LSEG' space. Required.
        :paramtype calendars: list[str]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Default is today. Default value is None.
        :paramtype start_date: ~datetime.date
        :return: GenerateHolidaysResponse. The GenerateHolidaysResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.GenerateHolidaysResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if end_date is _Unset:
                raise TypeError("missing required argument: end_date")
            if calendars is _Unset:
                raise TypeError("missing required argument: calendars")
            body = {"calendars": calendars, "endDate": end_date, "startDate": start_date}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendars_resource_generate_holidays_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GenerateHolidaysResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def compute_dates(
        self,
        *,
        tenors: List[str],
        calendars: List[str],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        start_date: Optional[datetime.date] = None,
        date_moving_convention: Optional[Union[str, _models.DateMovingConvention]] = None,
        end_of_month_convention: Optional[Union[str, _models.EndOfMonthConvention]] = None,
        **kwargs: Any,
    ) -> _models.ComputeDatesResponse:
        """Computes dates for the calendar according to specified conditions. Start Date is included in
        the calculation. Only saved calendars are supported.

        :keyword tenors: Tenors to be added to startDate to calculate the resultant dates (e.g., 1M,
         1Y).
         A tenor expresses a period of time using a specific syntax. There are two kinds of tenor:


         * Ad-hoc tenors explicitly state the length of time in Days (D), Weeks (W), Months (M) and
         Years (Y).
           For example "1D" for one day, "2W" for two weeks or "3M1D" for three months and a day.
           When mixing units, units must be written in descending order of size (Y > M > W > D).  So,
         5M3D is valid, but 3D5M is not.
         * Common tenors are expressed as letter codes:
         * ON (Overnight) - A one business day period that starts today.
         * TN (Tomorrow-Next) - A one business day period that starts next business day.
         * SPOT (Spot Date) - A period that ends on the spot date.  Date is calculated as trade date
         (today) + days to spot.
         * SN (Spot-Next) - A one business day period that starts at the spot date.
         * SW (Spot-Week) - A one business week period that starts at the spot date. Required.
        :paramtype tenors: list[str]
        :keyword calendars: An array of calendar defining objects for which the calculation should be
         done. Each string being composed of the space and name of a calendar. For example 'LSEG/UKG' is
         the string referencing the 'UKG' calendar stored in the 'LSEG' space. Required.
        :paramtype calendars: list[str]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Default is Today. Default value is None.
        :paramtype start_date: ~datetime.date
        :keyword date_moving_convention: The method to adjust dates to working days. The default value
         is ModifiedFollowing. Known values are: "ModifiedFollowing", "NextBusinessDay",
         "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and "BbswModifiedFollowing". Default
         value is None.
        :paramtype date_moving_convention: str or ~analyticsapi.models.DateMovingConvention
        :keyword end_of_month_convention: Conventions to adjust payment dates when they fall at the end
         of a month. Known values are: "Last", "Same", "Last28", "Same28", and "Same1". Default value is
         None.
        :paramtype end_of_month_convention: str or ~analyticsapi.models.EndOfMonthConvention
        :return: ComputeDatesResponse. The ComputeDatesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def compute_dates(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ComputeDatesResponse:
        """Computes dates for the calendar according to specified conditions. Start Date is included in
        the calculation. Only saved calendars are supported.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ComputeDatesResponse. The ComputeDatesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def compute_dates(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ComputeDatesResponse:
        """Computes dates for the calendar according to specified conditions. Start Date is included in
        the calculation. Only saved calendars are supported.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ComputeDatesResponse. The ComputeDatesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def compute_dates(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        tenors: List[str] = _Unset,
        calendars: List[str] = _Unset,
        fields: Optional[str] = None,
        start_date: Optional[datetime.date] = None,
        date_moving_convention: Optional[Union[str, _models.DateMovingConvention]] = None,
        end_of_month_convention: Optional[Union[str, _models.EndOfMonthConvention]] = None,
        **kwargs: Any,
    ) -> _models.ComputeDatesResponse:
        """Computes dates for the calendar according to specified conditions. Start Date is included in
        the calculation. Only saved calendars are supported.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword tenors: Tenors to be added to startDate to calculate the resultant dates (e.g., 1M,
         1Y).
         A tenor expresses a period of time using a specific syntax. There are two kinds of tenor:


         * Ad-hoc tenors explicitly state the length of time in Days (D), Weeks (W), Months (M) and
         Years (Y).
           For example "1D" for one day, "2W" for two weeks or "3M1D" for three months and a day.
           When mixing units, units must be written in descending order of size (Y > M > W > D).  So,
         5M3D is valid, but 3D5M is not.
         * Common tenors are expressed as letter codes:
         * ON (Overnight) - A one business day period that starts today.
         * TN (Tomorrow-Next) - A one business day period that starts next business day.
         * SPOT (Spot Date) - A period that ends on the spot date.  Date is calculated as trade date
         (today) + days to spot.
         * SN (Spot-Next) - A one business day period that starts at the spot date.
         * SW (Spot-Week) - A one business week period that starts at the spot date. Required.
        :paramtype tenors: list[str]
        :keyword calendars: An array of calendar defining objects for which the calculation should be
         done. Each string being composed of the space and name of a calendar. For example 'LSEG/UKG' is
         the string referencing the 'UKG' calendar stored in the 'LSEG' space. Required.
        :paramtype calendars: list[str]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Default is Today. Default value is None.
        :paramtype start_date: ~datetime.date
        :keyword date_moving_convention: The method to adjust dates to working days. The default value
         is ModifiedFollowing. Known values are: "ModifiedFollowing", "NextBusinessDay",
         "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and "BbswModifiedFollowing". Default
         value is None.
        :paramtype date_moving_convention: str or ~analyticsapi.models.DateMovingConvention
        :keyword end_of_month_convention: Conventions to adjust payment dates when they fall at the end
         of a month. Known values are: "Last", "Same", "Last28", "Same28", and "Same1". Default value is
         None.
        :paramtype end_of_month_convention: str or ~analyticsapi.models.EndOfMonthConvention
        :return: ComputeDatesResponse. The ComputeDatesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ComputeDatesResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if tenors is _Unset:
                raise TypeError("missing required argument: tenors")
            if calendars is _Unset:
                raise TypeError("missing required argument: calendars")
            body = {
                "calendars": calendars,
                "dateMovingConvention": date_moving_convention,
                "endOfMonthConvention": end_of_month_convention,
                "startDate": start_date,
                "tenors": tenors,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendars_resource_compute_dates_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ComputeDatesResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def generate_date_schedule(
        self,
        *,
        frequency: Union[str, _models.Frequency],
        calendars: List[str],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        start_date: Optional[datetime.date] = None,
        end_date: Optional[datetime.date] = None,
        calendar_day_of_month: Optional[int] = None,
        count: Optional[int] = None,
        day_of_week: Optional[Union[str, _models.WeekDay]] = None,
        **kwargs: Any,
    ) -> _models.GenerateDateScheduleResponse:
        """Generates a date schedule for the calendar according to specified conditions. Start and End
        Dates are included in the calculation. Only saved calendars are supported.

        :keyword frequency: The frequency of dates in the schedule which should be generated. Note that
         "Daily" refers to working days only. Known values are: "Daily", "Weekly", "BiWeekly",
         "Monthly", "Quarterly", and "Anually". Required.
        :paramtype frequency: str or ~analyticsapi.models.Frequency
        :keyword calendars: An array of calendar defining objects for which the calculation should be
         done. Each string being composed of the space and name of a calendar. For example 'LSEG/UKG' is
         the string referencing the 'UKG' calendar stored in the 'LSEG' space. Required.
        :paramtype calendars: list[str]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01).
         The start date must be less or equal to the end date.
         Required if endDate is in the past. Default value is None.
        :paramtype start_date: ~datetime.date
        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01).
         If startDate is not specified, endDate is used to define the list of dates from today's date
         to the end date.
         The end date must be greater or equal to the start date.
         Required if count is not specified. Only one of endDate and count can be set at a time.
         Default value is None.
        :paramtype end_date: ~datetime.date
        :keyword calendar_day_of_month: The number of the day of the month. Required if frequency is
         Monthly; do not use otherwise. The minimum value is 1. The maximum value is 31. Default value
         is None.
        :paramtype calendar_day_of_month: int
        :keyword count: The number of dates to be generated,  counting from the start date (or today's
         date if the start day is not set) to the end date.
         It should not have a negative value.
         Required if endDate is not specified. Only one of endDate and count can be set at a time.
         Default value is None.
        :paramtype count: int
        :keyword day_of_week: The day of the week. Required if frequency is Weekly or BiWeekly; do not
         use otherwise. Known values are: "Monday", "Tuesday", "Wednesday", "Thursday", "Friday",
         "Saturday", and "Sunday". Default value is None.
        :paramtype day_of_week: str or ~analyticsapi.models.WeekDay
        :return: GenerateDateScheduleResponse. The GenerateDateScheduleResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def generate_date_schedule(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.GenerateDateScheduleResponse:
        """Generates a date schedule for the calendar according to specified conditions. Start and End
        Dates are included in the calculation. Only saved calendars are supported.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GenerateDateScheduleResponse. The GenerateDateScheduleResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def generate_date_schedule(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.GenerateDateScheduleResponse:
        """Generates a date schedule for the calendar according to specified conditions. Start and End
        Dates are included in the calculation. Only saved calendars are supported.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GenerateDateScheduleResponse. The GenerateDateScheduleResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def generate_date_schedule(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        frequency: Union[str, _models.Frequency] = _Unset,
        calendars: List[str] = _Unset,
        fields: Optional[str] = None,
        start_date: Optional[datetime.date] = None,
        end_date: Optional[datetime.date] = None,
        calendar_day_of_month: Optional[int] = None,
        count: Optional[int] = None,
        day_of_week: Optional[Union[str, _models.WeekDay]] = None,
        **kwargs: Any,
    ) -> _models.GenerateDateScheduleResponse:
        """Generates a date schedule for the calendar according to specified conditions. Start and End
        Dates are included in the calculation. Only saved calendars are supported.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword frequency: The frequency of dates in the schedule which should be generated. Note that
         "Daily" refers to working days only. Known values are: "Daily", "Weekly", "BiWeekly",
         "Monthly", "Quarterly", and "Anually". Required.
        :paramtype frequency: str or ~analyticsapi.models.Frequency
        :keyword calendars: An array of calendar defining objects for which the calculation should be
         done. Each string being composed of the space and name of a calendar. For example 'LSEG/UKG' is
         the string referencing the 'UKG' calendar stored in the 'LSEG' space. Required.
        :paramtype calendars: list[str]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01).
         The start date must be less or equal to the end date.
         Required if endDate is in the past. Default value is None.
        :paramtype start_date: ~datetime.date
        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01).
         If startDate is not specified, endDate is used to define the list of dates from today's date
         to the end date.
         The end date must be greater or equal to the start date.
         Required if count is not specified. Only one of endDate and count can be set at a time.
         Default value is None.
        :paramtype end_date: ~datetime.date
        :keyword calendar_day_of_month: The number of the day of the month. Required if frequency is
         Monthly; do not use otherwise. The minimum value is 1. The maximum value is 31. Default value
         is None.
        :paramtype calendar_day_of_month: int
        :keyword count: The number of dates to be generated,  counting from the start date (or today's
         date if the start day is not set) to the end date.
         It should not have a negative value.
         Required if endDate is not specified. Only one of endDate and count can be set at a time.
         Default value is None.
        :paramtype count: int
        :keyword day_of_week: The day of the week. Required if frequency is Weekly or BiWeekly; do not
         use otherwise. Known values are: "Monday", "Tuesday", "Wednesday", "Thursday", "Friday",
         "Saturday", and "Sunday". Default value is None.
        :paramtype day_of_week: str or ~analyticsapi.models.WeekDay
        :return: GenerateDateScheduleResponse. The GenerateDateScheduleResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.GenerateDateScheduleResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if frequency is _Unset:
                raise TypeError("missing required argument: frequency")
            if calendars is _Unset:
                raise TypeError("missing required argument: calendars")
            body = {
                "calendarDayOfMonth": calendar_day_of_month,
                "calendars": calendars,
                "count": count,
                "dayOfWeek": day_of_week,
                "endDate": end_date,
                "frequency": frequency,
                "startDate": start_date,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendars_resource_generate_date_schedule_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GenerateDateScheduleResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def count_periods(
        self,
        *,
        start_date: datetime.date,
        end_date: datetime.date,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        day_count_basis: Optional[Union[str, _models.DayCountBasis]] = None,
        period_type: Optional[Union[str, _models.PeriodType]] = None,
        calendars: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.CountPeriodsResponse:
        """Counts the time periods that satisfy specified conditions. Note the use of date strings for
        convenience. Start and End Dates are included in the calculation. Only saved calendars are
        supported.

        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Required.
        :paramtype start_date: ~datetime.date
        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01). Required.
        :paramtype end_date: ~datetime.date
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword day_count_basis: The day count basis convention used to calculate the period between
         two dates.
         It is used when periodType is set to Year.
         Each convention defines the number of days between two dates and the year length in days
         (basis) for the period calculation.
         Default is DCB_ACTUAL_ACTUAL. Known values are: "Dcb_30_360", "Dcb_30_360_US",
         "Dcb_30_360_German", "Dcb_30_360_ISDA", "Dcb_30_365_ISDA", "Dcb_30_365_German",
         "Dcb_30_365_Brazil", "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
         "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364", "Dcb_Actual_365", "Dcb_Actual_Actual",
         "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252", "Dcb_Actual_365L",
         "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360", "Dcb_Actual_36525", and
         "Dcb_Actual_365_CanadianConvention". Default value is None.
        :paramtype day_count_basis: str or ~analyticsapi.models.DayCountBasis
        :keyword period_type: The method of the period calculation. Default is Day. Known values are:
         "WorkingDay", "NonWorkingDay", "Day", "Week", "Month", "Quarter", and "Year". Default value is
         None.
        :paramtype period_type: str or ~analyticsapi.models.PeriodType
        :keyword calendars: An array of calendar defining objects for which the calculation should be
         done. Each string being composed of the space and name of a calendar.
         For example 'LSEG/UKG' is the string referencing the 'UKG' calendar stored in the 'LSEG'
         space.
         The calendars parameter is optional only when periodType is "Day" or "Year".
         For a given day to be considered a working day, it must be a working day in all of the
         selected calendars. If it is a non-working day in any of the calendars, it is a non-working
         day. Default value is None.
        :paramtype calendars: list[str]
        :return: CountPeriodsResponse. The CountPeriodsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def count_periods(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CountPeriodsResponse:
        """Counts the time periods that satisfy specified conditions. Note the use of date strings for
        convenience. Start and End Dates are included in the calculation. Only saved calendars are
        supported.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CountPeriodsResponse. The CountPeriodsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def count_periods(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CountPeriodsResponse:
        """Counts the time periods that satisfy specified conditions. Note the use of date strings for
        convenience. Start and End Dates are included in the calculation. Only saved calendars are
        supported.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CountPeriodsResponse. The CountPeriodsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def count_periods(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        start_date: datetime.date = _Unset,
        end_date: datetime.date = _Unset,
        fields: Optional[str] = None,
        day_count_basis: Optional[Union[str, _models.DayCountBasis]] = None,
        period_type: Optional[Union[str, _models.PeriodType]] = None,
        calendars: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.CountPeriodsResponse:
        """Counts the time periods that satisfy specified conditions. Note the use of date strings for
        convenience. Start and End Dates are included in the calculation. Only saved calendars are
        supported.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Required.
        :paramtype start_date: ~datetime.date
        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01). Required.
        :paramtype end_date: ~datetime.date
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword day_count_basis: The day count basis convention used to calculate the period between
         two dates.
         It is used when periodType is set to Year.
         Each convention defines the number of days between two dates and the year length in days
         (basis) for the period calculation.
         Default is DCB_ACTUAL_ACTUAL. Known values are: "Dcb_30_360", "Dcb_30_360_US",
         "Dcb_30_360_German", "Dcb_30_360_ISDA", "Dcb_30_365_ISDA", "Dcb_30_365_German",
         "Dcb_30_365_Brazil", "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
         "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364", "Dcb_Actual_365", "Dcb_Actual_Actual",
         "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252", "Dcb_Actual_365L",
         "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360", "Dcb_Actual_36525", and
         "Dcb_Actual_365_CanadianConvention". Default value is None.
        :paramtype day_count_basis: str or ~analyticsapi.models.DayCountBasis
        :keyword period_type: The method of the period calculation. Default is Day. Known values are:
         "WorkingDay", "NonWorkingDay", "Day", "Week", "Month", "Quarter", and "Year". Default value is
         None.
        :paramtype period_type: str or ~analyticsapi.models.PeriodType
        :keyword calendars: An array of calendar defining objects for which the calculation should be
         done. Each string being composed of the space and name of a calendar.
         For example 'LSEG/UKG' is the string referencing the 'UKG' calendar stored in the 'LSEG'
         space.
         The calendars parameter is optional only when periodType is "Day" or "Year".
         For a given day to be considered a working day, it must be a working day in all of the
         selected calendars. If it is a non-working day in any of the calendars, it is a non-working
         day. Default value is None.
        :paramtype calendars: list[str]
        :return: CountPeriodsResponse. The CountPeriodsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CountPeriodsResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if start_date is _Unset:
                raise TypeError("missing required argument: start_date")
            if end_date is _Unset:
                raise TypeError("missing required argument: end_date")
            body = {
                "calendars": calendars,
                "dayCountBasis": day_count_basis,
                "endDate": end_date,
                "periodType": period_type,
                "startDate": start_date,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendars_resource_count_periods_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CountPeriodsResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class calendarResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`calendar_resource` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def read(self, calendar_id: str, *, fields: Optional[str] = None, **kwargs: Any) -> _models.CalendarResponse:
        """Access a resource that exists in the platform.

        Access a Calendar existing in the platform (read). The Calendar can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param calendar_id: Required.
        :type calendar_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: CalendarResponse. The CalendarResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CalendarResponse] = kwargs.pop("cls", None)

        _request = build_calendar_resource_read_request(
            calendar_id=calendar_id,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CalendarResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def delete(self, calendar_id: str, **kwargs: Any) -> None:
        """Delete a resource that exists in the platform.

        Delete a Calendar that exists in the platform. The Calendar can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param calendar_id: Required.
        :type calendar_id: str
        :return: None
        :rtype: None
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_calendar_resource_delete_request(
            calendar_id=calendar_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def overwrite(
        self,
        calendar_id: str,
        *,
        location: _models.Location,
        definition: _models.CalendarDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.CalendarResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a Calendar that exists in the platform. The Calendar can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param calendar_id: Required.
        :type calendar_id: str
        :keyword location: Object defining the location of the Calendar in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the Calendar. Required.
        :paramtype definition: ~analyticsapi.models.CalendarDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the Calendar. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CalendarResponse. The CalendarResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, calendar_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CalendarResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a Calendar that exists in the platform. The Calendar can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CalendarResponse. The CalendarResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, calendar_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CalendarResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a Calendar that exists in the platform. The Calendar can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CalendarResponse. The CalendarResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def overwrite(
        self,
        calendar_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.CalendarDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.CalendarResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a Calendar that exists in the platform. The Calendar can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the Calendar in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the Calendar. Required.
        :paramtype definition: ~analyticsapi.models.CalendarDefinition
        :keyword description: Object defining metadata for the Calendar. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: CalendarResponse. The CalendarResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CalendarResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CalendarResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendar_resource_overwrite_request(
            calendar_id=calendar_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CalendarResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def generate_holidays(
        self,
        calendar_id: str,
        *,
        end_date: datetime.date,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        start_date: Optional[datetime.date] = None,
        **kwargs: Any,
    ) -> _models.GenerateHolidaysResponse:
        """Gets the holidays for the calendar within a date range. Start and End Dates are included in the
        calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01). Required.
        :paramtype end_date: ~datetime.date
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Default is today. Default value is None.
        :paramtype start_date: ~datetime.date
        :return: GenerateHolidaysResponse. The GenerateHolidaysResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def generate_holidays(
        self,
        calendar_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.GenerateHolidaysResponse:
        """Gets the holidays for the calendar within a date range. Start and End Dates are included in the
        calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GenerateHolidaysResponse. The GenerateHolidaysResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def generate_holidays(
        self,
        calendar_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.GenerateHolidaysResponse:
        """Gets the holidays for the calendar within a date range. Start and End Dates are included in the
        calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GenerateHolidaysResponse. The GenerateHolidaysResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def generate_holidays(
        self,
        calendar_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        end_date: datetime.date = _Unset,
        fields: Optional[str] = None,
        start_date: Optional[datetime.date] = None,
        **kwargs: Any,
    ) -> _models.GenerateHolidaysResponse:
        """Gets the holidays for the calendar within a date range. Start and End Dates are included in the
        calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01). Required.
        :paramtype end_date: ~datetime.date
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Default is today. Default value is None.
        :paramtype start_date: ~datetime.date
        :return: GenerateHolidaysResponse. The GenerateHolidaysResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.GenerateHolidaysResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.GenerateHolidaysResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if end_date is _Unset:
                raise TypeError("missing required argument: end_date")
            body = {"endDate": end_date, "startDate": start_date}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendar_resource_generate_holidays_request(
            calendar_id=calendar_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GenerateHolidaysResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def compute_dates(
        self,
        calendar_id: str,
        *,
        tenors: List[str],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        start_date: Optional[datetime.date] = None,
        date_moving_convention: Optional[Union[str, _models.DateMovingConvention]] = None,
        end_of_month_convention: Optional[Union[str, _models.EndOfMonthConvention]] = None,
        **kwargs: Any,
    ) -> _models.ComputeDatesResponse:
        """Computes dates for the calendar according to specified conditions. Start Date is included in
        the calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :keyword tenors: Tenors to be added to startDate to calculate the resultant dates (e.g., 1M,
         1Y).
         A tenor expresses a period of time using a specific syntax. There are two kinds of tenor:


         * Ad-hoc tenors explicitly state the length of time in Days (D), Weeks (W), Months (M) and
         Years (Y).
           For example "1D" for one day, "2W" for two weeks or "3M1D" for three months and a day.
           When mixing units, units must be written in descending order of size (Y > M > W > D).  So,
         5M3D is valid, but 3D5M is not.
         * Common tenors are expressed as letter codes:
         * ON (Overnight) - A one business day period that starts today.
         * TN (Tomorrow-Next) - A one business day period that starts next business day.
         * SPOT (Spot Date) - A period that ends on the spot date.  Date is calculated as trade date
         (today) + days to spot.
         * SN (Spot-Next) - A one business day period that starts at the spot date.
         * SW (Spot-Week) - A one business week period that starts at the spot date. Required.
        :paramtype tenors: list[str]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Default is Today. Default value is None.
        :paramtype start_date: ~datetime.date
        :keyword date_moving_convention: The method to adjust dates to working days. The default value
         is ModifiedFollowing. Known values are: "ModifiedFollowing", "NextBusinessDay",
         "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and "BbswModifiedFollowing". Default
         value is None.
        :paramtype date_moving_convention: str or ~analyticsapi.models.DateMovingConvention
        :keyword end_of_month_convention: Conventions to adjust payment dates when they fall at the end
         of a month. Known values are: "Last", "Same", "Last28", "Same28", and "Same1". Default value is
         None.
        :paramtype end_of_month_convention: str or ~analyticsapi.models.EndOfMonthConvention
        :return: ComputeDatesResponse. The ComputeDatesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def compute_dates(
        self,
        calendar_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ComputeDatesResponse:
        """Computes dates for the calendar according to specified conditions. Start Date is included in
        the calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ComputeDatesResponse. The ComputeDatesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def compute_dates(
        self,
        calendar_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ComputeDatesResponse:
        """Computes dates for the calendar according to specified conditions. Start Date is included in
        the calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ComputeDatesResponse. The ComputeDatesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def compute_dates(
        self,
        calendar_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        tenors: List[str] = _Unset,
        fields: Optional[str] = None,
        start_date: Optional[datetime.date] = None,
        date_moving_convention: Optional[Union[str, _models.DateMovingConvention]] = None,
        end_of_month_convention: Optional[Union[str, _models.EndOfMonthConvention]] = None,
        **kwargs: Any,
    ) -> _models.ComputeDatesResponse:
        """Computes dates for the calendar according to specified conditions. Start Date is included in
        the calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword tenors: Tenors to be added to startDate to calculate the resultant dates (e.g., 1M,
         1Y).
         A tenor expresses a period of time using a specific syntax. There are two kinds of tenor:


         * Ad-hoc tenors explicitly state the length of time in Days (D), Weeks (W), Months (M) and
         Years (Y).
           For example "1D" for one day, "2W" for two weeks or "3M1D" for three months and a day.
           When mixing units, units must be written in descending order of size (Y > M > W > D).  So,
         5M3D is valid, but 3D5M is not.
         * Common tenors are expressed as letter codes:
         * ON (Overnight) - A one business day period that starts today.
         * TN (Tomorrow-Next) - A one business day period that starts next business day.
         * SPOT (Spot Date) - A period that ends on the spot date.  Date is calculated as trade date
         (today) + days to spot.
         * SN (Spot-Next) - A one business day period that starts at the spot date.
         * SW (Spot-Week) - A one business week period that starts at the spot date. Required.
        :paramtype tenors: list[str]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Default is Today. Default value is None.
        :paramtype start_date: ~datetime.date
        :keyword date_moving_convention: The method to adjust dates to working days. The default value
         is ModifiedFollowing. Known values are: "ModifiedFollowing", "NextBusinessDay",
         "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and "BbswModifiedFollowing". Default
         value is None.
        :paramtype date_moving_convention: str or ~analyticsapi.models.DateMovingConvention
        :keyword end_of_month_convention: Conventions to adjust payment dates when they fall at the end
         of a month. Known values are: "Last", "Same", "Last28", "Same28", and "Same1". Default value is
         None.
        :paramtype end_of_month_convention: str or ~analyticsapi.models.EndOfMonthConvention
        :return: ComputeDatesResponse. The ComputeDatesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ComputeDatesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ComputeDatesResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if tenors is _Unset:
                raise TypeError("missing required argument: tenors")
            body = {
                "dateMovingConvention": date_moving_convention,
                "endOfMonthConvention": end_of_month_convention,
                "startDate": start_date,
                "tenors": tenors,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendar_resource_compute_dates_request(
            calendar_id=calendar_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ComputeDatesResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def generate_date_schedule(
        self,
        calendar_id: str,
        *,
        frequency: Union[str, _models.Frequency],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        start_date: Optional[datetime.date] = None,
        end_date: Optional[datetime.date] = None,
        calendar_day_of_month: Optional[int] = None,
        count: Optional[int] = None,
        day_of_week: Optional[Union[str, _models.WeekDay]] = None,
        **kwargs: Any,
    ) -> _models.GenerateDateScheduleResponse:
        """Generates a date schedule for the calendar according to specified conditions. Start and End
        Dates are included in the calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :keyword frequency: The frequency of dates in the schedule which should be generated. Note that
         "Daily" refers to working days only. Known values are: "Daily", "Weekly", "BiWeekly",
         "Monthly", "Quarterly", and "Anually". Required.
        :paramtype frequency: str or ~analyticsapi.models.Frequency
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01).
         The start date must be less or equal to the end date.
         Required if endDate is in the past. Default value is None.
        :paramtype start_date: ~datetime.date
        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01).
         If startDate is not specified, endDate is used to define the list of dates from today's date
         to the end date.
         The end date must be greater or equal to the start date.
         Required if count is not specified. Only one of endDate and count can be set at a time.
         Default value is None.
        :paramtype end_date: ~datetime.date
        :keyword calendar_day_of_month: The number of the day of the month. Required if frequency is
         Monthly; do not use otherwise. The minimum value is 1. The maximum value is 31. Default value
         is None.
        :paramtype calendar_day_of_month: int
        :keyword count: The number of dates to be generated,  counting from the start date (or today's
         date if the start day is not set) to the end date.
         It should not have a negative value.
         Required if endDate is not specified. Only one of endDate and count can be set at a time.
         Default value is None.
        :paramtype count: int
        :keyword day_of_week: The day of the week. Required if frequency is Weekly or BiWeekly; do not
         use otherwise. Known values are: "Monday", "Tuesday", "Wednesday", "Thursday", "Friday",
         "Saturday", and "Sunday". Default value is None.
        :paramtype day_of_week: str or ~analyticsapi.models.WeekDay
        :return: GenerateDateScheduleResponse. The GenerateDateScheduleResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def generate_date_schedule(
        self,
        calendar_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.GenerateDateScheduleResponse:
        """Generates a date schedule for the calendar according to specified conditions. Start and End
        Dates are included in the calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GenerateDateScheduleResponse. The GenerateDateScheduleResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def generate_date_schedule(
        self,
        calendar_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.GenerateDateScheduleResponse:
        """Generates a date schedule for the calendar according to specified conditions. Start and End
        Dates are included in the calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GenerateDateScheduleResponse. The GenerateDateScheduleResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def generate_date_schedule(
        self,
        calendar_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        frequency: Union[str, _models.Frequency] = _Unset,
        fields: Optional[str] = None,
        start_date: Optional[datetime.date] = None,
        end_date: Optional[datetime.date] = None,
        calendar_day_of_month: Optional[int] = None,
        count: Optional[int] = None,
        day_of_week: Optional[Union[str, _models.WeekDay]] = None,
        **kwargs: Any,
    ) -> _models.GenerateDateScheduleResponse:
        """Generates a date schedule for the calendar according to specified conditions. Start and End
        Dates are included in the calculation. Only saved calendars are supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword frequency: The frequency of dates in the schedule which should be generated. Note that
         "Daily" refers to working days only. Known values are: "Daily", "Weekly", "BiWeekly",
         "Monthly", "Quarterly", and "Anually". Required.
        :paramtype frequency: str or ~analyticsapi.models.Frequency
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01).
         The start date must be less or equal to the end date.
         Required if endDate is in the past. Default value is None.
        :paramtype start_date: ~datetime.date
        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01).
         If startDate is not specified, endDate is used to define the list of dates from today's date
         to the end date.
         The end date must be greater or equal to the start date.
         Required if count is not specified. Only one of endDate and count can be set at a time.
         Default value is None.
        :paramtype end_date: ~datetime.date
        :keyword calendar_day_of_month: The number of the day of the month. Required if frequency is
         Monthly; do not use otherwise. The minimum value is 1. The maximum value is 31. Default value
         is None.
        :paramtype calendar_day_of_month: int
        :keyword count: The number of dates to be generated,  counting from the start date (or today's
         date if the start day is not set) to the end date.
         It should not have a negative value.
         Required if endDate is not specified. Only one of endDate and count can be set at a time.
         Default value is None.
        :paramtype count: int
        :keyword day_of_week: The day of the week. Required if frequency is Weekly or BiWeekly; do not
         use otherwise. Known values are: "Monday", "Tuesday", "Wednesday", "Thursday", "Friday",
         "Saturday", and "Sunday". Default value is None.
        :paramtype day_of_week: str or ~analyticsapi.models.WeekDay
        :return: GenerateDateScheduleResponse. The GenerateDateScheduleResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.GenerateDateScheduleResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.GenerateDateScheduleResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if frequency is _Unset:
                raise TypeError("missing required argument: frequency")
            body = {
                "calendarDayOfMonth": calendar_day_of_month,
                "count": count,
                "dayOfWeek": day_of_week,
                "endDate": end_date,
                "frequency": frequency,
                "startDate": start_date,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendar_resource_generate_date_schedule_request(
            calendar_id=calendar_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GenerateDateScheduleResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def count_periods(
        self,
        calendar_id: str,
        *,
        start_date: datetime.date,
        end_date: datetime.date,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        day_count_basis: Optional[Union[str, _models.DayCountBasis]] = None,
        period_type: Optional[Union[str, _models.PeriodType]] = None,
        **kwargs: Any,
    ) -> _models.CountPeriodsResponse:
        """Counts the time periods that satisfy specified conditions. Note the use of date strings for
        convenience. Start and End Dates are included in the calculation. Only saved calendars are
        supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Required.
        :paramtype start_date: ~datetime.date
        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01). Required.
        :paramtype end_date: ~datetime.date
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword day_count_basis: The day count basis convention used to calculate the period between
         two dates.
         It is used when periodType is set to Year.
         Each convention defines the number of days between two dates and the year length in days
         (basis) for the period calculation.
         Default is DCB_ACTUAL_ACTUAL. Known values are: "Dcb_30_360", "Dcb_30_360_US",
         "Dcb_30_360_German", "Dcb_30_360_ISDA", "Dcb_30_365_ISDA", "Dcb_30_365_German",
         "Dcb_30_365_Brazil", "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
         "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364", "Dcb_Actual_365", "Dcb_Actual_Actual",
         "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252", "Dcb_Actual_365L",
         "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360", "Dcb_Actual_36525", and
         "Dcb_Actual_365_CanadianConvention". Default value is None.
        :paramtype day_count_basis: str or ~analyticsapi.models.DayCountBasis
        :keyword period_type: The method of the period calculation. Default is Day. Known values are:
         "WorkingDay", "NonWorkingDay", "Day", "Week", "Month", "Quarter", and "Year". Default value is
         None.
        :paramtype period_type: str or ~analyticsapi.models.PeriodType
        :return: CountPeriodsResponse. The CountPeriodsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def count_periods(
        self,
        calendar_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.CountPeriodsResponse:
        """Counts the time periods that satisfy specified conditions. Note the use of date strings for
        convenience. Start and End Dates are included in the calculation. Only saved calendars are
        supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CountPeriodsResponse. The CountPeriodsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def count_periods(
        self,
        calendar_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.CountPeriodsResponse:
        """Counts the time periods that satisfy specified conditions. Note the use of date strings for
        convenience. Start and End Dates are included in the calculation. Only saved calendars are
        supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CountPeriodsResponse. The CountPeriodsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def count_periods(
        self,
        calendar_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        start_date: datetime.date = _Unset,
        end_date: datetime.date = _Unset,
        fields: Optional[str] = None,
        day_count_basis: Optional[Union[str, _models.DayCountBasis]] = None,
        period_type: Optional[Union[str, _models.PeriodType]] = None,
        **kwargs: Any,
    ) -> _models.CountPeriodsResponse:
        """Counts the time periods that satisfy specified conditions. Note the use of date strings for
        convenience. Start and End Dates are included in the calculation. Only saved calendars are
        supported.

        :param calendar_id: Required.
        :type calendar_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword start_date: The start date of the calculation. The value is expressed in ISO 8601
         format: YYYY-MM-DD (e.g., 2023-01-01). Required.
        :paramtype start_date: ~datetime.date
        :keyword end_date: The end date of the calculation. The value is expressed in ISO 8601 format:
         YYYY-MM-DD (e.g., 2024-01-01). Required.
        :paramtype end_date: ~datetime.date
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword day_count_basis: The day count basis convention used to calculate the period between
         two dates.
         It is used when periodType is set to Year.
         Each convention defines the number of days between two dates and the year length in days
         (basis) for the period calculation.
         Default is DCB_ACTUAL_ACTUAL. Known values are: "Dcb_30_360", "Dcb_30_360_US",
         "Dcb_30_360_German", "Dcb_30_360_ISDA", "Dcb_30_365_ISDA", "Dcb_30_365_German",
         "Dcb_30_365_Brazil", "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
         "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364", "Dcb_Actual_365", "Dcb_Actual_Actual",
         "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252", "Dcb_Actual_365L",
         "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360", "Dcb_Actual_36525", and
         "Dcb_Actual_365_CanadianConvention". Default value is None.
        :paramtype day_count_basis: str or ~analyticsapi.models.DayCountBasis
        :keyword period_type: The method of the period calculation. Default is Day. Known values are:
         "WorkingDay", "NonWorkingDay", "Day", "Week", "Month", "Quarter", and "Year". Default value is
         None.
        :paramtype period_type: str or ~analyticsapi.models.PeriodType
        :return: CountPeriodsResponse. The CountPeriodsResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CountPeriodsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CountPeriodsResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if start_date is _Unset:
                raise TypeError("missing required argument: start_date")
            if end_date is _Unset:
                raise TypeError("missing required argument: end_date")
            body = {
                "dayCountBasis": day_count_basis,
                "endDate": end_date,
                "periodType": period_type,
                "startDate": start_date,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_calendar_resource_count_periods_request(
            calendar_id=calendar_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CountPeriodsResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class fxForwardCurvesResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`fx_forward_curves_resource` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        page: Optional[int] = None,
        spaces: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        space_name_sort_order: Optional[Union[str, _models.SortingOrderEnum]] = None,
        tags: Optional[List[str]] = None,
        fields: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.FxForwardCurveCollectionResponse:
        """List the resources that exist in the platform.

        List the FxForwardCurves existing in the platform (depending on permissions).

        :keyword item_per_page: A parameter used to select the number of items allowed per page. The
         valid range is 1-500. If not provided, 50 will be used. Default value is None.
        :paramtype item_per_page: int
        :keyword page: A parameter used to define the page number to display. Default value is None.
        :paramtype page: int
        :keyword spaces: A parameter used to search for platform resources stored in a given space.
         Space is like a namespace where resources are stored. By default there are two spaces:
         LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space.
         If space is not specified, it will search within all spaces. Default value is None.
        :paramtype spaces: list[str]
        :keyword names: A parameter used to search for platform resources with given names. Default
         value is None.
        :paramtype names: list[str]
        :keyword space_name_sort_order: A parameter used to sort platform resources by name based on a
         defined order. Known values are: "Asc" and "Desc". Default value is None.
        :paramtype space_name_sort_order: str or ~analyticsapi.models.SortingOrderEnum
        :keyword tags: A parameter used to search for platform resources with given tags. Default value
         is None.
        :paramtype tags: list[str]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: FxForwardCurveCollectionResponse. The FxForwardCurveCollectionResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCollectionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FxForwardCurveCollectionResponse] = kwargs.pop("cls", None)

        _request = build_fx_forward_curves_resource_list_request(
            item_per_page=item_per_page,
            page=page,
            spaces=spaces,
            names=names,
            space_name_sort_order=space_name_sort_order,
            tags=tags,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxForwardCurveCollectionResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self,
        *,
        location: _models.Location,
        definition: _models.FxForwardCurveDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.FxForwardCurveResponse:
        """Create a new resource to be saved in the platform.

        Save a new FxForwardCurve in the platform.

        :keyword location: Object defining the location of the FxForwardCurve in the platform.
         Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the FxForwardCurve. Required.
        :paramtype definition: ~analyticsapi.models.FxForwardCurveDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the FxForwardCurve. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardCurveResponse. The FxForwardCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxForwardCurveResponse:
        """Create a new resource to be saved in the platform.

        Save a new FxForwardCurve in the platform.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardCurveResponse. The FxForwardCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxForwardCurveResponse:
        """Create a new resource to be saved in the platform.

        Save a new FxForwardCurve in the platform.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardCurveResponse. The FxForwardCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.FxForwardCurveDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.FxForwardCurveResponse:
        """Create a new resource to be saved in the platform.

        Save a new FxForwardCurve in the platform.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the FxForwardCurve in the platform.
         Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the FxForwardCurve. Required.
        :paramtype definition: ~analyticsapi.models.FxForwardCurveDefinition
        :keyword description: Object defining metadata for the FxForwardCurve. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardCurveResponse. The FxForwardCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FxForwardCurveResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curves_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxForwardCurveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def build_from_fx_forwards(
        self,
        *,
        cross_currency: str,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        reference_currency: Optional[str] = None,
        additional_tenor_types: Optional[List[Union[str, _models.TenorType]]] = None,
        sources: Optional[_models.IndirectSourcesSwaps] = None,
        **kwargs: Any,
    ) -> _models.BuildResponse:
        """The request used to build a curve from FxSpot and FxForward constituents when the
        cross-currency quotation can be derived via a reference currency.
        For example, if a reference currency is specified, available constituents are returned for each
        currency in the pair against the reference (e.g., EURGBP via EURUSD and GBPUSD).
        If the reference currency is one of the pair, only constituents for that pair are returned; if
        not specified, the first currency of the pair is used as the reference.
        The output tenors depend on the construction path; by default, market-contributed tenors are
        returned.

        :keyword cross_currency: A string to define the cross currency pair of the curve, expressed in
         ISO 4217 alphabetical format (e.g., 'EURCHF'). Maximum of 6 characters. Required.
        :paramtype cross_currency: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword reference_currency: A string to define the reference currency for the cross-currency
         pair of the curve, expressed in ISO 4217 alphabetical format (e.g., 'EUR'). Maximum of 3
         characters. Default is the base currency of the specified cross currency pair. Default value is
         None.
        :paramtype reference_currency: str
        :keyword additional_tenor_types: An array of tenor types that can be used for instruments, in
         addition to the standard tenor. When passing a string value, it must be one of the TenorType
         types. Default value is None.
        :paramtype additional_tenor_types: list[str or ~analyticsapi.models.TenorType]
        :keyword sources: An object that defines the sources containing the market data for the
         instruments used to create the curve definition. It will return from all the accessible sources
         if not specified. Default value is None.
        :paramtype sources: ~analyticsapi.models.IndirectSourcesSwaps
        :return: BuildResponse. The BuildResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def build_from_fx_forwards(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.BuildResponse:
        """The request used to build a curve from FxSpot and FxForward constituents when the
        cross-currency quotation can be derived via a reference currency.
        For example, if a reference currency is specified, available constituents are returned for each
        currency in the pair against the reference (e.g., EURGBP via EURUSD and GBPUSD).
        If the reference currency is one of the pair, only constituents for that pair are returned; if
        not specified, the first currency of the pair is used as the reference.
        The output tenors depend on the construction path; by default, market-contributed tenors are
        returned.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BuildResponse. The BuildResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def build_from_fx_forwards(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.BuildResponse:
        """The request used to build a curve from FxSpot and FxForward constituents when the
        cross-currency quotation can be derived via a reference currency.
        For example, if a reference currency is specified, available constituents are returned for each
        currency in the pair against the reference (e.g., EURGBP via EURUSD and GBPUSD).
        If the reference currency is one of the pair, only constituents for that pair are returned; if
        not specified, the first currency of the pair is used as the reference.
        The output tenors depend on the construction path; by default, market-contributed tenors are
        returned.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BuildResponse. The BuildResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def build_from_fx_forwards(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        cross_currency: str = _Unset,
        fields: Optional[str] = None,
        reference_currency: Optional[str] = None,
        additional_tenor_types: Optional[List[Union[str, _models.TenorType]]] = None,
        sources: Optional[_models.IndirectSourcesSwaps] = None,
        **kwargs: Any,
    ) -> _models.BuildResponse:
        """The request used to build a curve from FxSpot and FxForward constituents when the
        cross-currency quotation can be derived via a reference currency.
        For example, if a reference currency is specified, available constituents are returned for each
        currency in the pair against the reference (e.g., EURGBP via EURUSD and GBPUSD).
        If the reference currency is one of the pair, only constituents for that pair are returned; if
        not specified, the first currency of the pair is used as the reference.
        The output tenors depend on the construction path; by default, market-contributed tenors are
        returned.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword cross_currency: A string to define the cross currency pair of the curve, expressed in
         ISO 4217 alphabetical format (e.g., 'EURCHF'). Maximum of 6 characters. Required.
        :paramtype cross_currency: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword reference_currency: A string to define the reference currency for the cross-currency
         pair of the curve, expressed in ISO 4217 alphabetical format (e.g., 'EUR'). Maximum of 3
         characters. Default is the base currency of the specified cross currency pair. Default value is
         None.
        :paramtype reference_currency: str
        :keyword additional_tenor_types: An array of tenor types that can be used for instruments, in
         addition to the standard tenor. When passing a string value, it must be one of the TenorType
         types. Default value is None.
        :paramtype additional_tenor_types: list[str or ~analyticsapi.models.TenorType]
        :keyword sources: An object that defines the sources containing the market data for the
         instruments used to create the curve definition. It will return from all the accessible sources
         if not specified. Default value is None.
        :paramtype sources: ~analyticsapi.models.IndirectSourcesSwaps
        :return: BuildResponse. The BuildResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.BuildResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if cross_currency is _Unset:
                raise TypeError("missing required argument: cross_currency")
            body = {
                "additionalTenorTypes": additional_tenor_types,
                "crossCurrency": cross_currency,
                "referenceCurrency": reference_currency,
                "sources": sources,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curves_resource_build_from_fx_forwards_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.BuildResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def build_from_deposits(
        self,
        *,
        cross_currency: str,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        reference_currency: Optional[str] = None,
        additional_tenor_types: Optional[List[Union[str, _models.TenorType]]] = None,
        sources: Optional[_models.IndirectSourcesDeposits] = None,
        **kwargs: Any,
    ) -> _models.BuildResponse:
        """The request used to build a curve from FxSpot and Deposit constituents when the cross-currency
        quotation can be derived via a reference currency.
        For example, if a reference currency is specified, available FxSpot constituents are returned
        for each currency in the pair against the reference (e.g., EURGBP via EURUSD and GBPUSD).
        If the reference currency is one of the pair, only constituents for that pair are returned; if
        not specified, the first currency of the pair is used as the reference.
        Available Deposit constituents are returned for each currency of the pair.
        The output tenors depend on the construction path; by default, market-contributed tenors are
        returned.

        :keyword cross_currency: A string to define the cross currency pair of the curve, expressed in
         ISO 4217 alphabetical format (e.g., 'EURCHF'). Maximum of 6 characters. Required.
        :paramtype cross_currency: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword reference_currency: A string to define the reference currency for the cross-currency
         pair of the curve, expressed in ISO 4217 alphabetical format (e.g., 'EUR'). Maximum of 3
         characters. Default is the base currency of the specified cross currency pair. Default value is
         None.
        :paramtype reference_currency: str
        :keyword additional_tenor_types: An array of tenor types that can be used for instruments, in
         addition to the standard tenor. When passing a string value, it must be one of the TenorType
         values. Default value is None.
        :paramtype additional_tenor_types: list[str or ~analyticsapi.models.TenorType]
        :keyword sources: An object that defines the sources containing the market data for the
         instruments used to create the curve definition. Default value is None.
        :paramtype sources: ~analyticsapi.models.IndirectSourcesDeposits
        :return: BuildResponse. The BuildResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def build_from_deposits(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.BuildResponse:
        """The request used to build a curve from FxSpot and Deposit constituents when the cross-currency
        quotation can be derived via a reference currency.
        For example, if a reference currency is specified, available FxSpot constituents are returned
        for each currency in the pair against the reference (e.g., EURGBP via EURUSD and GBPUSD).
        If the reference currency is one of the pair, only constituents for that pair are returned; if
        not specified, the first currency of the pair is used as the reference.
        Available Deposit constituents are returned for each currency of the pair.
        The output tenors depend on the construction path; by default, market-contributed tenors are
        returned.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BuildResponse. The BuildResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def build_from_deposits(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.BuildResponse:
        """The request used to build a curve from FxSpot and Deposit constituents when the cross-currency
        quotation can be derived via a reference currency.
        For example, if a reference currency is specified, available FxSpot constituents are returned
        for each currency in the pair against the reference (e.g., EURGBP via EURUSD and GBPUSD).
        If the reference currency is one of the pair, only constituents for that pair are returned; if
        not specified, the first currency of the pair is used as the reference.
        Available Deposit constituents are returned for each currency of the pair.
        The output tenors depend on the construction path; by default, market-contributed tenors are
        returned.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BuildResponse. The BuildResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def build_from_deposits(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        cross_currency: str = _Unset,
        fields: Optional[str] = None,
        reference_currency: Optional[str] = None,
        additional_tenor_types: Optional[List[Union[str, _models.TenorType]]] = None,
        sources: Optional[_models.IndirectSourcesDeposits] = None,
        **kwargs: Any,
    ) -> _models.BuildResponse:
        """The request used to build a curve from FxSpot and Deposit constituents when the cross-currency
        quotation can be derived via a reference currency.
        For example, if a reference currency is specified, available FxSpot constituents are returned
        for each currency in the pair against the reference (e.g., EURGBP via EURUSD and GBPUSD).
        If the reference currency is one of the pair, only constituents for that pair are returned; if
        not specified, the first currency of the pair is used as the reference.
        Available Deposit constituents are returned for each currency of the pair.
        The output tenors depend on the construction path; by default, market-contributed tenors are
        returned.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword cross_currency: A string to define the cross currency pair of the curve, expressed in
         ISO 4217 alphabetical format (e.g., 'EURCHF'). Maximum of 6 characters. Required.
        :paramtype cross_currency: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword reference_currency: A string to define the reference currency for the cross-currency
         pair of the curve, expressed in ISO 4217 alphabetical format (e.g., 'EUR'). Maximum of 3
         characters. Default is the base currency of the specified cross currency pair. Default value is
         None.
        :paramtype reference_currency: str
        :keyword additional_tenor_types: An array of tenor types that can be used for instruments, in
         addition to the standard tenor. When passing a string value, it must be one of the TenorType
         values. Default value is None.
        :paramtype additional_tenor_types: list[str or ~analyticsapi.models.TenorType]
        :keyword sources: An object that defines the sources containing the market data for the
         instruments used to create the curve definition. Default value is None.
        :paramtype sources: ~analyticsapi.models.IndirectSourcesDeposits
        :return: BuildResponse. The BuildResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BuildResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.BuildResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if cross_currency is _Unset:
                raise TypeError("missing required argument: cross_currency")
            body = {
                "additionalTenorTypes": additional_tenor_types,
                "crossCurrency": cross_currency,
                "referenceCurrency": reference_currency,
                "sources": sources,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curves_resource_build_from_deposits_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.BuildResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def calculate(
        self,
        *,
        definitions: List[_models.FxForwardCurveDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.FxForwardCurveCalculationParameters] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxForwardCurveCalculateArrayResponse:
        """Calculate curve points from a custom definition - on the fly.
        The user can override a reference currency, constituents and calculation preferences.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.FxForwardCurveDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxForwardCurveCalculationParameters
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxForwardCurveCalculateArrayResponse. The FxForwardCurveCalculateArrayResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateArrayResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxForwardCurveCalculateArrayResponse:
        """Calculate curve points from a custom definition - on the fly.
        The user can override a reference currency, constituents and calculation preferences.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardCurveCalculateArrayResponse. The FxForwardCurveCalculateArrayResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateArrayResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxForwardCurveCalculateArrayResponse:
        """Calculate curve points from a custom definition - on the fly.
        The user can override a reference currency, constituents and calculation preferences.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardCurveCalculateArrayResponse. The FxForwardCurveCalculateArrayResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateArrayResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def calculate(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.FxForwardCurveDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.FxForwardCurveCalculationParameters] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxForwardCurveCalculateArrayResponse:
        """Calculate curve points from a custom definition - on the fly.
        The user can override a reference currency, constituents and calculation preferences.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.FxForwardCurveDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxForwardCurveCalculationParameters
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxForwardCurveCalculateArrayResponse. The FxForwardCurveCalculateArrayResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateArrayResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FxForwardCurveCalculateArrayResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curves_resource_calculate_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxForwardCurveCalculateArrayResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class fxForwardCurveResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`fx_forward_curve_resource` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def read(
        self, curve_id: str, *, fields: Optional[str] = None, **kwargs: Any
    ) -> _models.FxForwardCurveResponse:
        """Access a resource that exists in the platform.

        Access a FxForwardCurve existing in the platform (read). The FxForwardCurve can be identified
        either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: FxForwardCurveResponse. The FxForwardCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FxForwardCurveResponse] = kwargs.pop("cls", None)

        _request = build_fx_forward_curve_resource_read_request(
            curve_id=curve_id,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxForwardCurveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def delete(self, curve_id: str, **kwargs: Any) -> None:
        """Delete a resource that exists in the platform.

        Delete a FxForwardCurve that exists in the platform. The FxForwardCurve can be identified
        either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :return: None
        :rtype: None
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_fx_forward_curve_resource_delete_request(
            curve_id=curve_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def overwrite(
        self,
        curve_id: str,
        *,
        location: _models.Location,
        definition: _models.FxForwardCurveDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.FxForwardCurveResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a FxForwardCurve that exists in the platform. The FxForwardCurve can be identified
        either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :keyword location: Object defining the location of the FxForwardCurve in the platform.
         Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the FxForwardCurve. Required.
        :paramtype definition: ~analyticsapi.models.FxForwardCurveDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the FxForwardCurve. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardCurveResponse. The FxForwardCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, curve_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxForwardCurveResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a FxForwardCurve that exists in the platform. The FxForwardCurve can be identified
        either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardCurveResponse. The FxForwardCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, curve_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxForwardCurveResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a FxForwardCurve that exists in the platform. The FxForwardCurve can be identified
        either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardCurveResponse. The FxForwardCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def overwrite(
        self,
        curve_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.FxForwardCurveDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.FxForwardCurveResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a FxForwardCurve that exists in the platform. The FxForwardCurve can be identified
        either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the FxForwardCurve in the platform.
         Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the FxForwardCurve. Required.
        :paramtype definition: ~analyticsapi.models.FxForwardCurveDefinition
        :keyword description: Object defining metadata for the FxForwardCurve. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardCurveResponse. The FxForwardCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FxForwardCurveResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curve_resource_overwrite_request(
            curve_id=curve_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxForwardCurveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def calculate(
        self,
        curve_id: str,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.FxForwardCurveCalculationParameters] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxForwardCurveCalculateResponse:
        """Calculate points for a curve stored in the platform.
        The user must provide a curve ID to use an available definition. Only calculation preferences
        can be overridden.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxForwardCurveCalculationParameters
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxForwardCurveCalculateResponse. The FxForwardCurveCalculateResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self,
        curve_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.FxForwardCurveCalculateResponse:
        """Calculate points for a curve stored in the platform.
        The user must provide a curve ID to use an available definition. Only calculation preferences
        can be overridden.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardCurveCalculateResponse. The FxForwardCurveCalculateResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self,
        curve_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.FxForwardCurveCalculateResponse:
        """Calculate points for a curve stored in the platform.
        The user must provide a curve ID to use an available definition. Only calculation preferences
        can be overridden.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardCurveCalculateResponse. The FxForwardCurveCalculateResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def calculate(
        self,
        curve_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.FxForwardCurveCalculationParameters] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxForwardCurveCalculateResponse:
        """Calculate points for a curve stored in the platform.
        The user must provide a curve ID to use an available definition. Only calculation preferences
        can be overridden.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxForwardCurveCalculationParameters
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxForwardCurveCalculateResponse. The FxForwardCurveCalculateResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCurveCalculateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FxForwardCurveCalculateResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"pricingPreferences": pricing_preferences, "returnMarketData": return_market_data}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_curve_resource_calculate_request(
            curve_id=curve_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxForwardCurveCalculateResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class fxForwardsResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`fx_forwards_resource` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        page: Optional[int] = None,
        spaces: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        space_name_sort_order: Optional[Union[str, _models.SortingOrderEnum]] = None,
        tags: Optional[List[str]] = None,
        fields: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.FxForwardCollectionResponse:
        """List the resources that exist in the platform.

        List the FxForwards existing in the platform (depending on permissions).

        :keyword item_per_page: A parameter used to select the number of items allowed per page. The
         valid range is 1-500. If not provided, 50 will be used. Default value is None.
        :paramtype item_per_page: int
        :keyword page: A parameter used to define the page number to display. Default value is None.
        :paramtype page: int
        :keyword spaces: A parameter used to search for platform resources stored in a given space.
         Space is like a namespace where resources are stored. By default there are two spaces:
         LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space.
         If space is not specified, it will search within all spaces. Default value is None.
        :paramtype spaces: list[str]
        :keyword names: A parameter used to search for platform resources with given names. Default
         value is None.
        :paramtype names: list[str]
        :keyword space_name_sort_order: A parameter used to sort platform resources by name based on a
         defined order. Known values are: "Asc" and "Desc". Default value is None.
        :paramtype space_name_sort_order: str or ~analyticsapi.models.SortingOrderEnum
        :keyword tags: A parameter used to search for platform resources with given tags. Default value
         is None.
        :paramtype tags: list[str]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: FxForwardCollectionResponse. The FxForwardCollectionResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardCollectionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FxForwardCollectionResponse] = kwargs.pop("cls", None)

        _request = build_fx_forwards_resource_list_request(
            item_per_page=item_per_page,
            page=page,
            spaces=spaces,
            names=names,
            space_name_sort_order=space_name_sort_order,
            tags=tags,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxForwardCollectionResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self,
        *,
        location: _models.Location,
        definition: _models.FxForwardDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.FxForwardResponse:
        """Create a new resource to be saved in the platform.

        Save a new FxForward in the platform.

        :keyword location: Object defining the location of the FxForward in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the FxForward. Required.
        :paramtype definition: ~analyticsapi.models.FxForwardDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the FxForward. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardResponse. The FxForwardResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxForwardResponse:
        """Create a new resource to be saved in the platform.

        Save a new FxForward in the platform.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardResponse. The FxForwardResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxForwardResponse:
        """Create a new resource to be saved in the platform.

        Save a new FxForward in the platform.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardResponse. The FxForwardResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.FxForwardDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.FxForwardResponse:
        """Create a new resource to be saved in the platform.

        Save a new FxForward in the platform.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the FxForward in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the FxForward. Required.
        :paramtype definition: ~analyticsapi.models.FxForwardDefinition
        :keyword description: Object defining metadata for the FxForward. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardResponse. The FxForwardResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FxForwardResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forwards_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxForwardResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def price(
        self,
        *,
        definitions: List[_models.FxForwardDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.FxPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxForwardArrayPriceResponse:
        """Pricing FxForwards by providing their definitions.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.FxForwardDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxForwardArrayPriceResponse. The FxForwardArrayPriceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardArrayPriceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxForwardArrayPriceResponse:
        """Pricing FxForwards by providing their definitions.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardArrayPriceResponse. The FxForwardArrayPriceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardArrayPriceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxForwardArrayPriceResponse:
        """Pricing FxForwards by providing their definitions.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardArrayPriceResponse. The FxForwardArrayPriceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardArrayPriceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def price(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.FxForwardDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.FxPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxForwardArrayPriceResponse:
        """Pricing FxForwards by providing their definitions.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.FxForwardDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxForwardArrayPriceResponse. The FxForwardArrayPriceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardArrayPriceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FxForwardArrayPriceResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forwards_resource_price_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxForwardArrayPriceResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def value(
        self,
        *,
        definitions: List[_models.FxForwardDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.FxPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxForwardArrayValuationResponse:
        """Valuing FxForwards by providing their definitions.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.FxForwardDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxForwardArrayValuationResponse. The FxForwardArrayValuationResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxForwardArrayValuationResponse:
        """Valuing FxForwards by providing their definitions.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardArrayValuationResponse. The FxForwardArrayValuationResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxForwardArrayValuationResponse:
        """Valuing FxForwards by providing their definitions.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardArrayValuationResponse. The FxForwardArrayValuationResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def value(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.FxForwardDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.FxPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxForwardArrayValuationResponse:
        """Valuing FxForwards by providing their definitions.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.FxForwardDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxForwardArrayValuationResponse. The FxForwardArrayValuationResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FxForwardArrayValuationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forwards_resource_value_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxForwardArrayValuationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def build_fx_forward_from_template(
        self,
        *,
        reference: str,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        overrides: Optional[_models.FxForwardOverride] = None,
        **kwargs: Any,
    ) -> _models.FxForwardFromTemplateResponse:
        """Creating FxForwards from an existing template and a set of overrides.

        :keyword reference: The reference to the Fx Forward template. Required.
        :paramtype reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword overrides: The object that contains the overridden properties. Default value is None.
        :paramtype overrides: ~analyticsapi.models.FxForwardOverride
        :return: FxForwardFromTemplateResponse. The FxForwardFromTemplateResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardFromTemplateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def build_fx_forward_from_template(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxForwardFromTemplateResponse:
        """Creating FxForwards from an existing template and a set of overrides.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardFromTemplateResponse. The FxForwardFromTemplateResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardFromTemplateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def build_fx_forward_from_template(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxForwardFromTemplateResponse:
        """Creating FxForwards from an existing template and a set of overrides.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardFromTemplateResponse. The FxForwardFromTemplateResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardFromTemplateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def build_fx_forward_from_template(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        reference: str = _Unset,
        fields: Optional[str] = None,
        overrides: Optional[_models.FxForwardOverride] = None,
        **kwargs: Any,
    ) -> _models.FxForwardFromTemplateResponse:
        """Creating FxForwards from an existing template and a set of overrides.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword reference: The reference to the Fx Forward template. Required.
        :paramtype reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword overrides: The object that contains the overridden properties. Default value is None.
        :paramtype overrides: ~analyticsapi.models.FxForwardOverride
        :return: FxForwardFromTemplateResponse. The FxForwardFromTemplateResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardFromTemplateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FxForwardFromTemplateResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if reference is _Unset:
                raise TypeError("missing required argument: reference")
            body = {"overrides": overrides, "reference": reference}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forwards_resource_build_fx_forward_from_template_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxForwardFromTemplateResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class fxForwardResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`fx_forward_resource` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def read(
        self, instrument_id: str, *, fields: Optional[str] = None, **kwargs: Any
    ) -> _models.FxForwardResponse:
        """Access a resource that exists in the platform.

        Access a FxForward existing in the platform (read). The FxForward can be identified either by
        its unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: FxForwardResponse. The FxForwardResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FxForwardResponse] = kwargs.pop("cls", None)

        _request = build_fx_forward_resource_read_request(
            instrument_id=instrument_id,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxForwardResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def delete(self, instrument_id: str, **kwargs: Any) -> None:
        """Delete a resource that exists in the platform.

        Delete a FxForward that exists in the platform. The FxForward can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :return: None
        :rtype: None
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_fx_forward_resource_delete_request(
            instrument_id=instrument_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def overwrite(
        self,
        instrument_id: str,
        *,
        location: _models.Location,
        definition: _models.FxForwardDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.FxForwardResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a FxForward that exists in the platform. The FxForward can be identified either by
        its unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword location: Object defining the location of the FxForward in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the FxForward. Required.
        :paramtype definition: ~analyticsapi.models.FxForwardDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the FxForward. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardResponse. The FxForwardResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxForwardResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a FxForward that exists in the platform. The FxForward can be identified either by
        its unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardResponse. The FxForwardResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxForwardResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a FxForward that exists in the platform. The FxForward can be identified either by
        its unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardResponse. The FxForwardResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def overwrite(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.FxForwardDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.FxForwardResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a FxForward that exists in the platform. The FxForward can be identified either by
        its unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the FxForward in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the FxForward. Required.
        :paramtype definition: ~analyticsapi.models.FxForwardDefinition
        :keyword description: Object defining metadata for the FxForward. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxForwardResponse. The FxForwardResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FxForwardResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_resource_overwrite_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxForwardResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def price(
        self,
        instrument_id: str,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.FxPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxForwardPriceResponse:
        """Pricing a FxForward existing in the platform (FxForward must be saved or loaded beforehand).
        Currently, only NextBusinessDay is supported for the date moving convention in the start date
        or end date.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxForwardPriceResponse. The FxForwardPriceResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardPriceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self,
        instrument_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.FxForwardPriceResponse:
        """Pricing a FxForward existing in the platform (FxForward must be saved or loaded beforehand).
        Currently, only NextBusinessDay is supported for the date moving convention in the start date
        or end date.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardPriceResponse. The FxForwardPriceResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardPriceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self,
        instrument_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.FxForwardPriceResponse:
        """Pricing a FxForward existing in the platform (FxForward must be saved or loaded beforehand).
        Currently, only NextBusinessDay is supported for the date moving convention in the start date
        or end date.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardPriceResponse. The FxForwardPriceResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardPriceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def price(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.FxPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxForwardPriceResponse:
        """Pricing a FxForward existing in the platform (FxForward must be saved or loaded beforehand).
        Currently, only NextBusinessDay is supported for the date moving convention in the start date
        or end date.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxForwardPriceResponse. The FxForwardPriceResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxForwardPriceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FxForwardPriceResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_resource_price_request(
            instrument_id=instrument_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxForwardPriceResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def value(
        self,
        instrument_id: str,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.FxPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxForwardValuationResponse:
        """Valuing a FxForward existing in the platform (FxForward must be saved or loaded beforehand).
        Currently, only NextBusinessDay is supported for the date moving convention in the start date
        or end date.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxForwardValuationResponse. The FxForwardValuationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self,
        instrument_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.FxForwardValuationResponse:
        """Valuing a FxForward existing in the platform (FxForward must be saved or loaded beforehand).
        Currently, only NextBusinessDay is supported for the date moving convention in the start date
        or end date.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardValuationResponse. The FxForwardValuationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self,
        instrument_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.FxForwardValuationResponse:
        """Valuing a FxForward existing in the platform (FxForward must be saved or loaded beforehand).
        Currently, only NextBusinessDay is supported for the date moving convention in the start date
        or end date.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxForwardValuationResponse. The FxForwardValuationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def value(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.FxPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxForwardValuationResponse:
        """Valuing a FxForward existing in the platform (FxForward must be saved or loaded beforehand).
        Currently, only NextBusinessDay is supported for the date moving convention in the start date
        or end date.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxForwardValuationResponse. The FxForwardValuationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxForwardValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FxForwardValuationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_forward_resource_value_request(
            instrument_id=instrument_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxForwardValuationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class fxSpotsResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`fx_spots_resource` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        page: Optional[int] = None,
        spaces: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        space_name_sort_order: Optional[Union[str, _models.SortingOrderEnum]] = None,
        tags: Optional[List[str]] = None,
        fields: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.FxSpotCollectionResponse:
        """List the resources that exist in the platform.

        List the FxSpots existing in the platform (depending on permissions).

        :keyword item_per_page: A parameter used to select the number of items allowed per page. The
         valid range is 1-500. If not provided, 50 will be used. Default value is None.
        :paramtype item_per_page: int
        :keyword page: A parameter used to define the page number to display. Default value is None.
        :paramtype page: int
        :keyword spaces: A parameter used to search for platform resources stored in a given space.
         Space is like a namespace where resources are stored. By default there are two spaces:
         LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space.
         If space is not specified, it will search within all spaces. Default value is None.
        :paramtype spaces: list[str]
        :keyword names: A parameter used to search for platform resources with given names. Default
         value is None.
        :paramtype names: list[str]
        :keyword space_name_sort_order: A parameter used to sort platform resources by name based on a
         defined order. Known values are: "Asc" and "Desc". Default value is None.
        :paramtype space_name_sort_order: str or ~analyticsapi.models.SortingOrderEnum
        :keyword tags: A parameter used to search for platform resources with given tags. Default value
         is None.
        :paramtype tags: list[str]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: FxSpotCollectionResponse. The FxSpotCollectionResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotCollectionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FxSpotCollectionResponse] = kwargs.pop("cls", None)

        _request = build_fx_spots_resource_list_request(
            item_per_page=item_per_page,
            page=page,
            spaces=spaces,
            names=names,
            space_name_sort_order=space_name_sort_order,
            tags=tags,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxSpotCollectionResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self,
        *,
        location: _models.Location,
        definition: _models.FxSpotDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.FxSpotResponse:
        """Create a new resource to be saved in the platform.

        Save a new FxSpot in the platform.

        :keyword location: Object defining the location of the FxSpot in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the FxSpot. Required.
        :paramtype definition: ~analyticsapi.models.FxSpotDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the FxSpot. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxSpotResponse. The FxSpotResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxSpotResponse:
        """Create a new resource to be saved in the platform.

        Save a new FxSpot in the platform.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotResponse. The FxSpotResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxSpotResponse:
        """Create a new resource to be saved in the platform.

        Save a new FxSpot in the platform.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotResponse. The FxSpotResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.FxSpotDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.FxSpotResponse:
        """Create a new resource to be saved in the platform.

        Save a new FxSpot in the platform.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the FxSpot in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the FxSpot. Required.
        :paramtype definition: ~analyticsapi.models.FxSpotDefinition
        :keyword description: Object defining metadata for the FxSpot. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxSpotResponse. The FxSpotResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FxSpotResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spots_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxSpotResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def price(
        self,
        *,
        definitions: List[_models.FxSpotDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.FxPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxSpotArrayPriceResponse:
        """Pricing FxSpots by providing their definitions.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.FxSpotDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxSpotArrayPriceResponse. The FxSpotArrayPriceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotArrayPriceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxSpotArrayPriceResponse:
        """Pricing FxSpots by providing their definitions.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotArrayPriceResponse. The FxSpotArrayPriceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotArrayPriceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxSpotArrayPriceResponse:
        """Pricing FxSpots by providing their definitions.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotArrayPriceResponse. The FxSpotArrayPriceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotArrayPriceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def price(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.FxSpotDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.FxPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxSpotArrayPriceResponse:
        """Pricing FxSpots by providing their definitions.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.FxSpotDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxSpotArrayPriceResponse. The FxSpotArrayPriceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotArrayPriceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FxSpotArrayPriceResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spots_resource_price_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxSpotArrayPriceResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def value(
        self,
        *,
        definitions: List[_models.FxSpotDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.FxPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxSpotArrayValuationResponse:
        """Valuing FxSpots by providing their definitions.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.FxSpotDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxSpotArrayValuationResponse. The FxSpotArrayValuationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxSpotArrayValuationResponse:
        """Valuing FxSpots by providing their definitions.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotArrayValuationResponse. The FxSpotArrayValuationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxSpotArrayValuationResponse:
        """Valuing FxSpots by providing their definitions.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotArrayValuationResponse. The FxSpotArrayValuationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def value(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.FxSpotDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.FxPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxSpotArrayValuationResponse:
        """Valuing FxSpots by providing their definitions.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.FxSpotDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxSpotArrayValuationResponse. The FxSpotArrayValuationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FxSpotArrayValuationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spots_resource_value_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxSpotArrayValuationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def build_fx_spot_from_template(
        self,
        *,
        reference: str,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        overrides: Optional[_models.FxSpotOverride] = None,
        **kwargs: Any,
    ) -> _models.FxSpotFromTemplateResponse:
        """Creating FxSpots from an existing template and a set of overrides.

        :keyword reference: The reference to the Fx Spot template. Required.
        :paramtype reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword overrides: The object that contains the overridden properties. Default value is None.
        :paramtype overrides: ~analyticsapi.models.FxSpotOverride
        :return: FxSpotFromTemplateResponse. The FxSpotFromTemplateResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotFromTemplateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def build_fx_spot_from_template(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxSpotFromTemplateResponse:
        """Creating FxSpots from an existing template and a set of overrides.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotFromTemplateResponse. The FxSpotFromTemplateResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotFromTemplateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def build_fx_spot_from_template(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxSpotFromTemplateResponse:
        """Creating FxSpots from an existing template and a set of overrides.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotFromTemplateResponse. The FxSpotFromTemplateResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotFromTemplateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def build_fx_spot_from_template(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        reference: str = _Unset,
        fields: Optional[str] = None,
        overrides: Optional[_models.FxSpotOverride] = None,
        **kwargs: Any,
    ) -> _models.FxSpotFromTemplateResponse:
        """Creating FxSpots from an existing template and a set of overrides.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword reference: The reference to the Fx Spot template. Required.
        :paramtype reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword overrides: The object that contains the overridden properties. Default value is None.
        :paramtype overrides: ~analyticsapi.models.FxSpotOverride
        :return: FxSpotFromTemplateResponse. The FxSpotFromTemplateResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FxSpotFromTemplateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FxSpotFromTemplateResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if reference is _Unset:
                raise TypeError("missing required argument: reference")
            body = {"overrides": overrides, "reference": reference}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spots_resource_build_fx_spot_from_template_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxSpotFromTemplateResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class fxSpotResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`fx_spot_resource` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def read(self, instrument_id: str, *, fields: Optional[str] = None, **kwargs: Any) -> _models.FxSpotResponse:
        """Access a resource that exists in the platform.

        Access a FxSpot existing in the platform (read). The FxSpot can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: FxSpotResponse. The FxSpotResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FxSpotResponse] = kwargs.pop("cls", None)

        _request = build_fx_spot_resource_read_request(
            instrument_id=instrument_id,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxSpotResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def delete(self, instrument_id: str, **kwargs: Any) -> None:
        """Delete a resource that exists in the platform.

        Delete a FxSpot that exists in the platform. The FxSpot can be identified either by its unique
        ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :return: None
        :rtype: None
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_fx_spot_resource_delete_request(
            instrument_id=instrument_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def overwrite(
        self,
        instrument_id: str,
        *,
        location: _models.Location,
        definition: _models.FxSpotDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.FxSpotResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a FxSpot that exists in the platform. The FxSpot can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword location: Object defining the location of the FxSpot in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the FxSpot. Required.
        :paramtype definition: ~analyticsapi.models.FxSpotDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the FxSpot. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxSpotResponse. The FxSpotResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxSpotResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a FxSpot that exists in the platform. The FxSpot can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotResponse. The FxSpotResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FxSpotResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a FxSpot that exists in the platform. The FxSpot can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotResponse. The FxSpotResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def overwrite(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.FxSpotDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.FxSpotResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a FxSpot that exists in the platform. The FxSpot can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the FxSpot in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the FxSpot. Required.
        :paramtype definition: ~analyticsapi.models.FxSpotDefinition
        :keyword description: Object defining metadata for the FxSpot. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FxSpotResponse. The FxSpotResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FxSpotResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spot_resource_overwrite_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxSpotResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def price(
        self,
        instrument_id: str,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.FxPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxSpotPriceResponse:
        """Pricing a FxForward existing on the platform (FxSpot must be saved or loaded beforehand).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxSpotPriceResponse. The FxSpotPriceResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotPriceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self,
        instrument_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.FxSpotPriceResponse:
        """Pricing a FxForward existing on the platform (FxSpot must be saved or loaded beforehand).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotPriceResponse. The FxSpotPriceResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotPriceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self,
        instrument_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.FxSpotPriceResponse:
        """Pricing a FxForward existing on the platform (FxSpot must be saved or loaded beforehand).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotPriceResponse. The FxSpotPriceResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotPriceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def price(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.FxPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxSpotPriceResponse:
        """Pricing a FxForward existing on the platform (FxSpot must be saved or loaded beforehand).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxSpotPriceResponse. The FxSpotPriceResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotPriceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FxSpotPriceResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spot_resource_price_request(
            instrument_id=instrument_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxSpotPriceResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def value(
        self,
        instrument_id: str,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.FxPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxSpotValuationResponse:
        """Valuing a FxForward existing on the platform (FxSpot must be saved or loaded beforehand).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxSpotValuationResponse. The FxSpotValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self,
        instrument_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.FxSpotValuationResponse:
        """Valuing a FxForward existing on the platform (FxSpot must be saved or loaded beforehand).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotValuationResponse. The FxSpotValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self,
        instrument_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.FxSpotValuationResponse:
        """Valuing a FxForward existing on the platform (FxSpot must be saved or loaded beforehand).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FxSpotValuationResponse. The FxSpotValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def value(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.FxPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.FxSpotValuationResponse:
        """Valuing a FxForward existing on the platform (FxSpot must be saved or loaded beforehand).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.FxPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: FxSpotValuationResponse. The FxSpotValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.FxSpotValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FxSpotValuationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_spot_resource_value_request(
            instrument_id=instrument_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FxSpotValuationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class YieldBookRestOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`yield_book_rest` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def request_bond_indic_sync(
        self,
        body: _models.BondIndicRequest,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.MappedResponseRefData:
        """Request Bond Indic Sync data via Post.

        Synchronous Post method to retrieve the contractual information about the reference data of
        instruments, which will typically not need any further calculations. Retrieve instrument
        reference data given a BondIndicRequest - 'Input' - parameter that includes the information of
        which security or list of securities to be queried by CUSIP, ISIN, or other identifier type to
        obtain basic contractual information in the MappedResponseRefData such as security type,
        sector,  maturity, credit ratings, coupon, and specific information based on security type like
        current pool factor if the requested identifier is a mortgage. Recommended and preferred method
        for single or low-volume instrument queries (up to 50-70 per request, 250 max).

        :param body: Required.
        :type body: ~analyticsapi.models.BondIndicRequest
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MappedResponseRefData. The MappedResponseRefData is compatible with MutableMapping
        :rtype: ~analyticsapi.models.MappedResponseRefData
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_bond_indic_sync(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.MappedResponseRefData:
        """Request Bond Indic Sync data via Post.

        Synchronous Post method to retrieve the contractual information about the reference data of
        instruments, which will typically not need any further calculations. Retrieve instrument
        reference data given a BondIndicRequest - 'Input' - parameter that includes the information of
        which security or list of securities to be queried by CUSIP, ISIN, or other identifier type to
        obtain basic contractual information in the MappedResponseRefData such as security type,
        sector,  maturity, credit ratings, coupon, and specific information based on security type like
        current pool factor if the requested identifier is a mortgage. Recommended and preferred method
        for single or low-volume instrument queries (up to 50-70 per request, 250 max).

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MappedResponseRefData. The MappedResponseRefData is compatible with MutableMapping
        :rtype: ~analyticsapi.models.MappedResponseRefData
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_bond_indic_sync(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.MappedResponseRefData:
        """Request Bond Indic Sync data via Post.

        Synchronous Post method to retrieve the contractual information about the reference data of
        instruments, which will typically not need any further calculations. Retrieve instrument
        reference data given a BondIndicRequest - 'Input' - parameter that includes the information of
        which security or list of securities to be queried by CUSIP, ISIN, or other identifier type to
        obtain basic contractual information in the MappedResponseRefData such as security type,
        sector,  maturity, credit ratings, coupon, and specific information based on security type like
        current pool factor if the requested identifier is a mortgage. Recommended and preferred method
        for single or low-volume instrument queries (up to 50-70 per request, 250 max).

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MappedResponseRefData. The MappedResponseRefData is compatible with MutableMapping
        :rtype: ~analyticsapi.models.MappedResponseRefData
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def request_bond_indic_sync(
        self,
        body: Union[_models.BondIndicRequest, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.MappedResponseRefData:
        """Request Bond Indic Sync data via Post.

        Synchronous Post method to retrieve the contractual information about the reference data of
        instruments, which will typically not need any further calculations. Retrieve instrument
        reference data given a BondIndicRequest - 'Input' - parameter that includes the information of
        which security or list of securities to be queried by CUSIP, ISIN, or other identifier type to
        obtain basic contractual information in the MappedResponseRefData such as security type,
        sector,  maturity, credit ratings, coupon, and specific information based on security type like
        current pool factor if the requested identifier is a mortgage. Recommended and preferred method
        for single or low-volume instrument queries (up to 50-70 per request, 250 max).

        :param body: Is one of the following types: BondIndicRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.BondIndicRequest or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: MappedResponseRefData. The MappedResponseRefData is compatible with MutableMapping
        :rtype: ~analyticsapi.models.MappedResponseRefData
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MappedResponseRefData] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_request_bond_indic_sync_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.MappedResponseRefData, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def request_bond_indic_async(
        self,
        body: _models.BondIndicRequest,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request Bond Indic Async data via Post.

        Asynchronous Post method to retrieve the contractual information about the reference data of
        instruments, which will typically not need any further calculations. Retrieve a request ID by
        which, using subsequent API 'getResult' endpoint, instrument reference data can be obtained
        given a BondIndicRequest - 'Input' - parameter that includes the information of which security
        or list of securities to be queried by CUSIP, ISIN, or other identifier type to obtain basic
        contractual information such as security type, sector,  maturity, credit ratings, coupon, and
        specific information based on security type like current pool factor if the requested
        identifier is a mortgage. Recommended and preferred method for high-volume instrument queries
        (single requsts broken to recommended 100 items, up to 250 max).

        :param body: Required.
        :type body: ~analyticsapi.models.BondIndicRequest
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_bond_indic_async(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request Bond Indic Async data via Post.

        Asynchronous Post method to retrieve the contractual information about the reference data of
        instruments, which will typically not need any further calculations. Retrieve a request ID by
        which, using subsequent API 'getResult' endpoint, instrument reference data can be obtained
        given a BondIndicRequest - 'Input' - parameter that includes the information of which security
        or list of securities to be queried by CUSIP, ISIN, or other identifier type to obtain basic
        contractual information such as security type, sector,  maturity, credit ratings, coupon, and
        specific information based on security type like current pool factor if the requested
        identifier is a mortgage. Recommended and preferred method for high-volume instrument queries
        (single requsts broken to recommended 100 items, up to 250 max).

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_bond_indic_async(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request Bond Indic Async data via Post.

        Asynchronous Post method to retrieve the contractual information about the reference data of
        instruments, which will typically not need any further calculations. Retrieve a request ID by
        which, using subsequent API 'getResult' endpoint, instrument reference data can be obtained
        given a BondIndicRequest - 'Input' - parameter that includes the information of which security
        or list of securities to be queried by CUSIP, ISIN, or other identifier type to obtain basic
        contractual information such as security type, sector,  maturity, credit ratings, coupon, and
        specific information based on security type like current pool factor if the requested
        identifier is a mortgage. Recommended and preferred method for high-volume instrument queries
        (single requsts broken to recommended 100 items, up to 250 max).

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def request_bond_indic_async(
        self,
        body: Union[_models.BondIndicRequest, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request Bond Indic Async data via Post.

        Asynchronous Post method to retrieve the contractual information about the reference data of
        instruments, which will typically not need any further calculations. Retrieve a request ID by
        which, using subsequent API 'getResult' endpoint, instrument reference data can be obtained
        given a BondIndicRequest - 'Input' - parameter that includes the information of which security
        or list of securities to be queried by CUSIP, ISIN, or other identifier type to obtain basic
        contractual information such as security type, sector,  maturity, credit ratings, coupon, and
        specific information based on security type like current pool factor if the requested
        identifier is a mortgage. Recommended and preferred method for high-volume instrument queries
        (single requsts broken to recommended 100 items, up to 250 max).

        :param body: Is one of the following types: BondIndicRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.BondIndicRequest or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_request_bond_indic_async_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_bond_indic_sync_get(
        self,
        id: str,
        *,
        id_type: Optional[Union[str, _models.IdTypeEnum]] = None,
        keywords: Optional[List[str]] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request Bond Indic Sync data via Get.

        Synchronous Get method to retrieve the contractual information about the reference data of an
        instrument, which will typically not need any further calculations. Retrieve instrument
        reference data given an instrument ID and optionaly an ID type as input parameters to obtain
        basic contractual information in the Record structure with information such as security type,
        sector,  maturity, credit ratings, coupon, and specific information based on security type like
        current pool factor if the requested identifier is a mortgage.

        :param id: Required.
        :type id: str
        :keyword id_type: Known values are: "SecurityIDEntry", "SecurityID", "CUSIP", "ISIN",
         "REGSISIN", "SEDOL", "Identifier", "ChinaInterbankCode", "ShanghaiExchangeCode",
         "ShenzhenExchangeCode", and "MXTickerID". Default value is None.
        :paramtype id_type: str or ~analyticsapi.models.IdTypeEnum
        :keyword keywords: Default value is None.
        :paramtype keywords: list[str]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_bond_indic_sync_get_request(
            id=id,
            id_type=id_type,
            keywords=keywords,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_bond_indic_async_get(
        self,
        id: str,
        *,
        id_type: Optional[Union[str, _models.IdTypeEnum]] = None,
        keywords: Optional[List[str]] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request Bond Indic Async data via Get.

        Asynchronous Get method to retrieve the contractual information about the reference data of
        instruments, which will typically not need any further calculations. Retrieve a request ID by
        which, using subsequent API 'getResult' endpoint, instrument reference data can be obtained
        given a BondIndicRequest - 'Input' - parameter that includes the information of which security
        or list of securities to be queried by CUSIP, ISIN, or other identifier type to obtain basic
        contractual information such as security type, sector,  maturity, credit ratings, coupon, and
        specific information based on security type like current pool factor if the requested
        identifier is a mortgage.

        :param id: Required.
        :type id: str
        :keyword id_type: Known values are: "SecurityIDEntry", "SecurityID", "CUSIP", "ISIN",
         "REGSISIN", "SEDOL", "Identifier", "ChinaInterbankCode", "ShanghaiExchangeCode",
         "ShenzhenExchangeCode", and "MXTickerID". Default value is None.
        :paramtype id_type: str or ~analyticsapi.models.IdTypeEnum
        :keyword keywords: Default value is None.
        :paramtype keywords: list[str]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_bond_indic_async_get_request(
            id=id,
            id_type=id_type,
            keywords=keywords,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_job(
        self, body: _models.JobCreationRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.JobResponse:
        """Create a new job.

        Create a new job.

        :param body: Required.
        :type body: ~analyticsapi.models.JobCreationRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JobResponse. The JobResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.JobResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_job(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.JobResponse:
        """Create a new job.

        Create a new job.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JobResponse. The JobResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.JobResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_job(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.JobResponse:
        """Create a new job.

        Create a new job.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JobResponse. The JobResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.JobResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create_job(
        self, body: Union[_models.JobCreationRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.JobResponse:
        """Create a new job.

        Create a new job.

        :param body: Is one of the following types: JobCreationRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.JobCreationRequest or JSON or IO[bytes]
        :return: JobResponse. The JobResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.JobResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.JobResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_create_job_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.JobResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def resubmit_job(
        self,
        job_ref: str,
        body: _models.JobResubmissionRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.JobResponse:
        """Resubmit a job.

        Resubmit a job.

        :param job_ref: Job reference. This can be of the form J-number or job name. Required.
        :type job_ref: str
        :param body: Required.
        :type body: ~analyticsapi.models.JobResubmissionRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JobResponse. The JobResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.JobResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def resubmit_job(
        self, job_ref: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.JobResponse:
        """Resubmit a job.

        Resubmit a job.

        :param job_ref: Job reference. This can be of the form J-number or job name. Required.
        :type job_ref: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JobResponse. The JobResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.JobResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def resubmit_job(
        self, job_ref: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.JobResponse:
        """Resubmit a job.

        Resubmit a job.

        :param job_ref: Job reference. This can be of the form J-number or job name. Required.
        :type job_ref: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JobResponse. The JobResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.JobResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def resubmit_job(
        self, job_ref: str, body: Union[_models.JobResubmissionRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.JobResponse:
        """Resubmit a job.

        Resubmit a job.

        :param job_ref: Job reference. This can be of the form J-number or job name. Required.
        :type job_ref: str
        :param body: Is one of the following types: JobResubmissionRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.JobResubmissionRequest or JSON or IO[bytes]
        :return: JobResponse. The JobResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.JobResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.JobResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_resubmit_job_request(
            job_ref=job_ref,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.JobResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def close_job(self, job_ref: str, **kwargs: Any) -> _models.JobResponse:
        """Close a job.

        Close a job.

        :param job_ref: Job reference. This can be of the form J-number or job name. Required.
        :type job_ref: str
        :return: JobResponse. The JobResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.JobResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.JobResponse] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_close_job_request(
            job_ref=job_ref,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.JobResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def abort_job(self, job_ref: str, **kwargs: Any) -> _models.JobResponse:
        """Abort a job.

        Abort a job.

        :param job_ref: Job reference. This can be of the form J-number or job name. Required.
        :type job_ref: str
        :return: JobResponse. The JobResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.JobResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.JobResponse] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_abort_job_request(
            job_ref=job_ref,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.JobResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def get_job(self, job_ref: str, **kwargs: Any) -> _models.JobResponse:
        """Get job details.

        Get job details.

        :param job_ref: Job reference. This can be of the form J-number or job name. Required.
        :type job_ref: str
        :return: JobResponse. The JobResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.JobResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.JobResponse] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_get_job_request(
            job_ref=job_ref,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.JobResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def get_job_status(self, job_ref: str, **kwargs: Any) -> _models.JobStatusResponse:
        """Get job status.

        Get job status.

        :param job_ref: Job reference. This can be of the form J-number or job name. Required.
        :type job_ref: str
        :return: JobStatusResponse. The JobStatusResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.JobStatusResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.JobStatusResponse] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_get_job_status_request(
            job_ref=job_ref,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.JobStatusResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def get_result(
        self, request_id_parameter: str, *, job: Optional[str] = None, **kwargs: Any
    ) -> Dict[str, Any]:
        """Retrieve single result using request id or request name.

        :param request_id_parameter: Unique request id. This can be of the format R-number or request
         name. If request name is used, corresponding job information should be passed in the query
         parameter. Required.
        :type request_id_parameter: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_get_result_request(
            request_id_parameter=request_id_parameter,
            job=job,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def get_formatted_result(
        self, request_id_parameter: str, format: str, *, job: Optional[str] = None, **kwargs: Any
    ) -> Any:
        """Retrieve single formatted result using request id or request name.

        :param request_id_parameter: Unique request id. This can be of the format R-number or request
         name. If request name is used, corresponding job information should be passed in the query
         parameter. Required.
        :type request_id_parameter: str
        :param format: Only "html" format supported for now. Required.
        :type format: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :return: any
        :rtype: any
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Any] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_get_formatted_result_request(
            request_id_parameter=request_id_parameter,
            format=format,
            job=job,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Any, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    async def get_csv_bulk_result(
        self, *, ids: List[str], fields: List[str], job: Optional[str] = None, **kwargs: Any
    ) -> str:
        """Retrieve bulk results with multiple request id or request name.

        :keyword ids: Ids can be provided comma separated. Different formats for id are:
           1) RequestId R-number
           2) Request name R:name. In this case also provide jobid (J-number) or jobname (J:name)
           3) Jobid J-number
           4) Job name J:name - only 1 active job with the jobname
           5) Tag name T:name. In this case also provide jobid (J-number) or jobname (J:name).
         Required.
        :paramtype ids: list[str]
        :keyword fields: Required.
        :paramtype fields: list[str]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :return: str
        :rtype: str
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[str] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_get_csv_bulk_result_request(
            ids=ids,
            fields=fields,
            job=job,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(str, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_csv_bulk_results_sync(
        self,
        body: _models.BulkResultRequest,
        *,
        ids: List[str],
        job: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> str:
        """Retrieve bulk result using request id or request name in csv format.

        :param body: Required.
        :type body: ~analyticsapi.models.BulkResultRequest
        :keyword ids: Ids can be provided comma separated. Different formats for id are:
           1) RequestId R-number
           2) Request name R:name. In this case also provide jobid (J-number) or jobname (J:name)
           3) Jobid J-number
           4) Job name J:name - only 1 active job with the jobname
           5) Tag name T:name. In this case also provide jobid (J-number) or jobname (J:name).
         Required.
        :paramtype ids: list[str]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: str
        :rtype: str
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def post_csv_bulk_results_sync(
        self,
        body: JSON,
        *,
        ids: List[str],
        job: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> str:
        """Retrieve bulk result using request id or request name in csv format.

        :param body: Required.
        :type body: JSON
        :keyword ids: Ids can be provided comma separated. Different formats for id are:
           1) RequestId R-number
           2) Request name R:name. In this case also provide jobid (J-number) or jobname (J:name)
           3) Jobid J-number
           4) Job name J:name - only 1 active job with the jobname
           5) Tag name T:name. In this case also provide jobid (J-number) or jobname (J:name).
         Required.
        :paramtype ids: list[str]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: str
        :rtype: str
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def post_csv_bulk_results_sync(
        self,
        body: IO[bytes],
        *,
        ids: List[str],
        job: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> str:
        """Retrieve bulk result using request id or request name in csv format.

        :param body: Required.
        :type body: IO[bytes]
        :keyword ids: Ids can be provided comma separated. Different formats for id are:
           1) RequestId R-number
           2) Request name R:name. In this case also provide jobid (J-number) or jobname (J:name)
           3) Jobid J-number
           4) Job name J:name - only 1 active job with the jobname
           5) Tag name T:name. In this case also provide jobid (J-number) or jobname (J:name).
         Required.
        :paramtype ids: list[str]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: str
        :rtype: str
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def post_csv_bulk_results_sync(
        self,
        body: Union[_models.BulkResultRequest, JSON, IO[bytes]],
        *,
        ids: List[str],
        job: Optional[str] = None,
        **kwargs: Any,
    ) -> str:
        """Retrieve bulk result using request id or request name in csv format.

        :param body: Is one of the following types: BulkResultRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.BulkResultRequest or JSON or IO[bytes]
        :keyword ids: Ids can be provided comma separated. Different formats for id are:
           1) RequestId R-number
           2) Request name R:name. In this case also provide jobid (J-number) or jobname (J:name)
           3) Jobid J-number
           4) Job name J:name - only 1 active job with the jobname
           5) Tag name T:name. In this case also provide jobid (J-number) or jobname (J:name).
         Required.
        :paramtype ids: list[str]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :return: str
        :rtype: str
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[str] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_post_csv_bulk_results_sync_request(
            ids=ids,
            job=job,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(str, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    async def get_json_result(
        self,
        *,
        ids: List[str],
        job: Optional[str] = None,
        fields: Optional[List[str]] = None,
        format: Optional[str] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Retrieve json result using request id or request name.

        :keyword ids: Ids can be provided comma separated. Different formats for id are:
           1) RequestId R-number
           2) Request name R:name. In this case also provide jobid (J-number) or jobname (J:name)
           3) Jobid J-number
           4) Job name J:name - only 1 active job with the jobname
           5) Tag name T:name. In this case also provide jobid (J-number) or jobname (J:name).
         Required.
        :paramtype ids: list[str]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword fields: Default value is None.
        :paramtype fields: list[str]
        :keyword format: Default value is None.
        :paramtype format: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_get_json_result_request(
            ids=ids,
            job=job,
            fields=fields,
            format=format,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_json_bulk_request_sync(
        self,
        body: _models.BulkResultRequest,
        *,
        ids: List[str],
        job: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Retrieve bulk json result using request id or request name.

        :param body: Required.
        :type body: ~analyticsapi.models.BulkResultRequest
        :keyword ids: Ids can be provided comma separated. Different formats for id are:
           1) RequestId R-number
           2) Request name R:name. In this case also provide jobid (J-number) or jobname (J:name)
           3) Jobid J-number
           4) Job name J:name - only 1 active job with the jobname
           5) Tag name T:name. In this case also provide jobid (J-number) or jobname (J:name).
         Required.
        :paramtype ids: list[str]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def post_json_bulk_request_sync(
        self,
        body: JSON,
        *,
        ids: List[str],
        job: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Retrieve bulk json result using request id or request name.

        :param body: Required.
        :type body: JSON
        :keyword ids: Ids can be provided comma separated. Different formats for id are:
           1) RequestId R-number
           2) Request name R:name. In this case also provide jobid (J-number) or jobname (J:name)
           3) Jobid J-number
           4) Job name J:name - only 1 active job with the jobname
           5) Tag name T:name. In this case also provide jobid (J-number) or jobname (J:name).
         Required.
        :paramtype ids: list[str]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def post_json_bulk_request_sync(
        self,
        body: IO[bytes],
        *,
        ids: List[str],
        job: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Retrieve bulk json result using request id or request name.

        :param body: Required.
        :type body: IO[bytes]
        :keyword ids: Ids can be provided comma separated. Different formats for id are:
           1) RequestId R-number
           2) Request name R:name. In this case also provide jobid (J-number) or jobname (J:name)
           3) Jobid J-number
           4) Job name J:name - only 1 active job with the jobname
           5) Tag name T:name. In this case also provide jobid (J-number) or jobname (J:name).
         Required.
        :paramtype ids: list[str]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def post_json_bulk_request_sync(
        self,
        body: Union[_models.BulkResultRequest, JSON, IO[bytes]],
        *,
        ids: List[str],
        job: Optional[str] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Retrieve bulk json result using request id or request name.

        :param body: Is one of the following types: BulkResultRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.BulkResultRequest or JSON or IO[bytes]
        :keyword ids: Ids can be provided comma separated. Different formats for id are:
           1) RequestId R-number
           2) Request name R:name. In this case also provide jobid (J-number) or jobname (J:name)
           3) Jobid J-number
           4) Job name J:name - only 1 active job with the jobname
           5) Tag name T:name. In this case also provide jobid (J-number) or jobname (J:name).
         Required.
        :paramtype ids: list[str]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_post_json_bulk_request_sync_request(
            ids=ids,
            job=job,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def upload_csv_job_data_with_name_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: str,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload csv job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "text/csv"))
        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _content = data

        _request = build_yield_book_rest_upload_csv_job_data_with_name_async_request(
            job=job,
            store_type=store_type,
            request_name=request_name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def upload_text_job_data_with_name_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: str,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload text job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "text/plain"))
        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _content = data

        _request = build_yield_book_rest_upload_text_job_data_with_name_async_request(
            job=job,
            store_type=store_type,
            request_name=request_name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def upload_json_job_data_with_name_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: _models.PrepayDialsInput,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload json job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: ~analyticsapi.models.PrepayDialsInput
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_with_name_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: _models.UserCurve,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload json job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: ~analyticsapi.models.UserCurve
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_with_name_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: _models.UserVol,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload json job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: ~analyticsapi.models.UserVol
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_with_name_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: _models.CMOModification,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload json job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: ~analyticsapi.models.CMOModification
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_with_name_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: _models.UserScenarioInput,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload json job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: ~analyticsapi.models.UserScenarioInput
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_with_name_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: _models.DataTable,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload json job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: ~analyticsapi.models.DataTable
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_with_name_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: _models.YBPortUserBond,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload json job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: ~analyticsapi.models.YBPortUserBond
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_with_name_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: _models.UserLoan,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload json job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: ~analyticsapi.models.UserLoan
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def upload_json_job_data_with_name_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: "_types.JobStoreInputData",
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload json job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Is one of the following types: PrepayDialsInput, UserCurve, UserVol,
         CMOModification, UserScenarioInput, DataTable, YBPortUserBond, UserLoan Required.
        :type data: ~analyticsapi.models.PrepayDialsInput or ~analyticsapi.models.UserCurve or
         ~analyticsapi.models.UserVol or ~analyticsapi.models.CMOModification or
         ~analyticsapi.models.UserScenarioInput or ~analyticsapi.models.DataTable or
         ~analyticsapi.models.YBPortUserBond or ~analyticsapi.models.UserLoan
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(data, _models.PrepayDialsInput):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.UserCurve):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.UserVol):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.CMOModification):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.UserScenarioInput):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.DataTable):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.YBPortUserBond):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.UserLoan):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_upload_json_job_data_with_name_async_request(
            job=job,
            store_type=store_type,
            request_name=request_name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def upload_csv_job_data_with_name_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: str,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload csv job with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "text/csv"))
        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _content = data

        _request = build_yield_book_rest_upload_csv_job_data_with_name_sync_request(
            job=job,
            store_type=store_type,
            request_name=request_name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def upload_text_job_data_with_name_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: str,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload text job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "text/plain"))
        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _content = data

        _request = build_yield_book_rest_upload_text_job_data_with_name_sync_request(
            job=job,
            store_type=store_type,
            request_name=request_name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def upload_json_job_data_with_name_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: _models.PrepayDialsInput,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload json job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: ~analyticsapi.models.PrepayDialsInput
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_with_name_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: _models.UserCurve,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload json job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: ~analyticsapi.models.UserCurve
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_with_name_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: _models.UserVol,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload json job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: ~analyticsapi.models.UserVol
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_with_name_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: _models.CMOModification,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload json job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: ~analyticsapi.models.CMOModification
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_with_name_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: _models.UserScenarioInput,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload json job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: ~analyticsapi.models.UserScenarioInput
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_with_name_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: _models.DataTable,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload json job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: ~analyticsapi.models.DataTable
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_with_name_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: _models.YBPortUserBond,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload json job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: ~analyticsapi.models.YBPortUserBond
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_with_name_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: _models.UserLoan,
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload json job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Required.
        :type data: ~analyticsapi.models.UserLoan
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def upload_json_job_data_with_name_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        request_name: str,
        data: "_types.JobStoreInputData",
        *,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload json job data with a user-provided name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: User provided name for the request. Required.
        :type request_name: str
        :param data: Is one of the following types: PrepayDialsInput, UserCurve, UserVol,
         CMOModification, UserScenarioInput, DataTable, YBPortUserBond, UserLoan Required.
        :type data: ~analyticsapi.models.PrepayDialsInput or ~analyticsapi.models.UserCurve or
         ~analyticsapi.models.UserVol or ~analyticsapi.models.CMOModification or
         ~analyticsapi.models.UserScenarioInput or ~analyticsapi.models.DataTable or
         ~analyticsapi.models.YBPortUserBond or ~analyticsapi.models.UserLoan
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(data, _models.PrepayDialsInput):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.UserCurve):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.UserVol):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.CMOModification):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.UserScenarioInput):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.DataTable):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.YBPortUserBond):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.UserLoan):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_upload_json_job_data_with_name_sync_request(
            job=job,
            store_type=store_type,
            request_name=request_name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def upload_csv_job_data_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: str,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload csv job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: str
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "text/csv"))
        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _content = data

        _request = build_yield_book_rest_upload_csv_job_data_async_request(
            job=job,
            store_type=store_type,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def upload_text_job_data_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: str,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload text job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: str
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "text/plain"))
        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _content = data

        _request = build_yield_book_rest_upload_text_job_data_async_request(
            job=job,
            store_type=store_type,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def upload_json_job_data_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: _models.PrepayDialsInput,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload json job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: ~analyticsapi.models.PrepayDialsInput
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: _models.UserCurve,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload json job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: ~analyticsapi.models.UserCurve
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: _models.UserVol,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload json job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: ~analyticsapi.models.UserVol
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: _models.CMOModification,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload json job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: ~analyticsapi.models.CMOModification
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: _models.UserScenarioInput,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload json job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: ~analyticsapi.models.UserScenarioInput
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: _models.DataTable,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload json job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: ~analyticsapi.models.DataTable
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: _models.YBPortUserBond,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload json job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: ~analyticsapi.models.YBPortUserBond
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: _models.UserLoan,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload json job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: ~analyticsapi.models.UserLoan
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def upload_json_job_data_async(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: "_types.JobStoreInputData",
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Async upload json job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Is one of the following types: PrepayDialsInput, UserCurve, UserVol,
         CMOModification, UserScenarioInput, DataTable, YBPortUserBond, UserLoan Required.
        :type data: ~analyticsapi.models.PrepayDialsInput or ~analyticsapi.models.UserCurve or
         ~analyticsapi.models.UserVol or ~analyticsapi.models.CMOModification or
         ~analyticsapi.models.UserScenarioInput or ~analyticsapi.models.DataTable or
         ~analyticsapi.models.YBPortUserBond or ~analyticsapi.models.UserLoan
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(data, _models.PrepayDialsInput):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.UserCurve):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.UserVol):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.CMOModification):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.UserScenarioInput):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.DataTable):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.YBPortUserBond):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.UserLoan):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_upload_json_job_data_async_request(
            job=job,
            store_type=store_type,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def upload_csv_job_data_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: str,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload csv job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: str
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "text/csv"))
        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _content = data

        _request = build_yield_book_rest_upload_csv_job_data_sync_request(
            job=job,
            store_type=store_type,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def upload_text_job_data_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: str,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload text job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: str
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "text/plain"))
        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _content = data

        _request = build_yield_book_rest_upload_text_job_data_sync_request(
            job=job,
            store_type=store_type,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def upload_json_job_data_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: _models.PrepayDialsInput,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload json job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: ~analyticsapi.models.PrepayDialsInput
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: _models.UserCurve,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload json job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: ~analyticsapi.models.UserCurve
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: _models.UserVol,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload json job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: ~analyticsapi.models.UserVol
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: _models.CMOModification,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload json job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: ~analyticsapi.models.CMOModification
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: _models.UserScenarioInput,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload json job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: ~analyticsapi.models.UserScenarioInput
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: _models.DataTable,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload json job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: ~analyticsapi.models.DataTable
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: _models.YBPortUserBond,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload json job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: ~analyticsapi.models.YBPortUserBond
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def upload_json_job_data_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: _models.UserLoan,
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload json job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Required.
        :type data: ~analyticsapi.models.UserLoan
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def upload_json_job_data_sync(
        self,
        job: str,
        store_type: Union[str, _models.StoreType],
        data: "_types.JobStoreInputData",
        *,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Sync upload json job data.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param data: Is one of the following types: PrepayDialsInput, UserCurve, UserVol,
         CMOModification, UserScenarioInput, DataTable, YBPortUserBond, UserLoan Required.
        :type data: ~analyticsapi.models.PrepayDialsInput or ~analyticsapi.models.UserCurve or
         ~analyticsapi.models.UserVol or ~analyticsapi.models.CMOModification or
         ~analyticsapi.models.UserScenarioInput or ~analyticsapi.models.DataTable or
         ~analyticsapi.models.YBPortUserBond or ~analyticsapi.models.UserLoan
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword pri: Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(data, _models.PrepayDialsInput):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.UserCurve):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.UserVol):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.CMOModification):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.UserScenarioInput):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.DataTable):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.YBPortUserBond):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore
        elif isinstance(data, _models.UserLoan):
            _content = json.dumps(data, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_upload_json_job_data_sync_request(
            job=job,
            store_type=store_type,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def get_job_data(
        self, job: str, store_type: Union[str, _models.StoreType], request_name: str, **kwargs: Any
    ) -> Any:
        """Retrieve job data body using request id or request name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_name: Unique request id. This can be of the format R-number or request name. If
         request name is used, corresponding job information should be passed in the query parameter.
         Required.
        :type request_name: str
        :return: any
        :rtype: any
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Any] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_get_job_data_request(
            job=job,
            store_type=store_type,
            request_name=request_name,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Any, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    async def get_job_object_meta(
        self, job: str, store_type: Union[str, _models.StoreType], request_id_parameter: str, **kwargs: Any
    ) -> Dict[str, Any]:
        """Retrieve job object metadata using request id or request name.

        :param job: Job reference. This can be of the form J-number or job name. Required.
        :type job: str
        :param store_type: Job store object type. Should be one of the enumerated types. Known values
         are: "table", "curve", "prepay-dials", "output-format", "vol-surface", "ybport-udi",
         "cmo-modification", "scenario-v1", "currentCouponSpread", and "wholeloan-udd". Required.
        :type store_type: str or ~analyticsapi.models.StoreType
        :param request_id_parameter: Unique request id. This can be of the format R-number or request
         name. If request name is used, corresponding job information should be passed in the query
         parameter. Required.
        :type request_id_parameter: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_get_job_object_meta_request(
            job=job,
            store_type=store_type,
            request_id_parameter=request_id_parameter,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_cash_flow_sync(
        self,
        body: _models.CashFlowRequestData,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Post cash flow sync.

        :param body: Required.
        :type body: ~analyticsapi.models.CashFlowRequestData
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def post_cash_flow_sync(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Post cash flow sync.

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def post_cash_flow_sync(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Post cash flow sync.

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def post_cash_flow_sync(
        self,
        body: Union[_models.CashFlowRequestData, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Post cash flow sync.

        :param body: Is one of the following types: CashFlowRequestData, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.CashFlowRequestData or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_post_cash_flow_sync_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_cash_flow_async(
        self,
        body: _models.CashFlowRequestData,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Post cash flow request async.

        :param body: Required.
        :type body: ~analyticsapi.models.CashFlowRequestData
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def post_cash_flow_async(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Post cash flow request async.

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def post_cash_flow_async(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Post cash flow request async.

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def post_cash_flow_async(
        self,
        body: Union[_models.CashFlowRequestData, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Post cash flow request async.

        :param body: Is one of the following types: CashFlowRequestData, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.CashFlowRequestData or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_post_cash_flow_async_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def get_cash_flow_sync(
        self,
        id: str,
        *,
        id_type: Optional[str] = None,
        pricing_date: Optional[str] = None,
        par_amount: Optional[str] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Get cash flow sync.

        :param id: Security reference ID. Required.
        :type id: str
        :keyword id_type: Default value is None.
        :paramtype id_type: str
        :keyword pricing_date: Default value is None.
        :paramtype pricing_date: str
        :keyword par_amount: Default value is None.
        :paramtype par_amount: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_get_cash_flow_sync_request(
            id=id,
            id_type=id_type,
            pricing_date=pricing_date,
            par_amount=par_amount,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def get_cash_flow_async(
        self,
        id: str,
        *,
        id_type: Optional[str] = None,
        pricing_date: Optional[str] = None,
        par_amount: Optional[str] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Get cash flow request async.

        :param id: Security reference ID. Required.
        :type id: str
        :keyword id_type: Default value is None.
        :paramtype id_type: str
        :keyword pricing_date: Default value is None.
        :paramtype pricing_date: str
        :keyword par_amount: Default value is None.
        :paramtype par_amount: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_get_cash_flow_async_request(
            id=id,
            id_type=id_type,
            pricing_date=pricing_date,
            par_amount=par_amount,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def request_scenario_calculation_sync(
        self,
        body: _models.ScenarioCalcRequest,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request scenario calculation sync.

        :param body: Required.
        :type body: ~analyticsapi.models.ScenarioCalcRequest
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_scenario_calculation_sync(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request scenario calculation sync.

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_scenario_calculation_sync(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request scenario calculation sync.

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def request_scenario_calculation_sync(
        self,
        body: Union[_models.ScenarioCalcRequest, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request scenario calculation sync.

        :param body: Is one of the following types: ScenarioCalcRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.ScenarioCalcRequest or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_request_scenario_calculation_sync_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def request_scenario_calculation_async(
        self,
        body: _models.ScenarioCalcRequest,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request scenario calculation async.

        :param body: Required.
        :type body: ~analyticsapi.models.ScenarioCalcRequest
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_scenario_calculation_async(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request scenario calculation async.

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_scenario_calculation_async(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request scenario calculation async.

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def request_scenario_calculation_async(
        self,
        body: Union[_models.ScenarioCalcRequest, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request scenario calculation async.

        :param body: Is one of the following types: ScenarioCalcRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.ScenarioCalcRequest or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_request_scenario_calculation_async_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_get_scen_calc_sys_scen_sync(
        self,
        id: str,
        *,
        level: str,
        pricing_date: str,
        curve_type: Union[str, _models.YbRestCurveType],
        h_py_method: str,
        scenario: str,
        id_type: Optional[str] = None,
        h_days: Optional[int] = None,
        h_months: Optional[int] = None,
        currency: Optional[str] = None,
        volatility: Optional[str] = None,
        prepay_type: Optional[str] = None,
        prepay_rate: Optional[float] = None,
        h_level: Optional[str] = None,
        h_prepay_rate: Optional[float] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request get scenario calculation system scenario sync.

        :param id: Security reference ID. Required.
        :type id: str
        :keyword level: Required.
        :paramtype level: str
        :keyword pricing_date: Required.
        :paramtype pricing_date: str
        :keyword curve_type: Known values are: "GVT", "GVT_TSYM", "GVT_TSYM_MUNI", "GVT_AGN",
         "GVT_MUNI", "GVT_BUND", "SWAP", "SWAP_RFR", "SWAP_MUNI", and "SWAP_LIB6M". Required.
        :paramtype curve_type: str or ~analyticsapi.models.YbRestCurveType
        :keyword h_py_method: Required.
        :paramtype h_py_method: str
        :keyword scenario: Required.
        :paramtype scenario: str
        :keyword id_type: Default value is None.
        :paramtype id_type: str
        :keyword h_days: Default value is None.
        :paramtype h_days: int
        :keyword h_months: Default value is None.
        :paramtype h_months: int
        :keyword currency: Default value is None.
        :paramtype currency: str
        :keyword volatility: Default value is None.
        :paramtype volatility: str
        :keyword prepay_type: Default value is None.
        :paramtype prepay_type: str
        :keyword prepay_rate: Default value is None.
        :paramtype prepay_rate: float
        :keyword h_level: Default value is None.
        :paramtype h_level: str
        :keyword h_prepay_rate: Default value is None.
        :paramtype h_prepay_rate: float
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_get_scen_calc_sys_scen_sync_request(
            id=id,
            level=level,
            pricing_date=pricing_date,
            curve_type=curve_type,
            h_py_method=h_py_method,
            scenario=scenario,
            id_type=id_type,
            h_days=h_days,
            h_months=h_months,
            currency=currency,
            volatility=volatility,
            prepay_type=prepay_type,
            prepay_rate=prepay_rate,
            h_level=h_level,
            h_prepay_rate=h_prepay_rate,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_get_scen_calc_sys_scen_async(
        self,
        id: str,
        *,
        level: str,
        pricing_date: str,
        curve_type: Union[str, _models.YbRestCurveType],
        h_py_method: str,
        scenario: str,
        id_type: Optional[str] = None,
        h_days: Optional[int] = None,
        h_months: Optional[int] = None,
        currency: Optional[str] = None,
        volatility: Optional[str] = None,
        prepay_type: Optional[str] = None,
        prepay_rate: Optional[float] = None,
        h_level: Optional[str] = None,
        h_prepay_rate: Optional[float] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request get scenario calculation system scenario async.

        :param id: Security reference ID. Required.
        :type id: str
        :keyword level: Required.
        :paramtype level: str
        :keyword pricing_date: Required.
        :paramtype pricing_date: str
        :keyword curve_type: Known values are: "GVT", "GVT_TSYM", "GVT_TSYM_MUNI", "GVT_AGN",
         "GVT_MUNI", "GVT_BUND", "SWAP", "SWAP_RFR", "SWAP_MUNI", and "SWAP_LIB6M". Required.
        :paramtype curve_type: str or ~analyticsapi.models.YbRestCurveType
        :keyword h_py_method: Required.
        :paramtype h_py_method: str
        :keyword scenario: Required.
        :paramtype scenario: str
        :keyword id_type: Default value is None.
        :paramtype id_type: str
        :keyword h_days: Default value is None.
        :paramtype h_days: int
        :keyword h_months: Default value is None.
        :paramtype h_months: int
        :keyword currency: Default value is None.
        :paramtype currency: str
        :keyword volatility: Default value is None.
        :paramtype volatility: str
        :keyword prepay_type: Default value is None.
        :paramtype prepay_type: str
        :keyword prepay_rate: Default value is None.
        :paramtype prepay_rate: float
        :keyword h_level: Default value is None.
        :paramtype h_level: str
        :keyword h_prepay_rate: Default value is None.
        :paramtype h_prepay_rate: float
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_get_scen_calc_sys_scen_async_request(
            id=id,
            level=level,
            pricing_date=pricing_date,
            curve_type=curve_type,
            h_py_method=h_py_method,
            scenario=scenario,
            id_type=id_type,
            h_days=h_days,
            h_months=h_months,
            currency=currency,
            volatility=volatility,
            prepay_type=prepay_type,
            prepay_rate=prepay_rate,
            h_level=h_level,
            h_prepay_rate=h_prepay_rate,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def request_return_attribution_sync(
        self,
        body: _models.ReturnAttributionRequest,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request return attribution sync.

        :param body: Required.
        :type body: ~analyticsapi.models.ReturnAttributionRequest
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_return_attribution_sync(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request return attribution sync.

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_return_attribution_sync(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request return attribution sync.

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def request_return_attribution_sync(
        self,
        body: Union[_models.ReturnAttributionRequest, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request return attribution sync.

        :param body: Is one of the following types: ReturnAttributionRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.ReturnAttributionRequest or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_request_return_attribution_sync_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def request_return_attribution_async(
        self,
        body: _models.ReturnAttributionRequest,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request return attribution async.

        :param body: Required.
        :type body: ~analyticsapi.models.ReturnAttributionRequest
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_return_attribution_async(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request return attribution async.

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_return_attribution_async(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request return attribution async.

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def request_return_attribution_async(
        self,
        body: Union[_models.ReturnAttributionRequest, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request return attribution async.

        :param body: Is one of the following types: ReturnAttributionRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.ReturnAttributionRequest or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_request_return_attribution_async_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def bulk_zip_request(
        self,
        data: bytes,
        *,
        default_target: Optional[str] = None,
        create_job: Optional[bool] = None,
        chain_job: Optional[str] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.ResultResponseBulkResultItem:
        """Bulk zip request.

        :param data: Required.
        :type data: bytes
        :keyword default_target: Default value is None.
        :paramtype default_target: str
        :keyword create_job: Default value is None.
        :paramtype create_job: bool
        :keyword chain_job: Default value is None.
        :paramtype chain_job: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: ResultResponseBulkResultItem. The ResultResponseBulkResultItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ResultResponseBulkResultItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "application/zip"))
        cls: ClsType[_models.ResultResponseBulkResultItem] = kwargs.pop("cls", None)

        _content = data

        _request = build_yield_book_rest_bulk_zip_request_request(
            default_target=default_target,
            create_job=create_job,
            chain_job=chain_job,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ResultResponseBulkResultItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def bulk_compact_request(
        self,
        body: _models.BulkCompact,
        *,
        create_job: Optional[bool] = None,
        chain_job: Optional[str] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ResultResponseBulkResultItem:
        """Bulk compact request.

        :param body: Required.
        :type body: ~analyticsapi.models.BulkCompact
        :keyword create_job: Default value is None.
        :paramtype create_job: bool
        :keyword chain_job: Default value is None.
        :paramtype chain_job: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ResultResponseBulkResultItem. The ResultResponseBulkResultItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ResultResponseBulkResultItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def bulk_compact_request(
        self,
        body: JSON,
        *,
        create_job: Optional[bool] = None,
        chain_job: Optional[str] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ResultResponseBulkResultItem:
        """Bulk compact request.

        :param body: Required.
        :type body: JSON
        :keyword create_job: Default value is None.
        :paramtype create_job: bool
        :keyword chain_job: Default value is None.
        :paramtype chain_job: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ResultResponseBulkResultItem. The ResultResponseBulkResultItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ResultResponseBulkResultItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def bulk_compact_request(
        self,
        body: IO[bytes],
        *,
        create_job: Optional[bool] = None,
        chain_job: Optional[str] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ResultResponseBulkResultItem:
        """Bulk compact request.

        :param body: Required.
        :type body: IO[bytes]
        :keyword create_job: Default value is None.
        :paramtype create_job: bool
        :keyword chain_job: Default value is None.
        :paramtype chain_job: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ResultResponseBulkResultItem. The ResultResponseBulkResultItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ResultResponseBulkResultItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def bulk_compact_request(
        self,
        body: Union[_models.BulkCompact, JSON, IO[bytes]],
        *,
        create_job: Optional[bool] = None,
        chain_job: Optional[str] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.ResultResponseBulkResultItem:
        """Bulk compact request.

        :param body: Is one of the following types: BulkCompact, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.BulkCompact or JSON or IO[bytes]
        :keyword create_job: Default value is None.
        :paramtype create_job: bool
        :keyword chain_job: Default value is None.
        :paramtype chain_job: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: ResultResponseBulkResultItem. The ResultResponseBulkResultItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ResultResponseBulkResultItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[_models.ResultResponseBulkResultItem] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_bulk_compact_request_request(
            create_job=create_job,
            chain_job=chain_job,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ResultResponseBulkResultItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def bulk_composite_request(
        self,
        body: _models.BulkComposite,
        *,
        create_job: Optional[bool] = None,
        chain_job: Optional[str] = None,
        partial: Optional[bool] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ResultResponseBulkResultItem:
        """Bulk composite request.

        :param body: Required.
        :type body: ~analyticsapi.models.BulkComposite
        :keyword create_job: Default value is None.
        :paramtype create_job: bool
        :keyword chain_job: Default value is None.
        :paramtype chain_job: str
        :keyword partial: Default value is None.
        :paramtype partial: bool
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ResultResponseBulkResultItem. The ResultResponseBulkResultItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ResultResponseBulkResultItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def bulk_composite_request(
        self,
        body: JSON,
        *,
        create_job: Optional[bool] = None,
        chain_job: Optional[str] = None,
        partial: Optional[bool] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ResultResponseBulkResultItem:
        """Bulk composite request.

        :param body: Required.
        :type body: JSON
        :keyword create_job: Default value is None.
        :paramtype create_job: bool
        :keyword chain_job: Default value is None.
        :paramtype chain_job: str
        :keyword partial: Default value is None.
        :paramtype partial: bool
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ResultResponseBulkResultItem. The ResultResponseBulkResultItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ResultResponseBulkResultItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def bulk_composite_request(
        self,
        body: IO[bytes],
        *,
        create_job: Optional[bool] = None,
        chain_job: Optional[str] = None,
        partial: Optional[bool] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ResultResponseBulkResultItem:
        """Bulk composite request.

        :param body: Required.
        :type body: IO[bytes]
        :keyword create_job: Default value is None.
        :paramtype create_job: bool
        :keyword chain_job: Default value is None.
        :paramtype chain_job: str
        :keyword partial: Default value is None.
        :paramtype partial: bool
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ResultResponseBulkResultItem. The ResultResponseBulkResultItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ResultResponseBulkResultItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def bulk_composite_request(
        self,
        body: Union[_models.BulkComposite, JSON, IO[bytes]],
        *,
        create_job: Optional[bool] = None,
        chain_job: Optional[str] = None,
        partial: Optional[bool] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.ResultResponseBulkResultItem:
        """Bulk composite request.

        :param body: Is one of the following types: BulkComposite, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.BulkComposite or JSON or IO[bytes]
        :keyword create_job: Default value is None.
        :paramtype create_job: bool
        :keyword chain_job: Default value is None.
        :paramtype chain_job: str
        :keyword partial: Default value is None.
        :paramtype partial: bool
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: ResultResponseBulkResultItem. The ResultResponseBulkResultItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ResultResponseBulkResultItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[_models.ResultResponseBulkResultItem] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_bulk_composite_request_request(
            create_job=create_job,
            chain_job=chain_job,
            partial=partial,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ResultResponseBulkResultItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def bulk_yb_port_udi_request(
        self,
        data: str,
        *,
        prefix: Optional[str] = None,
        suffix: Optional[str] = None,
        create_job: Optional[bool] = None,
        chain_job: Optional[str] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.ResultResponseBulkResultItem:
        """Bulk YB Port UDI request.

        :param data: Required.
        :type data: str
        :keyword prefix: Default value is None.
        :paramtype prefix: str
        :keyword suffix: Default value is None.
        :paramtype suffix: str
        :keyword create_job: Default value is None.
        :paramtype create_job: bool
        :keyword chain_job: Default value is None.
        :paramtype chain_job: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: ResultResponseBulkResultItem. The ResultResponseBulkResultItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ResultResponseBulkResultItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "text/plain"))
        cls: ClsType[_models.ResultResponseBulkResultItem] = kwargs.pop("cls", None)

        _content = data

        _request = build_yield_book_rest_bulk_yb_port_udi_request_request(
            prefix=prefix,
            suffix=suffix,
            create_job=create_job,
            chain_job=chain_job,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ResultResponseBulkResultItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def request_py_calculation_sync(
        self,
        body: _models.PyCalcRequest,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request PY calculation sync.

        :param body: Required.
        :type body: ~analyticsapi.models.PyCalcRequest
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_py_calculation_sync(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request PY calculation sync.

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_py_calculation_sync(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request PY calculation sync.

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def request_py_calculation_sync(
        self,
        body: Union[_models.PyCalcRequest, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request PY calculation sync.

        :param body: Is one of the following types: PyCalcRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.PyCalcRequest or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_request_py_calculation_sync_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def request_py_calculation_async(
        self,
        body: _models.PyCalcRequest,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request PY calculation async.

        :param body: Required.
        :type body: ~analyticsapi.models.PyCalcRequest
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_py_calculation_async(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request PY calculation async.

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_py_calculation_async(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request PY calculation async.

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def request_py_calculation_async(
        self,
        body: Union[_models.PyCalcRequest, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request PY calculation async.

        :param body: Is one of the following types: PyCalcRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.PyCalcRequest or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_request_py_calculation_async_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_py_calculation_sync_by_id(
        self,
        id: str,
        *,
        level: str,
        curve_type: Union[str, _models.YbRestCurveType],
        id_type: Optional[str] = None,
        pricing_date: Optional[datetime.date] = None,
        currency: Optional[str] = None,
        prepay_type: Optional[str] = None,
        prepay_rate: Optional[float] = None,
        option_model: Optional[Union[str, _models.OptionModel]] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request PY calculation sync by ID.

        :param id: Required.
        :type id: str
        :keyword level: Required.
        :paramtype level: str
        :keyword curve_type: Known values are: "GVT", "GVT_TSYM", "GVT_TSYM_MUNI", "GVT_AGN",
         "GVT_MUNI", "GVT_BUND", "SWAP", "SWAP_RFR", "SWAP_MUNI", and "SWAP_LIB6M". Required.
        :paramtype curve_type: str or ~analyticsapi.models.YbRestCurveType
        :keyword id_type: Default value is None.
        :paramtype id_type: str
        :keyword pricing_date: Default value is None.
        :paramtype pricing_date: ~datetime.date
        :keyword currency: Default value is None.
        :paramtype currency: str
        :keyword prepay_type: Default value is None.
        :paramtype prepay_type: str
        :keyword prepay_rate: Default value is None.
        :paramtype prepay_rate: float
        :keyword option_model: Known values are: "OAS", "OASEDUR", and "YCMARGIN". Default value is
         None.
        :paramtype option_model: str or ~analyticsapi.models.OptionModel
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_py_calculation_sync_by_id_request(
            id=id,
            level=level,
            curve_type=curve_type,
            id_type=id_type,
            pricing_date=pricing_date,
            currency=currency,
            prepay_type=prepay_type,
            prepay_rate=prepay_rate,
            option_model=option_model,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_py_calculation_async_by_id(
        self,
        id: str,
        *,
        level: str,
        curve_type: Union[str, _models.YbRestCurveType],
        id_type: Optional[str] = None,
        pricing_date: Optional[datetime.date] = None,
        currency: Optional[str] = None,
        prepay_type: Optional[str] = None,
        prepay_rate: Optional[float] = None,
        option_model: Optional[Union[str, _models.OptionModel]] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request PY calculation async by ID.

        :param id: Required.
        :type id: str
        :keyword level: Required.
        :paramtype level: str
        :keyword curve_type: Known values are: "GVT", "GVT_TSYM", "GVT_TSYM_MUNI", "GVT_AGN",
         "GVT_MUNI", "GVT_BUND", "SWAP", "SWAP_RFR", "SWAP_MUNI", and "SWAP_LIB6M". Required.
        :paramtype curve_type: str or ~analyticsapi.models.YbRestCurveType
        :keyword id_type: Default value is None.
        :paramtype id_type: str
        :keyword pricing_date: Default value is None.
        :paramtype pricing_date: ~datetime.date
        :keyword currency: Default value is None.
        :paramtype currency: str
        :keyword prepay_type: Default value is None.
        :paramtype prepay_type: str
        :keyword prepay_rate: Default value is None.
        :paramtype prepay_rate: float
        :keyword option_model: Known values are: "OAS", "OASEDUR", and "YCMARGIN". Default value is
         None.
        :paramtype option_model: str or ~analyticsapi.models.OptionModel
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_py_calculation_async_by_id_request(
            id=id,
            level=level,
            curve_type=curve_type,
            id_type=id_type,
            pricing_date=pricing_date,
            currency=currency,
            prepay_type=prepay_type,
            prepay_rate=prepay_rate,
            option_model=option_model,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_volatility_sync(
        self,
        currency: str,
        date: str,
        *,
        quote_type: str,
        vol_model: Optional[str] = None,
        vol_type: Optional[str] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request volatility sync.

        :param currency: Currency should be a 3 letter upper case string. Required.
        :type currency: str
        :param date: Required.
        :type date: str
        :keyword quote_type: Should be one of the following - Calibrated, SOFRMarket, LIBORMarket.
         Required.
        :paramtype quote_type: str
        :keyword vol_model: Should be one of the following - Default, LMMSOFR, LMMSOFRNEW, LMMSOFRFLAT,
         LMMDL, LMMDDNEW, LMMDD. To be provided when quoteType is Calibrated. Default value is None.
        :paramtype vol_model: str
        :keyword vol_type: Should be one of the following - NORM, BLACK, To be provided when quoteType
         is SOFRMarket or LIBORMarket. Default value is None.
        :paramtype vol_type: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_volatility_sync_request(
            currency=currency,
            date=date,
            quote_type=quote_type,
            vol_model=vol_model,
            vol_type=vol_type,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_volatility_async(
        self,
        currency: str,
        date: str,
        *,
        quote_type: str,
        vol_model: Optional[str] = None,
        vol_type: Optional[str] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request volatility async.

        :param currency: Currency should be a 3 letter upper case string. Required.
        :type currency: str
        :param date: Required.
        :type date: str
        :keyword quote_type: Should be one of the following - Calibrated, SOFRMarket, LIBORMarket.
         Required.
        :paramtype quote_type: str
        :keyword vol_model: Should be one of the following - Default, LMMSOFR, LMMSOFRNEW, LMMSOFRFLAT,
         LMMDL, LMMDDNEW, LMMDD. To be provided when quoteType is Calibrated. Default value is None.
        :paramtype vol_model: str
        :keyword vol_type: Should be one of the following - NORM, BLACK, To be provided when quoteType
         is SOFRMarket or LIBORMarket. Default value is None.
        :paramtype vol_type: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_volatility_async_request(
            currency=currency,
            date=date,
            quote_type=quote_type,
            vol_model=vol_model,
            vol_type=vol_type,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def request_curves_sync(
        self,
        body: _models.CurveDetailsRequest,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request curves sync.

        :param body: Required.
        :type body: ~analyticsapi.models.CurveDetailsRequest
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_curves_sync(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request curves sync.

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_curves_sync(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request curves sync.

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def request_curves_sync(
        self,
        body: Union[_models.CurveDetailsRequest, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request curves sync.

        :param body: Is one of the following types: CurveDetailsRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.CurveDetailsRequest or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_request_curves_sync_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def request_curves_async(
        self,
        body: _models.CurveDetailsRequest,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request curves async.

        :param body: Required.
        :type body: ~analyticsapi.models.CurveDetailsRequest
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_curves_async(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request curves async.

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_curves_async(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request curves async.

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def request_curves_async(
        self,
        body: Union[_models.CurveDetailsRequest, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request curves async.

        :param body: Is one of the following types: CurveDetailsRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.CurveDetailsRequest or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_request_curves_async_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_curve_sync(
        self,
        date: datetime.date,
        *,
        currency: str,
        curve_type: Union[str, _models.YbRestCurveType],
        cds_ticker: Optional[str] = None,
        expand_curve: Optional[bool] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Request curve sync.

        :param date: Required.
        :type date: ~datetime.date
        :keyword currency: Required.
        :paramtype currency: str
        :keyword curve_type: Known values are: "GVT", "GVT_TSYM", "GVT_TSYM_MUNI", "GVT_AGN",
         "GVT_MUNI", "GVT_BUND", "SWAP", "SWAP_RFR", "SWAP_MUNI", and "SWAP_LIB6M". Required.
        :paramtype curve_type: str or ~analyticsapi.models.YbRestCurveType
        :keyword cds_ticker: Default value is None.
        :paramtype cds_ticker: str
        :keyword expand_curve: Default value is None.
        :paramtype expand_curve: bool
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_curve_sync_request(
            date=date,
            currency=currency,
            curve_type=curve_type,
            cds_ticker=cds_ticker,
            expand_curve=expand_curve,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_curve_async(
        self,
        date: datetime.date,
        *,
        currency: str,
        curve_type: Union[str, _models.YbRestCurveType],
        cds_ticker: Optional[str] = None,
        expand_curve: Optional[bool] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Request curve async.

        :param date: Required.
        :type date: ~datetime.date
        :keyword currency: Required.
        :paramtype currency: str
        :keyword curve_type: Known values are: "GVT", "GVT_TSYM", "GVT_TSYM_MUNI", "GVT_AGN",
         "GVT_MUNI", "GVT_BUND", "SWAP", "SWAP_RFR", "SWAP_MUNI", and "SWAP_LIB6M". Required.
        :paramtype curve_type: str or ~analyticsapi.models.YbRestCurveType
        :keyword cds_ticker: Default value is None.
        :paramtype cds_ticker: str
        :keyword expand_curve: Default value is None.
        :paramtype expand_curve: bool
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_curve_async_request(
            date=date,
            currency=currency,
            curve_type=curve_type,
            cds_ticker=cds_ticker,
            expand_curve=expand_curve,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def get_tba_pricing_sync(
        self,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Get tba-pricing sync.

        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_get_tba_pricing_sync_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_market_setting_sync(
        self,
        body: _models.MarketSettingsRequest,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Post Bond market setting.

        :param body: Required.
        :type body: ~analyticsapi.models.MarketSettingsRequest
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def post_market_setting_sync(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Post Bond market setting.

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def post_market_setting_sync(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Post Bond market setting.

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def post_market_setting_sync(
        self,
        body: Union[_models.MarketSettingsRequest, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Post Bond market setting.

        :param body: Is one of the following types: MarketSettingsRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.MarketSettingsRequest or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_post_market_setting_sync_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_historical_data_sync(
        self,
        id: str,
        *,
        id_type: Optional[str] = None,
        keyword: Optional[List[str]] = None,
        start_date: Optional[datetime.date] = None,
        end_date: Optional[datetime.date] = None,
        frequency: Optional[Union[str, _models.YbRestFrequency]] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Get Historical Data sync.

        Request Historical Data sync by Security reference ID.

        :param id: Security reference ID. Required.
        :type id: str
        :keyword id_type: Default value is None.
        :paramtype id_type: str
        :keyword keyword: Default value is None.
        :paramtype keyword: list[str]
        :keyword start_date: Default value is None.
        :paramtype start_date: ~datetime.date
        :keyword end_date: Default value is None.
        :paramtype end_date: ~datetime.date
        :keyword frequency: Known values are: "DAILY", "WEEKLY", "MONTHLY", "QUARTERLY", and "YEARLY".
         Default value is None.
        :paramtype frequency: str or ~analyticsapi.models.YbRestFrequency
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_historical_data_sync_request(
            id=id,
            id_type=id_type,
            keyword=keyword,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_historical_data_async(
        self,
        id: str,
        *,
        id_type: Optional[str] = None,
        keyword: Optional[List[str]] = None,
        start_date: Optional[datetime.date] = None,
        end_date: Optional[datetime.date] = None,
        frequency: Optional[Union[str, _models.YbRestFrequency]] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """Get Historical Data Async.

        Request Historical Data async by Security reference ID.

        :param id: Security reference ID. Required.
        :type id: str
        :keyword id_type: Default value is None.
        :paramtype id_type: str
        :keyword keyword: Default value is None.
        :paramtype keyword: list[str]
        :keyword start_date: Default value is None.
        :paramtype start_date: ~datetime.date
        :keyword end_date: Default value is None.
        :paramtype end_date: ~datetime.date
        :keyword frequency: Known values are: "DAILY", "WEEKLY", "MONTHLY", "QUARTERLY", and "YEARLY".
         Default value is None.
        :paramtype frequency: str or ~analyticsapi.models.YbRestFrequency
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_historical_data_async_request(
            id=id,
            id_type=id_type,
            keyword=keyword,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_mbs_history_sync(
        self,
        id: str,
        *,
        id_type: Optional[str] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_mbs_history_sync.

        :param id: Security reference ID. Required.
        :type id: str
        :keyword id_type: Default value is None.
        :paramtype id_type: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_mbs_history_sync_request(
            id=id,
            id_type=id_type,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_mbs_history_async(
        self,
        id: str,
        *,
        id_type: Optional[str] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_mbs_history_async.

        :param id: Security reference ID. Required.
        :type id: str
        :keyword id_type: Default value is None.
        :paramtype id_type: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_mbs_history_async_request(
            id=id,
            id_type=id_type,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def request_wal_sensitivity_sync(
        self,
        body: _models.WalSensitivityRequest,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_wal_sensitivity_sync.

        :param body: Required.
        :type body: ~analyticsapi.models.WalSensitivityRequest
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_wal_sensitivity_sync(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_wal_sensitivity_sync.

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_wal_sensitivity_sync(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_wal_sensitivity_sync.

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def request_wal_sensitivity_sync(
        self,
        body: Union[_models.WalSensitivityRequest, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_wal_sensitivity_sync.

        :param body: Is one of the following types: WalSensitivityRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.WalSensitivityRequest or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_request_wal_sensitivity_sync_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def request_wal_sensitivity_async(
        self,
        body: _models.WalSensitivityRequest,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_wal_sensitivity_async.

        :param body: Required.
        :type body: ~analyticsapi.models.WalSensitivityRequest
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_wal_sensitivity_async(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_wal_sensitivity_async.

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_wal_sensitivity_async(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_wal_sensitivity_async.

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def request_wal_sensitivity_async(
        self,
        body: Union[_models.WalSensitivityRequest, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_wal_sensitivity_async.

        :param body: Is one of the following types: WalSensitivityRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.WalSensitivityRequest or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_request_wal_sensitivity_async_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_wal_sensitivity_sync_get(
        self,
        id: str,
        *,
        prepay_type: Union[str, _models.WalSensitivityPrepayType],
        prepay_rate_start: int,
        prepay_rate_end: int,
        prepay_rate_step: int,
        tolerance: float,
        id_type: Optional[str] = None,
        horizon_date: Optional[datetime.date] = None,
        prepay_rate: Optional[int] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_wal_sensitivity_sync_get.

        :param id: Security reference ID. Required.
        :type id: str
        :keyword prepay_type: Known values are: "PSA" and "CPR". Required.
        :paramtype prepay_type: str or ~analyticsapi.models.WalSensitivityPrepayType
        :keyword prepay_rate_start: Required.
        :paramtype prepay_rate_start: int
        :keyword prepay_rate_end: Required.
        :paramtype prepay_rate_end: int
        :keyword prepay_rate_step: Required.
        :paramtype prepay_rate_step: int
        :keyword tolerance: Required.
        :paramtype tolerance: float
        :keyword id_type: Default value is None.
        :paramtype id_type: str
        :keyword horizon_date: Default value is None.
        :paramtype horizon_date: ~datetime.date
        :keyword prepay_rate: Default value is None.
        :paramtype prepay_rate: int
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_wal_sensitivity_sync_get_request(
            id=id,
            prepay_type=prepay_type,
            prepay_rate_start=prepay_rate_start,
            prepay_rate_end=prepay_rate_end,
            prepay_rate_step=prepay_rate_step,
            tolerance=tolerance,
            id_type=id_type,
            horizon_date=horizon_date,
            prepay_rate=prepay_rate,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_wal_sensitivity_asyn_get(
        self,
        id: str,
        *,
        prepay_type: Union[str, _models.WalSensitivityPrepayType],
        prepay_rate_start: int,
        prepay_rate_end: int,
        prepay_rate_step: int,
        tolerance: float,
        id_type: Optional[str] = None,
        horizon_date: Optional[datetime.date] = None,
        prepay_rate: Optional[int] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_wal_sensitivity_asyn_get.

        :param id: Security reference ID. Required.
        :type id: str
        :keyword prepay_type: Known values are: "PSA" and "CPR". Required.
        :paramtype prepay_type: str or ~analyticsapi.models.WalSensitivityPrepayType
        :keyword prepay_rate_start: Required.
        :paramtype prepay_rate_start: int
        :keyword prepay_rate_end: Required.
        :paramtype prepay_rate_end: int
        :keyword prepay_rate_step: Required.
        :paramtype prepay_rate_step: int
        :keyword tolerance: Required.
        :paramtype tolerance: float
        :keyword id_type: Default value is None.
        :paramtype id_type: str
        :keyword horizon_date: Default value is None.
        :paramtype horizon_date: ~datetime.date
        :keyword prepay_rate: Default value is None.
        :paramtype prepay_rate: int
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_wal_sensitivity_asyn_get_request(
            id=id,
            prepay_type=prepay_type,
            prepay_rate_start=prepay_rate_start,
            prepay_rate_end=prepay_rate_end,
            prepay_rate_step=prepay_rate_step,
            tolerance=tolerance,
            id_type=id_type,
            horizon_date=horizon_date,
            prepay_rate=prepay_rate,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_actual_vs_projected_async_get(
        self,
        id: str,
        *,
        id_type: Optional[str] = None,
        prepay_type: Optional[str] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_actual_vs_projected_async_get.

        :param id: Security reference ID. Required.
        :type id: str
        :keyword id_type: Default value is None.
        :paramtype id_type: str
        :keyword prepay_type: Default value is None.
        :paramtype prepay_type: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_actual_vs_projected_async_get_request(
            id=id,
            id_type=id_type,
            prepay_type=prepay_type,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_actual_vs_projected_sync_get(
        self,
        id: str,
        *,
        id_type: Optional[str] = None,
        prepay_type: Optional[str] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_actual_vs_projected_sync_get.

        :param id: Security reference ID. Required.
        :type id: str
        :keyword id_type: Default value is None.
        :paramtype id_type: str
        :keyword prepay_type: Default value is None.
        :paramtype prepay_type: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_actual_vs_projected_sync_get_request(
            id=id,
            id_type=id_type,
            prepay_type=prepay_type,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def request_actual_vs_projected_sync(
        self,
        body: _models.ActualVsProjectedRequest,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_actual_vs_projected_sync.

        :param body: Required.
        :type body: ~analyticsapi.models.ActualVsProjectedRequest
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_actual_vs_projected_sync(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_actual_vs_projected_sync.

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_actual_vs_projected_sync(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_actual_vs_projected_sync.

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def request_actual_vs_projected_sync(
        self,
        body: Union[_models.ActualVsProjectedRequest, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_actual_vs_projected_sync.

        :param body: Is one of the following types: ActualVsProjectedRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.ActualVsProjectedRequest or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_request_actual_vs_projected_sync_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def request_actual_vs_projected_async(
        self,
        body: _models.ActualVsProjectedRequest,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_actual_vs_projected_async.

        :param body: Required.
        :type body: ~analyticsapi.models.ActualVsProjectedRequest
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_actual_vs_projected_async(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_actual_vs_projected_async.

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_actual_vs_projected_async(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_actual_vs_projected_async.

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def request_actual_vs_projected_async(
        self,
        body: Union[_models.ActualVsProjectedRequest, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_actual_vs_projected_async.

        :param body: Is one of the following types: ActualVsProjectedRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.ActualVsProjectedRequest or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_request_actual_vs_projected_async_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def request_collateral_details_sync(
        self,
        body: _models.CollateralDetailsRequest,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_collateral_details_sync.

        :param body: Required.
        :type body: ~analyticsapi.models.CollateralDetailsRequest
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_collateral_details_sync(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_collateral_details_sync.

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_collateral_details_sync(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_collateral_details_sync.

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def request_collateral_details_sync(
        self,
        body: Union[_models.CollateralDetailsRequest, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_collateral_details_sync.

        :param body: Is one of the following types: CollateralDetailsRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.CollateralDetailsRequest or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_request_collateral_details_sync_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def request_collateral_details_async(
        self,
        body: _models.CollateralDetailsRequest,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_collateral_details_async.

        :param body: Required.
        :type body: ~analyticsapi.models.CollateralDetailsRequest
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_collateral_details_async(
        self,
        body: JSON,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_collateral_details_async.

        :param body: Required.
        :type body: JSON
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def request_collateral_details_async(
        self,
        body: IO[bytes],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_collateral_details_async.

        :param body: Required.
        :type body: IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def request_collateral_details_async(
        self,
        body: Union[_models.CollateralDetailsRequest, JSON, IO[bytes]],
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_collateral_details_async.

        :param body: Is one of the following types: CollateralDetailsRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.CollateralDetailsRequest or JSON or IO[bytes]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_yield_book_rest_request_collateral_details_async_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_collateral_details_sync_get(
        self,
        id: str,
        *,
        id_type: Optional[str] = None,
        user_tag: Optional[str] = None,
        data_items: Optional[List[Union[str, _models.DataItems]]] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_collateral_details_sync_get.

        :param id: Security reference ID. Required.
        :type id: str
        :keyword id_type: Default value is None.
        :paramtype id_type: str
        :keyword user_tag: Default value is None.
        :paramtype user_tag: str
        :keyword data_items: Default value is None.
        :paramtype data_items: list[str or ~analyticsapi.models.DataItems]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_collateral_details_sync_get_request(
            id=id,
            id_type=id_type,
            user_tag=user_tag,
            data_items=data_items,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_collateral_details_async_get(
        self,
        id: str,
        *,
        id_type: Optional[str] = None,
        user_tag: Optional[str] = None,
        data_items: Optional[List[Union[str, _models.DataItems]]] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_collateral_details_async_get.

        :param id: Security reference ID. Required.
        :type id: str
        :keyword id_type: Default value is None.
        :paramtype id_type: str
        :keyword user_tag: Default value is None.
        :paramtype user_tag: str
        :keyword data_items: Default value is None.
        :paramtype data_items: list[str or ~analyticsapi.models.DataItems]
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_collateral_details_async_get_request(
            id=id,
            id_type=id_type,
            user_tag=user_tag,
            data_items=data_items,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_index_providers_sync(
        self,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_index_providers_sync.

        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_index_providers_sync_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_index_providers_async(
        self,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_index_providers_async.

        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_index_providers_async_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_index_data_by_ticker_sync(
        self,
        ticker: str,
        asof_date: datetime.date,
        *,
        pricing_date: Optional[datetime.date] = None,
        base_currency: Optional[str] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_index_data_by_ticker_sync.

        :param ticker: Required.
        :type ticker: str
        :param asof_date: Required.
        :type asof_date: ~datetime.date
        :keyword pricing_date: Default value is None.
        :paramtype pricing_date: ~datetime.date
        :keyword base_currency: Default value is None.
        :paramtype base_currency: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_index_data_by_ticker_sync_request(
            ticker=ticker,
            asof_date=asof_date,
            pricing_date=pricing_date,
            base_currency=base_currency,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_index_data_by_ticker_async(
        self,
        ticker: str,
        asof_date: datetime.date,
        *,
        pricing_date: Optional[datetime.date] = None,
        base_currency: Optional[str] = None,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_index_data_by_ticker_async.

        :param ticker: Required.
        :type ticker: str
        :param asof_date: Required.
        :type asof_date: ~datetime.date
        :keyword pricing_date: Default value is None.
        :paramtype pricing_date: ~datetime.date
        :keyword base_currency: Default value is None.
        :paramtype base_currency: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_index_data_by_ticker_async_request(
            ticker=ticker,
            asof_date=asof_date,
            pricing_date=pricing_date,
            base_currency=base_currency,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_index_catalogue_info_sync(
        self,
        provider: str,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_index_catalogue_info_sync.

        :param provider: Required.
        :type provider: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_index_catalogue_info_sync_request(
            provider=provider,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_index_catalogue_info_async(
        self,
        provider: str,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_index_catalogue_info_async.

        :param provider: Required.
        :type provider: str
        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_index_catalogue_info_async_request(
            provider=provider,
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_mortgage_model_sync(
        self,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """request_mortgage_model_sync.

        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, Any]] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_mortgage_model_sync_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def request_mortgage_model_async(
        self,
        *,
        job: Optional[str] = None,
        name: Optional[str] = None,
        pri: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> _models.RequestId:
        """request_mortgage_model_async.

        :keyword job: Job reference. This can be of the form J-number or job name. Default value is
         None.
        :paramtype job: str
        :keyword name: User provided name. Default value is None.
        :paramtype name: str
        :keyword pri: Priority for this request in the queue. Default value is None.
        :paramtype pri: int
        :keyword tags: Default value is None.
        :paramtype tags: list[str]
        :return: RequestId. The RequestId is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RequestId
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.RequestId] = kwargs.pop("cls", None)

        _request = build_yield_book_rest_request_mortgage_model_async_request(
            job=job,
            name=name,
            pri=pri,
            tags=tags,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RequestId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class instrumentTemplatesResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`instrument_templates_resource` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        page: Optional[int] = None,
        spaces: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        space_name_sort_order: Optional[Union[str, _models.SortingOrderEnum]] = None,
        tags: Optional[List[str]] = None,
        fields: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.InstrumentTemplateCollectionResponse:
        """List the resources that exist in the platform.

        List the InstrumentTemplates existing in the platform (depending on permissions).

        :keyword item_per_page: A parameter used to select the number of items allowed per page. The
         valid range is 1-500. If not provided, 50 will be used. Default value is None.
        :paramtype item_per_page: int
        :keyword page: A parameter used to define the page number to display. Default value is None.
        :paramtype page: int
        :keyword spaces: A parameter used to search for platform resources stored in a given space.
         Space is like a namespace where resources are stored. By default there are two spaces:
         LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space.
         If space is not specified, it will search within all spaces. Default value is None.
        :paramtype spaces: list[str]
        :keyword names: A parameter used to search for platform resources with given names. Default
         value is None.
        :paramtype names: list[str]
        :keyword space_name_sort_order: A parameter used to sort platform resources by name based on a
         defined order. Known values are: "Asc" and "Desc". Default value is None.
        :paramtype space_name_sort_order: str or ~analyticsapi.models.SortingOrderEnum
        :keyword tags: A parameter used to search for platform resources with given tags. Default value
         is None.
        :paramtype tags: list[str]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: InstrumentTemplateCollectionResponse. The InstrumentTemplateCollectionResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.InstrumentTemplateCollectionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.InstrumentTemplateCollectionResponse] = kwargs.pop("cls", None)

        _request = build_instrument_templates_resource_list_request(
            item_per_page=item_per_page,
            page=page,
            spaces=spaces,
            names=names,
            space_name_sort_order=space_name_sort_order,
            tags=tags,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.InstrumentTemplateCollectionResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self,
        *,
        location: _models.Location,
        definition: _models.InstrumentTemplateDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.InstrumentTemplateResponse:
        """Create a new resource to be saved in the platform.

        Save a new InstrumentTemplate in the platform.

        :keyword location: Object defining the location of the InstrumentTemplate in the platform.
         Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the InstrumentTemplate. Required.
        :paramtype definition: ~analyticsapi.models.InstrumentTemplateDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the InstrumentTemplate. Default value is
         None.
        :paramtype description: ~analyticsapi.models.Description
        :return: InstrumentTemplateResponse. The InstrumentTemplateResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InstrumentTemplateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InstrumentTemplateResponse:
        """Create a new resource to be saved in the platform.

        Save a new InstrumentTemplate in the platform.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InstrumentTemplateResponse. The InstrumentTemplateResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InstrumentTemplateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InstrumentTemplateResponse:
        """Create a new resource to be saved in the platform.

        Save a new InstrumentTemplate in the platform.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InstrumentTemplateResponse. The InstrumentTemplateResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InstrumentTemplateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.InstrumentTemplateDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.InstrumentTemplateResponse:
        """Create a new resource to be saved in the platform.

        Save a new InstrumentTemplate in the platform.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the InstrumentTemplate in the platform.
         Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the InstrumentTemplate. Required.
        :paramtype definition: ~analyticsapi.models.InstrumentTemplateDefinition
        :keyword description: Object defining metadata for the InstrumentTemplate. Default value is
         None.
        :paramtype description: ~analyticsapi.models.Description
        :return: InstrumentTemplateResponse. The InstrumentTemplateResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InstrumentTemplateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.InstrumentTemplateResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_instrument_templates_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.InstrumentTemplateResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class instrumentTemplateResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`instrument_template_resource` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def read(
        self, template_id: str, *, fields: Optional[str] = None, **kwargs: Any
    ) -> _models.InstrumentTemplateResponse:
        """Access a resource that exists in the platform.

        Access a InstrumentTemplate existing in the platform (read). The InstrumentTemplate can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param template_id: Required.
        :type template_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: InstrumentTemplateResponse. The InstrumentTemplateResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InstrumentTemplateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.InstrumentTemplateResponse] = kwargs.pop("cls", None)

        _request = build_instrument_template_resource_read_request(
            template_id=template_id,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.InstrumentTemplateResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def delete(self, template_id: str, **kwargs: Any) -> None:
        """Delete a resource that exists in the platform.

        Delete a InstrumentTemplate that exists in the platform. The InstrumentTemplate can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param template_id: Required.
        :type template_id: str
        :return: None
        :rtype: None
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_instrument_template_resource_delete_request(
            template_id=template_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def overwrite(
        self,
        template_id: str,
        *,
        location: _models.Location,
        definition: _models.InstrumentTemplateDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.InstrumentTemplateResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a InstrumentTemplate that exists in the platform. The InstrumentTemplate can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param template_id: Required.
        :type template_id: str
        :keyword location: Object defining the location of the InstrumentTemplate in the platform.
         Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the InstrumentTemplate. Required.
        :paramtype definition: ~analyticsapi.models.InstrumentTemplateDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the InstrumentTemplate. Default value is
         None.
        :paramtype description: ~analyticsapi.models.Description
        :return: InstrumentTemplateResponse. The InstrumentTemplateResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InstrumentTemplateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, template_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InstrumentTemplateResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a InstrumentTemplate that exists in the platform. The InstrumentTemplate can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param template_id: Required.
        :type template_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InstrumentTemplateResponse. The InstrumentTemplateResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InstrumentTemplateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, template_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InstrumentTemplateResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a InstrumentTemplate that exists in the platform. The InstrumentTemplate can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param template_id: Required.
        :type template_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InstrumentTemplateResponse. The InstrumentTemplateResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InstrumentTemplateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def overwrite(
        self,
        template_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.InstrumentTemplateDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.InstrumentTemplateResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a InstrumentTemplate that exists in the platform. The InstrumentTemplate can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param template_id: Required.
        :type template_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the InstrumentTemplate in the platform.
         Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the InstrumentTemplate. Required.
        :paramtype definition: ~analyticsapi.models.InstrumentTemplateDefinition
        :keyword description: Object defining metadata for the InstrumentTemplate. Default value is
         None.
        :paramtype description: ~analyticsapi.models.Description
        :return: InstrumentTemplateResponse. The InstrumentTemplateResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InstrumentTemplateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.InstrumentTemplateResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_instrument_template_resource_overwrite_request(
            template_id=template_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.InstrumentTemplateResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class irSwapsResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`ir_swaps_resource` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        page: Optional[int] = None,
        spaces: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        space_name_sort_order: Optional[Union[str, _models.SortingOrderEnum]] = None,
        tags: Optional[List[str]] = None,
        fields: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.IrSwapCollectionResponse:
        """List the resources that exist in the platform.

        List the IrSwaps existing in the platform (depending on permissions).

        :keyword item_per_page: A parameter used to select the number of items allowed per page. The
         valid range is 1-500. If not provided, 50 will be used. Default value is None.
        :paramtype item_per_page: int
        :keyword page: A parameter used to define the page number to display. Default value is None.
        :paramtype page: int
        :keyword spaces: A parameter used to search for platform resources stored in a given space.
         Space is like a namespace where resources are stored. By default there are two spaces:
         LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space.
         If space is not specified, it will search within all spaces. Default value is None.
        :paramtype spaces: list[str]
        :keyword names: A parameter used to search for platform resources with given names. Default
         value is None.
        :paramtype names: list[str]
        :keyword space_name_sort_order: A parameter used to sort platform resources by name based on a
         defined order. Known values are: "Asc" and "Desc". Default value is None.
        :paramtype space_name_sort_order: str or ~analyticsapi.models.SortingOrderEnum
        :keyword tags: A parameter used to search for platform resources with given tags. Default value
         is None.
        :paramtype tags: list[str]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: IrSwapCollectionResponse. The IrSwapCollectionResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.IrSwapCollectionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.IrSwapCollectionResponse] = kwargs.pop("cls", None)

        _request = build_ir_swaps_resource_list_request(
            item_per_page=item_per_page,
            page=page,
            spaces=spaces,
            names=names,
            space_name_sort_order=space_name_sort_order,
            tags=tags,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IrSwapCollectionResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self,
        *,
        location: _models.Location,
        definition: _models.IrSwapDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.IrSwapResponse:
        """Create a new resource to be saved in the platform.

        Save a new IrSwap in the platform.

        :keyword location: Object defining the location of the IrSwap in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the IrSwap. Required.
        :paramtype definition: ~analyticsapi.models.IrSwapDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the IrSwap. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: IrSwapResponse. The IrSwapResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IrSwapResponse:
        """Create a new resource to be saved in the platform.

        Save a new IrSwap in the platform.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrSwapResponse. The IrSwapResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IrSwapResponse:
        """Create a new resource to be saved in the platform.

        Save a new IrSwap in the platform.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrSwapResponse. The IrSwapResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.IrSwapDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.IrSwapResponse:
        """Create a new resource to be saved in the platform.

        Save a new IrSwap in the platform.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the IrSwap in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the IrSwap. Required.
        :paramtype definition: ~analyticsapi.models.IrSwapDefinition
        :keyword description: Object defining metadata for the IrSwap. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: IrSwapResponse. The IrSwapResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IrSwapResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ir_swaps_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IrSwapResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def solve(
        self,
        *,
        definitions: List[_models.IrSwapDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.IrPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.IrSwapInstrumentArraySolveResponse:
        """Solve IrSwap with custom definition.

        Calculate analytics for one or more swaps not stored on the platform, by solving a variable
        parameter (e.g., fixed rate) provided in the request,
        so that a specified property (e.g., market value, duration) matches a target value.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.IrSwapDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.IrPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: IrSwapInstrumentArraySolveResponse. The IrSwapInstrumentArraySolveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapInstrumentArraySolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def solve(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IrSwapInstrumentArraySolveResponse:
        """Solve IrSwap with custom definition.

        Calculate analytics for one or more swaps not stored on the platform, by solving a variable
        parameter (e.g., fixed rate) provided in the request,
        so that a specified property (e.g., market value, duration) matches a target value.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrSwapInstrumentArraySolveResponse. The IrSwapInstrumentArraySolveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapInstrumentArraySolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def solve(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IrSwapInstrumentArraySolveResponse:
        """Solve IrSwap with custom definition.

        Calculate analytics for one or more swaps not stored on the platform, by solving a variable
        parameter (e.g., fixed rate) provided in the request,
        so that a specified property (e.g., market value, duration) matches a target value.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrSwapInstrumentArraySolveResponse. The IrSwapInstrumentArraySolveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapInstrumentArraySolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def solve(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.IrSwapDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.IrPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.IrSwapInstrumentArraySolveResponse:
        """Solve IrSwap with custom definition.

        Calculate analytics for one or more swaps not stored on the platform, by solving a variable
        parameter (e.g., fixed rate) provided in the request,
        so that a specified property (e.g., market value, duration) matches a target value.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.IrSwapDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.IrPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: IrSwapInstrumentArraySolveResponse. The IrSwapInstrumentArraySolveResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapInstrumentArraySolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IrSwapInstrumentArraySolveResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ir_swaps_resource_solve_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IrSwapInstrumentArraySolveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def value(
        self,
        *,
        definitions: List[_models.IrSwapDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.IrPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.IrSwapInstrumentArrayValuationResponse:
        """Value IrSwap with custom definition.

        Calculate analytics for one or more swaps not stored on the platform, including valuation
        results, risk metrics, and other relevant measures.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.IrSwapDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.IrPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: IrSwapInstrumentArrayValuationResponse. The IrSwapInstrumentArrayValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapInstrumentArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IrSwapInstrumentArrayValuationResponse:
        """Value IrSwap with custom definition.

        Calculate analytics for one or more swaps not stored on the platform, including valuation
        results, risk metrics, and other relevant measures.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrSwapInstrumentArrayValuationResponse. The IrSwapInstrumentArrayValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapInstrumentArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IrSwapInstrumentArrayValuationResponse:
        """Value IrSwap with custom definition.

        Calculate analytics for one or more swaps not stored on the platform, including valuation
        results, risk metrics, and other relevant measures.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrSwapInstrumentArrayValuationResponse. The IrSwapInstrumentArrayValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapInstrumentArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def value(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.IrSwapDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.IrPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.IrSwapInstrumentArrayValuationResponse:
        """Value IrSwap with custom definition.

        Calculate analytics for one or more swaps not stored on the platform, including valuation
        results, risk metrics, and other relevant measures.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.IrSwapDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.IrPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: IrSwapInstrumentArrayValuationResponse. The IrSwapInstrumentArrayValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapInstrumentArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IrSwapInstrumentArrayValuationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ir_swaps_resource_value_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IrSwapInstrumentArrayValuationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_irs_from_leg_template(
        self,
        *,
        first_leg_reference: str,
        second_leg_reference: str,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from leg templates.

        Create an interest rate swap instance from two interest rate leg templates.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :keyword first_leg_reference: The identifier of the template for the instrument's first leg
         (GUID or URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype first_leg_reference: str
        :keyword second_leg_reference: The identifier of the template for the instrument's second leg
         (GUID or URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype second_leg_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_irs_from_leg_template(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from leg templates.

        Create an interest rate swap instance from two interest rate leg templates.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_irs_from_leg_template(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from leg templates.

        Create an interest rate swap instance from two interest rate leg templates.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create_irs_from_leg_template(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        first_leg_reference: str = _Unset,
        second_leg_reference: str = _Unset,
        fields: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from leg templates.

        Create an interest rate swap instance from two interest rate leg templates.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword first_leg_reference: The identifier of the template for the instrument's first leg
         (GUID or URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype first_leg_reference: str
        :keyword second_leg_reference: The identifier of the template for the instrument's second leg
         (GUID or URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype second_leg_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IrsInstrumentResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if first_leg_reference is _Unset:
                raise TypeError("missing required argument: first_leg_reference")
            if second_leg_reference is _Unset:
                raise TypeError("missing required argument: second_leg_reference")
            body = {"firstLegReference": first_leg_reference, "secondLegReference": second_leg_reference}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ir_swaps_resource_create_irs_from_leg_template_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IrsInstrumentResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_irs_from_vanilla_irs_template(
        self,
        *,
        template_reference: str,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        overrides: Optional[_models.VanillaIrsOverride] = None,
        **kwargs: Any,
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from vanilla IRS template.

        Create an interest rate swap instance from a vanilla IRS template.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :keyword template_reference: "The identifier of the vanilla interest rate swap template (GUID
         or URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword overrides: An object that contains interest rate swap properties that can be
         overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.VanillaIrsOverride
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_irs_from_vanilla_irs_template(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from vanilla IRS template.

        Create an interest rate swap instance from a vanilla IRS template.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_irs_from_vanilla_irs_template(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from vanilla IRS template.

        Create an interest rate swap instance from a vanilla IRS template.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create_irs_from_vanilla_irs_template(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        template_reference: str = _Unset,
        fields: Optional[str] = None,
        overrides: Optional[_models.VanillaIrsOverride] = None,
        **kwargs: Any,
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from vanilla IRS template.

        Create an interest rate swap instance from a vanilla IRS template.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword template_reference: "The identifier of the vanilla interest rate swap template (GUID
         or URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword overrides: An object that contains interest rate swap properties that can be
         overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.VanillaIrsOverride
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IrsInstrumentResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if template_reference is _Unset:
                raise TypeError("missing required argument: template_reference")
            body = {"overrides": overrides, "templateReference": template_reference}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ir_swaps_resource_create_irs_from_vanilla_irs_template_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IrsInstrumentResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_irs_from_tbs_template(
        self,
        *,
        template_reference: str,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        overrides: Optional[_models.TenorBasisSwapOverride] = None,
        **kwargs: Any,
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from TBS template.

        Create an interest rate swap instance from a tenor basis swap template.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :keyword template_reference: "The identifier of the tenor basis swap template (GUID or URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword overrides: An object that contains the tenor basis swap properties that can be
         overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.TenorBasisSwapOverride
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_irs_from_tbs_template(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from TBS template.

        Create an interest rate swap instance from a tenor basis swap template.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_irs_from_tbs_template(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from TBS template.

        Create an interest rate swap instance from a tenor basis swap template.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create_irs_from_tbs_template(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        template_reference: str = _Unset,
        fields: Optional[str] = None,
        overrides: Optional[_models.TenorBasisSwapOverride] = None,
        **kwargs: Any,
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from TBS template.

        Create an interest rate swap instance from a tenor basis swap template.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword template_reference: "The identifier of the tenor basis swap template (GUID or URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword overrides: An object that contains the tenor basis swap properties that can be
         overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.TenorBasisSwapOverride
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IrsInstrumentResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if template_reference is _Unset:
                raise TypeError("missing required argument: template_reference")
            body = {"overrides": overrides, "templateReference": template_reference}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ir_swaps_resource_create_irs_from_tbs_template_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IrsInstrumentResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_irs_from_ccs_template(
        self,
        *,
        template_reference: str,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        overrides: Optional[_models.CrossCurencySwapOverride] = None,
        **kwargs: Any,
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from CCS template.

        Create an interest rate swap instance from a cross currency swap template.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :keyword template_reference: "The identifier of the cross currency swap template (GUID or URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword overrides: An object that contains the cross currency swap properties that can be
         overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.CrossCurencySwapOverride
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_irs_from_ccs_template(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from CCS template.

        Create an interest rate swap instance from a cross currency swap template.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_irs_from_ccs_template(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from CCS template.

        Create an interest rate swap instance from a cross currency swap template.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create_irs_from_ccs_template(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        template_reference: str = _Unset,
        fields: Optional[str] = None,
        overrides: Optional[_models.CrossCurencySwapOverride] = None,
        **kwargs: Any,
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from CCS template.

        Create an interest rate swap instance from a cross currency swap template.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword template_reference: "The identifier of the cross currency swap template (GUID or URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword overrides: An object that contains the cross currency swap properties that can be
         overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.CrossCurencySwapOverride
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IrsInstrumentResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if template_reference is _Unset:
                raise TypeError("missing required argument: template_reference")
            body = {"overrides": overrides, "templateReference": template_reference}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ir_swaps_resource_create_irs_from_ccs_template_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IrsInstrumentResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_irs_from_cbs_template(
        self,
        *,
        template_reference: str,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        overrides: Optional[_models.CurencyBasisSwapOverride] = None,
        **kwargs: Any,
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from CBS template.

        Create an interest rate swap instance from a currency basis swap template.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :keyword template_reference: "The identifier of the currency basis swap template (GUID or URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword overrides: An object that contains the currency basis swap properties that can be
         overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.CurencyBasisSwapOverride
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_irs_from_cbs_template(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from CBS template.

        Create an interest rate swap instance from a currency basis swap template.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_irs_from_cbs_template(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from CBS template.

        Create an interest rate swap instance from a currency basis swap template.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create_irs_from_cbs_template(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        template_reference: str = _Unset,
        fields: Optional[str] = None,
        overrides: Optional[_models.CurencyBasisSwapOverride] = None,
        **kwargs: Any,
    ) -> _models.IrsInstrumentResponse:
        """Create IrSwap from CBS template.

        Create an interest rate swap instance from a currency basis swap template.
        This user-defined instrument includes all trade-specific details (e.g., fixed rate, spread,
        start date, end date), and is typically based on a general template available via the
        Instrument Template API.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword template_reference: "The identifier of the currency basis swap template (GUID or URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword overrides: An object that contains the currency basis swap properties that can be
         overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.CurencyBasisSwapOverride
        :return: IrsInstrumentResponse. The IrsInstrumentResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrsInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IrsInstrumentResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if template_reference is _Unset:
                raise TypeError("missing required argument: template_reference")
            body = {"overrides": overrides, "templateReference": template_reference}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ir_swaps_resource_create_irs_from_cbs_template_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IrsInstrumentResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class irSwapResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`ir_swap_resource` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def read(self, instrument_id: str, *, fields: Optional[str] = None, **kwargs: Any) -> _models.IrSwapResponse:
        """Access a resource that exists in the platform.

        Access a IrSwap existing in the platform (read). The IrSwap can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: IrSwapResponse. The IrSwapResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.IrSwapResponse] = kwargs.pop("cls", None)

        _request = build_ir_swap_resource_read_request(
            instrument_id=instrument_id,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IrSwapResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def delete(self, instrument_id: str, **kwargs: Any) -> None:
        """Delete a resource that exists in the platform.

        Delete a IrSwap that exists in the platform. The IrSwap can be identified either by its unique
        ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :return: None
        :rtype: None
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_ir_swap_resource_delete_request(
            instrument_id=instrument_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def overwrite(
        self,
        instrument_id: str,
        *,
        location: _models.Location,
        definition: _models.IrSwapDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.IrSwapResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a IrSwap that exists in the platform. The IrSwap can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword location: Object defining the location of the IrSwap in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the IrSwap. Required.
        :paramtype definition: ~analyticsapi.models.IrSwapDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the IrSwap. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: IrSwapResponse. The IrSwapResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IrSwapResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a IrSwap that exists in the platform. The IrSwap can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrSwapResponse. The IrSwapResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IrSwapResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a IrSwap that exists in the platform. The IrSwap can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrSwapResponse. The IrSwapResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def overwrite(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.IrSwapDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.IrSwapResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a IrSwap that exists in the platform. The IrSwap can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the IrSwap in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the IrSwap. Required.
        :paramtype definition: ~analyticsapi.models.IrSwapDefinition
        :keyword description: Object defining metadata for the IrSwap. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: IrSwapResponse. The IrSwapResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IrSwapResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ir_swap_resource_overwrite_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IrSwapResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def solve(
        self,
        instrument_id: str,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.IrPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.IrSwapInstrumentSolveResponse:
        """Solve existing IrSwap.

        Calculate analytics for an interest rate swap stored on the platform, by solving a variable
        parameter (e.g., fixed rate) provided in the request,
        so that a specified property (e.g., market value, duration) matches a target value.
        Provide an instrument ID in the request to perform the solving.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.IrPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: IrSwapInstrumentSolveResponse. The IrSwapInstrumentSolveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.IrSwapInstrumentSolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def solve(
        self,
        instrument_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.IrSwapInstrumentSolveResponse:
        """Solve existing IrSwap.

        Calculate analytics for an interest rate swap stored on the platform, by solving a variable
        parameter (e.g., fixed rate) provided in the request,
        so that a specified property (e.g., market value, duration) matches a target value.
        Provide an instrument ID in the request to perform the solving.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrSwapInstrumentSolveResponse. The IrSwapInstrumentSolveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.IrSwapInstrumentSolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def solve(
        self,
        instrument_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.IrSwapInstrumentSolveResponse:
        """Solve existing IrSwap.

        Calculate analytics for an interest rate swap stored on the platform, by solving a variable
        parameter (e.g., fixed rate) provided in the request,
        so that a specified property (e.g., market value, duration) matches a target value.
        Provide an instrument ID in the request to perform the solving.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrSwapInstrumentSolveResponse. The IrSwapInstrumentSolveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.IrSwapInstrumentSolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def solve(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.IrPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.IrSwapInstrumentSolveResponse:
        """Solve existing IrSwap.

        Calculate analytics for an interest rate swap stored on the platform, by solving a variable
        parameter (e.g., fixed rate) provided in the request,
        so that a specified property (e.g., market value, duration) matches a target value.
        Provide an instrument ID in the request to perform the solving.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.IrPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: IrSwapInstrumentSolveResponse. The IrSwapInstrumentSolveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.IrSwapInstrumentSolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IrSwapInstrumentSolveResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ir_swap_resource_solve_request(
            instrument_id=instrument_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IrSwapInstrumentSolveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def value(
        self,
        instrument_id: str,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.IrPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.IrSwapInstrumentValuationResponse:
        """Value existing IrSwap.

        Calculate analytics for an interest rate swap stored on the platform, including valuation
        results, risk metrics, and other relevant measures.
        Provide an instrument ID in the request to perform the valuation.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.IrPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: IrSwapInstrumentValuationResponse. The IrSwapInstrumentValuationResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapInstrumentValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self,
        instrument_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.IrSwapInstrumentValuationResponse:
        """Value existing IrSwap.

        Calculate analytics for an interest rate swap stored on the platform, including valuation
        results, risk metrics, and other relevant measures.
        Provide an instrument ID in the request to perform the valuation.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrSwapInstrumentValuationResponse. The IrSwapInstrumentValuationResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapInstrumentValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self,
        instrument_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.IrSwapInstrumentValuationResponse:
        """Value existing IrSwap.

        Calculate analytics for an interest rate swap stored on the platform, including valuation
        results, risk metrics, and other relevant measures.
        Provide an instrument ID in the request to perform the valuation.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IrSwapInstrumentValuationResponse. The IrSwapInstrumentValuationResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapInstrumentValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def value(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.IrPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.IrSwapInstrumentValuationResponse:
        """Value existing IrSwap.

        Calculate analytics for an interest rate swap stored on the platform, including valuation
        results, risk metrics, and other relevant measures.
        Provide an instrument ID in the request to perform the valuation.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.IrPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: IrSwapInstrumentValuationResponse. The IrSwapInstrumentValuationResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.IrSwapInstrumentValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IrSwapInstrumentValuationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ir_swap_resource_value_request(
            instrument_id=instrument_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IrSwapInstrumentValuationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class floatingRateIndicesResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`floating_rate_indices_resource` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        page: Optional[int] = None,
        spaces: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        space_name_sort_order: Optional[Union[str, _models.SortingOrderEnum]] = None,
        tags: Optional[List[str]] = None,
        fields: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.FloatingRateIndexCollectionResponse:
        """List the resources that exist in the platform.

        List the FloatingRateIndexs existing in the platform (depending on permissions).

        :keyword item_per_page: A parameter used to select the number of items allowed per page. The
         valid range is 1-500. If not provided, 50 will be used. Default value is None.
        :paramtype item_per_page: int
        :keyword page: A parameter used to define the page number to display. Default value is None.
        :paramtype page: int
        :keyword spaces: A parameter used to search for platform resources stored in a given space.
         Space is like a namespace where resources are stored. By default there are two spaces:
         LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space.
         If space is not specified, it will search within all spaces. Default value is None.
        :paramtype spaces: list[str]
        :keyword names: A parameter used to search for platform resources with given names. Default
         value is None.
        :paramtype names: list[str]
        :keyword space_name_sort_order: A parameter used to sort platform resources by name based on a
         defined order. Known values are: "Asc" and "Desc". Default value is None.
        :paramtype space_name_sort_order: str or ~analyticsapi.models.SortingOrderEnum
        :keyword tags: A parameter used to search for platform resources with given tags. Default value
         is None.
        :paramtype tags: list[str]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: FloatingRateIndexCollectionResponse. The FloatingRateIndexCollectionResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.FloatingRateIndexCollectionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FloatingRateIndexCollectionResponse] = kwargs.pop("cls", None)

        _request = build_floating_rate_indices_resource_list_request(
            item_per_page=item_per_page,
            page=page,
            spaces=spaces,
            names=names,
            space_name_sort_order=space_name_sort_order,
            tags=tags,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FloatingRateIndexCollectionResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self,
        *,
        location: _models.Location,
        definition: _models.FloatingRateIndexDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.FloatingRateIndexResponse:
        """Create a new resource to be saved in the platform.

        Save a new FloatingRateIndex in the platform.

        :keyword location: Object defining the location of the FloatingRateIndex in the platform.
         Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the FloatingRateIndex. Required.
        :paramtype definition: ~analyticsapi.models.FloatingRateIndexDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the FloatingRateIndex. Default value is
         None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FloatingRateIndexResponse. The FloatingRateIndexResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FloatingRateIndexResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FloatingRateIndexResponse:
        """Create a new resource to be saved in the platform.

        Save a new FloatingRateIndex in the platform.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FloatingRateIndexResponse. The FloatingRateIndexResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FloatingRateIndexResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FloatingRateIndexResponse:
        """Create a new resource to be saved in the platform.

        Save a new FloatingRateIndex in the platform.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FloatingRateIndexResponse. The FloatingRateIndexResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FloatingRateIndexResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.FloatingRateIndexDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.FloatingRateIndexResponse:
        """Create a new resource to be saved in the platform.

        Save a new FloatingRateIndex in the platform.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the FloatingRateIndex in the platform.
         Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the FloatingRateIndex. Required.
        :paramtype definition: ~analyticsapi.models.FloatingRateIndexDefinition
        :keyword description: Object defining metadata for the FloatingRateIndex. Default value is
         None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FloatingRateIndexResponse. The FloatingRateIndexResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FloatingRateIndexResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FloatingRateIndexResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_floating_rate_indices_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FloatingRateIndexResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class floatingRateIndexResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`floating_rate_index_resource` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def read(
        self, floating_rate_index_id: str, *, fields: Optional[str] = None, **kwargs: Any
    ) -> _models.FloatingRateIndexResponse:
        """Access a resource that exists in the platform.

        Access a FloatingRateIndex existing in the platform (read). The FloatingRateIndex can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param floating_rate_index_id: Required.
        :type floating_rate_index_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: FloatingRateIndexResponse. The FloatingRateIndexResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FloatingRateIndexResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FloatingRateIndexResponse] = kwargs.pop("cls", None)

        _request = build_floating_rate_index_resource_read_request(
            floating_rate_index_id=floating_rate_index_id,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FloatingRateIndexResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def delete(self, floating_rate_index_id: str, **kwargs: Any) -> None:
        """Delete a resource that exists in the platform.

        Delete a FloatingRateIndex that exists in the platform. The FloatingRateIndex can be identified
        either by its unique ID (GUID format) or by its location path (space/name).

        :param floating_rate_index_id: Required.
        :type floating_rate_index_id: str
        :return: None
        :rtype: None
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_floating_rate_index_resource_delete_request(
            floating_rate_index_id=floating_rate_index_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def overwrite(
        self,
        floating_rate_index_id: str,
        *,
        location: _models.Location,
        definition: _models.FloatingRateIndexDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.FloatingRateIndexResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a FloatingRateIndex that exists in the platform. The FloatingRateIndex can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param floating_rate_index_id: Required.
        :type floating_rate_index_id: str
        :keyword location: Object defining the location of the FloatingRateIndex in the platform.
         Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the FloatingRateIndex. Required.
        :paramtype definition: ~analyticsapi.models.FloatingRateIndexDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the FloatingRateIndex. Default value is
         None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FloatingRateIndexResponse. The FloatingRateIndexResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FloatingRateIndexResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, floating_rate_index_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FloatingRateIndexResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a FloatingRateIndex that exists in the platform. The FloatingRateIndex can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param floating_rate_index_id: Required.
        :type floating_rate_index_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FloatingRateIndexResponse. The FloatingRateIndexResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FloatingRateIndexResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, floating_rate_index_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FloatingRateIndexResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a FloatingRateIndex that exists in the platform. The FloatingRateIndex can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param floating_rate_index_id: Required.
        :type floating_rate_index_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FloatingRateIndexResponse. The FloatingRateIndexResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FloatingRateIndexResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def overwrite(
        self,
        floating_rate_index_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.FloatingRateIndexDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.FloatingRateIndexResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a FloatingRateIndex that exists in the platform. The FloatingRateIndex can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param floating_rate_index_id: Required.
        :type floating_rate_index_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the FloatingRateIndex in the platform.
         Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the FloatingRateIndex. Required.
        :paramtype definition: ~analyticsapi.models.FloatingRateIndexDefinition
        :keyword description: Object defining metadata for the FloatingRateIndex. Default value is
         None.
        :paramtype description: ~analyticsapi.models.Description
        :return: FloatingRateIndexResponse. The FloatingRateIndexResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.FloatingRateIndexResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FloatingRateIndexResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_floating_rate_index_resource_overwrite_request(
            floating_rate_index_id=floating_rate_index_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FloatingRateIndexResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class commoditiesCurvesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`commodities_curves` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create(
        self, body: _models.CommoditiesCurveCreateRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CommoditiesCurveResponse:
        """Creates a curve definition.

        :param body: Required.
        :type body: ~analyticsapi.models.CommoditiesCurveCreateRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CommoditiesCurveResponse. The CommoditiesCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CommoditiesCurveResponse:
        """Creates a curve definition.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CommoditiesCurveResponse. The CommoditiesCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CommoditiesCurveResponse:
        """Creates a curve definition.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CommoditiesCurveResponse. The CommoditiesCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create(
        self, body: Union[_models.CommoditiesCurveCreateRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.CommoditiesCurveResponse:
        """Creates a curve definition.

        :param body: Is one of the following types: CommoditiesCurveCreateRequest, JSON, IO[bytes]
         Required.
        :type body: ~analyticsapi.models.CommoditiesCurveCreateRequest or JSON or IO[bytes]
        :return: CommoditiesCurveResponse. The CommoditiesCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CommoditiesCurveResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_commodities_curves_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CommoditiesCurveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    async def read(
        self, curve_id: str, *, fields: Optional[str] = None, **kwargs: Any
    ) -> _models.CommoditiesCurveResponse:
        """Access a CommoditiesCurveDefinition existing in the platform (read). The
        CommoditiesCurveDefinition can be identified either by its unique ID (GUID format) or by its
        location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: CommoditiesCurveResponse. The CommoditiesCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CommoditiesCurveResponse] = kwargs.pop("cls", None)

        _request = build_commodities_curves_read_request(
            curve_id=curve_id,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CommoditiesCurveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def delete(self, curve_id: str, **kwargs: Any) -> None:
        """Delete a CommoditiesCurveDefinition that exists in the platform. The CommoditiesCurveDefinition
        can be identified either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :return: None
        :rtype: None
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_commodities_curves_delete_request(
            curve_id=curve_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def overwrite(
        self,
        curve_id: str,
        body: _models.CommoditiesCurveCreateRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.CommoditiesCurveResponse:
        """Overwrite a CommoditiesCurveDefinition that exists in the platform. The
        CommoditiesCurveDefinition can be identified either by its unique ID (GUID format) or by its
        location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.CommoditiesCurveCreateRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CommoditiesCurveResponse. The CommoditiesCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, curve_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CommoditiesCurveResponse:
        """Overwrite a CommoditiesCurveDefinition that exists in the platform. The
        CommoditiesCurveDefinition can be identified either by its unique ID (GUID format) or by its
        location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CommoditiesCurveResponse. The CommoditiesCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, curve_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CommoditiesCurveResponse:
        """Overwrite a CommoditiesCurveDefinition that exists in the platform. The
        CommoditiesCurveDefinition can be identified either by its unique ID (GUID format) or by its
        location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CommoditiesCurveResponse. The CommoditiesCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def overwrite(
        self, curve_id: str, body: Union[_models.CommoditiesCurveCreateRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.CommoditiesCurveResponse:
        """Overwrite a CommoditiesCurveDefinition that exists in the platform. The
        CommoditiesCurveDefinition can be identified either by its unique ID (GUID format) or by its
        location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Is one of the following types: CommoditiesCurveCreateRequest, JSON, IO[bytes]
         Required.
        :type body: ~analyticsapi.models.CommoditiesCurveCreateRequest or JSON or IO[bytes]
        :return: CommoditiesCurveResponse. The CommoditiesCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CommoditiesCurveResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_commodities_curves_overwrite_request(
            curve_id=curve_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CommoditiesCurveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def calculate_by_id(
        self,
        curve_id: str,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        valuation_date: Optional[datetime.date] = None,
        **kwargs: Any,
    ) -> _models.CommoditiesCurvesResponseItem:
        """Generates the curve for the given curve id.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword valuation_date: The date on which the curve is constructed. The value is expressed in
         ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
         The valuation date should not be in the future. Default value is None.
        :paramtype valuation_date: ~datetime.date
        :return: CommoditiesCurvesResponseItem. The CommoditiesCurvesResponseItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurvesResponseItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate_by_id(
        self,
        curve_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.CommoditiesCurvesResponseItem:
        """Generates the curve for the given curve id.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CommoditiesCurvesResponseItem. The CommoditiesCurvesResponseItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurvesResponseItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate_by_id(
        self,
        curve_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.CommoditiesCurvesResponseItem:
        """Generates the curve for the given curve id.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CommoditiesCurvesResponseItem. The CommoditiesCurvesResponseItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurvesResponseItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def calculate_by_id(
        self,
        curve_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        valuation_date: Optional[datetime.date] = None,
        **kwargs: Any,
    ) -> _models.CommoditiesCurvesResponseItem:
        """Generates the curve for the given curve id.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword valuation_date: The date on which the curve is constructed. The value is expressed in
         ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
         The valuation date should not be in the future. Default value is None.
        :paramtype valuation_date: ~datetime.date
        :return: CommoditiesCurvesResponseItem. The CommoditiesCurvesResponseItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurvesResponseItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CommoditiesCurvesResponseItem] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"valuationDate": valuation_date}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_commodities_curves_calculate_by_id_request(
            curve_id=curve_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CommoditiesCurvesResponseItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def search(
        self,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        universe: Optional[List[_models.CommoditiesCurveDefinitionRequest]] = None,
        **kwargs: Any,
    ) -> _models.CommoditiesCurveDefinitionsResponse:
        """Returns the definitions of the available curves for the filters selected.

        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword universe: Get universe. Default value is None.
        :paramtype universe: list[~analyticsapi.models.CommoditiesCurveDefinitionRequest]
        :return: CommoditiesCurveDefinitionsResponse. The CommoditiesCurveDefinitionsResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurveDefinitionsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def search(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CommoditiesCurveDefinitionsResponse:
        """Returns the definitions of the available curves for the filters selected.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CommoditiesCurveDefinitionsResponse. The CommoditiesCurveDefinitionsResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurveDefinitionsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def search(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CommoditiesCurveDefinitionsResponse:
        """Returns the definitions of the available curves for the filters selected.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CommoditiesCurveDefinitionsResponse. The CommoditiesCurveDefinitionsResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurveDefinitionsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def search(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        universe: Optional[List[_models.CommoditiesCurveDefinitionRequest]] = None,
        **kwargs: Any,
    ) -> _models.CommoditiesCurveDefinitionsResponse:
        """Returns the definitions of the available curves for the filters selected.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword universe: Get universe. Default value is None.
        :paramtype universe: list[~analyticsapi.models.CommoditiesCurveDefinitionRequest]
        :return: CommoditiesCurveDefinitionsResponse. The CommoditiesCurveDefinitionsResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurveDefinitionsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CommoditiesCurveDefinitionsResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"universe": universe}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_commodities_curves_search_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CommoditiesCurveDefinitionsResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def calculate(
        self,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        universe: Optional[List[_models.CommoditiesCurveRequestItem]] = None,
        **kwargs: Any,
    ) -> _models.CommoditiesCurvesResponse:
        """Generates the curves for the definitions provided.

        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword universe: Default value is None.
        :paramtype universe: list[~analyticsapi.models.CommoditiesCurveRequestItem]
        :return: CommoditiesCurvesResponse. The CommoditiesCurvesResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurvesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CommoditiesCurvesResponse:
        """Generates the curves for the definitions provided.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CommoditiesCurvesResponse. The CommoditiesCurvesResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurvesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CommoditiesCurvesResponse:
        """Generates the curves for the definitions provided.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CommoditiesCurvesResponse. The CommoditiesCurvesResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurvesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def calculate(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        universe: Optional[List[_models.CommoditiesCurveRequestItem]] = None,
        **kwargs: Any,
    ) -> _models.CommoditiesCurvesResponse:
        """Generates the curves for the definitions provided.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword universe: Default value is None.
        :paramtype universe: list[~analyticsapi.models.CommoditiesCurveRequestItem]
        :return: CommoditiesCurvesResponse. The CommoditiesCurvesResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CommoditiesCurvesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CommoditiesCurvesResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"universe": universe}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_commodities_curves_calculate_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CommoditiesCurvesResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class creditCurvesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`credit_curves` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create(
        self, body: _models.CreditCurveCreateRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreditCurveResponse:
        """Creates a curve definition.

        :param body: Required.
        :type body: ~analyticsapi.models.CreditCurveCreateRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreditCurveResponse. The CreditCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CreditCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreditCurveResponse:
        """Creates a curve definition.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreditCurveResponse. The CreditCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CreditCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreditCurveResponse:
        """Creates a curve definition.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreditCurveResponse. The CreditCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CreditCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create(
        self, body: Union[_models.CreditCurveCreateRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.CreditCurveResponse:
        """Creates a curve definition.

        :param body: Is one of the following types: CreditCurveCreateRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.CreditCurveCreateRequest or JSON or IO[bytes]
        :return: CreditCurveResponse. The CreditCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CreditCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CreditCurveResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_credit_curves_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CreditCurveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    async def read(self, curve_id: str, *, fields: Optional[str] = None, **kwargs: Any) -> _models.CreditCurveResponse:
        """Access a CreditCurveDefinition existing in the platform (read). The CreditCurveDefinition can
        be identified either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: CreditCurveResponse. The CreditCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CreditCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CreditCurveResponse] = kwargs.pop("cls", None)

        _request = build_credit_curves_read_request(
            curve_id=curve_id,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CreditCurveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def delete(self, curve_id: str, **kwargs: Any) -> None:
        """Delete a CreditCurveDefinition that exists in the platform. The CreditCurveDefinition can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :return: None
        :rtype: None
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_credit_curves_delete_request(
            curve_id=curve_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def overwrite(
        self,
        curve_id: str,
        body: _models.CreditCurveCreateRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.CreditCurveResponse:
        """Overwrite a CreditCurveDefinition that exists in the platform. The CreditCurveDefinition can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.CreditCurveCreateRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreditCurveResponse. The CreditCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CreditCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, curve_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreditCurveResponse:
        """Overwrite a CreditCurveDefinition that exists in the platform. The CreditCurveDefinition can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreditCurveResponse. The CreditCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CreditCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, curve_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreditCurveResponse:
        """Overwrite a CreditCurveDefinition that exists in the platform. The CreditCurveDefinition can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreditCurveResponse. The CreditCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CreditCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def overwrite(
        self, curve_id: str, body: Union[_models.CreditCurveCreateRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.CreditCurveResponse:
        """Overwrite a CreditCurveDefinition that exists in the platform. The CreditCurveDefinition can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Is one of the following types: CreditCurveCreateRequest, JSON, IO[bytes] Required.
        :type body: ~analyticsapi.models.CreditCurveCreateRequest or JSON or IO[bytes]
        :return: CreditCurveResponse. The CreditCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CreditCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CreditCurveResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_credit_curves_overwrite_request(
            curve_id=curve_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CreditCurveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def calculate_by_id(
        self,
        curve_id: str,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        valuation_date: Optional[datetime.date] = None,
        **kwargs: Any,
    ) -> _models.CreditCurvesResponseItem:
        """Generates the curve for the given curve id.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword valuation_date: The date on which the curve is constructed. The value is expressed in
         ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
         The valuation date should not be in the future. Default value is None.
        :paramtype valuation_date: ~datetime.date
        :return: CreditCurvesResponseItem. The CreditCurvesResponseItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CreditCurvesResponseItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate_by_id(
        self,
        curve_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.CreditCurvesResponseItem:
        """Generates the curve for the given curve id.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreditCurvesResponseItem. The CreditCurvesResponseItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CreditCurvesResponseItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate_by_id(
        self,
        curve_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.CreditCurvesResponseItem:
        """Generates the curve for the given curve id.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreditCurvesResponseItem. The CreditCurvesResponseItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CreditCurvesResponseItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def calculate_by_id(
        self,
        curve_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        valuation_date: Optional[datetime.date] = None,
        **kwargs: Any,
    ) -> _models.CreditCurvesResponseItem:
        """Generates the curve for the given curve id.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword valuation_date: The date on which the curve is constructed. The value is expressed in
         ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
         The valuation date should not be in the future. Default value is None.
        :paramtype valuation_date: ~datetime.date
        :return: CreditCurvesResponseItem. The CreditCurvesResponseItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CreditCurvesResponseItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CreditCurvesResponseItem] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"valuationDate": valuation_date}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_credit_curves_calculate_by_id_request(
            curve_id=curve_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CreditCurvesResponseItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def search(
        self,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        universe: Optional[List[_models.CreditCurveSearchDefinition]] = None,
        **kwargs: Any,
    ) -> _models.CreditCurveDefinitionsResponse:
        """Returns the definitions of the available curves for the filters selected.

        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword universe: Get universe. Default value is None.
        :paramtype universe: list[~analyticsapi.models.CreditCurveSearchDefinition]
        :return: CreditCurveDefinitionsResponse. The CreditCurveDefinitionsResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CreditCurveDefinitionsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def search(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreditCurveDefinitionsResponse:
        """Returns the definitions of the available curves for the filters selected.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreditCurveDefinitionsResponse. The CreditCurveDefinitionsResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CreditCurveDefinitionsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def search(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreditCurveDefinitionsResponse:
        """Returns the definitions of the available curves for the filters selected.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreditCurveDefinitionsResponse. The CreditCurveDefinitionsResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CreditCurveDefinitionsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def search(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        universe: Optional[List[_models.CreditCurveSearchDefinition]] = None,
        **kwargs: Any,
    ) -> _models.CreditCurveDefinitionsResponse:
        """Returns the definitions of the available curves for the filters selected.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword universe: Get universe. Default value is None.
        :paramtype universe: list[~analyticsapi.models.CreditCurveSearchDefinition]
        :return: CreditCurveDefinitionsResponse. The CreditCurveDefinitionsResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CreditCurveDefinitionsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CreditCurveDefinitionsResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"universe": universe}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_credit_curves_search_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CreditCurveDefinitionsResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def calculate(
        self,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        universe: Optional[List[_models.CreditCurveRequestItem]] = None,
        **kwargs: Any,
    ) -> _models.CreditCurvesResponse:
        """Generates the curves for the definitions provided.

        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword universe: Default value is None.
        :paramtype universe: list[~analyticsapi.models.CreditCurveRequestItem]
        :return: CreditCurvesResponse. The CreditCurvesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CreditCurvesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreditCurvesResponse:
        """Generates the curves for the definitions provided.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreditCurvesResponse. The CreditCurvesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CreditCurvesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreditCurvesResponse:
        """Generates the curves for the definitions provided.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreditCurvesResponse. The CreditCurvesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CreditCurvesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def calculate(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        universe: Optional[List[_models.CreditCurveRequestItem]] = None,
        **kwargs: Any,
    ) -> _models.CreditCurvesResponse:
        """Generates the curves for the definitions provided.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword universe: Default value is None.
        :paramtype universe: list[~analyticsapi.models.CreditCurveRequestItem]
        :return: CreditCurvesResponse. The CreditCurvesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CreditCurvesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CreditCurvesResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"universe": universe}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_credit_curves_calculate_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CreditCurvesResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class inflationCurvesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`inflation_curves` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create(
        self, body: _models.InflationCurveCreateRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InflationCurveResponse:
        """Creates a curve definition.

        :param body: Required.
        :type body: ~analyticsapi.models.InflationCurveCreateRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InflationCurveResponse. The InflationCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.InflationCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InflationCurveResponse:
        """Creates a curve definition.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InflationCurveResponse. The InflationCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.InflationCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InflationCurveResponse:
        """Creates a curve definition.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InflationCurveResponse. The InflationCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.InflationCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create(
        self, body: Union[_models.InflationCurveCreateRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.InflationCurveResponse:
        """Creates a curve definition.

        :param body: Is one of the following types: InflationCurveCreateRequest, JSON, IO[bytes]
         Required.
        :type body: ~analyticsapi.models.InflationCurveCreateRequest or JSON or IO[bytes]
        :return: InflationCurveResponse. The InflationCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.InflationCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.InflationCurveResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_inflation_curves_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.InflationCurveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    async def read(
        self, curve_id: str, *, fields: Optional[str] = None, **kwargs: Any
    ) -> _models.InflationCurveResponse:
        """Access a InflationCurveDefinition existing in the platform (read). The InflationCurveDefinition
        can be identified either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: InflationCurveResponse. The InflationCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.InflationCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.InflationCurveResponse] = kwargs.pop("cls", None)

        _request = build_inflation_curves_read_request(
            curve_id=curve_id,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.InflationCurveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def delete(self, curve_id: str, **kwargs: Any) -> None:
        """Delete a InflationCurveDefinition that exists in the platform. The InflationCurveDefinition can
        be identified either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :return: None
        :rtype: None
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_inflation_curves_delete_request(
            curve_id=curve_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def overwrite(
        self,
        curve_id: str,
        body: _models.InflationCurveCreateRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.InflationCurveResponse:
        """Overwrite a InflationCurveDefinition that exists in the platform. The InflationCurveDefinition
        can be identified either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.InflationCurveCreateRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InflationCurveResponse. The InflationCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.InflationCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, curve_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InflationCurveResponse:
        """Overwrite a InflationCurveDefinition that exists in the platform. The InflationCurveDefinition
        can be identified either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InflationCurveResponse. The InflationCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.InflationCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, curve_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InflationCurveResponse:
        """Overwrite a InflationCurveDefinition that exists in the platform. The InflationCurveDefinition
        can be identified either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InflationCurveResponse. The InflationCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.InflationCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def overwrite(
        self, curve_id: str, body: Union[_models.InflationCurveCreateRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.InflationCurveResponse:
        """Overwrite a InflationCurveDefinition that exists in the platform. The InflationCurveDefinition
        can be identified either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Is one of the following types: InflationCurveCreateRequest, JSON, IO[bytes]
         Required.
        :type body: ~analyticsapi.models.InflationCurveCreateRequest or JSON or IO[bytes]
        :return: InflationCurveResponse. The InflationCurveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.InflationCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.InflationCurveResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_inflation_curves_overwrite_request(
            curve_id=curve_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.InflationCurveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def calculate_by_id(
        self,
        curve_id: str,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        valuation_date: Optional[datetime.date] = None,
        **kwargs: Any,
    ) -> _models.InflationCurvesResponseItem:
        """Generates the curve for the given curve id.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword valuation_date: The date on which the curve is constructed. The value is expressed in
         ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
         The valuation date should not be in the future. Default value is None.
        :paramtype valuation_date: ~datetime.date
        :return: InflationCurvesResponseItem. The InflationCurvesResponseItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InflationCurvesResponseItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate_by_id(
        self,
        curve_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.InflationCurvesResponseItem:
        """Generates the curve for the given curve id.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InflationCurvesResponseItem. The InflationCurvesResponseItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InflationCurvesResponseItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate_by_id(
        self,
        curve_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.InflationCurvesResponseItem:
        """Generates the curve for the given curve id.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InflationCurvesResponseItem. The InflationCurvesResponseItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InflationCurvesResponseItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def calculate_by_id(
        self,
        curve_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        valuation_date: Optional[datetime.date] = None,
        **kwargs: Any,
    ) -> _models.InflationCurvesResponseItem:
        """Generates the curve for the given curve id.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword valuation_date: The date on which the curve is constructed. The value is expressed in
         ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
         The valuation date should not be in the future. Default value is None.
        :paramtype valuation_date: ~datetime.date
        :return: InflationCurvesResponseItem. The InflationCurvesResponseItem is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InflationCurvesResponseItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.InflationCurvesResponseItem] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"valuationDate": valuation_date}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_inflation_curves_calculate_by_id_request(
            curve_id=curve_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.InflationCurvesResponseItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def search(
        self,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        universe: Optional[List[_models.InflationCurveGetDefinitionItem]] = None,
        **kwargs: Any,
    ) -> _models.InflationCurveDefinitionsResponse:
        """Returns the definitions of the available curves for the filters selected.

        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword universe: The list of the curve items which can be requested. Default value is None.
        :paramtype universe: list[~analyticsapi.models.InflationCurveGetDefinitionItem]
        :return: InflationCurveDefinitionsResponse. The InflationCurveDefinitionsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.InflationCurveDefinitionsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def search(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InflationCurveDefinitionsResponse:
        """Returns the definitions of the available curves for the filters selected.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InflationCurveDefinitionsResponse. The InflationCurveDefinitionsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.InflationCurveDefinitionsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def search(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InflationCurveDefinitionsResponse:
        """Returns the definitions of the available curves for the filters selected.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InflationCurveDefinitionsResponse. The InflationCurveDefinitionsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.InflationCurveDefinitionsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def search(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        universe: Optional[List[_models.InflationCurveGetDefinitionItem]] = None,
        **kwargs: Any,
    ) -> _models.InflationCurveDefinitionsResponse:
        """Returns the definitions of the available curves for the filters selected.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword universe: The list of the curve items which can be requested. Default value is None.
        :paramtype universe: list[~analyticsapi.models.InflationCurveGetDefinitionItem]
        :return: InflationCurveDefinitionsResponse. The InflationCurveDefinitionsResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.InflationCurveDefinitionsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.InflationCurveDefinitionsResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"universe": universe}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_inflation_curves_search_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.InflationCurveDefinitionsResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def calculate(
        self,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        universe: Optional[List[_models.InflationCurvesRequestItem]] = None,
        **kwargs: Any,
    ) -> _models.InflationCurvesResponse:
        """Generates the curves for the definitions provided.

        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword universe: Default value is None.
        :paramtype universe: list[~analyticsapi.models.InflationCurvesRequestItem]
        :return: InflationCurvesResponse. The InflationCurvesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.InflationCurvesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InflationCurvesResponse:
        """Generates the curves for the definitions provided.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InflationCurvesResponse. The InflationCurvesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.InflationCurvesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InflationCurvesResponse:
        """Generates the curves for the definitions provided.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InflationCurvesResponse. The InflationCurvesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.InflationCurvesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def calculate(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        universe: Optional[List[_models.InflationCurvesRequestItem]] = None,
        **kwargs: Any,
    ) -> _models.InflationCurvesResponse:
        """Generates the curves for the definitions provided.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword universe: Default value is None.
        :paramtype universe: list[~analyticsapi.models.InflationCurvesRequestItem]
        :return: InflationCurvesResponse. The InflationCurvesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.InflationCurvesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.InflationCurvesResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"universe": universe}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_inflation_curves_calculate_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.InflationCurvesResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ipaInterestRateCurvesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`ipa_interest_rate_curves` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create(
        self, body: _models.InterestRateCurveCreateRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IPAInterestRateCurveResponse:
        """Creates a curve definition.

        :param body: Required.
        :type body: ~analyticsapi.models.InterestRateCurveCreateRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IPAInterestRateCurveResponse. The IPAInterestRateCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.IPAInterestRateCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IPAInterestRateCurveResponse:
        """Creates a curve definition.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IPAInterestRateCurveResponse. The IPAInterestRateCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.IPAInterestRateCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IPAInterestRateCurveResponse:
        """Creates a curve definition.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IPAInterestRateCurveResponse. The IPAInterestRateCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.IPAInterestRateCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create(
        self, body: Union[_models.InterestRateCurveCreateRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.IPAInterestRateCurveResponse:
        """Creates a curve definition.

        :param body: Is one of the following types: InterestRateCurveCreateRequest, JSON, IO[bytes]
         Required.
        :type body: ~analyticsapi.models.InterestRateCurveCreateRequest or JSON or IO[bytes]
        :return: IPAInterestRateCurveResponse. The IPAInterestRateCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.IPAInterestRateCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IPAInterestRateCurveResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ipa_interest_rate_curves_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IPAInterestRateCurveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    async def read(
        self, curve_id: str, *, fields: Optional[str] = None, **kwargs: Any
    ) -> _models.IPAInterestRateCurveResponse:
        """Access a InterestRateCurveDefinition existing in the platform (read). The
        InterestRateCurveDefinition can be identified either by its unique ID (GUID format) or by its
        location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: IPAInterestRateCurveResponse. The IPAInterestRateCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.IPAInterestRateCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.IPAInterestRateCurveResponse] = kwargs.pop("cls", None)

        _request = build_ipa_interest_rate_curves_read_request(
            curve_id=curve_id,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IPAInterestRateCurveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def delete(self, curve_id: str, **kwargs: Any) -> None:
        """Delete a InterestRateCurveDefinition that exists in the platform. The
        InterestRateCurveDefinition can be identified either by its unique ID (GUID format) or by its
        location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :return: None
        :rtype: None
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_ipa_interest_rate_curves_delete_request(
            curve_id=curve_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def overwrite(
        self,
        curve_id: str,
        body: _models.InterestRateCurveCreateRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.IPAInterestRateCurveResponse:
        """Overwrite a InterestRateCurveDefinition that exists in the platform. The
        InterestRateCurveDefinition can be identified either by its unique ID (GUID format) or by its
        location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: ~analyticsapi.models.InterestRateCurveCreateRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IPAInterestRateCurveResponse. The IPAInterestRateCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.IPAInterestRateCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, curve_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IPAInterestRateCurveResponse:
        """Overwrite a InterestRateCurveDefinition that exists in the platform. The
        InterestRateCurveDefinition can be identified either by its unique ID (GUID format) or by its
        location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IPAInterestRateCurveResponse. The IPAInterestRateCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.IPAInterestRateCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, curve_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IPAInterestRateCurveResponse:
        """Overwrite a InterestRateCurveDefinition that exists in the platform. The
        InterestRateCurveDefinition can be identified either by its unique ID (GUID format) or by its
        location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IPAInterestRateCurveResponse. The IPAInterestRateCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.IPAInterestRateCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def overwrite(
        self, curve_id: str, body: Union[_models.InterestRateCurveCreateRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.IPAInterestRateCurveResponse:
        """Overwrite a InterestRateCurveDefinition that exists in the platform. The
        InterestRateCurveDefinition can be identified either by its unique ID (GUID format) or by its
        location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Is one of the following types: InterestRateCurveCreateRequest, JSON, IO[bytes]
         Required.
        :type body: ~analyticsapi.models.InterestRateCurveCreateRequest or JSON or IO[bytes]
        :return: IPAInterestRateCurveResponse. The IPAInterestRateCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.IPAInterestRateCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IPAInterestRateCurveResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ipa_interest_rate_curves_overwrite_request(
            curve_id=curve_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IPAInterestRateCurveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def calculate_by_id(
        self,
        curve_id: str,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        valuation_date: Optional[datetime.date] = None,
        **kwargs: Any,
    ) -> _models.ZcCurvesResponseItem:
        """Generates the curve for the given curve id.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword valuation_date: The date on which the curve is constructed. The value is expressed in
         ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
         The valuation date should not be in the future. Default value is None.
        :paramtype valuation_date: ~datetime.date
        :return: ZcCurvesResponseItem. The ZcCurvesResponseItem is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ZcCurvesResponseItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate_by_id(
        self,
        curve_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ZcCurvesResponseItem:
        """Generates the curve for the given curve id.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ZcCurvesResponseItem. The ZcCurvesResponseItem is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ZcCurvesResponseItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate_by_id(
        self,
        curve_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ZcCurvesResponseItem:
        """Generates the curve for the given curve id.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ZcCurvesResponseItem. The ZcCurvesResponseItem is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ZcCurvesResponseItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def calculate_by_id(
        self,
        curve_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        valuation_date: Optional[datetime.date] = None,
        **kwargs: Any,
    ) -> _models.ZcCurvesResponseItem:
        """Generates the curve for the given curve id.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword valuation_date: The date on which the curve is constructed. The value is expressed in
         ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
         The valuation date should not be in the future. Default value is None.
        :paramtype valuation_date: ~datetime.date
        :return: ZcCurvesResponseItem. The ZcCurvesResponseItem is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ZcCurvesResponseItem
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ZcCurvesResponseItem] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"valuationDate": valuation_date}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ipa_interest_rate_curves_calculate_by_id_request(
            curve_id=curve_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ZcCurvesResponseItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def search(
        self,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        universe: Optional[List[_models.ZcCurveDefinitionRequest]] = None,
        **kwargs: Any,
    ) -> _models.ZcCurveDefinitionsResponse:
        """Returns the definitions of the available curves for the filters selected.

        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword universe: Get universe. Default value is None.
        :paramtype universe: list[~analyticsapi.models.ZcCurveDefinitionRequest]
        :return: ZcCurveDefinitionsResponse. The ZcCurveDefinitionsResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ZcCurveDefinitionsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def search(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ZcCurveDefinitionsResponse:
        """Returns the definitions of the available curves for the filters selected.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ZcCurveDefinitionsResponse. The ZcCurveDefinitionsResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ZcCurveDefinitionsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def search(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ZcCurveDefinitionsResponse:
        """Returns the definitions of the available curves for the filters selected.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ZcCurveDefinitionsResponse. The ZcCurveDefinitionsResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ZcCurveDefinitionsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def search(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        universe: Optional[List[_models.ZcCurveDefinitionRequest]] = None,
        **kwargs: Any,
    ) -> _models.ZcCurveDefinitionsResponse:
        """Returns the definitions of the available curves for the filters selected.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword universe: Get universe. Default value is None.
        :paramtype universe: list[~analyticsapi.models.ZcCurveDefinitionRequest]
        :return: ZcCurveDefinitionsResponse. The ZcCurveDefinitionsResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.ZcCurveDefinitionsResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ZcCurveDefinitionsResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"universe": universe}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ipa_interest_rate_curves_search_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ZcCurveDefinitionsResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def calculate(
        self,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        universe: Optional[List[_models.ZcCurveRequestItem]] = None,
        **kwargs: Any,
    ) -> _models.ZcCurvesResponse:
        """Generates the curves for the definitions provided.

        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword universe: Default value is None.
        :paramtype universe: list[~analyticsapi.models.ZcCurveRequestItem]
        :return: ZcCurvesResponse. The ZcCurvesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ZcCurvesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ZcCurvesResponse:
        """Generates the curves for the definitions provided.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ZcCurvesResponse. The ZcCurvesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ZcCurvesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ZcCurvesResponse:
        """Generates the curves for the definitions provided.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ZcCurvesResponse. The ZcCurvesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ZcCurvesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def calculate(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        universe: Optional[List[_models.ZcCurveRequestItem]] = None,
        **kwargs: Any,
    ) -> _models.ZcCurvesResponse:
        """Generates the curves for the definitions provided.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword universe: Default value is None.
        :paramtype universe: list[~analyticsapi.models.ZcCurveRequestItem]
        :return: ZcCurvesResponse. The ZcCurvesResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ZcCurvesResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ZcCurvesResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"universe": universe}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ipa_interest_rate_curves_calculate_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ZcCurvesResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class bondOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`bond` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def price(
        self,
        *,
        definitions: List[_models.BondDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.BondPricingParameters] = None,
        market_data: Optional[_models.MarketDataQps] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.BondCalculationResponse:
        """Calculate Bond analytics.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.BondDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.BondPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataQps
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: BondCalculationResponse. The BondCalculationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BondCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.BondCalculationResponse:
        """Calculate Bond analytics.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BondCalculationResponse. The BondCalculationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BondCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.BondCalculationResponse:
        """Calculate Bond analytics.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BondCalculationResponse. The BondCalculationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BondCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def price(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.BondDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.BondPricingParameters] = None,
        market_data: Optional[_models.MarketDataQps] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.BondCalculationResponse:
        """Calculate Bond analytics.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.BondDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.BondPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataQps
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: BondCalculationResponse. The BondCalculationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.BondCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.BondCalculationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_bond_price_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.BondCalculationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class bondFutureOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`bond_future` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def price(
        self,
        *,
        definitions: List[_models.BondFutureDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.BondFuturePricingParameters] = None,
        market_data: Optional[_models.MarketDataQps] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.BondFutureCalculationResponse:
        """Calculate BondFuture analytics.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.BondFutureDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.BondFuturePricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataQps
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: BondFutureCalculationResponse. The BondFutureCalculationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.BondFutureCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.BondFutureCalculationResponse:
        """Calculate BondFuture analytics.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BondFutureCalculationResponse. The BondFutureCalculationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.BondFutureCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.BondFutureCalculationResponse:
        """Calculate BondFuture analytics.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BondFutureCalculationResponse. The BondFutureCalculationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.BondFutureCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def price(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.BondFutureDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.BondFuturePricingParameters] = None,
        market_data: Optional[_models.MarketDataQps] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.BondFutureCalculationResponse:
        """Calculate BondFuture analytics.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.BondFutureDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.BondFuturePricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataQps
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: BondFutureCalculationResponse. The BondFutureCalculationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.BondFutureCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.BondFutureCalculationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_bond_future_price_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.BondFutureCalculationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class capFloorOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`cap_floor` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def price(
        self,
        *,
        definitions: List[_models.IPACapFloorDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.CapFloorPricingParameters] = None,
        market_data: Optional[_models.MarketDataQps] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.CapFloorCalculationResponse:
        """Calculate CapFloor analytics.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.IPACapFloorDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.CapFloorPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataQps
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: CapFloorCalculationResponse. The CapFloorCalculationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CapFloorCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CapFloorCalculationResponse:
        """Calculate CapFloor analytics.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CapFloorCalculationResponse. The CapFloorCalculationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CapFloorCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CapFloorCalculationResponse:
        """Calculate CapFloor analytics.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CapFloorCalculationResponse. The CapFloorCalculationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CapFloorCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def price(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.IPACapFloorDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.CapFloorPricingParameters] = None,
        market_data: Optional[_models.MarketDataQps] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.CapFloorCalculationResponse:
        """Calculate CapFloor analytics.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.IPACapFloorDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.CapFloorPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataQps
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: CapFloorCalculationResponse. The CapFloorCalculationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.CapFloorCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CapFloorCalculationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_cap_floor_price_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CapFloorCalculationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class cdsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`cds` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def price(
        self,
        *,
        definitions: List[_models.CdsDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.CdsPricingParameters] = None,
        market_data: Optional[_models.MarketDataQps] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.CdsCalculationResponse:
        """Calculate Cds analytics.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.CdsDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.CdsPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataQps
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: CdsCalculationResponse. The CdsCalculationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CdsCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CdsCalculationResponse:
        """Calculate Cds analytics.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CdsCalculationResponse. The CdsCalculationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CdsCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CdsCalculationResponse:
        """Calculate Cds analytics.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CdsCalculationResponse. The CdsCalculationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CdsCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def price(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.CdsDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.CdsPricingParameters] = None,
        market_data: Optional[_models.MarketDataQps] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.CdsCalculationResponse:
        """Calculate Cds analytics.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.CdsDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.CdsPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataQps
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: CdsCalculationResponse. The CdsCalculationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.CdsCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CdsCalculationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_cds_price_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CdsCalculationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class forwardRateAgreementOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`forward_rate_agreement` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def price(
        self,
        *,
        definitions: List[_models.ForwardRateAgreementDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.ForwardRateAgreementPricingParameters] = None,
        market_data: Optional[_models.MarketDataQps] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.ForwardRateAgreementCalculationResponse:
        """Calculate ForwardRateAgreement analytics.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.ForwardRateAgreementDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.ForwardRateAgreementPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataQps
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: ForwardRateAgreementCalculationResponse. The ForwardRateAgreementCalculationResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ForwardRateAgreementCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ForwardRateAgreementCalculationResponse:
        """Calculate ForwardRateAgreement analytics.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ForwardRateAgreementCalculationResponse. The ForwardRateAgreementCalculationResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ForwardRateAgreementCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ForwardRateAgreementCalculationResponse:
        """Calculate ForwardRateAgreement analytics.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ForwardRateAgreementCalculationResponse. The ForwardRateAgreementCalculationResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ForwardRateAgreementCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def price(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.ForwardRateAgreementDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.ForwardRateAgreementPricingParameters] = None,
        market_data: Optional[_models.MarketDataQps] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.ForwardRateAgreementCalculationResponse:
        """Calculate ForwardRateAgreement analytics.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.ForwardRateAgreementDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.ForwardRateAgreementPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataQps
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: ForwardRateAgreementCalculationResponse. The ForwardRateAgreementCalculationResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.ForwardRateAgreementCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ForwardRateAgreementCalculationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_forward_rate_agreement_price_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ForwardRateAgreementCalculationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class repoOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`repo` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def price(
        self,
        *,
        definitions: List[_models.RepoDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.RepoPricingParameters] = None,
        market_data: Optional[_models.MarketDataQps] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.RepoCalculationResponse:
        """Calculate Repo analytics.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.RepoDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.RepoPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataQps
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: RepoCalculationResponse. The RepoCalculationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RepoCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RepoCalculationResponse:
        """Calculate Repo analytics.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RepoCalculationResponse. The RepoCalculationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RepoCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RepoCalculationResponse:
        """Calculate Repo analytics.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RepoCalculationResponse. The RepoCalculationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RepoCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def price(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.RepoDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.RepoPricingParameters] = None,
        market_data: Optional[_models.MarketDataQps] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.RepoCalculationResponse:
        """Calculate Repo analytics.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.RepoDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.RepoPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataQps
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: RepoCalculationResponse. The RepoCalculationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.RepoCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RepoCalculationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_repo_price_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RepoCalculationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class structuredProductsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`structured_products` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def price(
        self,
        *,
        definitions: List[_models.StructuredProductsDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.StructuredProductsPricingParameters] = None,
        market_data: Optional[_models.MarketDataQps] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.StructuredProductsCalculationResponse:
        """Calculate StructuredProducts analytics.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.StructuredProductsDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.StructuredProductsPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataQps
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: StructuredProductsCalculationResponse. The StructuredProductsCalculationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.StructuredProductsCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.StructuredProductsCalculationResponse:
        """Calculate StructuredProducts analytics.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StructuredProductsCalculationResponse. The StructuredProductsCalculationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.StructuredProductsCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.StructuredProductsCalculationResponse:
        """Calculate StructuredProducts analytics.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StructuredProductsCalculationResponse. The StructuredProductsCalculationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.StructuredProductsCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def price(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.StructuredProductsDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.StructuredProductsPricingParameters] = None,
        market_data: Optional[_models.MarketDataQps] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.StructuredProductsCalculationResponse:
        """Calculate StructuredProducts analytics.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.StructuredProductsDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.StructuredProductsPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataQps
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: StructuredProductsCalculationResponse. The StructuredProductsCalculationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.StructuredProductsCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StructuredProductsCalculationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_structured_products_price_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StructuredProductsCalculationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class swaptionOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`swaption` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def price(
        self,
        *,
        definitions: List[_models.SwaptionDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.SwaptionPricingParameters] = None,
        market_data: Optional[_models.MarketDataQps] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.SwaptionCalculationResponse:
        """Calculate Swaption analytics.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.SwaptionDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.SwaptionPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataQps
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: SwaptionCalculationResponse. The SwaptionCalculationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.SwaptionCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SwaptionCalculationResponse:
        """Calculate Swaption analytics.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SwaptionCalculationResponse. The SwaptionCalculationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.SwaptionCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SwaptionCalculationResponse:
        """Calculate Swaption analytics.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SwaptionCalculationResponse. The SwaptionCalculationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.SwaptionCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def price(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.SwaptionDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.SwaptionPricingParameters] = None,
        market_data: Optional[_models.MarketDataQps] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.SwaptionCalculationResponse:
        """Calculate Swaption analytics.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.SwaptionDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.SwaptionPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataQps
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: SwaptionCalculationResponse. The SwaptionCalculationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.SwaptionCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SwaptionCalculationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_swaption_price_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SwaptionCalculationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class termDepositOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`term_deposit` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def price(
        self,
        *,
        definitions: List[_models.TermDepositDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.TermDepositPricingParameters] = None,
        market_data: Optional[_models.MarketDataQps] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.TermDepositCalculationResponse:
        """Calculate TermDeposit analytics.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.TermDepositDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.TermDepositPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataQps
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: TermDepositCalculationResponse. The TermDepositCalculationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.TermDepositCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.TermDepositCalculationResponse:
        """Calculate TermDeposit analytics.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TermDepositCalculationResponse. The TermDepositCalculationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.TermDepositCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.TermDepositCalculationResponse:
        """Calculate TermDeposit analytics.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TermDepositCalculationResponse. The TermDepositCalculationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.TermDepositCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def price(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.TermDepositDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.TermDepositPricingParameters] = None,
        market_data: Optional[_models.MarketDataQps] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.TermDepositCalculationResponse:
        """Calculate TermDeposit analytics.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.TermDepositDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.TermDepositPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketDataQps
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: TermDepositCalculationResponse. The TermDepositCalculationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.TermDepositCalculationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.TermDepositCalculationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_term_deposit_price_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TermDepositCalculationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class eqVolatilityOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`eq_volatility` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def calculate(
        self,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        universe: Optional[List[_models.EtiVolatilitySurfaceRequestItem]] = None,
        **kwargs: Any,
    ) -> _models.VolatilitySurfaceResponse:
        """Generates the surfaces for the definitions provided.

        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword universe: Default value is None.
        :paramtype universe: list[~analyticsapi.models.EtiVolatilitySurfaceRequestItem]
        :return: VolatilitySurfaceResponse. The VolatilitySurfaceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.VolatilitySurfaceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VolatilitySurfaceResponse:
        """Generates the surfaces for the definitions provided.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VolatilitySurfaceResponse. The VolatilitySurfaceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.VolatilitySurfaceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VolatilitySurfaceResponse:
        """Generates the surfaces for the definitions provided.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VolatilitySurfaceResponse. The VolatilitySurfaceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.VolatilitySurfaceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def calculate(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        universe: Optional[List[_models.EtiVolatilitySurfaceRequestItem]] = None,
        **kwargs: Any,
    ) -> _models.VolatilitySurfaceResponse:
        """Generates the surfaces for the definitions provided.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword universe: Default value is None.
        :paramtype universe: list[~analyticsapi.models.EtiVolatilitySurfaceRequestItem]
        :return: VolatilitySurfaceResponse. The VolatilitySurfaceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.VolatilitySurfaceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VolatilitySurfaceResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"universe": universe}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_eq_volatility_calculate_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VolatilitySurfaceResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class fxVolatilityOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`fx_volatility` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def calculate(
        self,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        universe: Optional[List[_models.FxVolatilitySurfaceRequestItem]] = None,
        **kwargs: Any,
    ) -> _models.VolatilitySurfaceResponse:
        """Generates the surfaces for the definitions provided.

        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword universe: Default value is None.
        :paramtype universe: list[~analyticsapi.models.FxVolatilitySurfaceRequestItem]
        :return: VolatilitySurfaceResponse. The VolatilitySurfaceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.VolatilitySurfaceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VolatilitySurfaceResponse:
        """Generates the surfaces for the definitions provided.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VolatilitySurfaceResponse. The VolatilitySurfaceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.VolatilitySurfaceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VolatilitySurfaceResponse:
        """Generates the surfaces for the definitions provided.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VolatilitySurfaceResponse. The VolatilitySurfaceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.VolatilitySurfaceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def calculate(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        universe: Optional[List[_models.FxVolatilitySurfaceRequestItem]] = None,
        **kwargs: Any,
    ) -> _models.VolatilitySurfaceResponse:
        """Generates the surfaces for the definitions provided.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword universe: Default value is None.
        :paramtype universe: list[~analyticsapi.models.FxVolatilitySurfaceRequestItem]
        :return: VolatilitySurfaceResponse. The VolatilitySurfaceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.VolatilitySurfaceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VolatilitySurfaceResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"universe": universe}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_fx_volatility_calculate_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VolatilitySurfaceResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ircapletVolatilityOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`ircaplet_volatility` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def calculate(
        self,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        universe: Optional[List[_models.CapletsStrippingSurfaceRequestItem]] = None,
        **kwargs: Any,
    ) -> _models.VolatilitySurfaceResponse:
        """Generates the surfaces for the definitions provided.

        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword universe: Default value is None.
        :paramtype universe: list[~analyticsapi.models.CapletsStrippingSurfaceRequestItem]
        :return: VolatilitySurfaceResponse. The VolatilitySurfaceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.VolatilitySurfaceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VolatilitySurfaceResponse:
        """Generates the surfaces for the definitions provided.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VolatilitySurfaceResponse. The VolatilitySurfaceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.VolatilitySurfaceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VolatilitySurfaceResponse:
        """Generates the surfaces for the definitions provided.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VolatilitySurfaceResponse. The VolatilitySurfaceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.VolatilitySurfaceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def calculate(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        universe: Optional[List[_models.CapletsStrippingSurfaceRequestItem]] = None,
        **kwargs: Any,
    ) -> _models.VolatilitySurfaceResponse:
        """Generates the surfaces for the definitions provided.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword universe: Default value is None.
        :paramtype universe: list[~analyticsapi.models.CapletsStrippingSurfaceRequestItem]
        :return: VolatilitySurfaceResponse. The VolatilitySurfaceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.VolatilitySurfaceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VolatilitySurfaceResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"universe": universe}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ircaplet_volatility_calculate_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VolatilitySurfaceResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class irswaptionVolatilityOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`irswaption_volatility` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def calculate(
        self,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        universe: Optional[List[_models.VolatilityCubeSurfaceRequestItem]] = None,
        **kwargs: Any,
    ) -> _models.VolatilitySurfaceResponse:
        """Generates the surfaces for the definitions provided.

        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword universe: Default value is None.
        :paramtype universe: list[~analyticsapi.models.VolatilityCubeSurfaceRequestItem]
        :return: VolatilitySurfaceResponse. The VolatilitySurfaceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.VolatilitySurfaceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VolatilitySurfaceResponse:
        """Generates the surfaces for the definitions provided.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VolatilitySurfaceResponse. The VolatilitySurfaceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.VolatilitySurfaceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VolatilitySurfaceResponse:
        """Generates the surfaces for the definitions provided.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VolatilitySurfaceResponse. The VolatilitySurfaceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.VolatilitySurfaceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def calculate(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        universe: Optional[List[_models.VolatilityCubeSurfaceRequestItem]] = None,
        **kwargs: Any,
    ) -> _models.VolatilitySurfaceResponse:
        """Generates the surfaces for the definitions provided.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword universe: Default value is None.
        :paramtype universe: list[~analyticsapi.models.VolatilityCubeSurfaceRequestItem]
        :return: VolatilitySurfaceResponse. The VolatilitySurfaceResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.VolatilitySurfaceResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VolatilitySurfaceResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"universe": universe}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_irswaption_volatility_calculate_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VolatilitySurfaceResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class optionsResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`options_resource` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        page: Optional[int] = None,
        spaces: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        space_name_sort_order: Optional[Union[str, _models.SortingOrderEnum]] = None,
        tags: Optional[List[str]] = None,
        fields: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.OptionCollectionResponse:
        """List the resources that exist in the platform.

        List the Options existing in the platform (depending on permissions).

        :keyword item_per_page: A parameter used to select the number of items allowed per page. The
         valid range is 1-500. If not provided, 50 will be used. Default value is None.
        :paramtype item_per_page: int
        :keyword page: A parameter used to define the page number to display. Default value is None.
        :paramtype page: int
        :keyword spaces: A parameter used to search for platform resources stored in a given space.
         Space is like a namespace where resources are stored. By default there are two spaces:
         LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space.
         If space is not specified, it will search within all spaces. Default value is None.
        :paramtype spaces: list[str]
        :keyword names: A parameter used to search for platform resources with given names. Default
         value is None.
        :paramtype names: list[str]
        :keyword space_name_sort_order: A parameter used to sort platform resources by name based on a
         defined order. Known values are: "Asc" and "Desc". Default value is None.
        :paramtype space_name_sort_order: str or ~analyticsapi.models.SortingOrderEnum
        :keyword tags: A parameter used to search for platform resources with given tags. Default value
         is None.
        :paramtype tags: list[str]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: OptionCollectionResponse. The OptionCollectionResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionCollectionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.OptionCollectionResponse] = kwargs.pop("cls", None)

        _request = build_options_resource_list_request(
            item_per_page=item_per_page,
            page=page,
            spaces=spaces,
            names=names,
            space_name_sort_order=space_name_sort_order,
            tags=tags,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OptionCollectionResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self,
        *,
        location: _models.Location,
        definition: _models.OptionDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.OptionResponse:
        """Create a new resource to be saved in the platform.

        Save a new Option in the platform.

        :keyword location: Object defining the location of the Option in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the Option. Required.
        :paramtype definition: ~analyticsapi.models.OptionDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the Option. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: OptionResponse. The OptionResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.OptionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionResponse:
        """Create a new resource to be saved in the platform.

        Save a new Option in the platform.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionResponse. The OptionResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.OptionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionResponse:
        """Create a new resource to be saved in the platform.

        Save a new Option in the platform.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionResponse. The OptionResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.OptionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.OptionDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.OptionResponse:
        """Create a new resource to be saved in the platform.

        Save a new Option in the platform.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the Option in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the Option. Required.
        :paramtype definition: ~analyticsapi.models.OptionDefinition
        :keyword description: Object defining metadata for the Option. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: OptionResponse. The OptionResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.OptionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.OptionResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_options_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OptionResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def solve(
        self,
        *,
        definitions: List[_models.OptionDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.OptionPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.OptionArraySolveResponse:
        """Calculate the solvable properties of an Option provided in the request so that a chosen
        property equals a target value.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.OptionDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.OptionPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: OptionArraySolveResponse. The OptionArraySolveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionArraySolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def solve(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionArraySolveResponse:
        """Calculate the solvable properties of an Option provided in the request so that a chosen
        property equals a target value.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionArraySolveResponse. The OptionArraySolveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionArraySolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def solve(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionArraySolveResponse:
        """Calculate the solvable properties of an Option provided in the request so that a chosen
        property equals a target value.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionArraySolveResponse. The OptionArraySolveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionArraySolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def solve(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.OptionDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.OptionPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.OptionArraySolveResponse:
        """Calculate the solvable properties of an Option provided in the request so that a chosen
        property equals a target value.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.OptionDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.OptionPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: OptionArraySolveResponse. The OptionArraySolveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionArraySolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.OptionArraySolveResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_options_resource_solve_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OptionArraySolveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def value(
        self,
        *,
        definitions: List[_models.OptionDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.OptionPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.OptionArrayValuationResponse:
        """Calculate the market value of the Option provided in the request.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.OptionDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.OptionPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: OptionArrayValuationResponse. The OptionArrayValuationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionArrayValuationResponse:
        """Calculate the market value of the Option provided in the request.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionArrayValuationResponse. The OptionArrayValuationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionArrayValuationResponse:
        """Calculate the market value of the Option provided in the request.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionArrayValuationResponse. The OptionArrayValuationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def value(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.OptionDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.OptionPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.OptionArrayValuationResponse:
        """Calculate the market value of the Option provided in the request.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.OptionDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.OptionPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: OptionArrayValuationResponse. The OptionArrayValuationResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.OptionArrayValuationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_options_resource_value_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OptionArrayValuationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_vanilla_otc_option_from_template(
        self,
        *,
        template_reference: str,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        overrides: Optional[_models.VanillaOtcOptionOverride] = None,
        **kwargs: Any,
    ) -> _models.OptionInstrumentResponse:
        """Create a vanilla OTC option from a template.

        :keyword template_reference: The identifier of the OTC vanilla option template (GUID or URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword overrides: An object that contains the properties of an OTC vanilla option that can be
         overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.VanillaOtcOptionOverride
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_vanilla_otc_option_from_template(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionInstrumentResponse:
        """Create a vanilla OTC option from a template.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_vanilla_otc_option_from_template(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionInstrumentResponse:
        """Create a vanilla OTC option from a template.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create_vanilla_otc_option_from_template(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        template_reference: str = _Unset,
        fields: Optional[str] = None,
        overrides: Optional[_models.VanillaOtcOptionOverride] = None,
        **kwargs: Any,
    ) -> _models.OptionInstrumentResponse:
        """Create a vanilla OTC option from a template.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword template_reference: The identifier of the OTC vanilla option template (GUID or URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword overrides: An object that contains the properties of an OTC vanilla option that can be
         overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.VanillaOtcOptionOverride
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.OptionInstrumentResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if template_reference is _Unset:
                raise TypeError("missing required argument: template_reference")
            body = {"overrides": overrides, "templateReference": template_reference}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_options_resource_create_vanilla_otc_option_from_template_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OptionInstrumentResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_asian_otc_option_from_template(
        self,
        *,
        template_reference: str,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        overrides: Optional[_models.AsianOtcOptionOverride] = None,
        **kwargs: Any,
    ) -> _models.OptionInstrumentResponse:
        """Create an asian OTC option from a template.

        :keyword template_reference: The identifier of the Asian OTC option template (GUID or URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword overrides: An object that contains the properties of an Asian OTC option that can be
         overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.AsianOtcOptionOverride
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_asian_otc_option_from_template(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionInstrumentResponse:
        """Create an asian OTC option from a template.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_asian_otc_option_from_template(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionInstrumentResponse:
        """Create an asian OTC option from a template.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create_asian_otc_option_from_template(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        template_reference: str = _Unset,
        fields: Optional[str] = None,
        overrides: Optional[_models.AsianOtcOptionOverride] = None,
        **kwargs: Any,
    ) -> _models.OptionInstrumentResponse:
        """Create an asian OTC option from a template.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword template_reference: The identifier of the Asian OTC option template (GUID or URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword overrides: An object that contains the properties of an Asian OTC option that can be
         overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.AsianOtcOptionOverride
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.OptionInstrumentResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if template_reference is _Unset:
                raise TypeError("missing required argument: template_reference")
            body = {"overrides": overrides, "templateReference": template_reference}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_options_resource_create_asian_otc_option_from_template_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OptionInstrumentResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_single_barrier_otc_option_from_template(  # pylint: disable=name-too-long
        self,
        *,
        template_reference: str,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        overrides: Optional[_models.SingleBarrierOtcOptionOverride] = None,
        **kwargs: Any,
    ) -> _models.OptionInstrumentResponse:
        """Create a single barrier OTC option from a template.

        :keyword template_reference: The identifier of the single barrier OTC option template (GUID or
         URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword overrides: An object that contains the properties of a single barrier OTC option that
         can be overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.SingleBarrierOtcOptionOverride
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_single_barrier_otc_option_from_template(  # pylint: disable=name-too-long
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionInstrumentResponse:
        """Create a single barrier OTC option from a template.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_single_barrier_otc_option_from_template(  # pylint: disable=name-too-long
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionInstrumentResponse:
        """Create a single barrier OTC option from a template.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create_single_barrier_otc_option_from_template(  # pylint: disable=name-too-long
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        template_reference: str = _Unset,
        fields: Optional[str] = None,
        overrides: Optional[_models.SingleBarrierOtcOptionOverride] = None,
        **kwargs: Any,
    ) -> _models.OptionInstrumentResponse:
        """Create a single barrier OTC option from a template.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword template_reference: The identifier of the single barrier OTC option template (GUID or
         URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword overrides: An object that contains the properties of a single barrier OTC option that
         can be overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.SingleBarrierOtcOptionOverride
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.OptionInstrumentResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if template_reference is _Unset:
                raise TypeError("missing required argument: template_reference")
            body = {"overrides": overrides, "templateReference": template_reference}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_options_resource_create_single_barrier_otc_option_from_template_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OptionInstrumentResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_double_barrier_otc_option_from_template(  # pylint: disable=name-too-long
        self,
        *,
        template_reference: str,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        overrides: Optional[_models.DoubleBarrierOtcOptionOverride] = None,
        **kwargs: Any,
    ) -> _models.OptionInstrumentResponse:
        """Create a double barrier OTC option from a template.

        :keyword template_reference: The identifier of the double barrier OTC option template (GUID or
         URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword overrides: An object that contains the properties of a double barrier OTC option that
         can be overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.DoubleBarrierOtcOptionOverride
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_double_barrier_otc_option_from_template(  # pylint: disable=name-too-long
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionInstrumentResponse:
        """Create a double barrier OTC option from a template.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_double_barrier_otc_option_from_template(  # pylint: disable=name-too-long
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionInstrumentResponse:
        """Create a double barrier OTC option from a template.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create_double_barrier_otc_option_from_template(  # pylint: disable=name-too-long
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        template_reference: str = _Unset,
        fields: Optional[str] = None,
        overrides: Optional[_models.DoubleBarrierOtcOptionOverride] = None,
        **kwargs: Any,
    ) -> _models.OptionInstrumentResponse:
        """Create a double barrier OTC option from a template.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword template_reference: The identifier of the double barrier OTC option template (GUID or
         URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword overrides: An object that contains the properties of a double barrier OTC option that
         can be overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.DoubleBarrierOtcOptionOverride
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.OptionInstrumentResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if template_reference is _Unset:
                raise TypeError("missing required argument: template_reference")
            body = {"overrides": overrides, "templateReference": template_reference}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_options_resource_create_double_barrier_otc_option_from_template_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OptionInstrumentResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_single_binary_otc_option_from_template(  # pylint: disable=name-too-long
        self,
        *,
        template_reference: str,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        overrides: Optional[_models.SingleBinaryOtcOptionOverride] = None,
        **kwargs: Any,
    ) -> _models.OptionInstrumentResponse:
        """Create a single binary OTC option from a template.

        :keyword template_reference: The identifier of the single binary OTC option template (GUID or
         URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword overrides: An object that contains the properties of a single binary OTC option that
         can be overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.SingleBinaryOtcOptionOverride
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_single_binary_otc_option_from_template(  # pylint: disable=name-too-long
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionInstrumentResponse:
        """Create a single binary OTC option from a template.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_single_binary_otc_option_from_template(  # pylint: disable=name-too-long
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionInstrumentResponse:
        """Create a single binary OTC option from a template.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create_single_binary_otc_option_from_template(  # pylint: disable=name-too-long
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        template_reference: str = _Unset,
        fields: Optional[str] = None,
        overrides: Optional[_models.SingleBinaryOtcOptionOverride] = None,
        **kwargs: Any,
    ) -> _models.OptionInstrumentResponse:
        """Create a single binary OTC option from a template.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword template_reference: The identifier of the single binary OTC option template (GUID or
         URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword overrides: An object that contains the properties of a single binary OTC option that
         can be overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.SingleBinaryOtcOptionOverride
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.OptionInstrumentResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if template_reference is _Unset:
                raise TypeError("missing required argument: template_reference")
            body = {"overrides": overrides, "templateReference": template_reference}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_options_resource_create_single_binary_otc_option_from_template_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OptionInstrumentResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_double_binary_otc_option_from_template(  # pylint: disable=name-too-long
        self,
        *,
        template_reference: str,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        overrides: Optional[_models.DoubleBinaryOtcOptionOverride] = None,
        **kwargs: Any,
    ) -> _models.OptionInstrumentResponse:
        """Create a double binary OTC option from a template.

        :keyword template_reference: The identifier of the double binary OTC option template (GUID or
         URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword overrides: An object that contains the properties of a double binary OTC option that
         can be overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.DoubleBinaryOtcOptionOverride
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_double_binary_otc_option_from_template(  # pylint: disable=name-too-long
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionInstrumentResponse:
        """Create a double binary OTC option from a template.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create_double_binary_otc_option_from_template(  # pylint: disable=name-too-long
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionInstrumentResponse:
        """Create a double binary OTC option from a template.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create_double_binary_otc_option_from_template(  # pylint: disable=name-too-long
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        template_reference: str = _Unset,
        fields: Optional[str] = None,
        overrides: Optional[_models.DoubleBinaryOtcOptionOverride] = None,
        **kwargs: Any,
    ) -> _models.OptionInstrumentResponse:
        """Create a double binary OTC option from a template.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword template_reference: The identifier of the double binary OTC option template (GUID or
         URI).
         Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
         character, and contain only alphanumeric characters, slashes and underscores. Required.
        :paramtype template_reference: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword overrides: An object that contains the properties of a double binary OTC option that
         can be overridden. Default value is None.
        :paramtype overrides: ~analyticsapi.models.DoubleBinaryOtcOptionOverride
        :return: OptionInstrumentResponse. The OptionInstrumentResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.OptionInstrumentResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.OptionInstrumentResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if template_reference is _Unset:
                raise TypeError("missing required argument: template_reference")
            body = {"overrides": overrides, "templateReference": template_reference}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_options_resource_create_double_binary_otc_option_from_template_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OptionInstrumentResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class optionResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`option_resource` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def read(self, instrument_id: str, *, fields: Optional[str] = None, **kwargs: Any) -> _models.OptionResponse:
        """Access a resource that exists in the platform.

        Access a Option existing in the platform (read). The Option can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: OptionResponse. The OptionResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.OptionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.OptionResponse] = kwargs.pop("cls", None)

        _request = build_option_resource_read_request(
            instrument_id=instrument_id,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OptionResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def delete(self, instrument_id: str, **kwargs: Any) -> None:
        """Delete a resource that exists in the platform.

        Delete a Option that exists in the platform. The Option can be identified either by its unique
        ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :return: None
        :rtype: None
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_option_resource_delete_request(
            instrument_id=instrument_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def overwrite(
        self,
        instrument_id: str,
        *,
        location: _models.Location,
        definition: _models.OptionDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.OptionResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a Option that exists in the platform. The Option can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword location: Object defining the location of the Option in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the Option. Required.
        :paramtype definition: ~analyticsapi.models.OptionDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the Option. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: OptionResponse. The OptionResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.OptionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a Option that exists in the platform. The Option can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionResponse. The OptionResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.OptionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.OptionResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a Option that exists in the platform. The Option can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionResponse. The OptionResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.OptionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def overwrite(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.OptionDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.OptionResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a Option that exists in the platform. The Option can be identified either by its
        unique ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the Option in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the Option. Required.
        :paramtype definition: ~analyticsapi.models.OptionDefinition
        :keyword description: Object defining metadata for the Option. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: OptionResponse. The OptionResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.OptionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.OptionResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_option_resource_overwrite_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OptionResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def solve(
        self,
        instrument_id: str,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.OptionPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.OptionSolveResponse:
        """Calculate the solvable properties of an Option provided in the request so that a chosen
        property equals a target value.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.OptionPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: OptionSolveResponse. The OptionSolveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.OptionSolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def solve(
        self,
        instrument_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.OptionSolveResponse:
        """Calculate the solvable properties of an Option provided in the request so that a chosen
        property equals a target value.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionSolveResponse. The OptionSolveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.OptionSolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def solve(
        self,
        instrument_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.OptionSolveResponse:
        """Calculate the solvable properties of an Option provided in the request so that a chosen
        property equals a target value.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionSolveResponse. The OptionSolveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.OptionSolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def solve(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.OptionPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.OptionSolveResponse:
        """Calculate the solvable properties of an Option provided in the request so that a chosen
        property equals a target value.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.OptionPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: OptionSolveResponse. The OptionSolveResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.OptionSolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.OptionSolveResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_option_resource_solve_request(
            instrument_id=instrument_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OptionSolveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def value(
        self,
        instrument_id: str,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.OptionPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.OptionValuationResponse:
        """Calculate the market value of a option stored on the platform.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.OptionPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: OptionValuationResponse. The OptionValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.OptionValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self,
        instrument_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.OptionValuationResponse:
        """Calculate the market value of a option stored on the platform.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionValuationResponse. The OptionValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.OptionValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self,
        instrument_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.OptionValuationResponse:
        """Calculate the market value of a option stored on the platform.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OptionValuationResponse. The OptionValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.OptionValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def value(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.OptionPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.OptionValuationResponse:
        """Calculate the market value of a option stored on the platform.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.OptionPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: OptionValuationResponse. The OptionValuationResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.OptionValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.OptionValuationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_option_resource_value_request(
            instrument_id=instrument_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OptionValuationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class interestRateCurvesServiceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`interest_rate_curves_service` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        page: Optional[int] = None,
        spaces: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        space_name_sort_order: Optional[Union[str, _models.SortingOrderEnum]] = None,
        tags: Optional[List[str]] = None,
        fields: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.InterestRateCurveCollectionResponse:
        """List the resources that exist in the platform.

        List the InterestRateCurves existing in the platform (depending on permissions).

        :keyword item_per_page: A parameter used to select the number of items allowed per page. The
         valid range is 1-500. If not provided, 50 will be used. Default value is None.
        :paramtype item_per_page: int
        :keyword page: A parameter used to define the page number to display. Default value is None.
        :paramtype page: int
        :keyword spaces: A parameter used to search for platform resources stored in a given space.
         Space is like a namespace where resources are stored. By default there are two spaces:
         LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space.
         If space is not specified, it will search within all spaces. Default value is None.
        :paramtype spaces: list[str]
        :keyword names: A parameter used to search for platform resources with given names. Default
         value is None.
        :paramtype names: list[str]
        :keyword space_name_sort_order: A parameter used to sort platform resources by name based on a
         defined order. Known values are: "Asc" and "Desc". Default value is None.
        :paramtype space_name_sort_order: str or ~analyticsapi.models.SortingOrderEnum
        :keyword tags: A parameter used to search for platform resources with given tags. Default value
         is None.
        :paramtype tags: list[str]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: InterestRateCurveCollectionResponse. The InterestRateCurveCollectionResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.InterestRateCurveCollectionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.InterestRateCurveCollectionResponse] = kwargs.pop("cls", None)

        _request = build_interest_rate_curves_service_list_request(
            item_per_page=item_per_page,
            page=page,
            spaces=spaces,
            names=names,
            space_name_sort_order=space_name_sort_order,
            tags=tags,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.InterestRateCurveCollectionResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self,
        *,
        location: _models.Location,
        definition: _models.IrCurveDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.InterestRateCurveResponse:
        """Create a new resource to be saved in the platform.

        Save a new InterestRateCurve in the platform.

        :keyword location: Object defining the location of the InterestRateCurve in the platform.
         Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the InterestRateCurve. Required.
        :paramtype definition: ~analyticsapi.models.IrCurveDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the InterestRateCurve. Default value is
         None.
        :paramtype description: ~analyticsapi.models.Description
        :return: InterestRateCurveResponse. The InterestRateCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InterestRateCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InterestRateCurveResponse:
        """Create a new resource to be saved in the platform.

        Save a new InterestRateCurve in the platform.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InterestRateCurveResponse. The InterestRateCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InterestRateCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InterestRateCurveResponse:
        """Create a new resource to be saved in the platform.

        Save a new InterestRateCurve in the platform.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InterestRateCurveResponse. The InterestRateCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InterestRateCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.IrCurveDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.InterestRateCurveResponse:
        """Create a new resource to be saved in the platform.

        Save a new InterestRateCurve in the platform.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the InterestRateCurve in the platform.
         Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the InterestRateCurve. Required.
        :paramtype definition: ~analyticsapi.models.IrCurveDefinition
        :keyword description: Object defining metadata for the InterestRateCurve. Default value is
         None.
        :paramtype description: ~analyticsapi.models.Description
        :return: InterestRateCurveResponse. The InterestRateCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InterestRateCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.InterestRateCurveResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_interest_rate_curves_service_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.InterestRateCurveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def calculate(
        self,
        *,
        definitions: List[_models.IrCurveDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.InterestRateCurveCalculationParameters] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.InterestRateCurveCalculateArrayResponse:
        """Calculate curve analytics using a custom definition.

        Calculate the points of the interest rate curve by requesting a custom definition (on the fly).

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.IrCurveDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.InterestRateCurveCalculationParameters
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: InterestRateCurveCalculateArrayResponse. The InterestRateCurveCalculateArrayResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.InterestRateCurveCalculateArrayResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InterestRateCurveCalculateArrayResponse:
        """Calculate curve analytics using a custom definition.

        Calculate the points of the interest rate curve by requesting a custom definition (on the fly).

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InterestRateCurveCalculateArrayResponse. The InterestRateCurveCalculateArrayResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.InterestRateCurveCalculateArrayResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InterestRateCurveCalculateArrayResponse:
        """Calculate curve analytics using a custom definition.

        Calculate the points of the interest rate curve by requesting a custom definition (on the fly).

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InterestRateCurveCalculateArrayResponse. The InterestRateCurveCalculateArrayResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.InterestRateCurveCalculateArrayResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def calculate(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.IrCurveDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.InterestRateCurveCalculationParameters] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.InterestRateCurveCalculateArrayResponse:
        """Calculate curve analytics using a custom definition.

        Calculate the points of the interest rate curve by requesting a custom definition (on the fly).

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.IrCurveDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.InterestRateCurveCalculationParameters
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: InterestRateCurveCalculateArrayResponse. The InterestRateCurveCalculateArrayResponse
         is compatible with MutableMapping
        :rtype: ~analyticsapi.models.InterestRateCurveCalculateArrayResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.InterestRateCurveCalculateArrayResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_interest_rate_curves_service_calculate_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.InterestRateCurveCalculateArrayResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class interestRateCurveServiceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`interest_rate_curve_service` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def read(
        self, curve_id: str, *, fields: Optional[str] = None, **kwargs: Any
    ) -> _models.InterestRateCurveResponse:
        """Access a resource that exists in the platform.

        Access a InterestRateCurve existing in the platform (read). The InterestRateCurve can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: InterestRateCurveResponse. The InterestRateCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InterestRateCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.InterestRateCurveResponse] = kwargs.pop("cls", None)

        _request = build_interest_rate_curve_service_read_request(
            curve_id=curve_id,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.InterestRateCurveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def delete(self, curve_id: str, **kwargs: Any) -> None:
        """Delete a resource that exists in the platform.

        Delete a InterestRateCurve that exists in the platform. The InterestRateCurve can be identified
        either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :return: None
        :rtype: None
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_interest_rate_curve_service_delete_request(
            curve_id=curve_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def overwrite(
        self,
        curve_id: str,
        *,
        location: _models.Location,
        definition: _models.IrCurveDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.InterestRateCurveResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a InterestRateCurve that exists in the platform. The InterestRateCurve can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :keyword location: Object defining the location of the InterestRateCurve in the platform.
         Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the InterestRateCurve. Required.
        :paramtype definition: ~analyticsapi.models.IrCurveDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the InterestRateCurve. Default value is
         None.
        :paramtype description: ~analyticsapi.models.Description
        :return: InterestRateCurveResponse. The InterestRateCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InterestRateCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, curve_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InterestRateCurveResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a InterestRateCurve that exists in the platform. The InterestRateCurve can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InterestRateCurveResponse. The InterestRateCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InterestRateCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, curve_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.InterestRateCurveResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a InterestRateCurve that exists in the platform. The InterestRateCurve can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InterestRateCurveResponse. The InterestRateCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InterestRateCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def overwrite(
        self,
        curve_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.IrCurveDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.InterestRateCurveResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a InterestRateCurve that exists in the platform. The InterestRateCurve can be
        identified either by its unique ID (GUID format) or by its location path (space/name).

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the InterestRateCurve in the platform.
         Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the InterestRateCurve. Required.
        :paramtype definition: ~analyticsapi.models.IrCurveDefinition
        :keyword description: Object defining metadata for the InterestRateCurve. Default value is
         None.
        :paramtype description: ~analyticsapi.models.Description
        :return: InterestRateCurveResponse. The InterestRateCurveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.InterestRateCurveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.InterestRateCurveResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_interest_rate_curve_service_overwrite_request(
            curve_id=curve_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.InterestRateCurveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def calculate(
        self,
        curve_id: str,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.InterestRateCurveCalculationParameters] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.InterestRateCurveCalculateResponse:
        """Calculate analytics for an existing curve.

        Calculate the points of the interest rate curve that exists in the platform.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.InterestRateCurveCalculationParameters
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: InterestRateCurveCalculateResponse. The InterestRateCurveCalculateResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.InterestRateCurveCalculateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self,
        curve_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.InterestRateCurveCalculateResponse:
        """Calculate analytics for an existing curve.

        Calculate the points of the interest rate curve that exists in the platform.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InterestRateCurveCalculateResponse. The InterestRateCurveCalculateResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.InterestRateCurveCalculateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def calculate(
        self,
        curve_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.InterestRateCurveCalculateResponse:
        """Calculate analytics for an existing curve.

        Calculate the points of the interest rate curve that exists in the platform.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: InterestRateCurveCalculateResponse. The InterestRateCurveCalculateResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.InterestRateCurveCalculateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def calculate(
        self,
        curve_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.InterestRateCurveCalculationParameters] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.InterestRateCurveCalculateResponse:
        """Calculate analytics for an existing curve.

        Calculate the points of the interest rate curve that exists in the platform.

        :param curve_id: The curve identifier. Required.
        :type curve_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.InterestRateCurveCalculationParameters
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: InterestRateCurveCalculateResponse. The InterestRateCurveCalculateResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.InterestRateCurveCalculateResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.InterestRateCurveCalculateResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"pricingPreferences": pricing_preferences, "returnMarketData": return_market_data}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_interest_rate_curve_service_calculate_request(
            curve_id=curve_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.InterestRateCurveCalculateResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class loansResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`loans_resource` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def list(
        self,
        *,
        item_per_page: Optional[int] = None,
        page: Optional[int] = None,
        spaces: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        space_name_sort_order: Optional[Union[str, _models.SortingOrderEnum]] = None,
        tags: Optional[List[str]] = None,
        fields: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.LoanCollectionResponse:
        """List the resources that exist in the platform.

        List the Loans existing in the platform (depending on permissions).

        :keyword item_per_page: A parameter used to select the number of items allowed per page. The
         valid range is 1-500. If not provided, 50 will be used. Default value is None.
        :paramtype item_per_page: int
        :keyword page: A parameter used to define the page number to display. Default value is None.
        :paramtype page: int
        :keyword spaces: A parameter used to search for platform resources stored in a given space.
         Space is like a namespace where resources are stored. By default there are two spaces:
         LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space.
         If space is not specified, it will search within all spaces. Default value is None.
        :paramtype spaces: list[str]
        :keyword names: A parameter used to search for platform resources with given names. Default
         value is None.
        :paramtype names: list[str]
        :keyword space_name_sort_order: A parameter used to sort platform resources by name based on a
         defined order. Known values are: "Asc" and "Desc". Default value is None.
        :paramtype space_name_sort_order: str or ~analyticsapi.models.SortingOrderEnum
        :keyword tags: A parameter used to search for platform resources with given tags. Default value
         is None.
        :paramtype tags: list[str]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: LoanCollectionResponse. The LoanCollectionResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.LoanCollectionResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LoanCollectionResponse] = kwargs.pop("cls", None)

        _request = build_loans_resource_list_request(
            item_per_page=item_per_page,
            page=page,
            spaces=spaces,
            names=names,
            space_name_sort_order=space_name_sort_order,
            tags=tags,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LoanCollectionResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self,
        *,
        location: _models.Location,
        definition: _models.LoanDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.LoanResponse:
        """Create a new resource to be saved in the platform.

        Save a new Loan in the platform.

        :keyword location: Object defining the location of the Loan in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the Loan. Required.
        :paramtype definition: ~analyticsapi.models.LoanDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the Loan. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: LoanResponse. The LoanResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.LoanResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.LoanResponse:
        """Create a new resource to be saved in the platform.

        Save a new Loan in the platform.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LoanResponse. The LoanResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.LoanResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.LoanResponse:
        """Create a new resource to be saved in the platform.

        Save a new Loan in the platform.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LoanResponse. The LoanResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.LoanResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def create(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.LoanDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.LoanResponse:
        """Create a new resource to be saved in the platform.

        Save a new Loan in the platform.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the Loan in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the Loan. Required.
        :paramtype definition: ~analyticsapi.models.LoanDefinition
        :keyword description: Object defining metadata for the Loan. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: LoanResponse. The LoanResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.LoanResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.LoanResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_loans_resource_create_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LoanResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def price(
        self,
        *,
        definitions: List[_models.LoanDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.IrPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.LoanInstrumentArraySolveResponse:
        """Solve a loan with a custom definition.

        Calculate the price (i.e., their respective fixed rates) of loans provided in the request so
        that a chosen property (e.g., market value, duration) equals a target value.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.LoanDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.IrPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: LoanInstrumentArraySolveResponse. The LoanInstrumentArraySolveResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.LoanInstrumentArraySolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.LoanInstrumentArraySolveResponse:
        """Solve a loan with a custom definition.

        Calculate the price (i.e., their respective fixed rates) of loans provided in the request so
        that a chosen property (e.g., market value, duration) equals a target value.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LoanInstrumentArraySolveResponse. The LoanInstrumentArraySolveResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.LoanInstrumentArraySolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.LoanInstrumentArraySolveResponse:
        """Solve a loan with a custom definition.

        Calculate the price (i.e., their respective fixed rates) of loans provided in the request so
        that a chosen property (e.g., market value, duration) equals a target value.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LoanInstrumentArraySolveResponse. The LoanInstrumentArraySolveResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.LoanInstrumentArraySolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def price(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.LoanDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.IrPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.LoanInstrumentArraySolveResponse:
        """Solve a loan with a custom definition.

        Calculate the price (i.e., their respective fixed rates) of loans provided in the request so
        that a chosen property (e.g., market value, duration) equals a target value.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.LoanDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.IrPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: LoanInstrumentArraySolveResponse. The LoanInstrumentArraySolveResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.LoanInstrumentArraySolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.LoanInstrumentArraySolveResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_loans_resource_price_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LoanInstrumentArraySolveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def value(
        self,
        *,
        definitions: List[_models.LoanDefinitionInstrument],
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.IrPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.LoanInstrumentArrayValuationResponse:
        """Value a loan with a custom definition.

        Calculate the market value of loans provided in the request.

        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.LoanDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.IrPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: LoanInstrumentArrayValuationResponse. The LoanInstrumentArrayValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.LoanInstrumentArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self, body: JSON, *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.LoanInstrumentArrayValuationResponse:
        """Value a loan with a custom definition.

        Calculate the market value of loans provided in the request.

        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LoanInstrumentArrayValuationResponse. The LoanInstrumentArrayValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.LoanInstrumentArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self, body: IO[bytes], *, fields: Optional[str] = None, content_type: str = "application/json", **kwargs: Any
    ) -> _models.LoanInstrumentArrayValuationResponse:
        """Value a loan with a custom definition.

        Calculate the market value of loans provided in the request.

        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LoanInstrumentArrayValuationResponse. The LoanInstrumentArrayValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.LoanInstrumentArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def value(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        definitions: List[_models.LoanDefinitionInstrument] = _Unset,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.IrPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.LoanInstrumentArrayValuationResponse:
        """Value a loan with a custom definition.

        Calculate the market value of loans provided in the request.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword definitions: An array of objects describing a curve or an instrument.
         Please provide either a full definition (for a user-defined curve/instrument), or reference to
         a curve/instrument definition saved in the platform, or the code identifying the existing
         curve/instrument. Required.
        :paramtype definitions: list[~analyticsapi.models.LoanDefinitionInstrument]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.IrPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: LoanInstrumentArrayValuationResponse. The LoanInstrumentArrayValuationResponse is
         compatible with MutableMapping
        :rtype: ~analyticsapi.models.LoanInstrumentArrayValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.LoanInstrumentArrayValuationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if definitions is _Unset:
                raise TypeError("missing required argument: definitions")
            body = {
                "definitions": definitions,
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_loans_resource_value_request(
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LoanInstrumentArrayValuationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class loanResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~analyticsapi.aio.AnalyticsAPIClient`'s
        :attr:`loan_resource` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: AnalyticsAPIClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    async def read(self, instrument_id: str, *, fields: Optional[str] = None, **kwargs: Any) -> _models.LoanResponse:
        """Access a resource that exists in the platform.

        Access a Loan existing in the platform (read). The Loan can be identified either by its unique
        ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :return: LoanResponse. The LoanResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.LoanResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LoanResponse] = kwargs.pop("cls", None)

        _request = build_loan_resource_read_request(
            instrument_id=instrument_id,
            fields=fields,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LoanResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def delete(self, instrument_id: str, **kwargs: Any) -> None:
        """Delete a resource that exists in the platform.

        Delete a Loan that exists in the platform. The Loan can be identified either by its unique ID
        (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :return: None
        :rtype: None
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_loan_resource_delete_request(
            instrument_id=instrument_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def overwrite(
        self,
        instrument_id: str,
        *,
        location: _models.Location,
        definition: _models.LoanDefinition,
        content_type: str = "application/json",
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.LoanResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a Loan that exists in the platform. The Loan can be identified either by its unique
        ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword location: Object defining the location of the Loan in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the Loan. Required.
        :paramtype definition: ~analyticsapi.models.LoanDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword description: Object defining metadata for the Loan. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: LoanResponse. The LoanResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.LoanResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, instrument_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.LoanResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a Loan that exists in the platform. The Loan can be identified either by its unique
        ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LoanResponse. The LoanResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.LoanResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def overwrite(
        self, instrument_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.LoanResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a Loan that exists in the platform. The Loan can be identified either by its unique
        ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LoanResponse. The LoanResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.LoanResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def overwrite(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        location: _models.Location = _Unset,
        definition: _models.LoanDefinition = _Unset,
        description: Optional[_models.Description] = None,
        **kwargs: Any,
    ) -> _models.LoanResponse:
        """Overwrite a resource that exists in the platform.

        Overwrite a Loan that exists in the platform. The Loan can be identified either by its unique
        ID (GUID format) or by its location path (space/name).

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword location: Object defining the location of the Loan in the platform. Required.
        :paramtype location: ~analyticsapi.models.Location
        :keyword definition: Object defining the Loan. Required.
        :paramtype definition: ~analyticsapi.models.LoanDefinition
        :keyword description: Object defining metadata for the Loan. Default value is None.
        :paramtype description: ~analyticsapi.models.Description
        :return: LoanResponse. The LoanResponse is compatible with MutableMapping
        :rtype: ~analyticsapi.models.LoanResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.LoanResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if location is _Unset:
                raise TypeError("missing required argument: location")
            if definition is _Unset:
                raise TypeError("missing required argument: definition")
            body = {"definition": definition, "description": description, "location": location}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_loan_resource_overwrite_request(
            instrument_id=instrument_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 412:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 423:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LoanResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def price(
        self,
        instrument_id: str,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.IrPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.LoanInstrumentSolveResponse:
        """Solve an existing loan.

        Calculate the price of a loan (i.e., its fixed rate) stored in the platform so that a chosen
        property (e.g., market value, duration) equals a target value.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.IrPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: LoanInstrumentSolveResponse. The LoanInstrumentSolveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.LoanInstrumentSolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self,
        instrument_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.LoanInstrumentSolveResponse:
        """Solve an existing loan.

        Calculate the price of a loan (i.e., its fixed rate) stored in the platform so that a chosen
        property (e.g., market value, duration) equals a target value.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LoanInstrumentSolveResponse. The LoanInstrumentSolveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.LoanInstrumentSolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def price(
        self,
        instrument_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.LoanInstrumentSolveResponse:
        """Solve an existing loan.

        Calculate the price of a loan (i.e., its fixed rate) stored in the platform so that a chosen
        property (e.g., market value, duration) equals a target value.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LoanInstrumentSolveResponse. The LoanInstrumentSolveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.LoanInstrumentSolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def price(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.IrPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.LoanInstrumentSolveResponse:
        """Solve an existing loan.

        Calculate the price of a loan (i.e., its fixed rate) stored in the platform so that a chosen
        property (e.g., market value, duration) equals a target value.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.IrPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: LoanInstrumentSolveResponse. The LoanInstrumentSolveResponse is compatible with
         MutableMapping
        :rtype: ~analyticsapi.models.LoanInstrumentSolveResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.LoanInstrumentSolveResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_loan_resource_price_request(
            instrument_id=instrument_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LoanInstrumentSolveResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def value(
        self,
        instrument_id: str,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        pricing_preferences: Optional[_models.IrPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.LoanInstrumentValuationResponse:
        """Value an existing loan.

        Calculate the market value of a loan stored in the platform.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.IrPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: LoanInstrumentValuationResponse. The LoanInstrumentValuationResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.LoanInstrumentValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self,
        instrument_id: str,
        body: JSON,
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.LoanInstrumentValuationResponse:
        """Value an existing loan.

        Calculate the market value of a loan stored in the platform.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: JSON
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LoanInstrumentValuationResponse. The LoanInstrumentValuationResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.LoanInstrumentValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    @overload
    async def value(
        self,
        instrument_id: str,
        body: IO[bytes],
        *,
        fields: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.LoanInstrumentValuationResponse:
        """Value an existing loan.

        Calculate the market value of a loan stored in the platform.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LoanInstrumentValuationResponse. The LoanInstrumentValuationResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.LoanInstrumentValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """

    async def value(
        self,
        instrument_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        fields: Optional[str] = None,
        pricing_preferences: Optional[_models.IrPricingParameters] = None,
        market_data: Optional[_models.MarketData] = None,
        return_market_data: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.LoanInstrumentValuationResponse:
        """Value an existing loan.

        Calculate the market value of a loan stored in the platform.

        :param instrument_id: The instrument identifier. Required.
        :type instrument_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword fields: A parameter used to select the fields to return in response. If not provided,
         all fields will be returned.
         Some usage examples:


         #. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the
         selected fields here, e.g., field1, field2 //'
         #. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and
         subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//’
         #. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected
         field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//’ (same
         result as example above)
         #. Operators can even be combined (forward slashes in brackets, not the way around), e.g.
         'fields=//please insert the selected field and subfields here, e.g.,
         field1(subfield1/subsubfield1), field2/subfield2//'. Default value is None.
        :paramtype fields: str
        :keyword pricing_preferences: The parameters that control the computation of the analytics.
         Default value is None.
        :paramtype pricing_preferences: ~analyticsapi.models.IrPricingParameters
        :keyword market_data: The market data used to compute the analytics. Default value is None.
        :paramtype market_data: ~analyticsapi.models.MarketData
        :keyword return_market_data: Boolean property to determine if undelying market data used for
         calculation should be returned in the response. Default value is None.
        :paramtype return_market_data: bool
        :return: LoanInstrumentValuationResponse. The LoanInstrumentValuationResponse is compatible
         with MutableMapping
        :rtype: ~analyticsapi.models.LoanInstrumentValuationResponse
        :raises ~corehttp.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.LoanInstrumentValuationResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {
                "marketData": market_data,
                "pricingPreferences": pricing_preferences,
                "returnMarketData": return_market_data,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_loan_resource_value_request(
            instrument_id=instrument_id,
            fields=fields,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client.pipeline.run(_request, stream=_stream, **kwargs)

        response = pipeline_response.http_response

        if response.content_type == "text/html" and "Microsoft-Azure-Application-Gateway" in response.headers.get(
            "Server", ""
        ):
            raise HttpResponseError(
                response=response,
                message=f"Azure WAF Error - unsupported content type {response.content_type}. Original message is {response.content}",
            )

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = None
            if response.status_code == 400:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 401:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ClientAuthenticationError(response=response, model=error)
            elif response.status_code == 403:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 404:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceNotFoundError(response=response, model=error)
            elif response.status_code == 405:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 406:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 408:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 409:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
                raise ResourceExistsError(response=response, model=error)
            elif response.status_code == 410:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 415:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 428:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 429:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 500:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 501:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 502:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 503:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            elif response.status_code == 504:
                error = _failsafe_deserialize(_models.ServiceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LoanInstrumentValuationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
