[
    {
        "type": "ClassChunk",
        "name": "BasketItem",
        "id": "lseg_analytics.instruments.structured_products.BasketItem",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "alive",
                "type": "str"
            },
            {
                "name": "notional",
                "type": "str"
            },
            {
                "name": "recovery_rate",
                "type": "float"
            },
            {
                "name": "underlying",
                "type": "BasketUnderlying"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 1538,
        "content": "class BasketItem:\n    \"\"\"BasketItem.\n\n    Attributes\n    ----------\n    alive : str\n    notional : str\n    recovery_rate : float\n    underlying : ~analyticsapi.models.BasketUnderlying\n    \n    \"\"\"\n    alive: typing.Optional[str]\n    notional: typing.Optional[str]\n    recovery_rate: typing.Optional[float]\n    underlying: typing.Optional[ForwardRef('_models.BasketUnderlying')]",
        "metadata": {
            "doc": "BasketItem.\n\n    Attributes\n    ----------\n    alive : str\n    notional : str\n    recovery_rate : float\n    underlying : ~analyticsapi.models.BasketUnderlying\n    \n",
            "annotations": "    alive: typing.Optional[str]\n    notional: typing.Optional[str]\n    recovery_rate: typing.Optional[float]\n    underlying: typing.Optional[ForwardRef('_models.BasketUnderlying')]",
            "signature": "class BasketItem:\n    \"\"\"\"\"\"\n    alive: typing.Optional[str]\n    notional: typing.Optional[str]\n    recovery_rate: typing.Optional[float]\n    underlying: typing.Optional[ForwardRef('_models.BasketUnderlying')]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.BasketItem.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.instruments.structured_products.BasketUnderlying"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "BasketItem.__init__",
        "id": "lseg_analytics.instruments.structured_products.BasketItem.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 1573,
        "content": "class BasketItem:\n    @overload\n    def __init__(self, *, alive: Optional[str] = None, notional: Optional[str] = None, recovery_rate: Optional[float] = None, underlying: Optional[ForwardRef('_models.BasketUnderlying')] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "BasketItem"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.BasketItem"
            ],
            "use": [
                "lseg_analytics.instruments.structured_products.BasketUnderlying"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "BasketUnderlying",
        "id": "lseg_analytics.instruments.structured_products.BasketUnderlying",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "ccy",
                "type": "str"
            },
            {
                "name": "code",
                "type": "str"
            },
            {
                "name": "name",
                "type": "str"
            },
            {
                "name": "type",
                "type": "str"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 1577,
        "content": "class BasketUnderlying:\n    \"\"\"BasketUnderlying.\n\n    Attributes\n    ----------\n    ccy : str\n    code : str\n    name : str\n    type : str\n    \n    \"\"\"\n    ccy: typing.Optional[str]\n    code: typing.Optional[str]\n    name: typing.Optional[str]\n    type: typing.Optional[str]",
        "metadata": {
            "doc": "BasketUnderlying.\n\n    Attributes\n    ----------\n    ccy : str\n    code : str\n    name : str\n    type : str\n    \n",
            "annotations": "    ccy: typing.Optional[str]\n    code: typing.Optional[str]\n    name: typing.Optional[str]\n    type: typing.Optional[str]",
            "signature": "class BasketUnderlying:\n    \"\"\"\"\"\"\n    ccy: typing.Optional[str]\n    code: typing.Optional[str]\n    name: typing.Optional[str]\n    type: typing.Optional[str]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.BasketUnderlying.__init__"
            ],
            "parent": [],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "BasketUnderlying.__init__",
        "id": "lseg_analytics.instruments.structured_products.BasketUnderlying.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 1612,
        "content": "class BasketUnderlying:\n    @overload\n    def __init__(self, *, ccy: Optional[str] = None, code: Optional[str] = None, name: Optional[str] = None, type: Optional[str] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "BasketUnderlying"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.BasketUnderlying"
            ],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "Calibration",
        "id": "lseg_analytics.instruments.structured_products.Calibration",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "calendar",
                "type": "str"
            },
            {
                "name": "calibration_type",
                "type": "CalibrationTypeEnum",
                "valuelookup": "enum.CalibrationTypeEnum"
            },
            {
                "name": "end_date",
                "type": "datetime"
            },
            {
                "name": "frequency",
                "type": "str"
            },
            {
                "name": "parameter",
                "type": "str"
            },
            {
                "name": "product_type",
                "type": "ProductTypeEnum",
                "valuelookup": "enum.ProductTypeEnum"
            },
            {
                "name": "start_date",
                "type": "datetime"
            },
            {
                "name": "strike",
                "type": "str"
            },
            {
                "name": "tenor",
                "type": "str",
                "valuelookup": "tenors"
            },
            {
                "name": "user_tenor",
                "type": "str"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 9121,
        "content": "class Calibration:\n    \"\"\"Calibration.\n\n    Attributes\n    ----------\n    calendar : str\n        The calendar used in the calibration.\n    calibration_type : str or ~analyticsapi.models.CalibrationTypeEnum\n        The type of calibration applied to solve for model parameters. The\n        possible values are:\n\n        * Bootstrap,\n        * Optimize,\n        * Global. Known values are: \"Bootstrap\", \"Optimize\", and \"Global\".\n    end_date : ~datetime.datetime\n        The end date of the calibration process. The value is expressed in ISO\n        8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Usually coincides with\n        the end date of the contract to price.\n    frequency : str\n        The frequency of the calibration. Usually it coincides with the\n        frequency of the contract to price.\n    parameter : str\n        The generic parameter name to solve for during calibration process. The\n        possible values are:\n\n        * Correlation,\n        * Factors,\n        * MeanReversion,\n        * MeanReversionSpread,\n        * Shift,Tenor,\n        * Volatility,\n        * VolatilityRatio,\n        * Alpha.\n    product_type : str or ~analyticsapi.models.ProductTypeEnum\n        Product type to use during the calibration process.  The possible\n        values are:\n\n        * Cap,\n        * Swaption. Known values are: \"Cap\" and \"Swaption\".\n    start_date : ~datetime.datetime\n        The start date of the calibration process. The value is expressed in\n        ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Usually coincides\n        with the start date of the contract to price or valuation date.\n    strike : str\n        The strike on which the model should be calibrated. It can be symbolic\n        (e.g 'ATM') or numeric.\n    tenor : str\n        The tenor of the calibration portfolio. In case of a CMS spread\n        contract, it defines the first tenor.\n    user_tenor : str\n        An additional custom tenor. In case of a CMS spread contract, it\n        defines the second tenor. If not used, an empty string should be\n        passed.\n    \n    \"\"\"\n    calendar: typing.Optional[str]\n    calibration_type: typing.Union[str, ForwardRef('_models.CalibrationTypeEnum'), NoneType]\n    end_date: typing.Optional[datetime.datetime]\n    frequency: typing.Optional[str]\n    parameter: typing.Optional[str]\n    product_type: typing.Union[str, ForwardRef('_models.ProductTypeEnum'), NoneType]\n    start_date: typing.Optional[datetime.datetime]\n    strike: typing.Optional[str]\n    tenor: typing.Optional[str]\n    user_tenor: typing.Optional[str]",
        "metadata": {
            "doc": "Calibration.\n\n    Attributes\n    ----------\n    calendar : str\n        The calendar used in the calibration.\n    calibration_type : str or ~analyticsapi.models.CalibrationTypeEnum\n        The type of calibration applied to solve for model parameters. The\n        possible values are:\n\n        * Bootstrap,\n        * Optimize,\n        * Global. Known values are: \"Bootstrap\", \"Optimize\", and \"Global\".\n    end_date : ~datetime.datetime\n        The end date of the calibration process. The value is expressed in ISO\n        8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Usually coincides with\n        the end date of the contract to price.\n    frequency : str\n        The frequency of the calibration. Usually it coincides with the\n        frequency of the contract to price.\n    parameter : str\n        The generic parameter name to solve for during calibration process. The\n        possible values are:\n\n        * Correlation,\n        * Factors,\n        * MeanReversion,\n        * MeanReversionSpread,\n        * Shift,Tenor,\n        * Volatility,\n        * VolatilityRatio,\n        * Alpha.\n    product_type : str or ~analyticsapi.models.ProductTypeEnum\n        Product type to use during the calibration process.  The possible\n        values are:\n\n        * Cap,\n        * Swaption. Known values are: \"Cap\" and \"Swaption\".\n    start_date : ~datetime.datetime\n        The start date of the calibration process. The value is expressed in\n        ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Usually coincides\n        with the start date of the contract to price or valuation date.\n    strike : str\n        The strike on which the model should be calibrated. It can be symbolic\n        (e.g 'ATM') or numeric.\n    tenor : str\n        The tenor of the calibration portfolio. In case of a CMS spread\n        contract, it defines the first tenor.\n    user_tenor : str\n        An additional custom tenor. In case of a CMS spread contract, it\n        defines the second tenor. If not used, an empty string should be\n        passed.\n    \n",
            "annotations": "    calendar: typing.Optional[str]\n    calibration_type: typing.Union[str, ForwardRef('_models.CalibrationTypeEnum'), NoneType]\n    end_date: typing.Optional[datetime.datetime]\n    frequency: typing.Optional[str]\n    parameter: typing.Optional[str]\n    product_type: typing.Union[str, ForwardRef('_models.ProductTypeEnum'), NoneType]\n    start_date: typing.Optional[datetime.datetime]\n    strike: typing.Optional[str]\n    tenor: typing.Optional[str]\n    user_tenor: typing.Optional[str]",
            "signature": "class Calibration:\n    \"\"\"\"\"\"\n    calendar: typing.Optional[str]\n    calibration_type: typing.Union[str, ForwardRef('_models.CalibrationTypeEnum'), NoneType]\n    end_date: typing.Optional[datetime.datetime]\n    frequency: typing.Optional[str]\n    parameter: typing.Optional[str]\n    product_type: typing.Union[str, ForwardRef('_models.ProductTypeEnum'), NoneType]\n    start_date: typing.Optional[datetime.datetime]\n    strike: typing.Optional[str]\n    tenor: typing.Optional[str]\n    user_tenor: typing.Optional[str]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.Calibration.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.instruments.structured_products.CalibrationTypeEnum",
                "lseg_analytics.instruments.structured_products.ProductTypeEnum"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "Calibration.__init__",
        "id": "lseg_analytics.instruments.structured_products.Calibration.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 9249,
        "content": "class Calibration:\n    @overload\n    def __init__(self, *, calendar: Optional[str] = None, calibration_type: Union[str, ForwardRef('_models.CalibrationTypeEnum'), NoneType] = None, end_date: Optional[datetime.datetime] = None, frequency: Optional[str] = None, parameter: Optional[str] = None, product_type: Union[str, ForwardRef('_models.ProductTypeEnum'), NoneType] = None, start_date: Optional[datetime.datetime] = None, strike: Optional[str] = None, tenor: Optional[str] = None, user_tenor: Optional[str] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "Calibration"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.Calibration"
            ],
            "use": [
                "lseg_analytics.instruments.structured_products.CalibrationTypeEnum",
                "lseg_analytics.instruments.structured_products.ProductTypeEnum"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "EnumChunk",
        "name": "CalibrationTypeEnum",
        "id": "lseg_analytics.instruments.structured_products.CalibrationTypeEnum",
        "content": "class CalibrationTypeEnum(str, Enum, metaclass=CaseInsensitiveEnumMeta):\n    \"\"\"Type of CalibrationTypeEnum.\"\"\"\n\n    BOOTSTRAP = \"Bootstrap\"\n    OPTIMIZE = \"Optimize\"\n    GLOBAL = \"Global\"\n",
        "metadata": {
            "doc": "Type of CalibrationTypeEnum.\n",
            "members": [
                "CalibrationTypeEnum.BOOTSTRAP = 'Bootstrap'",
                "CalibrationTypeEnum.OPTIMIZE = 'Optimize'",
                "CalibrationTypeEnum.GLOBAL = 'Global'"
            ],
            "signature": "class CalibrationTypeEnum(Enum):\n    \"\"\"\"\"\"\n    BOOTSTRAP = 'Bootstrap'\n    OPTIMIZE = 'Optimize'\n    GLOBAL = 'Global'"
        },
        "dependencies": {
            "children": [],
            "parent": [],
            "use": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "EnumChunk",
        "name": "FinancialContractAssetClassEnum",
        "id": "lseg_analytics.instruments.structured_products.FinancialContractAssetClassEnum",
        "content": "class FinancialContractAssetClassEnum(str, Enum, metaclass=CaseInsensitiveEnumMeta):\n    \"\"\"Type of FinancialContractAssetClassEnum.\"\"\"\n\n    FOREIGN_EXCHANGE = \"ForeignExchange\"\n    INTEREST_RATE = \"InterestRate\"\n    EQUITY = \"Equity\"\n",
        "metadata": {
            "doc": "Type of FinancialContractAssetClassEnum.\n",
            "members": [
                "FinancialContractAssetClassEnum.FOREIGN_EXCHANGE = 'ForeignExchange'",
                "FinancialContractAssetClassEnum.INTEREST_RATE = 'InterestRate'",
                "FinancialContractAssetClassEnum.EQUITY = 'Equity'"
            ],
            "signature": "class FinancialContractAssetClassEnum(Enum):\n    \"\"\"\"\"\"\n    FOREIGN_EXCHANGE = 'ForeignExchange'\n    INTEREST_RATE = 'InterestRate'\n    EQUITY = 'Equity'"
        },
        "dependencies": {
            "children": [],
            "parent": [],
            "use": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "FinancialContractResponse",
        "id": "lseg_analytics.instruments.structured_products.FinancialContractResponse",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "data",
                "type": "List[Any]"
            },
            {
                "name": "headers",
                "type": "List[Header]"
            },
            {
                "name": "statuses",
                "type": "List[int]"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 27216,
        "content": "class FinancialContractResponse:\n    \"\"\"The tabular response of the Financial Contract API of the Quantitative Analytics service.\n\n    Attributes\n    ----------\n    data : list[any]\n        The list that contains the values of requested fields for each\n        Financial Contract definition sent.Financial Contracts appears in the\n        rows and fields in the columns.  The default value is None, needs to be\n        assigned before using.\n    headers : list[~analyticsapi.models.Header]\n        The column headers of the requested fields.  The default value is None,\n        needs to be assigned before using.\n    statuses : list[int]\n        A list that contains the status of each calculation requested. Each\n        code is described in the \"Messages\" property. Codes higher than 1000\n        represents errors.  The default value is None, needs to be assigned\n        before using.\n    \n    \"\"\"\n    data: typing.Optional[typing.List[typing.Any]]\n    headers: typing.Optional[typing.List[ForwardRef('_models.Header')]]\n    statuses: typing.Optional[typing.List[int]]",
        "metadata": {
            "doc": "The tabular response of the Financial Contract API of the Quantitative Analytics service.\n\n    Attributes\n    ----------\n    data : list[any]\n        The list that contains the values of requested fields for each\n        Financial Contract definition sent.Financial Contracts appears in the\n        rows and fields in the columns.  The default value is None, needs to be\n        assigned before using.\n    headers : list[~analyticsapi.models.Header]\n        The column headers of the requested fields.  The default value is None,\n        needs to be assigned before using.\n    statuses : list[int]\n        A list that contains the status of each calculation requested. Each\n        code is described in the \"Messages\" property. Codes higher than 1000\n        represents errors.  The default value is None, needs to be assigned\n        before using.\n    \n",
            "annotations": "    data: typing.Optional[typing.List[typing.Any]]\n    headers: typing.Optional[typing.List[ForwardRef('_models.Header')]]\n    statuses: typing.Optional[typing.List[int]]",
            "signature": "class FinancialContractResponse:\n    \"\"\"\"\"\"\n    data: typing.Optional[typing.List[typing.Any]]\n    headers: typing.Optional[typing.List[ForwardRef('_models.Header')]]\n    statuses: typing.Optional[typing.List[int]]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.FinancialContractResponse.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.instruments.structured_products.Header"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "FinancialContractResponse.__init__",
        "id": "lseg_analytics.instruments.structured_products.FinancialContractResponse.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 27263,
        "content": "class FinancialContractResponse:\n    @overload\n    def __init__(self, *, data: Optional[List[Any]] = None, headers: Optional[List[ForwardRef('_models.Header')]] = None, statuses: Optional[List[int]] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "FinancialContractResponse"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.FinancialContractResponse"
            ],
            "use": [
                "lseg_analytics.instruments.structured_products.Header"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "GenericNumericalMethod",
        "id": "lseg_analytics.instruments.structured_products.GenericNumericalMethod",
        "params": [
            {
                "name": "method",
                "type": "MethodEnum",
                "valuelookup": "enum.MethodEnum"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 34461,
        "content": "class GenericNumericalMethod:\n    \"\"\"GenericNumericalMethod.\n\n    Attributes\n    ----------\n    method : str or ~analyticsapi.models.MethodEnum\n        The name of numerical method to be used for pricing. The possible\n        values are:\n\n        * MonteCarlo,\n        * Analytic,\n        * AmericanMonteCarlo,\n        * PDE(partial differential equation). Known values are: \"MonteCarlo\", \"Analytic\",\n        \"AmericanMonteCarlo\", and \"PDE\".\n    \n    \"\"\"\n    method: typing.Union[str, ForwardRef('_models.MethodEnum'), NoneType]",
        "metadata": {
            "doc": "GenericNumericalMethod.\n\n    Attributes\n    ----------\n    method : str or ~analyticsapi.models.MethodEnum\n        The name of numerical method to be used for pricing. The possible\n        values are:\n\n        * MonteCarlo,\n        * Analytic,\n        * AmericanMonteCarlo,\n        * PDE(partial differential equation). Known values are: \"MonteCarlo\", \"Analytic\",\n        \"AmericanMonteCarlo\", and \"PDE\".\n    \n",
            "annotations": "    method: typing.Union[str, ForwardRef('_models.MethodEnum'), NoneType]",
            "signature": "class GenericNumericalMethod:\n    \"\"\"\"\"\"\n    method: typing.Union[str, ForwardRef('_models.MethodEnum'), NoneType]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.GenericNumericalMethod.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.instruments.structured_products.MethodEnum"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "GenericNumericalMethod.__init__",
        "id": "lseg_analytics.instruments.structured_products.GenericNumericalMethod.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 34502,
        "content": "class GenericNumericalMethod:\n    @overload\n    def __init__(self, method: Union[str, ForwardRef('_models.MethodEnum'), NoneType] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "GenericNumericalMethod"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.GenericNumericalMethod"
            ],
            "use": [
                "lseg_analytics.instruments.structured_products.MethodEnum"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "Header",
        "id": "lseg_analytics.instruments.structured_products.Header",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "name",
                "type": "str"
            },
            {
                "name": "type",
                "type": "TypeEnum",
                "valuelookup": "enum.TypeEnum"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 34629,
        "content": "class Header:\n    \"\"\"Header.\n\n    Attributes\n    ----------\n    name : str\n        Name of the field.\n    type : str or ~analyticsapi.models.TypeEnum\n        Type of the field. Known values are: \"String\", \"Float\", \"DateTime\",\n        \"Integer\", \"Object\", \"Date\", \"Bool\", \"StringArray\", \"FloatArray\",\n        \"DateArray\", \"ObjectArray\", and \"InvalidField\".\n    \n    \"\"\"\n    name: typing.Optional[str]\n    type: typing.Union[str, ForwardRef('_models.TypeEnum'), NoneType]",
        "metadata": {
            "doc": "Header.\n\n    Attributes\n    ----------\n    name : str\n        Name of the field.\n    type : str or ~analyticsapi.models.TypeEnum\n        Type of the field. Known values are: \"String\", \"Float\", \"DateTime\",\n        \"Integer\", \"Object\", \"Date\", \"Bool\", \"StringArray\", \"FloatArray\",\n        \"DateArray\", \"ObjectArray\", and \"InvalidField\".\n    \n",
            "annotations": "    name: typing.Optional[str]\n    type: typing.Union[str, ForwardRef('_models.TypeEnum'), NoneType]",
            "signature": "class Header:\n    \"\"\"\"\"\"\n    name: typing.Optional[str]\n    type: typing.Union[str, ForwardRef('_models.TypeEnum'), NoneType]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.Header.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.instruments.structured_products.TypeEnum"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "Header.__init__",
        "id": "lseg_analytics.instruments.structured_products.Header.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 34666,
        "content": "class Header:\n    @overload\n    def __init__(self, *, name: Optional[str] = None, type: Union[str, ForwardRef('_models.TypeEnum'), NoneType] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "Header"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.Header"
            ],
            "use": [
                "lseg_analytics.instruments.structured_products.TypeEnum"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "IPAModelParameters",
        "id": "lseg_analytics.instruments.structured_products.IPAModelParameters",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 41489,
        "content": "class IPAModelParameters:\n    \"\"\"IPAModelParameters.\n    \"\"\"\n",
        "metadata": {
            "doc": "IPAModelParameters.\n",
            "annotations": "",
            "signature": "class IPAModelParameters:\n    \"\"\"\"\"\"\n"
        },
        "dependencies": {
            "children": [],
            "parent": [],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "MarketDataQps",
        "id": "lseg_analytics.instruments.structured_products.MarketDataQps",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 45954,
        "content": "class MarketDataQps:\n    \"\"\"MarketDataQps.\n    \"\"\"\n",
        "metadata": {
            "doc": "MarketDataQps.\n",
            "annotations": "",
            "signature": "class MarketDataQps:\n    \"\"\"\"\"\"\n"
        },
        "dependencies": {
            "children": [],
            "parent": [],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "EnumChunk",
        "name": "MethodEnum",
        "id": "lseg_analytics.instruments.structured_products.MethodEnum",
        "content": "class MethodEnum(str, Enum, metaclass=CaseInsensitiveEnumMeta):\n    \"\"\"Type of MethodEnum.\"\"\"\n\n    MONTE_CARLO = \"MonteCarlo\"\n    ANALYTIC = \"Analytic\"\n    AMERICAN_MONTE_CARLO = \"AmericanMonteCarlo\"\n    PDE = \"PDE\"\n",
        "metadata": {
            "doc": "Type of MethodEnum.\n",
            "members": [
                "MethodEnum.MONTE_CARLO = 'MonteCarlo'",
                "MethodEnum.ANALYTIC = 'Analytic'",
                "MethodEnum.AMERICAN_MONTE_CARLO = 'AmericanMonteCarlo'",
                "MethodEnum.PDE = 'PDE'"
            ],
            "signature": "class MethodEnum(Enum):\n    \"\"\"\"\"\"\n    MONTE_CARLO = 'MonteCarlo'\n    ANALYTIC = 'Analytic'\n    AMERICAN_MONTE_CARLO = 'AmericanMonteCarlo'\n    PDE = 'PDE'"
        },
        "dependencies": {
            "children": [],
            "parent": [],
            "use": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "ModelDefinition",
        "id": "lseg_analytics.instruments.structured_products.ModelDefinition",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "asset_class",
                "type": "FinancialContractAssetClassEnum",
                "valuelookup": "enum.FinancialContractAssetClassEnum"
            },
            {
                "name": "calibration_list",
                "type": "List[Calibration]"
            },
            {
                "name": "chain_ric",
                "type": "str"
            },
            {
                "name": "foreign_currency",
                "type": "str"
            },
            {
                "name": "model_name",
                "type": "ModelNameEnum",
                "valuelookup": "enum.ModelNameEnum"
            },
            {
                "name": "model_parameters",
                "type": "IPAModelParameters"
            },
            {
                "name": "reference_entity_type",
                "type": "str"
            },
            {
                "name": "underlying_code",
                "type": "str"
            },
            {
                "name": "underlying_currency",
                "type": "str"
            },
            {
                "name": "underlying_tag",
                "type": "str"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 46354,
        "content": "class ModelDefinition:\n    \"\"\"ModelDefinition.\n\n    Attributes\n    ----------\n    asset_class : str or ~analyticsapi.models.FinancialContractAssetClassEnum\n        The asset class of the underlying asset. The possible values are:\n\n        * Equity,\n        * InterestRate,\n        * ForeignExchange. Known values are: \"ForeignExchange\", \"InterestRate\", and \"Equity\".\n    calibration_list : list[~analyticsapi.models.Calibration]\n        The list of properties used to calibrate the model parameters. It is\n        used only for interest rate models. All properties are mandatory if\n        calibrationList is requested. Depending on the asset class the\n        different sets of parameters should be specified. The default value is\n        None, needs to be assigned before using.\n    chain_ric : str\n        The CDS chain RIC, if applicable.\n    foreign_currency : str\n        The foreign currency of the underlying asset. It is mainly used in FX\n        models in combination with the underlying currency. The value is\n        expressed in ISO 4217 alphabetical format (e.g., 'USD').\n    model_name : str or ~analyticsapi.models.ModelNameEnum\n        The name of the model to be used to price a specific underlying asset.\n        The possible values are: ForeignExchange:\n\n        * Deterministic,\n        * BlackScholes: stochastic model with constant volatility,\n        * BlackScholesVannaVolga: stochastic model extending the Black-Scholes model by incorporating\n        hedging costs,\n        * Dupire: stochastic model with deterministic non-constant volatility,\n        * Heston: stochastic model with stochastic volatility,\n        * HestonLocalStochasticVolatility: stochastic model with both stochastic volatility and local\n        volatility components,\n        * MarketBlackScholes: stochastic model with constant volatility,\n        * Andersen: stochastic model with deterministic non-constant volatility extending the Dupire\n        model by adding jumps.\n\n        InterestRate:\n\n        * Forward: deterministic model,\n        * HullWhite1Factor: stochastic model with one factor,\n        * HullWhite2Factor: stochastic model with two factors,\n        * LiborMarketModelnFactor: stochastic model with 'n' factors,\n        * MarketBlackScholes: stochastic model with constant volatility,\n        * Normal: stochastic model with constant volatility,\n        * StochasticAlphaBetaRho: stochastic model with stochastic volatility.\n\n        Equity:\n\n        * BlackScholes: stochastic model with constant volatility,\n        * Dupire: stochastic model with deterministic non-constant volatility,\n        * Heston: stochastic model with stochastic volatility,\n        * MarketBlackScholes: stochastic model with constant volatility,\n        * Andersen: stochastic model with deterministic non-constant volatility extending the Dupire\n        model by adding jumps. Known values are: \"BlackScholes\", \"BlackScholesVannaVolga\",\n        \"Deterministic\", \"DetIntensity\", \"Dupire\", \"Forward\", \"Gaussian\", \"Heston\", \"HullWhite1Factor\",\n        \"HullWhite2Factor\", \"LiborMarketModelnFactor\", \"LogNormal\", \"MarketBlackScholes\", \"Normal\",\n        \"StochasticAlphaBetaRho\", and \"Andersen\".\n    model_parameters : ~analyticsapi.models.IPAModelParameters\n    reference_entity_type : str\n    underlying_code : str\n        The code used to identify the underlying asset which is defined in\n        payoffDefinition and to which the model is applied.\n    underlying_currency : str\n        The currency of underlying asset which is used in payoff definition and\n        for which this model will be applied. The value is expressed in ISO\n        4217 alphabetical format (e.g., 'EUR'). Mandatory for assetClass =\n        'InterestRate'.\n    underlying_tag : str\n        Tag used to identify the model.\n    \n    \"\"\"\n    asset_class: typing.Union[str, ForwardRef('_models.FinancialContractAssetClassEnum'), NoneType]\n    calibration_list: typing.Optional[typing.List[ForwardRef('_models.Calibration')]]\n    chain_ric: typing.Optional[str]\n    foreign_currency: typing.Optional[str]\n    model_name: typing.Union[str, ForwardRef('_models.ModelNameEnum'), NoneType]\n    model_parameters: typing.Optional[ForwardRef('_models.IPAModelParameters')]\n    reference_entity_type: typing.Optional[str]\n    underlying_code: typing.Optional[str]\n    underlying_currency: typing.Optional[str]\n    underlying_tag: typing.Optional[str]",
        "metadata": {
            "doc": "ModelDefinition.\n\n    Attributes\n    ----------\n    asset_class : str or ~analyticsapi.models.FinancialContractAssetClassEnum\n        The asset class of the underlying asset. The possible values are:\n\n        * Equity,\n        * InterestRate,\n        * ForeignExchange. Known values are: \"ForeignExchange\", \"InterestRate\", and \"Equity\".\n    calibration_list : list[~analyticsapi.models.Calibration]\n        The list of properties used to calibrate the model parameters. It is\n        used only for interest rate models. All properties are mandatory if\n        calibrationList is requested. Depending on the asset class the\n        different sets of parameters should be specified. The default value is\n        None, needs to be assigned before using.\n    chain_ric : str\n        The CDS chain RIC, if applicable.\n    foreign_currency : str\n        The foreign currency of the underlying asset. It is mainly used in FX\n        models in combination with the underlying currency. The value is\n        expressed in ISO 4217 alphabetical format (e.g., 'USD').\n    model_name : str or ~analyticsapi.models.ModelNameEnum\n        The name of the model to be used to price a specific underlying asset.\n        The possible values are: ForeignExchange:\n\n        * Deterministic,\n        * BlackScholes: stochastic model with constant volatility,\n        * BlackScholesVannaVolga: stochastic model extending the Black-Scholes model by incorporating\n        hedging costs,\n        * Dupire: stochastic model with deterministic non-constant volatility,\n        * Heston: stochastic model with stochastic volatility,\n        * HestonLocalStochasticVolatility: stochastic model with both stochastic volatility and local\n        volatility components,\n        * MarketBlackScholes: stochastic model with constant volatility,\n        * Andersen: stochastic model with deterministic non-constant volatility extending the Dupire\n        model by adding jumps.\n\n        InterestRate:\n\n        * Forward: deterministic model,\n        * HullWhite1Factor: stochastic model with one factor,\n        * HullWhite2Factor: stochastic model with two factors,\n        * LiborMarketModelnFactor: stochastic model with 'n' factors,\n        * MarketBlackScholes: stochastic model with constant volatility,\n        * Normal: stochastic model with constant volatility,\n        * StochasticAlphaBetaRho: stochastic model with stochastic volatility.\n\n        Equity:\n\n        * BlackScholes: stochastic model with constant volatility,\n        * Dupire: stochastic model with deterministic non-constant volatility,\n        * Heston: stochastic model with stochastic volatility,\n        * MarketBlackScholes: stochastic model with constant volatility,\n        * Andersen: stochastic model with deterministic non-constant volatility extending the Dupire\n        model by adding jumps. Known values are: \"BlackScholes\", \"BlackScholesVannaVolga\",\n        \"Deterministic\", \"DetIntensity\", \"Dupire\", \"Forward\", \"Gaussian\", \"Heston\", \"HullWhite1Factor\",\n        \"HullWhite2Factor\", \"LiborMarketModelnFactor\", \"LogNormal\", \"MarketBlackScholes\", \"Normal\",\n        \"StochasticAlphaBetaRho\", and \"Andersen\".\n    model_parameters : ~analyticsapi.models.IPAModelParameters\n    reference_entity_type : str\n    underlying_code : str\n        The code used to identify the underlying asset which is defined in\n        payoffDefinition and to which the model is applied.\n    underlying_currency : str\n        The currency of underlying asset which is used in payoff definition and\n        for which this model will be applied. The value is expressed in ISO\n        4217 alphabetical format (e.g., 'EUR'). Mandatory for assetClass =\n        'InterestRate'.\n    underlying_tag : str\n        Tag used to identify the model.\n    \n",
            "annotations": "    asset_class: typing.Union[str, ForwardRef('_models.FinancialContractAssetClassEnum'), NoneType]\n    calibration_list: typing.Optional[typing.List[ForwardRef('_models.Calibration')]]\n    chain_ric: typing.Optional[str]\n    foreign_currency: typing.Optional[str]\n    model_name: typing.Union[str, ForwardRef('_models.ModelNameEnum'), NoneType]\n    model_parameters: typing.Optional[ForwardRef('_models.IPAModelParameters')]\n    reference_entity_type: typing.Optional[str]\n    underlying_code: typing.Optional[str]\n    underlying_currency: typing.Optional[str]\n    underlying_tag: typing.Optional[str]",
            "signature": "class ModelDefinition:\n    \"\"\"\"\"\"\n    asset_class: typing.Union[str, ForwardRef('_models.FinancialContractAssetClassEnum'), NoneType]\n    calibration_list: typing.Optional[typing.List[ForwardRef('_models.Calibration')]]\n    chain_ric: typing.Optional[str]\n    foreign_currency: typing.Optional[str]\n    model_name: typing.Union[str, ForwardRef('_models.ModelNameEnum'), NoneType]\n    model_parameters: typing.Optional[ForwardRef('_models.IPAModelParameters')]\n    reference_entity_type: typing.Optional[str]\n    underlying_code: typing.Optional[str]\n    underlying_currency: typing.Optional[str]\n    underlying_tag: typing.Optional[str]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.ModelDefinition.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.instruments.structured_products.FinancialContractAssetClassEnum",
                "lseg_analytics.instruments.structured_products.Calibration",
                "lseg_analytics.instruments.structured_products.ModelNameEnum",
                "lseg_analytics.instruments.structured_products.IPAModelParameters"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "ModelDefinition.__init__",
        "id": "lseg_analytics.instruments.structured_products.ModelDefinition.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 46522,
        "content": "class ModelDefinition:\n    @overload\n    def __init__(self, *, asset_class: Union[str, ForwardRef('_models.FinancialContractAssetClassEnum'), NoneType] = None, calibration_list: Optional[List[ForwardRef('_models.Calibration')]] = None, chain_ric: Optional[str] = None, foreign_currency: Optional[str] = None, model_name: Union[str, ForwardRef('_models.ModelNameEnum'), NoneType] = None, model_parameters: Optional[ForwardRef('_models.IPAModelParameters')] = None, reference_entity_type: Optional[str] = None, underlying_code: Optional[str] = None, underlying_currency: Optional[str] = None, underlying_tag: Optional[str] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "ModelDefinition"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.ModelDefinition"
            ],
            "use": [
                "lseg_analytics.instruments.structured_products.FinancialContractAssetClassEnum",
                "lseg_analytics.instruments.structured_products.Calibration",
                "lseg_analytics.instruments.structured_products.ModelNameEnum",
                "lseg_analytics.instruments.structured_products.IPAModelParameters"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "EnumChunk",
        "name": "ModelNameEnum",
        "id": "lseg_analytics.instruments.structured_products.ModelNameEnum",
        "content": "class ModelNameEnum(str, Enum, metaclass=CaseInsensitiveEnumMeta):\n    \"\"\"Type of ModelNameEnum.\"\"\"\n\n    BLACK_SCHOLES = \"BlackScholes\"\n    BLACK_SCHOLES_VANNA_VOLGA = \"BlackScholesVannaVolga\"\n    DETERMINISTIC = \"Deterministic\"\n    DET_INTENSITY = \"DetIntensity\"\n    DUPIRE = \"Dupire\"\n    FORWARD = \"Forward\"\n    GAUSSIAN = \"Gaussian\"\n    HESTON = \"Heston\"\n    HULL_WHITE1_FACTOR = \"HullWhite1Factor\"\n    HULL_WHITE2_FACTOR = \"HullWhite2Factor\"\n    LIBOR_MARKET_MODELN_FACTOR = \"LiborMarketModelnFactor\"\n    LOG_NORMAL = \"LogNormal\"\n    MARKET_BLACK_SCHOLES = \"MarketBlackScholes\"\n    NORMAL = \"Normal\"\n    STOCHASTIC_ALPHA_BETA_RHO = \"StochasticAlphaBetaRho\"\n    ANDERSEN = \"Andersen\"\n",
        "metadata": {
            "doc": "Type of ModelNameEnum.\n",
            "members": [
                "ModelNameEnum.BLACK_SCHOLES = 'BlackScholes'",
                "ModelNameEnum.BLACK_SCHOLES_VANNA_VOLGA = 'BlackScholesVannaVolga'",
                "ModelNameEnum.DETERMINISTIC = 'Deterministic'",
                "ModelNameEnum.DET_INTENSITY = 'DetIntensity'",
                "ModelNameEnum.DUPIRE = 'Dupire'",
                "ModelNameEnum.FORWARD = 'Forward'",
                "ModelNameEnum.GAUSSIAN = 'Gaussian'",
                "ModelNameEnum.HESTON = 'Heston'",
                "ModelNameEnum.HULL_WHITE1_FACTOR = 'HullWhite1Factor'",
                "ModelNameEnum.HULL_WHITE2_FACTOR = 'HullWhite2Factor'",
                "ModelNameEnum.LIBOR_MARKET_MODELN_FACTOR = 'LiborMarketModelnFactor'",
                "ModelNameEnum.LOG_NORMAL = 'LogNormal'",
                "ModelNameEnum.MARKET_BLACK_SCHOLES = 'MarketBlackScholes'",
                "ModelNameEnum.NORMAL = 'Normal'",
                "ModelNameEnum.STOCHASTIC_ALPHA_BETA_RHO = 'StochasticAlphaBetaRho'",
                "ModelNameEnum.ANDERSEN = 'Andersen'"
            ],
            "signature": "class ModelNameEnum(Enum):\n    \"\"\"\"\"\"\n    BLACK_SCHOLES = 'BlackScholes'\n    BLACK_SCHOLES_VANNA_VOLGA = 'BlackScholesVannaVolga'\n    DETERMINISTIC = 'Deterministic'\n    DET_INTENSITY = 'DetIntensity'\n    DUPIRE = 'Dupire'\n    FORWARD = 'Forward'\n    GAUSSIAN = 'Gaussian'\n    HESTON = 'Heston'\n    HULL_WHITE1_FACTOR = 'HullWhite1Factor'\n    HULL_WHITE2_FACTOR = 'HullWhite2Factor'\n    LIBOR_MARKET_MODELN_FACTOR = 'LiborMarketModelnFactor'\n    LOG_NORMAL = 'LogNormal'\n    MARKET_BLACK_SCHOLES = 'MarketBlackScholes'\n    NORMAL = 'Normal'\n    STOCHASTIC_ALPHA_BETA_RHO = 'StochasticAlphaBetaRho'\n    ANDERSEN = 'Andersen'"
        },
        "dependencies": {
            "children": [],
            "parent": [],
            "use": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "NameTypeValue",
        "id": "lseg_analytics.instruments.structured_products.NameTypeValue",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "basket",
                "type": "List[BasketItem]"
            },
            {
                "name": "name",
                "type": "str"
            },
            {
                "name": "type",
                "type": "str"
            },
            {
                "name": "value",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 46901,
        "content": "class NameTypeValue:\n    \"\"\"NameTypeValue.\n\n    Attributes\n    ----------\n    basket : list[~analyticsapi.models.BasketItem]\n        The default value is None, needs to be assigned before using.\n    name : str\n    type : str\n    value : any\n    \n    \"\"\"\n    basket: typing.Optional[typing.List[ForwardRef('_models.BasketItem')]]\n    name: typing.Optional[str]\n    type: typing.Optional[str]\n    value: typing.Optional[typing.Any]",
        "metadata": {
            "doc": "NameTypeValue.\n\n    Attributes\n    ----------\n    basket : list[~analyticsapi.models.BasketItem]\n        The default value is None, needs to be assigned before using.\n    name : str\n    type : str\n    value : any\n    \n",
            "annotations": "    basket: typing.Optional[typing.List[ForwardRef('_models.BasketItem')]]\n    name: typing.Optional[str]\n    type: typing.Optional[str]\n    value: typing.Optional[typing.Any]",
            "signature": "class NameTypeValue:\n    \"\"\"\"\"\"\n    basket: typing.Optional[typing.List[ForwardRef('_models.BasketItem')]]\n    name: typing.Optional[str]\n    type: typing.Optional[str]\n    value: typing.Optional[typing.Any]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.NameTypeValue.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.instruments.structured_products.BasketItem"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "NameTypeValue.__init__",
        "id": "lseg_analytics.instruments.structured_products.NameTypeValue.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 46937,
        "content": "class NameTypeValue:\n    @overload\n    def __init__(self, *, basket: Optional[List[ForwardRef('_models.BasketItem')]] = None, name: Optional[str] = None, type: Optional[str] = None, value: Optional[Any] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "NameTypeValue"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.NameTypeValue"
            ],
            "use": [
                "lseg_analytics.instruments.structured_products.BasketItem"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "EnumChunk",
        "name": "ProductTypeEnum",
        "id": "lseg_analytics.instruments.structured_products.ProductTypeEnum",
        "content": "class ProductTypeEnum(str, Enum, metaclass=CaseInsensitiveEnumMeta):\n    \"\"\"Type of ProductTypeEnum.\"\"\"\n\n    CAP = \"Cap\"\n    SWAPTION = \"Swaption\"\n",
        "metadata": {
            "doc": "Type of ProductTypeEnum.\n",
            "members": [
                "ProductTypeEnum.CAP = 'Cap'",
                "ProductTypeEnum.SWAPTION = 'Swaption'"
            ],
            "signature": "class ProductTypeEnum(Enum):\n    \"\"\"\"\"\"\n    CAP = 'Cap'\n    SWAPTION = 'Swaption'"
        },
        "dependencies": {
            "children": [],
            "parent": [],
            "use": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "StructuredProductsAnalyticsResponseData",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsAnalyticsResponseData",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "definitions",
                "type": "List[StructuredProductsDefinitionInstrument]"
            },
            {
                "name": "pricing_preferences",
                "type": "StructuredProductsPricingParameters"
            },
            {
                "name": "analytics",
                "type": "List[StructuredProductsAnalyticsResponseWithError]"
            },
            {
                "name": "market_data",
                "type": "MarketDataQps"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 55466,
        "content": "class StructuredProductsAnalyticsResponseData:\n    \"\"\"StructuredProductsAnalyticsResponseData.\n\n    Attributes\n    ----------\n    definitions : list[~analyticsapi.models.StructuredProductsDefinitionInstrument]\n        An array of objects describing a curve or an instrument. Please provide\n        either a full definition (for a user-defined curve/instrument), or\n        reference to a curve/instrument definition saved in the platform, or\n        the code identifying the existing curve/instrument.  The default value\n        is None, needs to be assigned before using.\n    pricing_preferences : ~analyticsapi.models.StructuredProductsPricingParameters\n        The parameters that control the computation of the analytics.\n    analytics : list[~analyticsapi.models.StructuredProductsAnalyticsResponseWithError]\n        The result of the calculation request.  The default value is None,\n        needs to be assigned before using.\n    market_data : ~analyticsapi.models.MarketDataQps\n        The market data used to compute the analytics.\n    \n    \"\"\"\n    definitions: typing.Optional[typing.List[ForwardRef('_models.StructuredProductsDefinitionInstrument')]]\n    pricing_preferences: typing.Optional[ForwardRef('_models.StructuredProductsPricingParameters')]\n    analytics: typing.Optional[typing.List[ForwardRef('_models.StructuredProductsAnalyticsResponseWithError')]]\n    market_data: typing.Optional[ForwardRef('_models.MarketDataQps')]",
        "metadata": {
            "doc": "StructuredProductsAnalyticsResponseData.\n\n    Attributes\n    ----------\n    definitions : list[~analyticsapi.models.StructuredProductsDefinitionInstrument]\n        An array of objects describing a curve or an instrument. Please provide\n        either a full definition (for a user-defined curve/instrument), or\n        reference to a curve/instrument definition saved in the platform, or\n        the code identifying the existing curve/instrument.  The default value\n        is None, needs to be assigned before using.\n    pricing_preferences : ~analyticsapi.models.StructuredProductsPricingParameters\n        The parameters that control the computation of the analytics.\n    analytics : list[~analyticsapi.models.StructuredProductsAnalyticsResponseWithError]\n        The result of the calculation request.  The default value is None,\n        needs to be assigned before using.\n    market_data : ~analyticsapi.models.MarketDataQps\n        The market data used to compute the analytics.\n    \n",
            "annotations": "    definitions: typing.Optional[typing.List[ForwardRef('_models.StructuredProductsDefinitionInstrument')]]\n    pricing_preferences: typing.Optional[ForwardRef('_models.StructuredProductsPricingParameters')]\n    analytics: typing.Optional[typing.List[ForwardRef('_models.StructuredProductsAnalyticsResponseWithError')]]\n    market_data: typing.Optional[ForwardRef('_models.MarketDataQps')]",
            "signature": "class StructuredProductsAnalyticsResponseData:\n    \"\"\"\"\"\"\n    definitions: typing.Optional[typing.List[ForwardRef('_models.StructuredProductsDefinitionInstrument')]]\n    pricing_preferences: typing.Optional[ForwardRef('_models.StructuredProductsPricingParameters')]\n    analytics: typing.Optional[typing.List[ForwardRef('_models.StructuredProductsAnalyticsResponseWithError')]]\n    market_data: typing.Optional[ForwardRef('_models.MarketDataQps')]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.StructuredProductsAnalyticsResponseData.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.instruments.structured_products.StructuredProductsDefinitionInstrument",
                "lseg_analytics.instruments.structured_products.StructuredProductsPricingParameters",
                "lseg_analytics.instruments.structured_products.StructuredProductsAnalyticsResponseWithError",
                "lseg_analytics.instruments.structured_products.MarketDataQps"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "StructuredProductsAnalyticsResponseData.__init__",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsAnalyticsResponseData.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 55517,
        "content": "class StructuredProductsAnalyticsResponseData:\n    @overload\n    def __init__(self, *, definitions: Optional[List[ForwardRef('_models.StructuredProductsDefinitionInstrument')]] = None, pricing_preferences: Optional[ForwardRef('_models.StructuredProductsPricingParameters')] = None, analytics: Optional[List[ForwardRef('_models.StructuredProductsAnalyticsResponseWithError')]] = None, market_data: Optional[ForwardRef('_models.MarketDataQps')] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "StructuredProductsAnalyticsResponseData"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.StructuredProductsAnalyticsResponseData"
            ],
            "use": [
                "lseg_analytics.instruments.structured_products.StructuredProductsDefinitionInstrument",
                "lseg_analytics.instruments.structured_products.StructuredProductsPricingParameters",
                "lseg_analytics.instruments.structured_products.StructuredProductsAnalyticsResponseWithError",
                "lseg_analytics.instruments.structured_products.MarketDataQps"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "StructuredProductsAnalyticsResponseWithError",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsAnalyticsResponseWithError",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "tabular_data",
                "type": "FinancialContractResponse"
            },
            {
                "name": "cashflows",
                "type": "StructuredProductsCashflows"
            },
            {
                "name": "description",
                "type": "StructuredProductsDescription"
            },
            {
                "name": "greeks",
                "type": "StructuredProductsGreeks"
            },
            {
                "name": "pricing_analysis",
                "type": "StructuredProductsPricingAnalysis"
            },
            {
                "name": "valuation",
                "type": "StructuredProductsValuation"
            },
            {
                "name": "error",
                "type": "ServiceError"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 55521,
        "content": "class StructuredProductsAnalyticsResponseWithError:\n    \"\"\"A model template describing a response with an error for a given object.\n\n    Attributes\n    ----------\n    tabular_data : ~analyticsapi.models.FinancialContractResponse\n        Standard Financial Contract Analytics in tabular format.\n    cashflows : ~analyticsapi.models.StructuredProductsCashflows\n        Response categorized under Cashflows.\n    description : ~analyticsapi.models.StructuredProductsDescription\n        Response categorized under Description.\n    greeks : ~analyticsapi.models.StructuredProductsGreeks\n        Response categorized under Greeks.\n    pricing_analysis : ~analyticsapi.models.StructuredProductsPricingAnalysis\n        Response categorized under Pricing analysis.\n    valuation : ~analyticsapi.models.StructuredProductsValuation\n        Response categorized under Valuation.\n    error : ~analyticsapi.models.ServiceError\n        The error message for the calculation in case of a non-blocking error.\n    \n    \"\"\"\n    tabular_data: typing.Optional[ForwardRef('_models.FinancialContractResponse')]\n    cashflows: typing.Optional[ForwardRef('_models.StructuredProductsCashflows')]\n    description: typing.Optional[ForwardRef('_models.StructuredProductsDescription')]\n    greeks: typing.Optional[ForwardRef('_models.StructuredProductsGreeks')]\n    pricing_analysis: typing.Optional[ForwardRef('_models.StructuredProductsPricingAnalysis')]\n    valuation: typing.Optional[ForwardRef('_models.StructuredProductsValuation')]\n    error: typing.Optional[ForwardRef('_models.ServiceError')]",
        "metadata": {
            "doc": "A model template describing a response with an error for a given object.\n\n    Attributes\n    ----------\n    tabular_data : ~analyticsapi.models.FinancialContractResponse\n        Standard Financial Contract Analytics in tabular format.\n    cashflows : ~analyticsapi.models.StructuredProductsCashflows\n        Response categorized under Cashflows.\n    description : ~analyticsapi.models.StructuredProductsDescription\n        Response categorized under Description.\n    greeks : ~analyticsapi.models.StructuredProductsGreeks\n        Response categorized under Greeks.\n    pricing_analysis : ~analyticsapi.models.StructuredProductsPricingAnalysis\n        Response categorized under Pricing analysis.\n    valuation : ~analyticsapi.models.StructuredProductsValuation\n        Response categorized under Valuation.\n    error : ~analyticsapi.models.ServiceError\n        The error message for the calculation in case of a non-blocking error.\n    \n",
            "annotations": "    tabular_data: typing.Optional[ForwardRef('_models.FinancialContractResponse')]\n    cashflows: typing.Optional[ForwardRef('_models.StructuredProductsCashflows')]\n    description: typing.Optional[ForwardRef('_models.StructuredProductsDescription')]\n    greeks: typing.Optional[ForwardRef('_models.StructuredProductsGreeks')]\n    pricing_analysis: typing.Optional[ForwardRef('_models.StructuredProductsPricingAnalysis')]\n    valuation: typing.Optional[ForwardRef('_models.StructuredProductsValuation')]\n    error: typing.Optional[ForwardRef('_models.ServiceError')]",
            "signature": "class StructuredProductsAnalyticsResponseWithError:\n    \"\"\"\"\"\"\n    tabular_data: typing.Optional[ForwardRef('_models.FinancialContractResponse')]\n    cashflows: typing.Optional[ForwardRef('_models.StructuredProductsCashflows')]\n    description: typing.Optional[ForwardRef('_models.StructuredProductsDescription')]\n    greeks: typing.Optional[ForwardRef('_models.StructuredProductsGreeks')]\n    pricing_analysis: typing.Optional[ForwardRef('_models.StructuredProductsPricingAnalysis')]\n    valuation: typing.Optional[ForwardRef('_models.StructuredProductsValuation')]\n    error: typing.Optional[ForwardRef('_models.ServiceError')]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.StructuredProductsAnalyticsResponseWithError.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.instruments.structured_products.FinancialContractResponse",
                "lseg_analytics.instruments.structured_products.StructuredProductsCashflows",
                "lseg_analytics.instruments.structured_products.StructuredProductsDescription",
                "lseg_analytics.instruments.structured_products.StructuredProductsGreeks",
                "lseg_analytics.instruments.structured_products.StructuredProductsPricingAnalysis",
                "lseg_analytics.instruments.structured_products.StructuredProductsValuation",
                "lseg_analytics.common.ServiceError"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "StructuredProductsAnalyticsResponseWithError.__init__",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsAnalyticsResponseWithError.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 55579,
        "content": "class StructuredProductsAnalyticsResponseWithError:\n    @overload\n    def __init__(self, *, tabular_data: Optional[ForwardRef('_models.FinancialContractResponse')] = None, cashflows: Optional[ForwardRef('_models.StructuredProductsCashflows')] = None, description: Optional[ForwardRef('_models.StructuredProductsDescription')] = None, greeks: Optional[ForwardRef('_models.StructuredProductsGreeks')] = None, pricing_analysis: Optional[ForwardRef('_models.StructuredProductsPricingAnalysis')] = None, valuation: Optional[ForwardRef('_models.StructuredProductsValuation')] = None, error: Optional[ForwardRef('_models.ServiceError')] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "StructuredProductsAnalyticsResponseWithError"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.StructuredProductsAnalyticsResponseWithError"
            ],
            "use": [
                "lseg_analytics.instruments.structured_products.FinancialContractResponse",
                "lseg_analytics.instruments.structured_products.StructuredProductsCashflows",
                "lseg_analytics.instruments.structured_products.StructuredProductsDescription",
                "lseg_analytics.instruments.structured_products.StructuredProductsGreeks",
                "lseg_analytics.instruments.structured_products.StructuredProductsPricingAnalysis",
                "lseg_analytics.instruments.structured_products.StructuredProductsValuation",
                "lseg_analytics.common.ServiceError"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "StructuredProductsCalculationResponse",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsCalculationResponse",
        "params": [
            {
                "name": "data",
                "type": "StructuredProductsAnalyticsResponseData"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 55583,
        "content": "class StructuredProductsCalculationResponse:\n    \"\"\"A model template describing the analytics response returned for an instrument provided as part\n    of the request.\n\n    Attributes\n    ----------\n    data : ~analyticsapi.models.StructuredProductsAnalyticsResponseData\n        An object that contains calculated analytics, requested, and other data\n        used for calculation. Required.\n    \n    \"\"\"\n    data: _models.StructuredProductsAnalyticsResponseData",
        "metadata": {
            "doc": "A model template describing the analytics response returned for an instrument provided as part\n    of the request.\n\n    Attributes\n    ----------\n    data : ~analyticsapi.models.StructuredProductsAnalyticsResponseData\n        An object that contains calculated analytics, requested, and other data\n        used for calculation. Required.\n    \n",
            "annotations": "    data: _models.StructuredProductsAnalyticsResponseData",
            "signature": "class StructuredProductsCalculationResponse:\n    \"\"\"\"\"\"\n    data: _models.StructuredProductsAnalyticsResponseData"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.StructuredProductsCalculationResponse.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.instruments.structured_products.StructuredProductsAnalyticsResponseData"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "StructuredProductsCalculationResponse.__init__",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsCalculationResponse.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 55613,
        "content": "class StructuredProductsCalculationResponse:\n    @overload\n    def __init__(self, data: '_models.StructuredProductsAnalyticsResponseData') -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "StructuredProductsCalculationResponse"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.StructuredProductsCalculationResponse"
            ],
            "use": [
                "lseg_analytics.instruments.structured_products.StructuredProductsAnalyticsResponseData"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "StructuredProductsCashflows",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsCashflows",
        "params": [
            {
                "name": "cash_flows",
                "type": "List[Any]"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 55620,
        "content": "class StructuredProductsCashflows:\n    \"\"\"Cashflows Object.\n\n    Attributes\n    ----------\n    cash_flows : list[any]\n        The information on the contract's cash flows during its lifetime. It\n        consists of the following properties:\n\n        * legTag: the leg information,\n        * instrumentType: the instrument type for which cash flows are computed,\n        * payments: the array of properties which define all instruments cash flows (paid and received)\n        during its lifetime.\n\n        For more details, please refer here.  The default value is None, needs to be assigned before\n        using.\n    \n    \"\"\"\n    cash_flows: typing.Optional[typing.List[typing.Any]]",
        "metadata": {
            "doc": "Cashflows Object.\n\n    Attributes\n    ----------\n    cash_flows : list[any]\n        The information on the contract's cash flows during its lifetime. It\n        consists of the following properties:\n\n        * legTag: the leg information,\n        * instrumentType: the instrument type for which cash flows are computed,\n        * payments: the array of properties which define all instruments cash flows (paid and received)\n        during its lifetime.\n\n        For more details, please refer here.  The default value is None, needs to be assigned before\n        using.\n    \n",
            "annotations": "    cash_flows: typing.Optional[typing.List[typing.Any]]",
            "signature": "class StructuredProductsCashflows:\n    \"\"\"\"\"\"\n    cash_flows: typing.Optional[typing.List[typing.Any]]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.StructuredProductsCashflows.__init__"
            ],
            "parent": [],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "StructuredProductsCashflows.__init__",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsCashflows.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 55665,
        "content": "class StructuredProductsCashflows:\n    @overload\n    def __init__(self, cash_flows: Optional[List[Any]] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "StructuredProductsCashflows"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.StructuredProductsCashflows"
            ],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "StructuredProductsDefinition",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsDefinition",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "deal_ccy",
                "type": "str"
            },
            {
                "name": "inputs",
                "type": "List[NameTypeValue]"
            },
            {
                "name": "instrument_tag",
                "type": "str"
            },
            {
                "name": "payoff_description",
                "type": "List[str]"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 55672,
        "content": "class StructuredProductsDefinition:\n    \"\"\"StructuredProductsDefinition.\n\n    Attributes\n    ----------\n    deal_ccy : str\n    inputs : list[~analyticsapi.models.NameTypeValue]\n        The default value is None, needs to be assigned before using.\n    instrument_tag : str\n    payoff_description : list[list[str]]\n        The default value is None, needs to be assigned before using.\n    \n    \"\"\"\n    deal_ccy: typing.Optional[str]\n    inputs: typing.Optional[typing.List[ForwardRef('_models.NameTypeValue')]]\n    instrument_tag: typing.Optional[str]\n    payoff_description: typing.Optional[typing.List[typing.List[str]]]",
        "metadata": {
            "doc": "StructuredProductsDefinition.\n\n    Attributes\n    ----------\n    deal_ccy : str\n    inputs : list[~analyticsapi.models.NameTypeValue]\n        The default value is None, needs to be assigned before using.\n    instrument_tag : str\n    payoff_description : list[list[str]]\n        The default value is None, needs to be assigned before using.\n    \n",
            "annotations": "    deal_ccy: typing.Optional[str]\n    inputs: typing.Optional[typing.List[ForwardRef('_models.NameTypeValue')]]\n    instrument_tag: typing.Optional[str]\n    payoff_description: typing.Optional[typing.List[typing.List[str]]]",
            "signature": "class StructuredProductsDefinition:\n    \"\"\"\"\"\"\n    deal_ccy: typing.Optional[str]\n    inputs: typing.Optional[typing.List[ForwardRef('_models.NameTypeValue')]]\n    instrument_tag: typing.Optional[str]\n    payoff_description: typing.Optional[typing.List[typing.List[str]]]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.StructuredProductsDefinition.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.instruments.structured_products.NameTypeValue"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "StructuredProductsDefinition.__init__",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsDefinition.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 55709,
        "content": "class StructuredProductsDefinition:\n    @overload\n    def __init__(self, *, deal_ccy: Optional[str] = None, inputs: Optional[List[ForwardRef('_models.NameTypeValue')]] = None, instrument_tag: Optional[str] = None, payoff_description: Optional[List[List[str]]] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "StructuredProductsDefinition"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.StructuredProductsDefinition"
            ],
            "use": [
                "lseg_analytics.instruments.structured_products.NameTypeValue"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "StructuredProductsDefinitionInstrument",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsDefinitionInstrument",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "definition",
                "type": "StructuredProductsDefinition"
            },
            {
                "name": "reference",
                "type": "str"
            },
            {
                "name": "code",
                "type": "str"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 55713,
        "content": "class StructuredProductsDefinitionInstrument:\n    \"\"\"An array of objects describing a curve or an instrument.\n    Please provide either a full definition (for a user-defined curve/instrument), or reference to\n    a curve/instrument definition saved in the platform, or the code identifying the existing\n    curve/instrument.\n\n    Attributes\n    ----------\n    definition : ~analyticsapi.models.StructuredProductsDefinition\n        The object that describes the definition of the instrument.\n    reference : str\n        The identifier of a resource (instrument definition, curve definition)\n        that is already in the platform.\n    code : str\n        The unique public code used to identify an instrument that exists on\n        the market (ISIN, RIC, etc.).\n    \n    \"\"\"\n    definition: typing.Optional[ForwardRef('_models.StructuredProductsDefinition')]\n    reference: typing.Optional[str]\n    code: typing.Optional[str]",
        "metadata": {
            "doc": "An array of objects describing a curve or an instrument.\n    Please provide either a full definition (for a user-defined curve/instrument), or reference to\n    a curve/instrument definition saved in the platform, or the code identifying the existing\n    curve/instrument.\n\n    Attributes\n    ----------\n    definition : ~analyticsapi.models.StructuredProductsDefinition\n        The object that describes the definition of the instrument.\n    reference : str\n        The identifier of a resource (instrument definition, curve definition)\n        that is already in the platform.\n    code : str\n        The unique public code used to identify an instrument that exists on\n        the market (ISIN, RIC, etc.).\n    \n",
            "annotations": "    definition: typing.Optional[ForwardRef('_models.StructuredProductsDefinition')]\n    reference: typing.Optional[str]\n    code: typing.Optional[str]",
            "signature": "class StructuredProductsDefinitionInstrument:\n    \"\"\"\"\"\"\n    definition: typing.Optional[ForwardRef('_models.StructuredProductsDefinition')]\n    reference: typing.Optional[str]\n    code: typing.Optional[str]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.StructuredProductsDefinitionInstrument.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.instruments.structured_products.StructuredProductsDefinition"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "StructuredProductsDefinitionInstrument.__init__",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsDefinitionInstrument.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 55758,
        "content": "class StructuredProductsDefinitionInstrument:\n    @overload\n    def __init__(self, *, definition: Optional[ForwardRef('_models.StructuredProductsDefinition')] = None, reference: Optional[str] = None, code: Optional[str] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "StructuredProductsDefinitionInstrument"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.StructuredProductsDefinitionInstrument"
            ],
            "use": [
                "lseg_analytics.instruments.structured_products.StructuredProductsDefinition"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "StructuredProductsDescription",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsDescription",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "instrument_tag",
                "type": "str"
            },
            {
                "name": "deal_ccy",
                "type": "str"
            },
            {
                "name": "report_ccy",
                "type": "str"
            },
            {
                "name": "discount_curve_id",
                "type": "str"
            },
            {
                "name": "discount_curve_name",
                "type": "str"
            },
            {
                "name": "inputs",
                "type": "List[Any]"
            },
            {
                "name": "payoff_description",
                "type": "List[str]"
            },
            {
                "name": "output_list",
                "type": "Any"
            },
            {
                "name": "processing_information",
                "type": "str"
            },
            {
                "name": "error_message",
                "type": "str"
            },
            {
                "name": "error_code",
                "type": "str"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 55762,
        "content": "class StructuredProductsDescription:\n    \"\"\"Description Object.\n\n    Attributes\n    ----------\n    instrument_tag : str\n        A user defined string to identify the instrument. It can be used to\n        link output results to the instrument definition. Limited to 40\n        characters. Only alphabetic, numeric and '- _.#=@' characters are\n        supported.\n    deal_ccy : str\n        The currency code which depending on the instrument represents:\n\n        * for FX instruments: the deal (base) currency,\n        * for Swap: the currency of the paid leg,\n        * for other instruments: the currency of the instrument's notional amount.\n\n        The value is expressed in ISO 4217 alphabetical format (e.g., 'USD').\n    report_ccy : str\n        The currency code set for the fields ending with '  xxxInReportCcy  '.\n        The value is expressed in ISO 4217 alphabetical format (e.g., '  USD\n        ').\n    discount_curve_id : str\n        The identifier of the zero-coupon curve used to discount the\n        instrument's future payments.\n    discount_curve_name : str\n        The name of the zero-coupon curve used to discount the instrument's\n        cash flows. Specifying data for this curve can be set using the market\n        data section. By default, the discount curve is found from the\n        instrument's currency and frequency.\n    inputs : list[any]\n        The list of input properties that define variables and their associated\n        values to be used in payoffDescription. For a detailed breakdown,\n        please refer here.  The default value is None, needs to be assigned\n        before using.\n    payoff_description : list[list[str]]\n        The list of string arrays that describes the instrument payoff.  The\n        default value is None, needs to be assigned before using.\n    output_list : any\n        The total present value of future cash flow payments coming from each\n        payoff input parameter defined in  payoffDescription  .\n    processing_information : str\n        The error message for the calculation in case of a non-blocking error.\n    error_message : str\n        The error message in case of a blocking error in calculation.\n    error_code : str\n        The code of  ErrorMessage.\n    \n    \"\"\"\n    instrument_tag: typing.Optional[str]\n    deal_ccy: typing.Optional[str]\n    report_ccy: typing.Optional[str]\n    discount_curve_id: typing.Optional[str]\n    discount_curve_name: typing.Optional[str]\n    inputs: typing.Optional[typing.List[typing.Any]]\n    payoff_description: typing.Optional[typing.List[typing.List[str]]]\n    output_list: typing.Optional[typing.Any]\n    processing_information: typing.Optional[str]\n    error_message: typing.Optional[str]\n    error_code: typing.Optional[str]",
        "metadata": {
            "doc": "Description Object.\n\n    Attributes\n    ----------\n    instrument_tag : str\n        A user defined string to identify the instrument. It can be used to\n        link output results to the instrument definition. Limited to 40\n        characters. Only alphabetic, numeric and '- _.#=@' characters are\n        supported.\n    deal_ccy : str\n        The currency code which depending on the instrument represents:\n\n        * for FX instruments: the deal (base) currency,\n        * for Swap: the currency of the paid leg,\n        * for other instruments: the currency of the instrument's notional amount.\n\n        The value is expressed in ISO 4217 alphabetical format (e.g., 'USD').\n    report_ccy : str\n        The currency code set for the fields ending with '  xxxInReportCcy  '.\n        The value is expressed in ISO 4217 alphabetical format (e.g., '  USD\n        ').\n    discount_curve_id : str\n        The identifier of the zero-coupon curve used to discount the\n        instrument's future payments.\n    discount_curve_name : str\n        The name of the zero-coupon curve used to discount the instrument's\n        cash flows. Specifying data for this curve can be set using the market\n        data section. By default, the discount curve is found from the\n        instrument's currency and frequency.\n    inputs : list[any]\n        The list of input properties that define variables and their associated\n        values to be used in payoffDescription. For a detailed breakdown,\n        please refer here.  The default value is None, needs to be assigned\n        before using.\n    payoff_description : list[list[str]]\n        The list of string arrays that describes the instrument payoff.  The\n        default value is None, needs to be assigned before using.\n    output_list : any\n        The total present value of future cash flow payments coming from each\n        payoff input parameter defined in  payoffDescription  .\n    processing_information : str\n        The error message for the calculation in case of a non-blocking error.\n    error_message : str\n        The error message in case of a blocking error in calculation.\n    error_code : str\n        The code of  ErrorMessage.\n    \n",
            "annotations": "    instrument_tag: typing.Optional[str]\n    deal_ccy: typing.Optional[str]\n    report_ccy: typing.Optional[str]\n    discount_curve_id: typing.Optional[str]\n    discount_curve_name: typing.Optional[str]\n    inputs: typing.Optional[typing.List[typing.Any]]\n    payoff_description: typing.Optional[typing.List[typing.List[str]]]\n    output_list: typing.Optional[typing.Any]\n    processing_information: typing.Optional[str]\n    error_message: typing.Optional[str]\n    error_code: typing.Optional[str]",
            "signature": "class StructuredProductsDescription:\n    \"\"\"\"\"\"\n    instrument_tag: typing.Optional[str]\n    deal_ccy: typing.Optional[str]\n    report_ccy: typing.Optional[str]\n    discount_curve_id: typing.Optional[str]\n    discount_curve_name: typing.Optional[str]\n    inputs: typing.Optional[typing.List[typing.Any]]\n    payoff_description: typing.Optional[typing.List[typing.List[str]]]\n    output_list: typing.Optional[typing.Any]\n    processing_information: typing.Optional[str]\n    error_message: typing.Optional[str]\n    error_code: typing.Optional[str]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.StructuredProductsDescription.__init__"
            ],
            "parent": [],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "StructuredProductsDescription.__init__",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsDescription.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 55875,
        "content": "class StructuredProductsDescription:\n    @overload\n    def __init__(self, *, instrument_tag: Optional[str] = None, deal_ccy: Optional[str] = None, report_ccy: Optional[str] = None, discount_curve_id: Optional[str] = None, discount_curve_name: Optional[str] = None, inputs: Optional[List[Any]] = None, payoff_description: Optional[List[List[str]]] = None, output_list: Optional[Any] = None, processing_information: Optional[str] = None, error_message: Optional[str] = None, error_code: Optional[str] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "StructuredProductsDescription"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.StructuredProductsDescription"
            ],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "StructuredProductsGreeks",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsGreeks",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "delta_amount_in_deal_ccy",
                "type": "float"
            },
            {
                "name": "delta_amount_in_report_ccy",
                "type": "float"
            },
            {
                "name": "gamma_amount_in_deal_ccy",
                "type": "float"
            },
            {
                "name": "gamma_amount_in_report_ccy",
                "type": "float"
            },
            {
                "name": "vega_amount_in_deal_ccy",
                "type": "float"
            },
            {
                "name": "vega_amount_in_report_ccy",
                "type": "float"
            },
            {
                "name": "theta_amount_in_deal_ccy",
                "type": "float"
            },
            {
                "name": "theta_amount_in_report_ccy",
                "type": "float"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 55879,
        "content": "class StructuredProductsGreeks:\n    \"\"\"Greeks Object.\n\n    Attributes\n    ----------\n    delta_amount_in_deal_ccy : float\n        The change in the instrument's price or market value caused by a one-\n        unit change in the price of the underlying asset, or by 1bp change in\n        the swap rate for a swaption, or by 100bp change in the outright for FX\n        instruments. The value is expressed in the deal currency.\n    delta_amount_in_report_ccy : float\n        The change in the instrument's price or market value caused by a one-\n        unit change in the price of the underlying asset, or by 1bp change in\n        the swap rate for a swaption, or by 100bp change in the outright for FX\n        instruments. The value is expressed in the reporting currency.\n    gamma_amount_in_deal_ccy : float\n        The change in the option's delta or DV01 per a one-unit change in the\n        price of the underlying asset, or 1 unit parallel shift in the curve\n        representing the instrument. The value is expressed in the deal\n        currency.\n    gamma_amount_in_report_ccy : float\n        The change in the option's delta or DV01 per a one-unit change in the\n        price of the underlying asset, or 1 unit parallel shift in the curve\n        representing the instrument. The value is expressed in the reporting\n        currency.\n    vega_amount_in_deal_ccy : float\n        The change in the instrument's price per 1% change in the implied\n        volatility of the underlying asset. The value is expressed in the deal\n        currency.\n    vega_amount_in_report_ccy : float\n        The change in the instrument's price per 1% change in the implied\n        volatility of the underlying asset. The value is expressed in the\n        reporting currency.\n    theta_amount_in_deal_ccy : float\n        The change in the instrument's price or market value caused by a one-\n        day decrease in its time to expiration. The value is expressed in the\n        deal currency.\n    theta_amount_in_report_ccy : float\n        The change in the instrument's price or market value caused by a one-\n        day decrease in its time to expiration. The value is expressed in the\n        reporting currency.\n    \n    \"\"\"\n    delta_amount_in_deal_ccy: typing.Optional[float]\n    delta_amount_in_report_ccy: typing.Optional[float]\n    gamma_amount_in_deal_ccy: typing.Optional[float]\n    gamma_amount_in_report_ccy: typing.Optional[float]\n    vega_amount_in_deal_ccy: typing.Optional[float]\n    vega_amount_in_report_ccy: typing.Optional[float]\n    theta_amount_in_deal_ccy: typing.Optional[float]\n    theta_amount_in_report_ccy: typing.Optional[float]",
        "metadata": {
            "doc": "Greeks Object.\n\n    Attributes\n    ----------\n    delta_amount_in_deal_ccy : float\n        The change in the instrument's price or market value caused by a one-\n        unit change in the price of the underlying asset, or by 1bp change in\n        the swap rate for a swaption, or by 100bp change in the outright for FX\n        instruments. The value is expressed in the deal currency.\n    delta_amount_in_report_ccy : float\n        The change in the instrument's price or market value caused by a one-\n        unit change in the price of the underlying asset, or by 1bp change in\n        the swap rate for a swaption, or by 100bp change in the outright for FX\n        instruments. The value is expressed in the reporting currency.\n    gamma_amount_in_deal_ccy : float\n        The change in the option's delta or DV01 per a one-unit change in the\n        price of the underlying asset, or 1 unit parallel shift in the curve\n        representing the instrument. The value is expressed in the deal\n        currency.\n    gamma_amount_in_report_ccy : float\n        The change in the option's delta or DV01 per a one-unit change in the\n        price of the underlying asset, or 1 unit parallel shift in the curve\n        representing the instrument. The value is expressed in the reporting\n        currency.\n    vega_amount_in_deal_ccy : float\n        The change in the instrument's price per 1% change in the implied\n        volatility of the underlying asset. The value is expressed in the deal\n        currency.\n    vega_amount_in_report_ccy : float\n        The change in the instrument's price per 1% change in the implied\n        volatility of the underlying asset. The value is expressed in the\n        reporting currency.\n    theta_amount_in_deal_ccy : float\n        The change in the instrument's price or market value caused by a one-\n        day decrease in its time to expiration. The value is expressed in the\n        deal currency.\n    theta_amount_in_report_ccy : float\n        The change in the instrument's price or market value caused by a one-\n        day decrease in its time to expiration. The value is expressed in the\n        reporting currency.\n    \n",
            "annotations": "    delta_amount_in_deal_ccy: typing.Optional[float]\n    delta_amount_in_report_ccy: typing.Optional[float]\n    gamma_amount_in_deal_ccy: typing.Optional[float]\n    gamma_amount_in_report_ccy: typing.Optional[float]\n    vega_amount_in_deal_ccy: typing.Optional[float]\n    vega_amount_in_report_ccy: typing.Optional[float]\n    theta_amount_in_deal_ccy: typing.Optional[float]\n    theta_amount_in_report_ccy: typing.Optional[float]",
            "signature": "class StructuredProductsGreeks:\n    \"\"\"\"\"\"\n    delta_amount_in_deal_ccy: typing.Optional[float]\n    delta_amount_in_report_ccy: typing.Optional[float]\n    gamma_amount_in_deal_ccy: typing.Optional[float]\n    gamma_amount_in_report_ccy: typing.Optional[float]\n    vega_amount_in_deal_ccy: typing.Optional[float]\n    vega_amount_in_report_ccy: typing.Optional[float]\n    theta_amount_in_deal_ccy: typing.Optional[float]\n    theta_amount_in_report_ccy: typing.Optional[float]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.StructuredProductsGreeks.__init__"
            ],
            "parent": [],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "StructuredProductsGreeks.__init__",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsGreeks.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 55974,
        "content": "class StructuredProductsGreeks:\n    @overload\n    def __init__(self, *, delta_amount_in_deal_ccy: Optional[float] = None, delta_amount_in_report_ccy: Optional[float] = None, gamma_amount_in_deal_ccy: Optional[float] = None, gamma_amount_in_report_ccy: Optional[float] = None, vega_amount_in_deal_ccy: Optional[float] = None, vega_amount_in_report_ccy: Optional[float] = None, theta_amount_in_deal_ccy: Optional[float] = None, theta_amount_in_report_ccy: Optional[float] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "StructuredProductsGreeks"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.StructuredProductsGreeks"
            ],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "StructuredProductsPricingAnalysis",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsPricingAnalysis",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "valuation_date",
                "type": "datetime"
            },
            {
                "name": "market_data_date",
                "type": "datetime"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 55978,
        "content": "class StructuredProductsPricingAnalysis:\n    \"\"\"Pricing analysis Object.\n\n    Attributes\n    ----------\n    valuation_date : ~datetime.datetime\n        The date at which the instrument is valued. The value is expressed in\n        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '\n        2021-01-01T00:00:00Z  ').\n    market_data_date : ~datetime.datetime\n        The date at which the market data is retrieved. The value is expressed\n        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '\n        2021-01-01T00:00:00Z  ').\n    \n    \"\"\"\n    valuation_date: typing.Optional[datetime.datetime]\n    market_data_date: typing.Optional[datetime.datetime]",
        "metadata": {
            "doc": "Pricing analysis Object.\n\n    Attributes\n    ----------\n    valuation_date : ~datetime.datetime\n        The date at which the instrument is valued. The value is expressed in\n        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '\n        2021-01-01T00:00:00Z  ').\n    market_data_date : ~datetime.datetime\n        The date at which the market data is retrieved. The value is expressed\n        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '\n        2021-01-01T00:00:00Z  ').\n    \n",
            "annotations": "    valuation_date: typing.Optional[datetime.datetime]\n    market_data_date: typing.Optional[datetime.datetime]",
            "signature": "class StructuredProductsPricingAnalysis:\n    \"\"\"\"\"\"\n    valuation_date: typing.Optional[datetime.datetime]\n    market_data_date: typing.Optional[datetime.datetime]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.StructuredProductsPricingAnalysis.__init__"
            ],
            "parent": [],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "StructuredProductsPricingAnalysis.__init__",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsPricingAnalysis.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 56017,
        "content": "class StructuredProductsPricingAnalysis:\n    @overload\n    def __init__(self, *, valuation_date: Optional[datetime.datetime] = None, market_data_date: Optional[datetime.datetime] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "StructuredProductsPricingAnalysis"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.StructuredProductsPricingAnalysis"
            ],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "StructuredProductsPricingParameters",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsPricingParameters",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "force_decreasing_discount_factor",
                "type": "bool"
            },
            {
                "name": "include_cash_flows_at_valuation_date",
                "type": "bool"
            },
            {
                "name": "market_data_date",
                "type": "datetime"
            },
            {
                "name": "models",
                "type": "List[ModelDefinition]"
            },
            {
                "name": "numerical_method",
                "type": "GenericNumericalMethod"
            },
            {
                "name": "report_ccy",
                "type": "str"
            },
            {
                "name": "valuation_date",
                "type": "datetime"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 56021,
        "content": "class StructuredProductsPricingParameters:\n    \"\"\".. raw:: html\n\n       <inheritdoc cref=\"T:TR.Qps.Calculators.BL.Common.Model.PricingParameters\" />.\n\n    Attributes\n    ----------\n    force_decreasing_discount_factor : bool\n        An indicator of whether the computation of decreasing discount factors\n        should be forced during bootstrapping. The possible values are:\n\n        * true: the computation should be forced,\n        * false: the computation should not be forced.\n\n        Optional. The default value is 'false'.\n    include_cash_flows_at_valuation_date : bool\n        An indicator of whether cash-flows payed at the pricing date are taken\n        into account. The possible values are:\n\n        * true: cash-flows are taken into account,\n        * false: cash-flows are not taken into account.\n\n        Optional. The default value is 'true'.\n    market_data_date : ~datetime.datetime\n        The date at which the market data is retrieved. The value is expressed\n        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,\n        '2021-01-01T00:00:00Z'). It should be less or equal to valuationDate).\n        Optional. By default, marketDataDate is valuationDate or today.\n    models : list[~analyticsapi.models.ModelDefinition]\n        The list of models which can be used to price the defined contract.\n        Mandatory. No default value applies.  The default value is None, needs\n        to be assigned before using.\n    numerical_method : ~analyticsapi.models.GenericNumericalMethod\n    report_ccy : str\n        The currency code set for the fields ending with 'xxxInReportCcy'. The\n        value is expressed in ISO 4217 alphabetical format (e.g., 'USD').\n        Optional. No default value applies.\n    valuation_date : ~datetime.datetime\n        The date at which the instrument is valued. The value is expressed in\n        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,\n        '2021-01-01T00:00:00Z'). By default, MarketDataDate is used. If\n        MarketDataDate is not specified, the default value is today.\n    \n    \"\"\"\n    force_decreasing_discount_factor: typing.Optional[bool]\n    include_cash_flows_at_valuation_date: typing.Optional[bool]\n    market_data_date: typing.Optional[datetime.datetime]\n    models: typing.Optional[typing.List[ForwardRef('_models.ModelDefinition')]]\n    numerical_method: typing.Optional[ForwardRef('_models.GenericNumericalMethod')]\n    report_ccy: typing.Optional[str]\n    valuation_date: typing.Optional[datetime.datetime]",
        "metadata": {
            "doc": ".. raw:: html\n\n       <inheritdoc cref=\"T:TR.Qps.Calculators.BL.Common.Model.PricingParameters\" />.\n\n    Attributes\n    ----------\n    force_decreasing_discount_factor : bool\n        An indicator of whether the computation of decreasing discount factors\n        should be forced during bootstrapping. The possible values are:\n\n        * true: the computation should be forced,\n        * false: the computation should not be forced.\n\n        Optional. The default value is 'false'.\n    include_cash_flows_at_valuation_date : bool\n        An indicator of whether cash-flows payed at the pricing date are taken\n        into account. The possible values are:\n\n        * true: cash-flows are taken into account,\n        * false: cash-flows are not taken into account.\n\n        Optional. The default value is 'true'.\n    market_data_date : ~datetime.datetime\n        The date at which the market data is retrieved. The value is expressed\n        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,\n        '2021-01-01T00:00:00Z'). It should be less or equal to valuationDate).\n        Optional. By default, marketDataDate is valuationDate or today.\n    models : list[~analyticsapi.models.ModelDefinition]\n        The list of models which can be used to price the defined contract.\n        Mandatory. No default value applies.  The default value is None, needs\n        to be assigned before using.\n    numerical_method : ~analyticsapi.models.GenericNumericalMethod\n    report_ccy : str\n        The currency code set for the fields ending with 'xxxInReportCcy'. The\n        value is expressed in ISO 4217 alphabetical format (e.g., 'USD').\n        Optional. No default value applies.\n    valuation_date : ~datetime.datetime\n        The date at which the instrument is valued. The value is expressed in\n        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,\n        '2021-01-01T00:00:00Z'). By default, MarketDataDate is used. If\n        MarketDataDate is not specified, the default value is today.\n    \n",
            "annotations": "    force_decreasing_discount_factor: typing.Optional[bool]\n    include_cash_flows_at_valuation_date: typing.Optional[bool]\n    market_data_date: typing.Optional[datetime.datetime]\n    models: typing.Optional[typing.List[ForwardRef('_models.ModelDefinition')]]\n    numerical_method: typing.Optional[ForwardRef('_models.GenericNumericalMethod')]\n    report_ccy: typing.Optional[str]\n    valuation_date: typing.Optional[datetime.datetime]",
            "signature": "class StructuredProductsPricingParameters:\n    \"\"\"\"\"\"\n    force_decreasing_discount_factor: typing.Optional[bool]\n    include_cash_flows_at_valuation_date: typing.Optional[bool]\n    market_data_date: typing.Optional[datetime.datetime]\n    models: typing.Optional[typing.List[ForwardRef('_models.ModelDefinition')]]\n    numerical_method: typing.Optional[ForwardRef('_models.GenericNumericalMethod')]\n    report_ccy: typing.Optional[str]\n    valuation_date: typing.Optional[datetime.datetime]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.StructuredProductsPricingParameters.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.instruments.structured_products.ModelDefinition",
                "lseg_analytics.instruments.structured_products.GenericNumericalMethod"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "StructuredProductsPricingParameters.__init__",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsPricingParameters.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 56124,
        "content": "class StructuredProductsPricingParameters:\n    @overload\n    def __init__(self, *, force_decreasing_discount_factor: Optional[bool] = None, include_cash_flows_at_valuation_date: Optional[bool] = None, market_data_date: Optional[datetime.datetime] = None, models: Optional[List[ForwardRef('_models.ModelDefinition')]] = None, numerical_method: Optional[ForwardRef('_models.GenericNumericalMethod')] = None, report_ccy: Optional[str] = None, valuation_date: Optional[datetime.datetime] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "StructuredProductsPricingParameters"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.StructuredProductsPricingParameters"
            ],
            "use": [
                "lseg_analytics.instruments.structured_products.ModelDefinition",
                "lseg_analytics.instruments.structured_products.GenericNumericalMethod"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "ClassChunk",
        "name": "StructuredProductsValuation",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsValuation",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "market_value_in_deal_ccy",
                "type": "float"
            },
            {
                "name": "market_value_in_report_ccy",
                "type": "float"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 56128,
        "content": "class StructuredProductsValuation:\n    \"\"\"Valuation Object.\n\n    Attributes\n    ----------\n    market_value_in_deal_ccy : float\n        The market value of the instrument. The value is expressed in the deal\n        currency.\n    market_value_in_report_ccy : float\n        The market value of the instrument. The value is expressed in the\n        reporting currency.\n    \n    \"\"\"\n    market_value_in_deal_ccy: typing.Optional[float]\n    market_value_in_report_ccy: typing.Optional[float]",
        "metadata": {
            "doc": "Valuation Object.\n\n    Attributes\n    ----------\n    market_value_in_deal_ccy : float\n        The market value of the instrument. The value is expressed in the deal\n        currency.\n    market_value_in_report_ccy : float\n        The market value of the instrument. The value is expressed in the\n        reporting currency.\n    \n",
            "annotations": "    market_value_in_deal_ccy: typing.Optional[float]\n    market_value_in_report_ccy: typing.Optional[float]",
            "signature": "class StructuredProductsValuation:\n    \"\"\"\"\"\"\n    market_value_in_deal_ccy: typing.Optional[float]\n    market_value_in_report_ccy: typing.Optional[float]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.instruments.structured_products.StructuredProductsValuation.__init__"
            ],
            "parent": [],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "StructuredProductsValuation.__init__",
        "id": "lseg_analytics.instruments.structured_products.StructuredProductsValuation.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics_basic_client/models/_models.py",
        "line_number": 56163,
        "content": "class StructuredProductsValuation:\n    @overload\n    def __init__(self, *, market_value_in_deal_ccy: Optional[float] = None, market_value_in_report_ccy: Optional[float] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "StructuredProductsValuation"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.instruments.structured_products.StructuredProductsValuation"
            ],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "EnumChunk",
        "name": "TypeEnum",
        "id": "lseg_analytics.instruments.structured_products.TypeEnum",
        "content": "class TypeEnum(str, Enum, metaclass=CaseInsensitiveEnumMeta):\n    \"\"\"Type of TypeEnum.\"\"\"\n\n    STRING = \"String\"\n    FLOAT = \"Float\"\n    DATE_TIME = \"DateTime\"\n    INTEGER = \"Integer\"\n    OBJECT = \"Object\"\n    DATE = \"Date\"\n    BOOL = \"Bool\"\n    STRING_ARRAY = \"StringArray\"\n    FLOAT_ARRAY = \"FloatArray\"\n    DATE_ARRAY = \"DateArray\"\n    OBJECT_ARRAY = \"ObjectArray\"\n    INVALID_FIELD = \"InvalidField\"\n",
        "metadata": {
            "doc": "Type of TypeEnum.\n",
            "members": [
                "TypeEnum.STRING = 'String'",
                "TypeEnum.FLOAT = 'Float'",
                "TypeEnum.DATE_TIME = 'DateTime'",
                "TypeEnum.INTEGER = 'Integer'",
                "TypeEnum.OBJECT = 'Object'",
                "TypeEnum.DATE = 'Date'",
                "TypeEnum.BOOL = 'Bool'",
                "TypeEnum.STRING_ARRAY = 'StringArray'",
                "TypeEnum.FLOAT_ARRAY = 'FloatArray'",
                "TypeEnum.DATE_ARRAY = 'DateArray'",
                "TypeEnum.OBJECT_ARRAY = 'ObjectArray'",
                "TypeEnum.INVALID_FIELD = 'InvalidField'"
            ],
            "signature": "class TypeEnum(Enum):\n    \"\"\"\"\"\"\n    STRING = 'String'\n    FLOAT = 'Float'\n    DATE_TIME = 'DateTime'\n    INTEGER = 'Integer'\n    OBJECT = 'Object'\n    DATE = 'Date'\n    BOOL = 'Bool'\n    STRING_ARRAY = 'StringArray'\n    FLOAT_ARRAY = 'FloatArray'\n    DATE_ARRAY = 'DateArray'\n    OBJECT_ARRAY = 'ObjectArray'\n    INVALID_FIELD = 'InvalidField'"
        },
        "dependencies": {
            "children": [],
            "parent": [],
            "use": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    },
    {
        "type": "FunctionChunk",
        "name": "price",
        "id": "lseg_analytics.instruments.structured_products.price",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "definitions",
                "type": "List[StructuredProductsDefinitionInstrument]"
            },
            {
                "name": "pricing_preferences",
                "type": "StructuredProductsPricingParameters"
            },
            {
                "name": "market_data",
                "type": "MarketDataQps"
            },
            {
                "name": "return_market_data",
                "type": "bool"
            },
            {
                "name": "fields",
                "type": "str"
            }
        ],
        "file_path": "lseg_analytics/instruments/structured_products/_functions.py",
        "line_number": 79,
        "content": "def price(*, definitions: List[StructuredProductsDefinitionInstrument], pricing_preferences: Optional[StructuredProductsPricingParameters] = None, market_data: Optional[MarketDataQps] = None, return_market_data: Optional[bool] = None, fields: Optional[str] = None) -> StructuredProductsCalculationResponse:\n    \"\"\"\n    Calculate StructuredProducts analytics\n\n    Parameters\n    ----------\n    definitions : List[StructuredProductsDefinitionInstrument]\n        An array of objects describing a curve or an instrument.\n        Please provide either a full definition (for a user-defined curve/instrument), or reference to a curve/instrument definition saved in the platform, or the code identifying the existing curve/instrument.\n    pricing_preferences : StructuredProductsPricingParameters, optional\n        The parameters that control the computation of the analytics.\n    market_data : MarketDataQps, optional\n        The market data used to compute the analytics.\n    return_market_data : bool, optional\n        Boolean property to determine if undelying market data used for calculation should be returned in the response\n    fields : str, optional\n        A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n        Some usage examples:\n        1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n        2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n        3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n        4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n    Returns\n    --------\n    StructuredProductsCalculationResponse\n        A model template describing the analytics response returned for an instrument provided as part of the request.\n\n    Examples\n    --------\n    >>> # 1. Create SP definition object\n    >>>\n    >>> tarf_definition = sp.StructuredProductsDefinition(\n    >>>     deal_ccy = \"EUR\",\n    >>>     instrument_tag = \"TARF_Target_KO\",\n    >>>     inputs = [\n    >>>         sp.NameTypeValue(name=\"Underlying\", type = \"string\", value=\"USDEUR\"),\n    >>>         sp.NameTypeValue(name=\"StartDate\", type = \"date\", value= dt.date(2022, 1, 25)),\n    >>>         sp.NameTypeValue(name=\"EndDate\", type = \"string\", value=\"StartDate + 1Y\"),\n    >>>         sp.NameTypeValue(name=\"Frequency\", type = \"string\", value=\"3M\"),\n    >>>         sp.NameTypeValue(name=\"Notional\", type = \"string\", value=\"100000\"),\n    >>>         sp.NameTypeValue(name=\"Strike\", type = \"string\", value=\"0.8\"),\n    >>>         sp.NameTypeValue(name=\"KnockOutRate\", type = \"string\", value=\"1.02\"),\n    >>>         sp.NameTypeValue(name=\"IsKnockOutEvent\", type = \"string\", value=\"FX[t] >= KnockOutRate\"),\n    >>>         sp.NameTypeValue(name=\"IsRedemptionEvent\", type = \"string\", value=\"Sum[t] >= ProfitTarget\"),\n    >>>         sp.NameTypeValue(name=\"ProfitTarget\", type = \"string\", value=\"4%\"),\n    >>>         sp.NameTypeValue(name=\"ResidualProfitTarget\", type = \"string\", value=\"Max(ProfitTarget - Sum[t-1], 0)\"),\n    >>>         sp.NameTypeValue(name=\"KO_Payment\", type = \"string\", value=\"Settlement[t]\"),\n    >>>     ],\n    >>>     payoff_description = [\n    >>> \t\t\t\t\t[\n    >>>                         \"Schedule Type\",\n    >>>                         \"Schedule description\",\n    >>>                         \"FX\",\n    >>>                         \"Coupon\",\n    >>>                         \"Settlement\",\n    >>>                         \"Sum\",\n    >>>                         \"Alive\",\n    >>>                         \"KO_Amount\",\n    >>>                         \"Price\"\n    >>>                     ],\n    >>>                     [\n    >>>                         \"AtDate\",\n    >>>                         \"StartDate\",\n    >>>                         \"\",\n    >>>                         \"\",\n    >>>                         \"0\",\n    >>>                         \"\",\n    >>>                         \"IF(ProfitTarget >= 0, 1, 0)\",\n    >>>                         \"\",\n    >>>                         \"\"\n    >>>                     ],\n    >>>                     [\n    >>>                         \"OnSchedule\",\n    >>>                         \"DateTable(StartDate + Frequency, EndDate, Frequency, ResetGap := 0b)\",\n    >>>                         \"FxSpot(Underlying)\",\n    >>>                         \"IF(IsKnockOutEvent, ResidualProfitTarget, FX[t] - Strike)\",\n    >>>                         \"Coupon[t] * Notional\",\n    >>>                         \"Sum[LastDate] + max(Coupon[t],0)\",\n    >>>                         \"If(IsRedemptionEvent or IsKnockOutEvent, 0, Alive[LastDate-1])\",\n    >>>                         \"Alive[LastDate-1] * (1-Alive[LastDate]) * KO_Payment\",\n    >>>                         \"Receive (Alive[t] * Settlement[t] + KO_Amount[t])\"\n    >>>                     ],\n    >>>                     [\n    >>>                         \"AtDate\",\n    >>>                         \"EndDate\",\n    >>>                         \"FxSpot(Underlying)\",\n    >>>                         \"IF(IsKnockOutEvent, ResidualProfitTarget, FX[t] - Strike)\",\n    >>>                         \"Coupon[LastDate] * Notional\",\n    >>>                         \"Sum[LastDate] + max(Coupon[t],0)\",\n    >>>                         \"If(IsRedemptionEvent or IsKnockOutEvent, 0, Alive[LastDate-1])\",\n    >>>                         \"Alive[LastDate-1] * (1-Alive[LastDate]) * KO_Payment\",\n    >>>                         \"Receive (Alive[LastDate] * Settlement[t] + KO_Amount[t])\"\n    >>>                     ]\n    >>> \t\t\t\t]\n    >>> )\n    >>>\n    >>>\n    >>> # 2. Create SP instrument definition object\n    >>>\n    >>> tarf_target_ko = sp.StructuredProductsDefinitionInstrument(definition = tarf_definition)\n    >>> print(\"Instrument definition created\")\n    >>>\n    >>>\n    >>> # 3. Create SP parameters object - optional\n    >>>\n    >>> tarf_pricing_params = sp.StructuredProductsPricingParameters(\n    >>>     valuation_date= dt.date(2022, 3, 16),  # Set your desired valuation date\n    >>>     numerical_method = sp.GenericNumericalMethod(method=\"MonteCarlo\"),\n    >>>     models=[sp.ModelDefinition(\n    >>>             underlying_code = \"USDEUR\",\n    >>>             underlying_tag = \"USDEUR\",\n    >>>             underlying_currency = \"EUR\",\n    >>>             asset_class = \"ForeignExchange\",\n    >>>             model_name= \"Heston\")]\n    >>> )\n    >>> print(\"Pricing parameters configured\")\n    Instrument definition created\n    Pricing parameters configured\n\n\n    >>> # Execute the calculation using the price() function\n    >>> # The 'definitions' parameter accepts a list of instruments definitions for batch processing\n    >>>\n    >>> response = sp.price(\n    >>>     definitions=[tarf_target_ko],\n    >>>     pricing_preferences=tarf_pricing_params,\n    >>>     market_data=None,\n    >>>     return_market_data=True,  # or False\n    >>>     fields=None  # or specify fields as a string\n    >>> )\n    >>>\n    >>> print(\"Pricing execution completed\")\n    Pricing execution completed\n\n    \n    \"\"\"",
        "metadata": {
            "doc": "\n    Calculate StructuredProducts analytics\n\n    Parameters\n    ----------\n    definitions : List[StructuredProductsDefinitionInstrument]\n        An array of objects describing a curve or an instrument.\n        Please provide either a full definition (for a user-defined curve/instrument), or reference to a curve/instrument definition saved in the platform, or the code identifying the existing curve/instrument.\n    pricing_preferences : StructuredProductsPricingParameters, optional\n        The parameters that control the computation of the analytics.\n    market_data : MarketDataQps, optional\n        The market data used to compute the analytics.\n    return_market_data : bool, optional\n        Boolean property to determine if undelying market data used for calculation should be returned in the response\n    fields : str, optional\n        A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n        Some usage examples:\n        1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n        2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n        3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n        4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n    Returns\n    --------\n    StructuredProductsCalculationResponse\n        A model template describing the analytics response returned for an instrument provided as part of the request.\n\n    Examples\n    --------\n    >>> # 1. Create SP definition object\n    >>>\n    >>> tarf_definition = sp.StructuredProductsDefinition(\n    >>>     deal_ccy = \"EUR\",\n    >>>     instrument_tag = \"TARF_Target_KO\",\n    >>>     inputs = [\n    >>>         sp.NameTypeValue(name=\"Underlying\", type = \"string\", value=\"USDEUR\"),\n    >>>         sp.NameTypeValue(name=\"StartDate\", type = \"date\", value= dt.date(2022, 1, 25)),\n    >>>         sp.NameTypeValue(name=\"EndDate\", type = \"string\", value=\"StartDate + 1Y\"),\n    >>>         sp.NameTypeValue(name=\"Frequency\", type = \"string\", value=\"3M\"),\n    >>>         sp.NameTypeValue(name=\"Notional\", type = \"string\", value=\"100000\"),\n    >>>         sp.NameTypeValue(name=\"Strike\", type = \"string\", value=\"0.8\"),\n    >>>         sp.NameTypeValue(name=\"KnockOutRate\", type = \"string\", value=\"1.02\"),\n    >>>         sp.NameTypeValue(name=\"IsKnockOutEvent\", type = \"string\", value=\"FX[t] >= KnockOutRate\"),\n    >>>         sp.NameTypeValue(name=\"IsRedemptionEvent\", type = \"string\", value=\"Sum[t] >= ProfitTarget\"),\n    >>>         sp.NameTypeValue(name=\"ProfitTarget\", type = \"string\", value=\"4%\"),\n    >>>         sp.NameTypeValue(name=\"ResidualProfitTarget\", type = \"string\", value=\"Max(ProfitTarget - Sum[t-1], 0)\"),\n    >>>         sp.NameTypeValue(name=\"KO_Payment\", type = \"string\", value=\"Settlement[t]\"),\n    >>>     ],\n    >>>     payoff_description = [\n    >>> \t\t\t\t\t[\n    >>>                         \"Schedule Type\",\n    >>>                         \"Schedule description\",\n    >>>                         \"FX\",\n    >>>                         \"Coupon\",\n    >>>                         \"Settlement\",\n    >>>                         \"Sum\",\n    >>>                         \"Alive\",\n    >>>                         \"KO_Amount\",\n    >>>                         \"Price\"\n    >>>                     ],\n    >>>                     [\n    >>>                         \"AtDate\",\n    >>>                         \"StartDate\",\n    >>>                         \"\",\n    >>>                         \"\",\n    >>>                         \"0\",\n    >>>                         \"\",\n    >>>                         \"IF(ProfitTarget >= 0, 1, 0)\",\n    >>>                         \"\",\n    >>>                         \"\"\n    >>>                     ],\n    >>>                     [\n    >>>                         \"OnSchedule\",\n    >>>                         \"DateTable(StartDate + Frequency, EndDate, Frequency, ResetGap := 0b)\",\n    >>>                         \"FxSpot(Underlying)\",\n    >>>                         \"IF(IsKnockOutEvent, ResidualProfitTarget, FX[t] - Strike)\",\n    >>>                         \"Coupon[t] * Notional\",\n    >>>                         \"Sum[LastDate] + max(Coupon[t],0)\",\n    >>>                         \"If(IsRedemptionEvent or IsKnockOutEvent, 0, Alive[LastDate-1])\",\n    >>>                         \"Alive[LastDate-1] * (1-Alive[LastDate]) * KO_Payment\",\n    >>>                         \"Receive (Alive[t] * Settlement[t] + KO_Amount[t])\"\n    >>>                     ],\n    >>>                     [\n    >>>                         \"AtDate\",\n    >>>                         \"EndDate\",\n    >>>                         \"FxSpot(Underlying)\",\n    >>>                         \"IF(IsKnockOutEvent, ResidualProfitTarget, FX[t] - Strike)\",\n    >>>                         \"Coupon[LastDate] * Notional\",\n    >>>                         \"Sum[LastDate] + max(Coupon[t],0)\",\n    >>>                         \"If(IsRedemptionEvent or IsKnockOutEvent, 0, Alive[LastDate-1])\",\n    >>>                         \"Alive[LastDate-1] * (1-Alive[LastDate]) * KO_Payment\",\n    >>>                         \"Receive (Alive[LastDate] * Settlement[t] + KO_Amount[t])\"\n    >>>                     ]\n    >>> \t\t\t\t]\n    >>> )\n    >>>\n    >>>\n    >>> # 2. Create SP instrument definition object\n    >>>\n    >>> tarf_target_ko = sp.StructuredProductsDefinitionInstrument(definition = tarf_definition)\n    >>> print(\"Instrument definition created\")\n    >>>\n    >>>\n    >>> # 3. Create SP parameters object - optional\n    >>>\n    >>> tarf_pricing_params = sp.StructuredProductsPricingParameters(\n    >>>     valuation_date= dt.date(2022, 3, 16),  # Set your desired valuation date\n    >>>     numerical_method = sp.GenericNumericalMethod(method=\"MonteCarlo\"),\n    >>>     models=[sp.ModelDefinition(\n    >>>             underlying_code = \"USDEUR\",\n    >>>             underlying_tag = \"USDEUR\",\n    >>>             underlying_currency = \"EUR\",\n    >>>             asset_class = \"ForeignExchange\",\n    >>>             model_name= \"Heston\")]\n    >>> )\n    >>> print(\"Pricing parameters configured\")\n    Instrument definition created\n    Pricing parameters configured\n\n\n    >>> # Execute the calculation using the price() function\n    >>> # The 'definitions' parameter accepts a list of instruments definitions for batch processing\n    >>>\n    >>> response = sp.price(\n    >>>     definitions=[tarf_target_ko],\n    >>>     pricing_preferences=tarf_pricing_params,\n    >>>     market_data=None,\n    >>>     return_market_data=True,  # or False\n    >>>     fields=None  # or specify fields as a string\n    >>> )\n    >>>\n    >>> print(\"Pricing execution completed\")\n    Pricing execution completed\n\n    \n",
            "signature": "def price(*, definitions: List[StructuredProductsDefinitionInstrument], pricing_preferences: Optional[StructuredProductsPricingParameters] = None, market_data: Optional[MarketDataQps] = None, return_market_data: Optional[bool] = None, fields: Optional[str] = None) -> StructuredProductsCalculationResponse:"
        },
        "dependencies": {
            "children": [],
            "parent": [],
            "use": [
                "lseg_analytics.instruments.structured_products.StructuredProductsDefinitionInstrument",
                "lseg_analytics.instruments.structured_products.StructuredProductsPricingParameters",
                "lseg_analytics.instruments.structured_products.MarketDataQps",
                "lseg_analytics.instruments.structured_products.StructuredProductsCalculationResponse"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.instruments.structured_products",
        "module_version": "2.1.0b5"
    }
]