# RedisSink 异步线程事件循环改造方案

## 背景与问题重述
- 当前 `RedisSink` 依赖调用线程的 `asyncio` 事件循环，在多线程环境下大量线程并未创建事件循环。
- 无事件循环的线程会将日志写入临时缓存 `_temp_buffer`，缓存容量默认仅 1000 条，压力场景下会快速溢出导致日志被丢弃。
- `_temp_buffer` 以普通列表实现，缺乏跨线程并发保护，存在竞争条件和数据丢失风险。
- 异步组件初始化流程受限于事件循环状态，可能长期无法启动消费者任务 `_log_consumer`，日志链路处于退化模式。

## 方案概述
- 在 `RedisSink` 内部创建独立的后台线程，并在其中运行专用的 `asyncio` 事件循环。
- 将所有需要异步执行的逻辑通过 `asyncio.run_coroutine_threadsafe` 投递到专用事件循环，彻底消除对调用线程事件循环的依赖。
- 初始化时配置异步队列、消费者任务等组件都绑定到该专用事件循环中，确保生命周期可控。
- 通过线程安全的临时缓存结构在 loop 启动前暂存日志，loop 就绪后批量回放，避免日志丢失。

## 架构设计要点
1. **事件循环管理器**
   - 构造 `self._loop = asyncio.new_event_loop()` 并启动后台线程执行 `self._loop.run_forever()`。
   - 提供线程安全的停止方法，在 `close()` 中通过 `self._loop.call_soon_threadsafe(self._loop.stop)` 优雅关闭，并等待线程退出。
2. **任务投递通道**
   - Loguru 调用 `RedisSink.__call__` 时，无论所在线程是否具备事件循环，都将 `log_record` 转换后通过 `run_coroutine_threadsafe(self._async_handle_log(...), self._loop)` 投递。
   - 对于异步场景（已有事件循环）可根据需要保留直接 `await` 的入口，但默认统一走线程安全通道，保证一致性。
3. **异步组件初始化**
   - `_ensure_initialized` 在后台线程中执行：初始化 `asyncio.Queue`、启动 `_log_consumer`。
   - 使用 `asyncio.Event` 或回调确保初始化只执行一次，避免竞态。
4. **线程安全临时缓存**
   - 改造 `_temp_buffer` 为 `collections.deque(maxlen=config.temp_buffer_max_size)` 并配合 `threading.Lock` 保护写入。
   - 后台事件循环准备就绪后，通过 `call_soon_threadsafe` 调度协程 `_transfer_temp_buffer_to_queue()` 将缓存数据回放至正式队列。

## 核心改进细节
- **独立事件循环生命周期控制**：所有异步资源的创建、运行、销毁都在后台线程内完成，避免跨线程 loop 操作。
- **任务调度统一入口**：同步与异步调用路径统一为线程安全投递，规避 `RuntimeError: There is no current event loop`。
- **临时缓存增强**：采用锁保护的 `deque` 自动淘汰策略，结合告警日志，避免连续溢出时的无提示数据丢失。
- **关闭流程优化**：`close()` 支持同步调用，先停止任务，再清理剩余队列并断开 Redis 连接，确保资源回收完整。
- **监控与诊断扩展**（可选）：记录队列长度、缓存丢弃计数、Redis 重试次数，便于运维监控。

## 优点
- **兼容性强**：无须依赖调用线程的事件循环，适配同步、多线程、异步混合使用场景。
- **性能稳定**：后台线程专注处理日志队列，减少上下文切换和阻塞，维持 Redis 写入吞吐。
- **可维护性好**：事件循环与资源管理集中在一个线程，逻辑清晰，易于扩展批处理、重试等机制。
- **扩展潜力**：便于未来在同一 loop 中添加指标上报、异步告警等功能。

## 缺点与风险
- **线程开销**：额外引入一个守护线程，对资源敏感的环境需评估线程数上限。
- **实现复杂度增加**：需要谨慎处理 loop 启动、关闭以及跨线程异常捕获，代码维护成本略有提升。
- **全局初始化顺序**：需要确保 `RedisSink` 在进程生命周期内只创建有限实例，避免过多独立 loop。
- **异常处理一致性**：`run_coroutine_threadsafe` 返回 `Future`，异常需统一记录或上报，避免悄然吞掉错误。

## 实施步骤
1. **抽象“异步运行时”组件**：封装 loop 创建、线程启动、停止逻辑，可作为 `RedisSink` 私有类或独立工具类。
2. **改造 `RedisSink` 初始化**：在构造函数中启动运行时，并在后台 loop 中执行 `_ensure_initialized`。
3. **统一日志写入口**：`__call__` 中使用线程安全投递；若存在异步上下文调用，可提供 `async def alog(...)` 直接 `await`。
4. **临时缓存改造与回放**：替换为 `deque` + `threading.Lock`，在 loop 就绪后异步回放。
5. **完善关闭流程**：在 `close()` 中停止消费者任务、清空队列、断开 Redis，最终关闭 loop 线程。
6. **补充监控与告警**（可选）：在关键状态变化时输出日志或钩子，便于部署后观测。

## 测试与验证建议
- 编写多线程压力用例（例如 20 个线程各写入 1 万条日志）验证无异常、无日志丢失。
- 模拟 Redis 不可用场景，观察重试与缓存行为，确认不会阻塞调用线程。
- 验证 `close()` 在不同调用时机（日志系统关闭、进程退出）都能安全回收。
- 对比前后内存与线程资源占用，确认新增线程影响可接受。

## 后续拓展方向
- 引入指标采集（Prometheus、自定义回调）监控队列长度与失败计数。
- 支持自定义同步降级策略（例如缓存写磁盘或告警 webhook）。
- 结合配置中心/环境变量动态调整队列大小、批量策略，实现弹性调优。
