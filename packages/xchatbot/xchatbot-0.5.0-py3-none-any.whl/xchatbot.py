#!/usr/bin/env python
"""
xchatbot - the Xtensible xmpp Chat Bot

Build an XMPP bot extending the base class `XChatBot`

Example:
	A simple bot with one public command "echo" and
	one private to admin command "hello"
	"help" command is autogenerated.

.. code-block:: python

	from xchatbot import Config, XChatBot, Peer, private

	class MyBot(XChatBot):
		def cmd_echo(self, peer:Peer, *args):
			"Echo back what you typed"
			msg = "You said: " + " ".join(args)
			peer.send(msg)

		@private
		def cmd_hello(self, peer:Peer, name):
			"<name> - Private command for admin user"
			peer.send("Welcome " + name)

	if __name__ == "__main__":
		config = Config.load('mybot')
		MyBot.start(config)


"""

import sys
import os
import logging
from datetime import datetime
import collections
import pickle
import shlex
from dataclasses import dataclass, field
from functools import wraps
from typing import Optional, Any, Callable
import signal


from nbxmpp.const import StreamState
from nbxmpp.client import Client
from nbxmpp.protocol import JID, Protocol, Presence, Message
from nbxmpp.namespaces import Namespace
from nbxmpp.structs import StanzaHandler
from nbxmpp.simplexml import Node

from gi.repository import GLib  # type:ignore


__version__ = "0.5.0"
__all__ = ['XChatBot', 'Config', 'Peer', 'store', 'load', 'private']

# logger
FORMATTER = logging.Formatter('%(levelname)-8s %(name)-10s %(message)s')
HANDLER = logging.StreamHandler()
HANDLER.setFormatter(FORMATTER)
logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
logger.setLevel('DEBUG')
logger.addHandler(HANDLER)

Attrs = dict[str, str]


# pylint: disable=invalid-name
def getDescendant(root: Node,
				name: str,
				attrs: Optional[Attrs] = None,
				namespace: Optional[str] = None) -> Optional[Node]:
	"""
	Filter root's descendat nodes using specified arguments as filter. Return the
	first found or None if not found
	"""
	found = root.getTag(name, attrs, namespace)
	if found is None:
		for node in root.kids:
			if isinstance(node, Node):
				found = getDescendant(node, name, attrs, namespace)
				if found is not None:
					break
	return found


def store(name: str, data: Any):
	"""store data as pickle value to file

	Args:
		name: Filename, without extension
		data:  Python data to store
	"""
	with open(name + ".data", "wb") as fp:
		pickle.dump(data, fp)


def load(name: str, default: Any) -> Any:
	"""Load pickled data from file.

	Args:
		name: Filename to load, without extension
		default: Python data returned if file is not found

	Returns:
		Loaded data

		If file is not found, the value of ``default`` parameter is returned
	"""
	if not os.path.isfile(name + ".data"):
		return default
	with open(name + ".data", "rb") as fp:
		return pickle.load(fp)


def private(func: Callable) -> Callable:
	"""Decorator to mark command private for admin user
	"""
	@wraps(func)
	def command_wrapper(self, peer, *args):
		if peer.is_admin:
			func(self, peer, *args)
	setattr(command_wrapper, 'is_private', True)
	return command_wrapper


@dataclass
class Config:
	jid: JID
	admin: JID
	accept_presence_request: bool = False
	muc_accept_invite: bool = False
	mucs: set[JID] = field(default_factory=set)
	password: Optional[str] = None
	muc_nick: str = "xbot"
	logger: str = "DEBUG"

	@classmethod
	def load(cls, filename: str = 'xchatbot') -> "Config":
		"""load and parse config file

		looks in ``$PWD/filename.rc``, ``~/.filename.rc`` and ``/etc/filename.rc``

		Args:
			filename: config file name
		"""
		confdata:dict[str, Any] = {}
		confiles = [
			'{}.rc'.format(filename),
			'{}/.{}.rc'.format(os.environ['HOME'], filename),
			'/etc/{}.rc'.format(filename)
		]
		confile = None
		for cf in confiles:
			if os.access(cf, os.R_OK):
				confile = cf
				break
		if confile is None:
			print("Can't find config file in " + ", ".join(confiles))
			sys.exit(1)

		# load conffile
		for ln in open(confile).readlines():
			ln = ln.strip()
			if ln != "" and not ln[0] in ('#', ';'):
				val:Any = None
				key, val = ln.strip().split('=', 1)
				key = key.lower()
				confdata[key] = val

		# check required fileds
		for mandatory in ['jid', 'password', 'admin']:
			if mandatory not in confdata.keys() or confdata[mandatory] == "":
				print('Please set in config file {} a value for {}.'.format(
					confile, mandatory.upper()))
				sys.exit(2)

		# covert values
		for key, val in confdata.items():
			if isinstance(val, str):
				if val.lower() == "false":
					val = False
				elif val.lower() == "true":
					val = True
				if key in ['jid', 'admin']:
					val = JID.from_string(val)
				if key == "mucs" and val.strip() != "":
					val = {JID.from_string(v.strip()) for v in val.strip().split(";") if v.strip() != ""}

				confdata[key] = val

		config = cls(**confdata)
		return config


class Peer:
	"""The peer that sent the message

	Attributes:
		jid: the peer jid
		nick: the nickname
		is_admin: ``True`` if the peer is a bot admin
		is_groupchat: ``True`` if the peer that wrote to the bot is in a MUC
	"""

	def __init__(self, bot:"XChatBot", jid:JID, nick:str, is_groupchat:bool=False):
		self.bot = bot
		self.jid = jid
		self.nick = nick
		self.is_admin = jid.bare_match(bot.config.admin)
		self.is_groupchat = is_groupchat

	def send(self, message: str):
		"""Send a message to the peer

		Note:
			If peer is in a groupchat, the nickname is prepended
			to the message:

				{nick}: {message}


		Args:
			message: The message
		"""
		if self.is_groupchat:
			message = self.nick + ": " + message
			self.bot.send_groupchat_to(self.jid, message)
		else:
			self.bot.send_message_to(self.jid, message)

	def __str__(self):
		return "{} <{} > {}".format(
			self.nick, self.jid,
			" in a groupchat" if self.is_groupchat else ""
		)


# main class
class XChatBot:
	"""The Xtensible xmpp Chat Bot

	Attributes:
		config (:obj:`Config`): options loaded from config file
		jid (:obj:`nbxmpp.protocol.JID`): bot JID
		logger (:obj:`logging.Logger`):
			configured logger to be used by the bot subclass

	"""

	def __init__(self, config: Config):
		self.config: Config = config
		self._client: Optional[Client] = None

		self.jid = config.jid

		self._conferences = load("mucs", set()).union(self.config.mucs)
		self._conferences_lastmessage:dict[JID,str] = collections.defaultdict(str)
		self._seen_ids = load("ids", collections.deque(maxlen=1000))

		self._ignore_before = datetime.now()

		self._commands = {}
		for name in dir(self):
			func = getattr(self, name)
			if name.startswith("cmd_") and callable(func):
				cmd = name.replace("cmd_", "")
				self._commands[cmd] = func

		# bot logger
		self.logger = logging.getLogger(self.__class__.__name__)
		self.logger.setLevel(self.config.logger)
		self.logger.addHandler(HANDLER)
		self.logger.debug(config)

	@classmethod
	def start(cls, config: Config):
		"""Start bot

		Connects the bot to the server, setups error and
		quit handlers, start :class:`GLib.MainLoop` loop.
		"""
		ml = GLib.MainLoop()

		bot = cls(config)
		bot.connect()

		def signal_handler(_signal, _frame):
			logger.info("disconnecting...")
			bot.disconnect()

		def on_disconnect(_client: Client, signal_name: str, *args: Any, **kwargs: Any):
			logger.info("quitting...")
			ml.quit()

		def _excepthook(etype, value, traceback):
			print(etype, value, traceback)
			ml.quit()
			sys.exit(-1)

		sys.excepthook = _excepthook
		signal.signal(signal.SIGINT, signal_handler)
		bot.register_on_disconnect(on_disconnect)

		try:
			ml.run()
		except KeyboardInterrupt:
			logger.info("keyboard interrupt")
			bot.disconnect()

	# # manage xmpp connection
	def connect(self):
		"""Connect to the server
		"""
		self.logger.info("connecting to %s", self.jid.domain)

		# code from https://dev.gajim.org/gajim/nbxmpp-client/-/blob/master/src/nbxmpp_client/client.py

		if self._client is not None:
			self._client.destroy()

		self._client = Client(log_context=self.__class__.__name__)
		self._client.set_domain(self.jid.domain)
		self._client.set_username(self.jid.localpart)
		if self.jid.resource:
			self._client.set_resource(self.jid.resource)

		# TODO: set proxy

		self._client.set_password(self.get_password())

		self._client.subscribe("connected", self._on_connected)
		self._client.subscribe("connection-failed", self._on_connection_failed)
		self._client.register_handler(StanzaHandler("message", self._on_message))

		self._client.connect()

	def register_on_disconnect(self, cb):
		self._client.subscribe("disconnected", cb)

	def send_message(self, message: Message):
		"""Send a message

		Args:
			message: the message to send
		"""
		if self._client is None or self._client.state != StreamState.ACTIVE:
			self.logger.warning("Cannot send message while not active")
			return
			
		id_ = self._client.send_stanza(message)  # pylint: disable=no-member
		self._add_seeenid(id_)
		self.logger.debug('sent %s message with id %s to "%s"', message.getType(), id_, message.getTo())

	def send_message_to(self, to_jid: JID, text: str):
		"""Send a chat message to a JID

		Args:
			to_jid: Recipient JID
			text: Message text
		"""
		self.send_message(
			Message(to=to_jid, body=text, typ='chat')
		)

	def send_groupchat_to(self, to_jid: JID, text: str):
		"""Send a message to a MUC by JID

		Args:
			to_jid: MUC JID
			text: Message text
		"""
		self.send_message(
			Message(to=to_jid, body=text, typ='groupchat')
		)

	def send_received(self, to_jid: JID, message_id: Optional[str]):
		"""Send a message delivery receipt

		Will mark the message as received by the bot in user's client.
		It's sent automatically when incoming messages are parsed.

		Args:
			to_jid: Recipient JID
			message_id: Message id
		"""
		if self._client is None or self._client.state != StreamState.ACTIVE:
			self.logger.warning("Cannot send receipt while not active")
			return

		if message_id is None:
			return

		message = Message(to=to_jid)
		message.setReceiptReceived(message_id)
		self._client.send_stanza(message)
		self.logger.debug('sent message delivery receipt for id %s', message_id)

	def send_presence(self):
		self._client.send_stanza(Presence())
		self.logger.debug('sent presence stanza')

	def disconnect(self):
		"""Disconnect from the server
		"""
		self._client.disconnect()

	def get_password(self):
		"""Get password

		By default, returns password from from config file.
		"""
		return self.config.password

	def _on_connected(self, _client: Client, _signal_name: str):
		self.logger.info('connected')
		self.send_presence()
		for muc_jid in self._conferences:
			self.enter_muc(muc_jid)

		self.ready()

	def _on_connection_failed(self, _client: Client, signal_name: str, *args: Any, **kwargs: Any):
		self.logger.error('could not connect!')


	def ready(self):
		"""
		Called when the bot is connected and logged in and ready to send/receive messages
		"""
		pass

	# # / manage xmpp connection

	# # manage xmpp events

	def _on_presence_request(self, _dispatcher, message):
		self.logger.debug("presence request %r", message)
		from_jid = message.getAttr("from")
		if self._client is None or self._client.state != StreamState.ACTIVE:
			self.logger.warning("Cannot reply to presence request while not active")
			return
		
		if from_jid.bare_match(self.jid):
			# https://xmpp.org/rfcs/rfc3921.html#rfc.section.2.2.1
			if self.accept_presence or from_jid == self.admin_jid:
				p = Presence(to=from_jid, typ="subscribed")
				self.logger.debug(f"Send presence 'subscribed' to {from_jid}")
			else:
				p = Presence(to=from_jid, typ="unsubscribed")
				self.logger.debug(f"Send presence 'unsubscribed' to {from_jid}")
			self.client.send_stanza(p)

	def _on_message(self, _stream, message: Message, _properties):
		self.logger.debug("on_message %s", message)
		message_type = message.getType()

		if message_type == "error":
			self.logger.error("error: %r", message)
			return

		if message.getTag("received") is not None:
			node = getDescendant(message, "message")
			if node is None:
				return
			message = Message(node=node)

		if message.getTag("composing") is not None:
			self.logger.debug('composing')
			return
		
		if message.getTag("displayed") is not None:
			self.logger.debug('displayed')
			return

		message_id = message.getID()
		if message_id in self._seen_ids:
			return

		delay = getDescendant(message, "delay") \
			or getDescendant(message, "x", namespace=Namespace.DELAY) \
			or getDescendant(message, "x", namespace=Namespace.DELAY2)

		if delay is not None:
			stamp = delay.getAttr("stamp")
			if stamp is None:
				self.logger.warning("got delay without stamp")
				return
			fmt = "%Y-%m-%dT%H:%M:%SZ"
			if "-" not in stamp:
				fmt = "%Y%m%dT%H:%M:%S"
			stampdatetime = datetime.strptime(stamp, fmt)
			if stampdatetime < self._ignore_before:
				return

		self._add_seeenid(message_id)

		myself = [self.jid.bare]
		myself += [muc.bare + "/" + self.config.muc_nick for muc in self._conferences]
		frm = str(message.getAttr("from"))
		if any([frm.startswith(me) or me.startswith(frm) for me in myself]):
			self.logger.debug("drop message event from self")
			return

		# TODO: skip history messages

		# manage invite to MUC
		self.logger.debug("invite: %s : %s",self.config.muc_accept_invite, getDescendant(message, "x", namespace=Namespace.CONFERENCE))
		if self.config.muc_accept_invite:
			node = getDescendant(message, "x", namespace=Namespace.CONFERENCE)
			if node is not None:
				self.logger.debug("invite node %s", node)
				conference = Protocol(node=node)
				self.logger.info("invited to %r", conference.getJid())
				self.enter_muc(conference.getJid())
				return

		if message_type == "chat":
			self._parse_message(message)

		if message_type == "groupchat":
			self._parse_message(message, True)

	def enter_muc(self, muc_jid: JID):
		"""Join a multiuser conference

		Args:
			muc_jid: MUC JID
		"""
		if self._client is None or self._client.state != StreamState.ACTIVE:
			self.logger.warning("Cannot enter MUC while not active")
			return

		muc_jid_nick = muc_jid.new_with(resource=self.config.muc_nick)  # type: ignore
		self.logger.debug("enter MUC as %s", muc_jid_nick)
		x = Node("x", attrs={'xmlns':Namespace.MUC})
		presence = Presence(
			frm=self.jid,
			to=muc_jid_nick,
			payload=[x])
		self.logger.debug(presence)
		self._client.send_stanza(presence)
		self._add_conference(muc_jid)

	def exit_muc(self, muc_jid: JID):
		"""Leave a multuser conference
		"""
		if self._client is None or self._client.state != StreamState.ACTIVE:
			self.logger.warning("Cannot leave MUC while not active")
			return
		
		muc_jid_nick = muc_jid.new_with(resource=self.config.muc_nick)  # type: ignore
		self.logger.debug("leave MUC as %s", muc_jid_nick)
		presence = Presence(
			frm=self.jid,
			to=muc_jid_nick,
			typ="unavailable")
		self.logger.debug(presence)
		self._client.send_stanza(presence)
		self._del_conference(muc_jid)		

	def _add_conference(self, muc_jid):
		if muc_jid not in self._conferences:
			self._conferences.add(muc_jid)
			if muc_jid not in self.config.mucs:
				store("mucs", self._conferences)

	def _del_conference(self, muc_jid):
		if muc_jid in self._conferences:
			self._conferences.remove(muc_jid)
			if muc_jid not in self.config.mucs:
				store("mucs", self._conferences)

	def _add_seeenid(self, id_):
		self._seen_ids.append(id_)
		store("ids", self._seen_ids)

	# # / manage xmpp events

	# # bot logic

	def _parse_message(self, message: Message, groupchat=False):
		bodytag = getDescendant(message, "body")
		if bodytag is None:
			self.logger.debug("can't find body tag!")
			return

		body = bodytag.getData().strip()
		self.logger.debug("parse_message: %r", body)

		from_jid = message.getFrom()

		nick = ""
		if groupchat:
			nick = from_jid.resource
			from_jid = from_jid.new_as_bare()
		else:
			nick = from_jid.localpart

		if getDescendant(message, "request", namespace=Namespace.RECEIPTS):
			self.send_received(from_jid, message.getID())

		peer = Peer(self, from_jid, nick, groupchat)

		self.logger.debug("from %s", peer)

		# check groupchat command
		if groupchat:
			tag = "!" + self.config.muc_nick
			if body.startswith(tag):
				body = body.replace(tag, "").strip()
			else:
				self.logger.debug("last message in %s : %s", from_jid, body)
				self._conferences_lastmessage[from_jid] = body
				return

		# parse commands

		body = body.strip()

		# # help
		if body.lower() in ["help", "aiuto", "guida", "?"]:
			self.do_help(peer)
			return

		cmdline = shlex.split(body)
		if len(cmdline) > 0:
			cmd = cmdline[0]
			args = cmdline[1:]
			if cmd in self._commands:
				try:
					self.logger.debug("call %r(%s, *%r)",
								 self._commands[cmd], peer, args)
					self._commands[cmd](peer, *args)
				except TypeError as e:
					self.logger.debug(e)
					peer.send("Invalid arguments!")
				return

		# no commands givend, fallback to default
		self.default(peer, *cmdline)

	def do_help(self, peer: Peer):
		"""Send help message to the peer

		Args:
			peer: The remote peer
		"""
		self.logger.debug("do_help")
		msg = "This bot reply to:\n"
		msg += "  *help* - this message\n"
		for name, func in self._commands.items():
			is_private = getattr(func, "is_private", False)
			is_admin = peer.jid.bare_match(self.config.admin)
			if not is_private or is_admin:
				msg += "ðŸ”’" if is_private else " "
				msg += f"*{name}"
				doc = func.__doc__
				if doc is not None:
					if " - " in doc:
						msg += " " + doc.replace(" - ", "* - ")
					else:
						msg += f"* - {doc}"
				else:
					msg += "*"
				msg += "\n"

		peer.send(msg)

	# Bot callbacks

	@private
	def cmd_muc(self, peer: Peer, cmd: str, *args):
		"""<list|join|leave> - Manage MUC rooms the bot is in"""
		
		if cmd == "list":
			roorms_list = [ jid.bare for jid in self._conferences ]
			if len(roorms_list) == 0:
				peer.send("I'm not in any MUC room.")
			else:
				msg = "I'm currently in:\n- "
				msg += "\n- ".join(roorms_list)
				peer.send(msg)
			return
		
		elif cmd in ['join', 'leave']:
			if len(args) != 1:
				peer.send(f"use: muc {cmd} <room@server>")
				return

			try:
				muc_jid = JID.from_user_input(args[0])
				if cmd == 'join':
					self.enter_muc(muc_jid)
				else:
					self.exit_muc(muc_jid)
				peer.send("Ok.")
			except Exception as e:
				peer.send(f"error: {e}")
				return

		else:
			peer.send("use: muc <list|join|leave>")
			return

	def default(self, peer: Peer, *args):
		"""Default command

		This is called when the peer sends a command not defined in the bot.

		Args:
			peer: The remote peer
			*args: arguments of the command
		"""


# # ENTRY POINT

if __name__ == "__main__":
	class EchoBot(XChatBot):
		"""Demo echo bot"""
		def cmd_echo(self, peer: Peer, *args):  # pylint: disable=no-self-use
			"""echo back the text"""
			peer.send(" ".join(args))

		@private
		def cmd_hello(self, peer: Peer, name):  # pylint: disable=no-self-use
			"""<name> - Private command for admin user"""
			peer.send("Welcome " + name)

	config = Config.load("echobot")
	EchoBot.start(config)
