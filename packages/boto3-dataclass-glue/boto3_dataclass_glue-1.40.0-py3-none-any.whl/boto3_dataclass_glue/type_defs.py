# -*- coding: utf-8 -*-

import typing as T
import dataclasses
from functools import cached_property

if T.TYPE_CHECKING:  # pragma: no cover
    from mypy_boto3_glue import type_defs


def field(name: str):
    def getter(self):
        return self.boto3_raw_data[name]

    return cached_property(getter)


@dataclasses.dataclass(frozen=True)
class NotificationProperty:
    boto3_raw_data: "type_defs.NotificationPropertyTypeDef" = dataclasses.field()

    NotifyDelayAfter = field("NotifyDelayAfter")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.NotificationPropertyTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.NotificationPropertyTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AggregateOperationOutput:
    boto3_raw_data: "type_defs.AggregateOperationOutputTypeDef" = dataclasses.field()

    Column = field("Column")
    AggFunc = field("AggFunc")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.AggregateOperationOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.AggregateOperationOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AggregateOperation:
    boto3_raw_data: "type_defs.AggregateOperationTypeDef" = dataclasses.field()

    Column = field("Column")
    AggFunc = field("AggFunc")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.AggregateOperationTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.AggregateOperationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AllowedValue:
    boto3_raw_data: "type_defs.AllowedValueTypeDef" = dataclasses.field()

    Value = field("Value")
    Description = field("Description")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.AllowedValueTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.AllowedValueTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AmazonRedshiftAdvancedOption:
    boto3_raw_data: "type_defs.AmazonRedshiftAdvancedOptionTypeDef" = (
        dataclasses.field()
    )

    Key = field("Key")
    Value = field("Value")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.AmazonRedshiftAdvancedOptionTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.AmazonRedshiftAdvancedOptionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Option:
    boto3_raw_data: "type_defs.OptionTypeDef" = dataclasses.field()

    Value = field("Value")
    Label = field("Label")
    Description = field("Description")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.OptionTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.OptionTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AnnotationError:
    boto3_raw_data: "type_defs.AnnotationErrorTypeDef" = dataclasses.field()

    ProfileId = field("ProfileId")
    StatisticId = field("StatisticId")
    FailureReason = field("FailureReason")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.AnnotationErrorTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.AnnotationErrorTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class MappingOutput:
    boto3_raw_data: "type_defs.MappingOutputTypeDef" = dataclasses.field()

    ToKey = field("ToKey")
    FromPath = field("FromPath")
    FromType = field("FromType")
    ToType = field("ToType")
    Dropped = field("Dropped")
    Children = field("Children")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.MappingOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.MappingOutputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class MappingPaginator:
    boto3_raw_data: "type_defs.MappingPaginatorTypeDef" = dataclasses.field()

    ToKey = field("ToKey")
    FromPath = field("FromPath")
    FromType = field("FromType")
    ToType = field("ToType")
    Dropped = field("Dropped")
    Children = field("Children")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.MappingPaginatorTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.MappingPaginatorTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AuditContext:
    boto3_raw_data: "type_defs.AuditContextTypeDef" = dataclasses.field()

    AdditionalAuditContext = field("AdditionalAuditContext")
    RequestedColumns = field("RequestedColumns")
    AllColumnsRequested = field("AllColumnsRequested")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.AuditContextTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.AuditContextTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BasicAuthenticationCredentials:
    boto3_raw_data: "type_defs.BasicAuthenticationCredentialsTypeDef" = (
        dataclasses.field()
    )

    Username = field("Username")
    Password = field("Password")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.BasicAuthenticationCredentialsTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BasicAuthenticationCredentialsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AuthorizationCodeProperties:
    boto3_raw_data: "type_defs.AuthorizationCodePropertiesTypeDef" = dataclasses.field()

    AuthorizationCode = field("AuthorizationCode")
    RedirectUri = field("RedirectUri")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.AuthorizationCodePropertiesTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.AuthorizationCodePropertiesTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AutoDataQuality:
    boto3_raw_data: "type_defs.AutoDataQualityTypeDef" = dataclasses.field()

    IsEnabled = field("IsEnabled")
    EvaluationContext = field("EvaluationContext")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.AutoDataQualityTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.AutoDataQualityTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PartitionValueListOutput:
    boto3_raw_data: "type_defs.PartitionValueListOutputTypeDef" = dataclasses.field()

    Values = field("Values")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.PartitionValueListOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PartitionValueListOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BasicCatalogTargetOutput:
    boto3_raw_data: "type_defs.BasicCatalogTargetOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Database = field("Database")
    Table = field("Table")
    PartitionKeys = field("PartitionKeys")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BasicCatalogTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BasicCatalogTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BasicCatalogTarget:
    boto3_raw_data: "type_defs.BasicCatalogTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Database = field("Database")
    Table = field("Table")
    PartitionKeys = field("PartitionKeys")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BasicCatalogTargetTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BasicCatalogTargetTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ResponseMetadata:
    boto3_raw_data: "type_defs.ResponseMetadataTypeDef" = dataclasses.field()

    RequestId = field("RequestId")
    HTTPStatusCode = field("HTTPStatusCode")
    HTTPHeaders = field("HTTPHeaders")
    RetryAttempts = field("RetryAttempts")
    HostId = field("HostId")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ResponseMetadataTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ResponseMetadataTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchDeleteConnectionRequest:
    boto3_raw_data: "type_defs.BatchDeleteConnectionRequestTypeDef" = (
        dataclasses.field()
    )

    ConnectionNameList = field("ConnectionNameList")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchDeleteConnectionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchDeleteConnectionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ErrorDetail:
    boto3_raw_data: "type_defs.ErrorDetailTypeDef" = dataclasses.field()

    ErrorCode = field("ErrorCode")
    ErrorMessage = field("ErrorMessage")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ErrorDetailTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ErrorDetailTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchDeleteTableRequest:
    boto3_raw_data: "type_defs.BatchDeleteTableRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TablesToDelete = field("TablesToDelete")
    CatalogId = field("CatalogId")
    TransactionId = field("TransactionId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchDeleteTableRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchDeleteTableRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchDeleteTableVersionRequest:
    boto3_raw_data: "type_defs.BatchDeleteTableVersionRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    VersionIds = field("VersionIds")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.BatchDeleteTableVersionRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchDeleteTableVersionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetBlueprintsRequest:
    boto3_raw_data: "type_defs.BatchGetBlueprintsRequestTypeDef" = dataclasses.field()

    Names = field("Names")
    IncludeBlueprint = field("IncludeBlueprint")
    IncludeParameterSpec = field("IncludeParameterSpec")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchGetBlueprintsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetBlueprintsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetCrawlersRequest:
    boto3_raw_data: "type_defs.BatchGetCrawlersRequestTypeDef" = dataclasses.field()

    CrawlerNames = field("CrawlerNames")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchGetCrawlersRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetCrawlersRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetCustomEntityTypesRequest:
    boto3_raw_data: "type_defs.BatchGetCustomEntityTypesRequestTypeDef" = (
        dataclasses.field()
    )

    Names = field("Names")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.BatchGetCustomEntityTypesRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetCustomEntityTypesRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CustomEntityType:
    boto3_raw_data: "type_defs.CustomEntityTypeTypeDef" = dataclasses.field()

    Name = field("Name")
    RegexString = field("RegexString")
    ContextWords = field("ContextWords")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CustomEntityTypeTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CustomEntityTypeTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetDataQualityResultRequest:
    boto3_raw_data: "type_defs.BatchGetDataQualityResultRequestTypeDef" = (
        dataclasses.field()
    )

    ResultIds = field("ResultIds")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.BatchGetDataQualityResultRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetDataQualityResultRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetDevEndpointsRequest:
    boto3_raw_data: "type_defs.BatchGetDevEndpointsRequestTypeDef" = dataclasses.field()

    DevEndpointNames = field("DevEndpointNames")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchGetDevEndpointsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetDevEndpointsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DevEndpoint:
    boto3_raw_data: "type_defs.DevEndpointTypeDef" = dataclasses.field()

    EndpointName = field("EndpointName")
    RoleArn = field("RoleArn")
    SecurityGroupIds = field("SecurityGroupIds")
    SubnetId = field("SubnetId")
    YarnEndpointAddress = field("YarnEndpointAddress")
    PrivateAddress = field("PrivateAddress")
    ZeppelinRemoteSparkInterpreterPort = field("ZeppelinRemoteSparkInterpreterPort")
    PublicAddress = field("PublicAddress")
    Status = field("Status")
    WorkerType = field("WorkerType")
    GlueVersion = field("GlueVersion")
    NumberOfWorkers = field("NumberOfWorkers")
    NumberOfNodes = field("NumberOfNodes")
    AvailabilityZone = field("AvailabilityZone")
    VpcId = field("VpcId")
    ExtraPythonLibsS3Path = field("ExtraPythonLibsS3Path")
    ExtraJarsS3Path = field("ExtraJarsS3Path")
    FailureReason = field("FailureReason")
    LastUpdateStatus = field("LastUpdateStatus")
    CreatedTimestamp = field("CreatedTimestamp")
    LastModifiedTimestamp = field("LastModifiedTimestamp")
    PublicKey = field("PublicKey")
    PublicKeys = field("PublicKeys")
    SecurityConfiguration = field("SecurityConfiguration")
    Arguments = field("Arguments")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DevEndpointTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.DevEndpointTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetJobsRequest:
    boto3_raw_data: "type_defs.BatchGetJobsRequestTypeDef" = dataclasses.field()

    JobNames = field("JobNames")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchGetJobsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetJobsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetTableOptimizerEntry:
    boto3_raw_data: "type_defs.BatchGetTableOptimizerEntryTypeDef" = dataclasses.field()

    catalogId = field("catalogId")
    databaseName = field("databaseName")
    tableName = field("tableName")
    type = field("type")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchGetTableOptimizerEntryTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetTableOptimizerEntryTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetTriggersRequest:
    boto3_raw_data: "type_defs.BatchGetTriggersRequestTypeDef" = dataclasses.field()

    TriggerNames = field("TriggerNames")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchGetTriggersRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetTriggersRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetWorkflowsRequest:
    boto3_raw_data: "type_defs.BatchGetWorkflowsRequestTypeDef" = dataclasses.field()

    Names = field("Names")
    IncludeGraph = field("IncludeGraph")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchGetWorkflowsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetWorkflowsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DatapointInclusionAnnotation:
    boto3_raw_data: "type_defs.DatapointInclusionAnnotationTypeDef" = (
        dataclasses.field()
    )

    ProfileId = field("ProfileId")
    StatisticId = field("StatisticId")
    InclusionAnnotation = field("InclusionAnnotation")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DatapointInclusionAnnotationTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DatapointInclusionAnnotationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchStopJobRunRequest:
    boto3_raw_data: "type_defs.BatchStopJobRunRequestTypeDef" = dataclasses.field()

    JobName = field("JobName")
    JobRunIds = field("JobRunIds")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchStopJobRunRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchStopJobRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchStopJobRunSuccessfulSubmission:
    boto3_raw_data: "type_defs.BatchStopJobRunSuccessfulSubmissionTypeDef" = (
        dataclasses.field()
    )

    JobName = field("JobName")
    JobRunId = field("JobRunId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.BatchStopJobRunSuccessfulSubmissionTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchStopJobRunSuccessfulSubmissionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BinaryColumnStatisticsData:
    boto3_raw_data: "type_defs.BinaryColumnStatisticsDataTypeDef" = dataclasses.field()

    MaximumLength = field("MaximumLength")
    AverageLength = field("AverageLength")
    NumberOfNulls = field("NumberOfNulls")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BinaryColumnStatisticsDataTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BinaryColumnStatisticsDataTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BlueprintDetails:
    boto3_raw_data: "type_defs.BlueprintDetailsTypeDef" = dataclasses.field()

    BlueprintName = field("BlueprintName")
    RunId = field("RunId")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.BlueprintDetailsTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BlueprintDetailsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BlueprintRun:
    boto3_raw_data: "type_defs.BlueprintRunTypeDef" = dataclasses.field()

    BlueprintName = field("BlueprintName")
    RunId = field("RunId")
    WorkflowName = field("WorkflowName")
    State = field("State")
    StartedOn = field("StartedOn")
    CompletedOn = field("CompletedOn")
    ErrorMessage = field("ErrorMessage")
    RollbackErrorMessage = field("RollbackErrorMessage")
    Parameters = field("Parameters")
    RoleArn = field("RoleArn")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.BlueprintRunTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.BlueprintRunTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class LastActiveDefinition:
    boto3_raw_data: "type_defs.LastActiveDefinitionTypeDef" = dataclasses.field()

    Description = field("Description")
    LastModifiedOn = field("LastModifiedOn")
    ParameterSpec = field("ParameterSpec")
    BlueprintLocation = field("BlueprintLocation")
    BlueprintServiceLocation = field("BlueprintServiceLocation")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.LastActiveDefinitionTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.LastActiveDefinitionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BooleanColumnStatisticsData:
    boto3_raw_data: "type_defs.BooleanColumnStatisticsDataTypeDef" = dataclasses.field()

    NumberOfTrues = field("NumberOfTrues")
    NumberOfFalses = field("NumberOfFalses")
    NumberOfNulls = field("NumberOfNulls")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BooleanColumnStatisticsDataTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BooleanColumnStatisticsDataTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CancelDataQualityRuleRecommendationRunRequest:
    boto3_raw_data: "type_defs.CancelDataQualityRuleRecommendationRunRequestTypeDef" = (
        dataclasses.field()
    )

    RunId = field("RunId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.CancelDataQualityRuleRecommendationRunRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CancelDataQualityRuleRecommendationRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CancelDataQualityRulesetEvaluationRunRequest:
    boto3_raw_data: "type_defs.CancelDataQualityRulesetEvaluationRunRequestTypeDef" = (
        dataclasses.field()
    )

    RunId = field("RunId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.CancelDataQualityRulesetEvaluationRunRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CancelDataQualityRulesetEvaluationRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CancelMLTaskRunRequest:
    boto3_raw_data: "type_defs.CancelMLTaskRunRequestTypeDef" = dataclasses.field()

    TransformId = field("TransformId")
    TaskRunId = field("TaskRunId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CancelMLTaskRunRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CancelMLTaskRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CancelStatementRequest:
    boto3_raw_data: "type_defs.CancelStatementRequestTypeDef" = dataclasses.field()

    SessionId = field("SessionId")
    Id = field("Id")
    RequestOrigin = field("RequestOrigin")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CancelStatementRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CancelStatementRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Capabilities:
    boto3_raw_data: "type_defs.CapabilitiesTypeDef" = dataclasses.field()

    SupportedAuthenticationTypes = field("SupportedAuthenticationTypes")
    SupportedDataOperations = field("SupportedDataOperations")
    SupportedComputeEnvironments = field("SupportedComputeEnvironments")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CapabilitiesTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.CapabilitiesTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogEntry:
    boto3_raw_data: "type_defs.CatalogEntryTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CatalogEntryTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.CatalogEntryTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogImportStatus:
    boto3_raw_data: "type_defs.CatalogImportStatusTypeDef" = dataclasses.field()

    ImportCompleted = field("ImportCompleted")
    ImportTime = field("ImportTime")
    ImportedBy = field("ImportedBy")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CatalogImportStatusTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CatalogImportStatusTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class FederatedCatalog:
    boto3_raw_data: "type_defs.FederatedCatalogTypeDef" = dataclasses.field()

    Identifier = field("Identifier")
    ConnectionName = field("ConnectionName")
    ConnectionType = field("ConnectionType")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.FederatedCatalogTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.FederatedCatalogTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TargetRedshiftCatalog:
    boto3_raw_data: "type_defs.TargetRedshiftCatalogTypeDef" = dataclasses.field()

    CatalogArn = field("CatalogArn")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.TargetRedshiftCatalogTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TargetRedshiftCatalogTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class KafkaStreamingSourceOptionsOutput:
    boto3_raw_data: "type_defs.KafkaStreamingSourceOptionsOutputTypeDef" = (
        dataclasses.field()
    )

    BootstrapServers = field("BootstrapServers")
    SecurityProtocol = field("SecurityProtocol")
    ConnectionName = field("ConnectionName")
    TopicName = field("TopicName")
    Assign = field("Assign")
    SubscribePattern = field("SubscribePattern")
    Classification = field("Classification")
    Delimiter = field("Delimiter")
    StartingOffsets = field("StartingOffsets")
    EndingOffsets = field("EndingOffsets")
    PollTimeoutMs = field("PollTimeoutMs")
    NumRetries = field("NumRetries")
    RetryIntervalMs = field("RetryIntervalMs")
    MaxOffsetsPerTrigger = field("MaxOffsetsPerTrigger")
    MinPartitions = field("MinPartitions")
    IncludeHeaders = field("IncludeHeaders")
    AddRecordTimestamp = field("AddRecordTimestamp")
    EmitConsumerLagMetrics = field("EmitConsumerLagMetrics")
    StartingTimestamp = field("StartingTimestamp")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.KafkaStreamingSourceOptionsOutputTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.KafkaStreamingSourceOptionsOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StreamingDataPreviewOptions:
    boto3_raw_data: "type_defs.StreamingDataPreviewOptionsTypeDef" = dataclasses.field()

    PollingTime = field("PollingTime")
    RecordPollingLimit = field("RecordPollingLimit")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StreamingDataPreviewOptionsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StreamingDataPreviewOptionsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class KinesisStreamingSourceOptionsOutput:
    boto3_raw_data: "type_defs.KinesisStreamingSourceOptionsOutputTypeDef" = (
        dataclasses.field()
    )

    EndpointUrl = field("EndpointUrl")
    StreamName = field("StreamName")
    Classification = field("Classification")
    Delimiter = field("Delimiter")
    StartingPosition = field("StartingPosition")
    MaxFetchTimeInMs = field("MaxFetchTimeInMs")
    MaxFetchRecordsPerShard = field("MaxFetchRecordsPerShard")
    MaxRecordPerRead = field("MaxRecordPerRead")
    AddIdleTimeBetweenReads = field("AddIdleTimeBetweenReads")
    IdleTimeBetweenReadsInMs = field("IdleTimeBetweenReadsInMs")
    DescribeShardInterval = field("DescribeShardInterval")
    NumRetries = field("NumRetries")
    RetryIntervalMs = field("RetryIntervalMs")
    MaxRetryIntervalMs = field("MaxRetryIntervalMs")
    AvoidEmptyBatches = field("AvoidEmptyBatches")
    StreamArn = field("StreamArn")
    RoleArn = field("RoleArn")
    RoleSessionName = field("RoleSessionName")
    AddRecordTimestamp = field("AddRecordTimestamp")
    EmitConsumerLagMetrics = field("EmitConsumerLagMetrics")
    StartingTimestamp = field("StartingTimestamp")
    FanoutConsumerARN = field("FanoutConsumerARN")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.KinesisStreamingSourceOptionsOutputTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.KinesisStreamingSourceOptionsOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataLakeAccessPropertiesOutput:
    boto3_raw_data: "type_defs.DataLakeAccessPropertiesOutputTypeDef" = (
        dataclasses.field()
    )

    DataLakeAccess = field("DataLakeAccess")
    DataTransferRole = field("DataTransferRole")
    KmsKey = field("KmsKey")
    ManagedWorkgroupName = field("ManagedWorkgroupName")
    ManagedWorkgroupStatus = field("ManagedWorkgroupStatus")
    RedshiftDatabaseName = field("RedshiftDatabaseName")
    StatusMessage = field("StatusMessage")
    CatalogType = field("CatalogType")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.DataLakeAccessPropertiesOutputTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataLakeAccessPropertiesOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IcebergOptimizationPropertiesOutput:
    boto3_raw_data: "type_defs.IcebergOptimizationPropertiesOutputTypeDef" = (
        dataclasses.field()
    )

    RoleArn = field("RoleArn")
    Compaction = field("Compaction")
    Retention = field("Retention")
    OrphanFileDeletion = field("OrphanFileDeletion")
    LastUpdatedTime = field("LastUpdatedTime")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.IcebergOptimizationPropertiesOutputTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IcebergOptimizationPropertiesOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataLakeAccessProperties:
    boto3_raw_data: "type_defs.DataLakeAccessPropertiesTypeDef" = dataclasses.field()

    DataLakeAccess = field("DataLakeAccess")
    DataTransferRole = field("DataTransferRole")
    KmsKey = field("KmsKey")
    CatalogType = field("CatalogType")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DataLakeAccessPropertiesTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataLakeAccessPropertiesTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IcebergOptimizationProperties:
    boto3_raw_data: "type_defs.IcebergOptimizationPropertiesTypeDef" = (
        dataclasses.field()
    )

    RoleArn = field("RoleArn")
    Compaction = field("Compaction")
    Retention = field("Retention")
    OrphanFileDeletion = field("OrphanFileDeletion")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.IcebergOptimizationPropertiesTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IcebergOptimizationPropertiesTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogSchemaChangePolicy:
    boto3_raw_data: "type_defs.CatalogSchemaChangePolicyTypeDef" = dataclasses.field()

    EnableUpdateCatalog = field("EnableUpdateCatalog")
    UpdateBehavior = field("UpdateBehavior")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CatalogSchemaChangePolicyTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CatalogSchemaChangePolicyTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogTargetOutput:
    boto3_raw_data: "type_defs.CatalogTargetOutputTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    Tables = field("Tables")
    ConnectionName = field("ConnectionName")
    EventQueueArn = field("EventQueueArn")
    DlqEventQueueArn = field("DlqEventQueueArn")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CatalogTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CatalogTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogTarget:
    boto3_raw_data: "type_defs.CatalogTargetTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    Tables = field("Tables")
    ConnectionName = field("ConnectionName")
    EventQueueArn = field("EventQueueArn")
    DlqEventQueueArn = field("DlqEventQueueArn")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CatalogTargetTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.CatalogTargetTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CheckSchemaVersionValidityInput:
    boto3_raw_data: "type_defs.CheckSchemaVersionValidityInputTypeDef" = (
        dataclasses.field()
    )

    DataFormat = field("DataFormat")
    SchemaDefinition = field("SchemaDefinition")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.CheckSchemaVersionValidityInputTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CheckSchemaVersionValidityInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CsvClassifier:
    boto3_raw_data: "type_defs.CsvClassifierTypeDef" = dataclasses.field()

    Name = field("Name")
    CreationTime = field("CreationTime")
    LastUpdated = field("LastUpdated")
    Version = field("Version")
    Delimiter = field("Delimiter")
    QuoteSymbol = field("QuoteSymbol")
    ContainsHeader = field("ContainsHeader")
    Header = field("Header")
    DisableValueTrimming = field("DisableValueTrimming")
    AllowSingleColumn = field("AllowSingleColumn")
    CustomDatatypeConfigured = field("CustomDatatypeConfigured")
    CustomDatatypes = field("CustomDatatypes")
    Serde = field("Serde")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CsvClassifierTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.CsvClassifierTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GrokClassifier:
    boto3_raw_data: "type_defs.GrokClassifierTypeDef" = dataclasses.field()

    Name = field("Name")
    Classification = field("Classification")
    GrokPattern = field("GrokPattern")
    CreationTime = field("CreationTime")
    LastUpdated = field("LastUpdated")
    Version = field("Version")
    CustomPatterns = field("CustomPatterns")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GrokClassifierTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.GrokClassifierTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JsonClassifier:
    boto3_raw_data: "type_defs.JsonClassifierTypeDef" = dataclasses.field()

    Name = field("Name")
    JsonPath = field("JsonPath")
    CreationTime = field("CreationTime")
    LastUpdated = field("LastUpdated")
    Version = field("Version")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.JsonClassifierTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.JsonClassifierTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class XMLClassifier:
    boto3_raw_data: "type_defs.XMLClassifierTypeDef" = dataclasses.field()

    Name = field("Name")
    Classification = field("Classification")
    CreationTime = field("CreationTime")
    LastUpdated = field("LastUpdated")
    Version = field("Version")
    RowTag = field("RowTag")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.XMLClassifierTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.XMLClassifierTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CloudWatchEncryption:
    boto3_raw_data: "type_defs.CloudWatchEncryptionTypeDef" = dataclasses.field()

    CloudWatchEncryptionMode = field("CloudWatchEncryptionMode")
    KmsKeyArn = field("KmsKeyArn")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CloudWatchEncryptionTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CloudWatchEncryptionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ConnectorDataTargetOutput:
    boto3_raw_data: "type_defs.ConnectorDataTargetOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    ConnectionType = field("ConnectionType")
    Data = field("Data")
    Inputs = field("Inputs")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ConnectorDataTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ConnectorDataTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DropDuplicatesOutput:
    boto3_raw_data: "type_defs.DropDuplicatesOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Columns = field("Columns")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DropDuplicatesOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DropDuplicatesOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DropFieldsOutput:
    boto3_raw_data: "type_defs.DropFieldsOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Paths = field("Paths")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DropFieldsOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DropFieldsOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class FillMissingValuesOutput:
    boto3_raw_data: "type_defs.FillMissingValuesOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    ImputedPath = field("ImputedPath")
    FilledPath = field("FilledPath")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.FillMissingValuesOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.FillMissingValuesOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class MergeOutput:
    boto3_raw_data: "type_defs.MergeOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Source = field("Source")
    PrimaryKeys = field("PrimaryKeys")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.MergeOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.MergeOutputTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class MicrosoftSQLServerCatalogSource:
    boto3_raw_data: "type_defs.MicrosoftSQLServerCatalogSourceTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.MicrosoftSQLServerCatalogSourceTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.MicrosoftSQLServerCatalogSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class MicrosoftSQLServerCatalogTargetOutput:
    boto3_raw_data: "type_defs.MicrosoftSQLServerCatalogTargetOutputTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    Inputs = field("Inputs")
    Database = field("Database")
    Table = field("Table")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.MicrosoftSQLServerCatalogTargetOutputTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.MicrosoftSQLServerCatalogTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class MySQLCatalogSource:
    boto3_raw_data: "type_defs.MySQLCatalogSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.MySQLCatalogSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.MySQLCatalogSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class MySQLCatalogTargetOutput:
    boto3_raw_data: "type_defs.MySQLCatalogTargetOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Database = field("Database")
    Table = field("Table")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.MySQLCatalogTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.MySQLCatalogTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class OracleSQLCatalogSource:
    boto3_raw_data: "type_defs.OracleSQLCatalogSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.OracleSQLCatalogSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.OracleSQLCatalogSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class OracleSQLCatalogTargetOutput:
    boto3_raw_data: "type_defs.OracleSQLCatalogTargetOutputTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    Inputs = field("Inputs")
    Database = field("Database")
    Table = field("Table")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.OracleSQLCatalogTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.OracleSQLCatalogTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PIIDetectionOutput:
    boto3_raw_data: "type_defs.PIIDetectionOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    PiiType = field("PiiType")
    EntityTypesToDetect = field("EntityTypesToDetect")
    OutputColumnName = field("OutputColumnName")
    SampleFraction = field("SampleFraction")
    ThresholdFraction = field("ThresholdFraction")
    MaskValue = field("MaskValue")
    RedactText = field("RedactText")
    RedactChar = field("RedactChar")
    MatchPattern = field("MatchPattern")
    NumLeftCharsToExclude = field("NumLeftCharsToExclude")
    NumRightCharsToExclude = field("NumRightCharsToExclude")
    DetectionParameters = field("DetectionParameters")
    DetectionSensitivity = field("DetectionSensitivity")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.PIIDetectionOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PIIDetectionOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PostgreSQLCatalogSource:
    boto3_raw_data: "type_defs.PostgreSQLCatalogSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.PostgreSQLCatalogSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PostgreSQLCatalogSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PostgreSQLCatalogTargetOutput:
    boto3_raw_data: "type_defs.PostgreSQLCatalogTargetOutputTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    Inputs = field("Inputs")
    Database = field("Database")
    Table = field("Table")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.PostgreSQLCatalogTargetOutputTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PostgreSQLCatalogTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RedshiftSource:
    boto3_raw_data: "type_defs.RedshiftSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    RedshiftTmpDir = field("RedshiftTmpDir")
    TmpDirIAMRole = field("TmpDirIAMRole")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.RedshiftSourceTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.RedshiftSourceTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RelationalCatalogSource:
    boto3_raw_data: "type_defs.RelationalCatalogSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.RelationalCatalogSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.RelationalCatalogSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RenameFieldOutput:
    boto3_raw_data: "type_defs.RenameFieldOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    SourcePath = field("SourcePath")
    TargetPath = field("TargetPath")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.RenameFieldOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.RenameFieldOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SelectFieldsOutput:
    boto3_raw_data: "type_defs.SelectFieldsOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Paths = field("Paths")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SelectFieldsOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SelectFieldsOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SelectFromCollectionOutput:
    boto3_raw_data: "type_defs.SelectFromCollectionOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Index = field("Index")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SelectFromCollectionOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SelectFromCollectionOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SpigotOutput:
    boto3_raw_data: "type_defs.SpigotOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Path = field("Path")
    Topk = field("Topk")
    Prob = field("Prob")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SpigotOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SpigotOutputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SplitFieldsOutput:
    boto3_raw_data: "type_defs.SplitFieldsOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Paths = field("Paths")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SplitFieldsOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SplitFieldsOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UnionOutput:
    boto3_raw_data: "type_defs.UnionOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    UnionType = field("UnionType")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.UnionOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.UnionOutputTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CodeGenEdge:
    boto3_raw_data: "type_defs.CodeGenEdgeTypeDef" = dataclasses.field()

    Source = field("Source")
    Target = field("Target")
    TargetParameter = field("TargetParameter")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CodeGenEdgeTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.CodeGenEdgeTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CodeGenNodeArg:
    boto3_raw_data: "type_defs.CodeGenNodeArgTypeDef" = dataclasses.field()

    Name = field("Name")
    Value = field("Value")
    Param = field("Param")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CodeGenNodeArgTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.CodeGenNodeArgTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ColumnImportance:
    boto3_raw_data: "type_defs.ColumnImportanceTypeDef" = dataclasses.field()

    ColumnName = field("ColumnName")
    Importance = field("Importance")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ColumnImportanceTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ColumnImportanceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ColumnOutput:
    boto3_raw_data: "type_defs.ColumnOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Type = field("Type")
    Comment = field("Comment")
    Parameters = field("Parameters")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ColumnOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ColumnOutputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ColumnRowFilter:
    boto3_raw_data: "type_defs.ColumnRowFilterTypeDef" = dataclasses.field()

    ColumnName = field("ColumnName")
    RowFilterExpression = field("RowFilterExpression")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ColumnRowFilterTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ColumnRowFilterTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DateColumnStatisticsDataOutput:
    boto3_raw_data: "type_defs.DateColumnStatisticsDataOutputTypeDef" = (
        dataclasses.field()
    )

    NumberOfNulls = field("NumberOfNulls")
    NumberOfDistinctValues = field("NumberOfDistinctValues")
    MinimumValue = field("MinimumValue")
    MaximumValue = field("MaximumValue")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.DateColumnStatisticsDataOutputTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DateColumnStatisticsDataOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DoubleColumnStatisticsData:
    boto3_raw_data: "type_defs.DoubleColumnStatisticsDataTypeDef" = dataclasses.field()

    NumberOfNulls = field("NumberOfNulls")
    NumberOfDistinctValues = field("NumberOfDistinctValues")
    MinimumValue = field("MinimumValue")
    MaximumValue = field("MaximumValue")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DoubleColumnStatisticsDataTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DoubleColumnStatisticsDataTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class LongColumnStatisticsData:
    boto3_raw_data: "type_defs.LongColumnStatisticsDataTypeDef" = dataclasses.field()

    NumberOfNulls = field("NumberOfNulls")
    NumberOfDistinctValues = field("NumberOfDistinctValues")
    MinimumValue = field("MinimumValue")
    MaximumValue = field("MaximumValue")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.LongColumnStatisticsDataTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.LongColumnStatisticsDataTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StringColumnStatisticsData:
    boto3_raw_data: "type_defs.StringColumnStatisticsDataTypeDef" = dataclasses.field()

    MaximumLength = field("MaximumLength")
    AverageLength = field("AverageLength")
    NumberOfNulls = field("NumberOfNulls")
    NumberOfDistinctValues = field("NumberOfDistinctValues")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StringColumnStatisticsDataTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StringColumnStatisticsDataTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ColumnStatisticsTaskRun:
    boto3_raw_data: "type_defs.ColumnStatisticsTaskRunTypeDef" = dataclasses.field()

    CustomerId = field("CustomerId")
    ColumnStatisticsTaskRunId = field("ColumnStatisticsTaskRunId")
    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    ColumnNameList = field("ColumnNameList")
    CatalogID = field("CatalogID")
    Role = field("Role")
    SampleSize = field("SampleSize")
    SecurityConfiguration = field("SecurityConfiguration")
    NumberOfWorkers = field("NumberOfWorkers")
    WorkerType = field("WorkerType")
    ComputationType = field("ComputationType")
    Status = field("Status")
    CreationTime = field("CreationTime")
    LastUpdated = field("LastUpdated")
    StartTime = field("StartTime")
    EndTime = field("EndTime")
    ErrorMessage = field("ErrorMessage")
    DPUSeconds = field("DPUSeconds")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ColumnStatisticsTaskRunTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ColumnStatisticsTaskRunTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ExecutionAttempt:
    boto3_raw_data: "type_defs.ExecutionAttemptTypeDef" = dataclasses.field()

    Status = field("Status")
    ColumnStatisticsTaskRunId = field("ColumnStatisticsTaskRunId")
    ExecutionTimestamp = field("ExecutionTimestamp")
    ErrorMessage = field("ErrorMessage")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ExecutionAttemptTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ExecutionAttemptTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Schedule:
    boto3_raw_data: "type_defs.ScheduleTypeDef" = dataclasses.field()

    ScheduleExpression = field("ScheduleExpression")
    State = field("State")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ScheduleTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ScheduleTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Column:
    boto3_raw_data: "type_defs.ColumnTypeDef" = dataclasses.field()

    Name = field("Name")
    Type = field("Type")
    Comment = field("Comment")
    Parameters = field("Parameters")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ColumnTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ColumnTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IcebergCompactionConfiguration:
    boto3_raw_data: "type_defs.IcebergCompactionConfigurationTypeDef" = (
        dataclasses.field()
    )

    strategy = field("strategy")
    minInputFiles = field("minInputFiles")
    deleteFileThreshold = field("deleteFileThreshold")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.IcebergCompactionConfigurationTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IcebergCompactionConfigurationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IcebergCompactionMetrics:
    boto3_raw_data: "type_defs.IcebergCompactionMetricsTypeDef" = dataclasses.field()

    NumberOfBytesCompacted = field("NumberOfBytesCompacted")
    NumberOfFilesCompacted = field("NumberOfFilesCompacted")
    DpuHours = field("DpuHours")
    NumberOfDpus = field("NumberOfDpus")
    JobDurationInHour = field("JobDurationInHour")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.IcebergCompactionMetricsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IcebergCompactionMetricsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ConditionExpression:
    boto3_raw_data: "type_defs.ConditionExpressionTypeDef" = dataclasses.field()

    Condition = field("Condition")
    TargetColumn = field("TargetColumn")
    Value = field("Value")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ConditionExpressionTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ConditionExpressionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Condition:
    boto3_raw_data: "type_defs.ConditionTypeDef" = dataclasses.field()

    LogicalOperator = field("LogicalOperator")
    JobName = field("JobName")
    State = field("State")
    CrawlerName = field("CrawlerName")
    CrawlState = field("CrawlState")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ConditionTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ConditionTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ConfigurationObjectOutput:
    boto3_raw_data: "type_defs.ConfigurationObjectOutputTypeDef" = dataclasses.field()

    DefaultValue = field("DefaultValue")
    AllowedValues = field("AllowedValues")
    MinValue = field("MinValue")
    MaxValue = field("MaxValue")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ConfigurationObjectOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ConfigurationObjectOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ConfigurationObject:
    boto3_raw_data: "type_defs.ConfigurationObjectTypeDef" = dataclasses.field()

    DefaultValue = field("DefaultValue")
    AllowedValues = field("AllowedValues")
    MinValue = field("MinValue")
    MaxValue = field("MaxValue")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ConfigurationObjectTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ConfigurationObjectTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ConfusionMatrix:
    boto3_raw_data: "type_defs.ConfusionMatrixTypeDef" = dataclasses.field()

    NumTruePositives = field("NumTruePositives")
    NumFalsePositives = field("NumFalsePositives")
    NumTrueNegatives = field("NumTrueNegatives")
    NumFalseNegatives = field("NumFalseNegatives")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ConfusionMatrixTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ConfusionMatrixTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ConnectionPasswordEncryption:
    boto3_raw_data: "type_defs.ConnectionPasswordEncryptionTypeDef" = (
        dataclasses.field()
    )

    ReturnConnectionPasswordEncrypted = field("ReturnConnectionPasswordEncrypted")
    AwsKmsKeyId = field("AwsKmsKeyId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ConnectionPasswordEncryptionTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ConnectionPasswordEncryptionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ConnectionTypeVariant:
    boto3_raw_data: "type_defs.ConnectionTypeVariantTypeDef" = dataclasses.field()

    ConnectionTypeVariantName = field("ConnectionTypeVariantName")
    DisplayName = field("DisplayName")
    Description = field("Description")
    LogoUrl = field("LogoUrl")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ConnectionTypeVariantTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ConnectionTypeVariantTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PhysicalConnectionRequirementsOutput:
    boto3_raw_data: "type_defs.PhysicalConnectionRequirementsOutputTypeDef" = (
        dataclasses.field()
    )

    SubnetId = field("SubnetId")
    SecurityGroupIdList = field("SecurityGroupIdList")
    AvailabilityZone = field("AvailabilityZone")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.PhysicalConnectionRequirementsOutputTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PhysicalConnectionRequirementsOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ConnectionsListOutput:
    boto3_raw_data: "type_defs.ConnectionsListOutputTypeDef" = dataclasses.field()

    Connections = field("Connections")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ConnectionsListOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ConnectionsListOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ConnectionsList:
    boto3_raw_data: "type_defs.ConnectionsListTypeDef" = dataclasses.field()

    Connections = field("Connections")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ConnectionsListTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ConnectionsListTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ConnectorDataTarget:
    boto3_raw_data: "type_defs.ConnectorDataTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    ConnectionType = field("ConnectionType")
    Data = field("Data")
    Inputs = field("Inputs")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ConnectorDataTargetTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ConnectorDataTargetTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Crawl:
    boto3_raw_data: "type_defs.CrawlTypeDef" = dataclasses.field()

    State = field("State")
    StartedOn = field("StartedOn")
    CompletedOn = field("CompletedOn")
    ErrorMessage = field("ErrorMessage")
    LogGroup = field("LogGroup")
    LogStream = field("LogStream")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CrawlTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.CrawlTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CrawlerHistory:
    boto3_raw_data: "type_defs.CrawlerHistoryTypeDef" = dataclasses.field()

    CrawlId = field("CrawlId")
    State = field("State")
    StartTime = field("StartTime")
    EndTime = field("EndTime")
    Summary = field("Summary")
    ErrorMessage = field("ErrorMessage")
    LogGroup = field("LogGroup")
    LogStream = field("LogStream")
    MessagePrefix = field("MessagePrefix")
    DPUHour = field("DPUHour")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CrawlerHistoryTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.CrawlerHistoryTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CrawlerMetrics:
    boto3_raw_data: "type_defs.CrawlerMetricsTypeDef" = dataclasses.field()

    CrawlerName = field("CrawlerName")
    TimeLeftSeconds = field("TimeLeftSeconds")
    StillEstimating = field("StillEstimating")
    LastRuntimeSeconds = field("LastRuntimeSeconds")
    MedianRuntimeSeconds = field("MedianRuntimeSeconds")
    TablesCreated = field("TablesCreated")
    TablesUpdated = field("TablesUpdated")
    TablesDeleted = field("TablesDeleted")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CrawlerMetricsTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.CrawlerMetricsTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeltaTargetOutput:
    boto3_raw_data: "type_defs.DeltaTargetOutputTypeDef" = dataclasses.field()

    DeltaTables = field("DeltaTables")
    ConnectionName = field("ConnectionName")
    WriteManifest = field("WriteManifest")
    CreateNativeDeltaTable = field("CreateNativeDeltaTable")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DeltaTargetOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeltaTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DynamoDBTarget:
    boto3_raw_data: "type_defs.DynamoDBTargetTypeDef" = dataclasses.field()

    Path = field("Path")
    scanAll = field("scanAll")
    scanRate = field("scanRate")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DynamoDBTargetTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.DynamoDBTargetTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class HudiTargetOutput:
    boto3_raw_data: "type_defs.HudiTargetOutputTypeDef" = dataclasses.field()

    Paths = field("Paths")
    ConnectionName = field("ConnectionName")
    Exclusions = field("Exclusions")
    MaximumTraversalDepth = field("MaximumTraversalDepth")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.HudiTargetOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.HudiTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IcebergTargetOutput:
    boto3_raw_data: "type_defs.IcebergTargetOutputTypeDef" = dataclasses.field()

    Paths = field("Paths")
    ConnectionName = field("ConnectionName")
    Exclusions = field("Exclusions")
    MaximumTraversalDepth = field("MaximumTraversalDepth")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.IcebergTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IcebergTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JdbcTargetOutput:
    boto3_raw_data: "type_defs.JdbcTargetOutputTypeDef" = dataclasses.field()

    ConnectionName = field("ConnectionName")
    Path = field("Path")
    Exclusions = field("Exclusions")
    EnableAdditionalMetadata = field("EnableAdditionalMetadata")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.JdbcTargetOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.JdbcTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class MongoDBTarget:
    boto3_raw_data: "type_defs.MongoDBTargetTypeDef" = dataclasses.field()

    ConnectionName = field("ConnectionName")
    Path = field("Path")
    ScanAll = field("ScanAll")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.MongoDBTargetTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.MongoDBTargetTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3TargetOutput:
    boto3_raw_data: "type_defs.S3TargetOutputTypeDef" = dataclasses.field()

    Path = field("Path")
    Exclusions = field("Exclusions")
    ConnectionName = field("ConnectionName")
    SampleSize = field("SampleSize")
    EventQueueArn = field("EventQueueArn")
    DlqEventQueueArn = field("DlqEventQueueArn")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.S3TargetOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.S3TargetOutputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeltaTarget:
    boto3_raw_data: "type_defs.DeltaTargetTypeDef" = dataclasses.field()

    DeltaTables = field("DeltaTables")
    ConnectionName = field("ConnectionName")
    WriteManifest = field("WriteManifest")
    CreateNativeDeltaTable = field("CreateNativeDeltaTable")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DeltaTargetTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.DeltaTargetTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class HudiTarget:
    boto3_raw_data: "type_defs.HudiTargetTypeDef" = dataclasses.field()

    Paths = field("Paths")
    ConnectionName = field("ConnectionName")
    Exclusions = field("Exclusions")
    MaximumTraversalDepth = field("MaximumTraversalDepth")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.HudiTargetTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.HudiTargetTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IcebergTarget:
    boto3_raw_data: "type_defs.IcebergTargetTypeDef" = dataclasses.field()

    Paths = field("Paths")
    ConnectionName = field("ConnectionName")
    Exclusions = field("Exclusions")
    MaximumTraversalDepth = field("MaximumTraversalDepth")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.IcebergTargetTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.IcebergTargetTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JdbcTarget:
    boto3_raw_data: "type_defs.JdbcTargetTypeDef" = dataclasses.field()

    ConnectionName = field("ConnectionName")
    Path = field("Path")
    Exclusions = field("Exclusions")
    EnableAdditionalMetadata = field("EnableAdditionalMetadata")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.JdbcTargetTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.JdbcTargetTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3Target:
    boto3_raw_data: "type_defs.S3TargetTypeDef" = dataclasses.field()

    Path = field("Path")
    Exclusions = field("Exclusions")
    ConnectionName = field("ConnectionName")
    SampleSize = field("SampleSize")
    EventQueueArn = field("EventQueueArn")
    DlqEventQueueArn = field("DlqEventQueueArn")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.S3TargetTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.S3TargetTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class LakeFormationConfiguration:
    boto3_raw_data: "type_defs.LakeFormationConfigurationTypeDef" = dataclasses.field()

    UseLakeFormationCredentials = field("UseLakeFormationCredentials")
    AccountId = field("AccountId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.LakeFormationConfigurationTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.LakeFormationConfigurationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class LastCrawlInfo:
    boto3_raw_data: "type_defs.LastCrawlInfoTypeDef" = dataclasses.field()

    Status = field("Status")
    ErrorMessage = field("ErrorMessage")
    LogGroup = field("LogGroup")
    LogStream = field("LogStream")
    MessagePrefix = field("MessagePrefix")
    StartTime = field("StartTime")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.LastCrawlInfoTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.LastCrawlInfoTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class LineageConfiguration:
    boto3_raw_data: "type_defs.LineageConfigurationTypeDef" = dataclasses.field()

    CrawlerLineageSettings = field("CrawlerLineageSettings")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.LineageConfigurationTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.LineageConfigurationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RecrawlPolicy:
    boto3_raw_data: "type_defs.RecrawlPolicyTypeDef" = dataclasses.field()

    RecrawlBehavior = field("RecrawlBehavior")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.RecrawlPolicyTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.RecrawlPolicyTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SchemaChangePolicy:
    boto3_raw_data: "type_defs.SchemaChangePolicyTypeDef" = dataclasses.field()

    UpdateBehavior = field("UpdateBehavior")
    DeleteBehavior = field("DeleteBehavior")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SchemaChangePolicyTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SchemaChangePolicyTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CrawlsFilter:
    boto3_raw_data: "type_defs.CrawlsFilterTypeDef" = dataclasses.field()

    FieldName = field("FieldName")
    FilterOperator = field("FilterOperator")
    FieldValue = field("FieldValue")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CrawlsFilterTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.CrawlsFilterTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateBlueprintRequest:
    boto3_raw_data: "type_defs.CreateBlueprintRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    BlueprintLocation = field("BlueprintLocation")
    Description = field("Description")
    Tags = field("Tags")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateBlueprintRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateBlueprintRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateCsvClassifierRequest:
    boto3_raw_data: "type_defs.CreateCsvClassifierRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    Delimiter = field("Delimiter")
    QuoteSymbol = field("QuoteSymbol")
    ContainsHeader = field("ContainsHeader")
    Header = field("Header")
    DisableValueTrimming = field("DisableValueTrimming")
    AllowSingleColumn = field("AllowSingleColumn")
    CustomDatatypeConfigured = field("CustomDatatypeConfigured")
    CustomDatatypes = field("CustomDatatypes")
    Serde = field("Serde")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateCsvClassifierRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateCsvClassifierRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateGrokClassifierRequest:
    boto3_raw_data: "type_defs.CreateGrokClassifierRequestTypeDef" = dataclasses.field()

    Classification = field("Classification")
    Name = field("Name")
    GrokPattern = field("GrokPattern")
    CustomPatterns = field("CustomPatterns")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateGrokClassifierRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateGrokClassifierRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateJsonClassifierRequest:
    boto3_raw_data: "type_defs.CreateJsonClassifierRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    JsonPath = field("JsonPath")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateJsonClassifierRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateJsonClassifierRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateXMLClassifierRequest:
    boto3_raw_data: "type_defs.CreateXMLClassifierRequestTypeDef" = dataclasses.field()

    Classification = field("Classification")
    Name = field("Name")
    RowTag = field("RowTag")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateXMLClassifierRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateXMLClassifierRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateColumnStatisticsTaskSettingsRequest:
    boto3_raw_data: "type_defs.CreateColumnStatisticsTaskSettingsRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    Role = field("Role")
    Schedule = field("Schedule")
    ColumnNameList = field("ColumnNameList")
    SampleSize = field("SampleSize")
    CatalogID = field("CatalogID")
    SecurityConfiguration = field("SecurityConfiguration")
    Tags = field("Tags")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.CreateColumnStatisticsTaskSettingsRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateColumnStatisticsTaskSettingsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateCustomEntityTypeRequest:
    boto3_raw_data: "type_defs.CreateCustomEntityTypeRequestTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    RegexString = field("RegexString")
    ContextWords = field("ContextWords")
    Tags = field("Tags")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.CreateCustomEntityTypeRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateCustomEntityTypeRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityTargetTable:
    boto3_raw_data: "type_defs.DataQualityTargetTableTypeDef" = dataclasses.field()

    TableName = field("TableName")
    DatabaseName = field("DatabaseName")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DataQualityTargetTableTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityTargetTableTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateDevEndpointRequest:
    boto3_raw_data: "type_defs.CreateDevEndpointRequestTypeDef" = dataclasses.field()

    EndpointName = field("EndpointName")
    RoleArn = field("RoleArn")
    SecurityGroupIds = field("SecurityGroupIds")
    SubnetId = field("SubnetId")
    PublicKey = field("PublicKey")
    PublicKeys = field("PublicKeys")
    NumberOfNodes = field("NumberOfNodes")
    WorkerType = field("WorkerType")
    GlueVersion = field("GlueVersion")
    NumberOfWorkers = field("NumberOfWorkers")
    ExtraPythonLibsS3Path = field("ExtraPythonLibsS3Path")
    ExtraJarsS3Path = field("ExtraJarsS3Path")
    SecurityConfiguration = field("SecurityConfiguration")
    Tags = field("Tags")
    Arguments = field("Arguments")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateDevEndpointRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateDevEndpointRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateGlueIdentityCenterConfigurationRequest:
    boto3_raw_data: "type_defs.CreateGlueIdentityCenterConfigurationRequestTypeDef" = (
        dataclasses.field()
    )

    InstanceArn = field("InstanceArn")
    Scopes = field("Scopes")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.CreateGlueIdentityCenterConfigurationRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateGlueIdentityCenterConfigurationRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Tag:
    boto3_raw_data: "type_defs.TagTypeDef" = dataclasses.field()

    key = field("key")
    value = field("value")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.TagTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.TagTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SourceProcessingProperties:
    boto3_raw_data: "type_defs.SourceProcessingPropertiesTypeDef" = dataclasses.field()

    RoleArn = field("RoleArn")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SourceProcessingPropertiesTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SourceProcessingPropertiesTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TargetProcessingProperties:
    boto3_raw_data: "type_defs.TargetProcessingPropertiesTypeDef" = dataclasses.field()

    RoleArn = field("RoleArn")
    KmsArn = field("KmsArn")
    ConnectionName = field("ConnectionName")
    EventBusArn = field("EventBusArn")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.TargetProcessingPropertiesTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TargetProcessingPropertiesTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IntegrationConfigOutput:
    boto3_raw_data: "type_defs.IntegrationConfigOutputTypeDef" = dataclasses.field()

    RefreshInterval = field("RefreshInterval")
    SourceProperties = field("SourceProperties")
    ContinuousSync = field("ContinuousSync")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.IntegrationConfigOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IntegrationConfigOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IntegrationError:
    boto3_raw_data: "type_defs.IntegrationErrorTypeDef" = dataclasses.field()

    ErrorCode = field("ErrorCode")
    ErrorMessage = field("ErrorMessage")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.IntegrationErrorTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IntegrationErrorTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ExecutionProperty:
    boto3_raw_data: "type_defs.ExecutionPropertyTypeDef" = dataclasses.field()

    MaxConcurrentRuns = field("MaxConcurrentRuns")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ExecutionPropertyTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ExecutionPropertyTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JobCommand:
    boto3_raw_data: "type_defs.JobCommandTypeDef" = dataclasses.field()

    Name = field("Name")
    ScriptLocation = field("ScriptLocation")
    PythonVersion = field("PythonVersion")
    Runtime = field("Runtime")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.JobCommandTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.JobCommandTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SourceControlDetails:
    boto3_raw_data: "type_defs.SourceControlDetailsTypeDef" = dataclasses.field()

    Provider = field("Provider")
    Repository = field("Repository")
    Owner = field("Owner")
    Branch = field("Branch")
    Folder = field("Folder")
    LastCommitId = field("LastCommitId")
    AuthStrategy = field("AuthStrategy")
    AuthToken = field("AuthToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SourceControlDetailsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SourceControlDetailsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PartitionIndex:
    boto3_raw_data: "type_defs.PartitionIndexTypeDef" = dataclasses.field()

    Keys = field("Keys")
    IndexName = field("IndexName")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.PartitionIndexTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.PartitionIndexTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateRegistryInput:
    boto3_raw_data: "type_defs.CreateRegistryInputTypeDef" = dataclasses.field()

    RegistryName = field("RegistryName")
    Description = field("Description")
    Tags = field("Tags")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateRegistryInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateRegistryInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RegistryId:
    boto3_raw_data: "type_defs.RegistryIdTypeDef" = dataclasses.field()

    RegistryName = field("RegistryName")
    RegistryArn = field("RegistryArn")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.RegistryIdTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.RegistryIdTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SessionCommand:
    boto3_raw_data: "type_defs.SessionCommandTypeDef" = dataclasses.field()

    Name = field("Name")
    PythonVersion = field("PythonVersion")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SessionCommandTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SessionCommandTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class EventBatchingCondition:
    boto3_raw_data: "type_defs.EventBatchingConditionTypeDef" = dataclasses.field()

    BatchSize = field("BatchSize")
    BatchWindow = field("BatchWindow")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.EventBatchingConditionTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.EventBatchingConditionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateWorkflowRequest:
    boto3_raw_data: "type_defs.CreateWorkflowRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    Description = field("Description")
    DefaultRunProperties = field("DefaultRunProperties")
    Tags = field("Tags")
    MaxConcurrentRuns = field("MaxConcurrentRuns")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateWorkflowRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateWorkflowRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DDBELTCatalogAdditionalOptions:
    boto3_raw_data: "type_defs.DDBELTCatalogAdditionalOptionsTypeDef" = (
        dataclasses.field()
    )

    DynamodbExport = field("DynamodbExport")
    DynamodbUnnestDDBJson = field("DynamodbUnnestDDBJson")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.DDBELTCatalogAdditionalOptionsTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DDBELTCatalogAdditionalOptionsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DDBELTConnectionOptions:
    boto3_raw_data: "type_defs.DDBELTConnectionOptionsTypeDef" = dataclasses.field()

    DynamodbTableArn = field("DynamodbTableArn")
    DynamodbExport = field("DynamodbExport")
    DynamodbUnnestDDBJson = field("DynamodbUnnestDDBJson")
    DynamodbS3Bucket = field("DynamodbS3Bucket")
    DynamodbS3Prefix = field("DynamodbS3Prefix")
    DynamodbS3BucketOwner = field("DynamodbS3BucketOwner")
    DynamodbStsRoleArn = field("DynamodbStsRoleArn")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DDBELTConnectionOptionsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DDBELTConnectionOptionsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DQResultsPublishingOptions:
    boto3_raw_data: "type_defs.DQResultsPublishingOptionsTypeDef" = dataclasses.field()

    EvaluationContext = field("EvaluationContext")
    ResultsS3Prefix = field("ResultsS3Prefix")
    CloudWatchMetricsEnabled = field("CloudWatchMetricsEnabled")
    ResultsPublishingEnabled = field("ResultsPublishingEnabled")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DQResultsPublishingOptionsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DQResultsPublishingOptionsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DQStopJobOnFailureOptions:
    boto3_raw_data: "type_defs.DQStopJobOnFailureOptionsTypeDef" = dataclasses.field()

    StopJobOnFailureTiming = field("StopJobOnFailureTiming")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DQStopJobOnFailureOptionsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DQStopJobOnFailureOptionsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class EncryptionAtRest:
    boto3_raw_data: "type_defs.EncryptionAtRestTypeDef" = dataclasses.field()

    CatalogEncryptionMode = field("CatalogEncryptionMode")
    SseAwsKmsKeyId = field("SseAwsKmsKeyId")
    CatalogEncryptionServiceRole = field("CatalogEncryptionServiceRole")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.EncryptionAtRestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.EncryptionAtRestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataLakePrincipal:
    boto3_raw_data: "type_defs.DataLakePrincipalTypeDef" = dataclasses.field()

    DataLakePrincipalIdentifier = field("DataLakePrincipalIdentifier")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DataLakePrincipalTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataLakePrincipalTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityAggregatedMetrics:
    boto3_raw_data: "type_defs.DataQualityAggregatedMetricsTypeDef" = (
        dataclasses.field()
    )

    TotalRowsProcessed = field("TotalRowsProcessed")
    TotalRowsPassed = field("TotalRowsPassed")
    TotalRowsFailed = field("TotalRowsFailed")
    TotalRulesProcessed = field("TotalRulesProcessed")
    TotalRulesPassed = field("TotalRulesPassed")
    TotalRulesFailed = field("TotalRulesFailed")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DataQualityAggregatedMetricsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityAggregatedMetricsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityAnalyzerResult:
    boto3_raw_data: "type_defs.DataQualityAnalyzerResultTypeDef" = dataclasses.field()

    Name = field("Name")
    Description = field("Description")
    EvaluationMessage = field("EvaluationMessage")
    EvaluatedMetrics = field("EvaluatedMetrics")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DataQualityAnalyzerResultTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityAnalyzerResultTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityEncryption:
    boto3_raw_data: "type_defs.DataQualityEncryptionTypeDef" = dataclasses.field()

    DataQualityEncryptionMode = field("DataQualityEncryptionMode")
    KmsKeyArn = field("KmsKeyArn")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DataQualityEncryptionTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityEncryptionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityEvaluationRunAdditionalRunOptions:
    boto3_raw_data: "type_defs.DataQualityEvaluationRunAdditionalRunOptionsTypeDef" = (
        dataclasses.field()
    )

    CloudWatchMetricsEnabled = field("CloudWatchMetricsEnabled")
    ResultsS3Prefix = field("ResultsS3Prefix")
    CompositeRuleEvaluationMethod = field("CompositeRuleEvaluationMethod")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.DataQualityEvaluationRunAdditionalRunOptionsTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityEvaluationRunAdditionalRunOptionsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityGlueTableOutput:
    boto3_raw_data: "type_defs.DataQualityGlueTableOutputTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    CatalogId = field("CatalogId")
    ConnectionName = field("ConnectionName")
    AdditionalOptions = field("AdditionalOptions")
    PreProcessingQuery = field("PreProcessingQuery")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DataQualityGlueTableOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityGlueTableOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityGlueTable:
    boto3_raw_data: "type_defs.DataQualityGlueTableTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    CatalogId = field("CatalogId")
    ConnectionName = field("ConnectionName")
    AdditionalOptions = field("AdditionalOptions")
    PreProcessingQuery = field("PreProcessingQuery")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DataQualityGlueTableTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityGlueTableTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityMetricValues:
    boto3_raw_data: "type_defs.DataQualityMetricValuesTypeDef" = dataclasses.field()

    ActualValue = field("ActualValue")
    ExpectedValue = field("ExpectedValue")
    LowerLimit = field("LowerLimit")
    UpperLimit = field("UpperLimit")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DataQualityMetricValuesTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityMetricValuesTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityRuleResult:
    boto3_raw_data: "type_defs.DataQualityRuleResultTypeDef" = dataclasses.field()

    Name = field("Name")
    Description = field("Description")
    EvaluationMessage = field("EvaluationMessage")
    Result = field("Result")
    EvaluatedMetrics = field("EvaluatedMetrics")
    EvaluatedRule = field("EvaluatedRule")
    RuleMetrics = field("RuleMetrics")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DataQualityRuleResultTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityRuleResultTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GlueTableOutput:
    boto3_raw_data: "type_defs.GlueTableOutputTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    CatalogId = field("CatalogId")
    ConnectionName = field("ConnectionName")
    AdditionalOptions = field("AdditionalOptions")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GlueTableOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.GlueTableOutputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DatabaseIdentifier:
    boto3_raw_data: "type_defs.DatabaseIdentifierTypeDef" = dataclasses.field()

    CatalogId = field("CatalogId")
    DatabaseName = field("DatabaseName")
    Region = field("Region")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DatabaseIdentifierTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DatabaseIdentifierTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class FederatedDatabase:
    boto3_raw_data: "type_defs.FederatedDatabaseTypeDef" = dataclasses.field()

    Identifier = field("Identifier")
    ConnectionName = field("ConnectionName")
    ConnectionType = field("ConnectionType")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.FederatedDatabaseTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.FederatedDatabaseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Datatype:
    boto3_raw_data: "type_defs.DatatypeTypeDef" = dataclasses.field()

    Id = field("Id")
    Label = field("Label")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DatatypeTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.DatatypeTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DecimalNumberOutput:
    boto3_raw_data: "type_defs.DecimalNumberOutputTypeDef" = dataclasses.field()

    UnscaledValue = field("UnscaledValue")
    Scale = field("Scale")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DecimalNumberOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DecimalNumberOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteBlueprintRequest:
    boto3_raw_data: "type_defs.DeleteBlueprintRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteBlueprintRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteBlueprintRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteCatalogRequest:
    boto3_raw_data: "type_defs.DeleteCatalogRequestTypeDef" = dataclasses.field()

    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteCatalogRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteCatalogRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteClassifierRequest:
    boto3_raw_data: "type_defs.DeleteClassifierRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteClassifierRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteClassifierRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteColumnStatisticsForPartitionRequest:
    boto3_raw_data: "type_defs.DeleteColumnStatisticsForPartitionRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    PartitionValues = field("PartitionValues")
    ColumnName = field("ColumnName")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.DeleteColumnStatisticsForPartitionRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteColumnStatisticsForPartitionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteColumnStatisticsForTableRequest:
    boto3_raw_data: "type_defs.DeleteColumnStatisticsForTableRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    ColumnName = field("ColumnName")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.DeleteColumnStatisticsForTableRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteColumnStatisticsForTableRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteColumnStatisticsTaskSettingsRequest:
    boto3_raw_data: "type_defs.DeleteColumnStatisticsTaskSettingsRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.DeleteColumnStatisticsTaskSettingsRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteColumnStatisticsTaskSettingsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteConnectionRequest:
    boto3_raw_data: "type_defs.DeleteConnectionRequestTypeDef" = dataclasses.field()

    ConnectionName = field("ConnectionName")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteConnectionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteConnectionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteCrawlerRequest:
    boto3_raw_data: "type_defs.DeleteCrawlerRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteCrawlerRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteCrawlerRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteCustomEntityTypeRequest:
    boto3_raw_data: "type_defs.DeleteCustomEntityTypeRequestTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.DeleteCustomEntityTypeRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteCustomEntityTypeRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteDataQualityRulesetRequest:
    boto3_raw_data: "type_defs.DeleteDataQualityRulesetRequestTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.DeleteDataQualityRulesetRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteDataQualityRulesetRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteDatabaseRequest:
    boto3_raw_data: "type_defs.DeleteDatabaseRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteDatabaseRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteDatabaseRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteDevEndpointRequest:
    boto3_raw_data: "type_defs.DeleteDevEndpointRequestTypeDef" = dataclasses.field()

    EndpointName = field("EndpointName")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteDevEndpointRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteDevEndpointRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteIntegrationRequest:
    boto3_raw_data: "type_defs.DeleteIntegrationRequestTypeDef" = dataclasses.field()

    IntegrationIdentifier = field("IntegrationIdentifier")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteIntegrationRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteIntegrationRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteIntegrationTablePropertiesRequest:
    boto3_raw_data: "type_defs.DeleteIntegrationTablePropertiesRequestTypeDef" = (
        dataclasses.field()
    )

    ResourceArn = field("ResourceArn")
    TableName = field("TableName")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.DeleteIntegrationTablePropertiesRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteIntegrationTablePropertiesRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteJobRequest:
    boto3_raw_data: "type_defs.DeleteJobRequestTypeDef" = dataclasses.field()

    JobName = field("JobName")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DeleteJobRequestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteJobRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteMLTransformRequest:
    boto3_raw_data: "type_defs.DeleteMLTransformRequestTypeDef" = dataclasses.field()

    TransformId = field("TransformId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteMLTransformRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteMLTransformRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeletePartitionIndexRequest:
    boto3_raw_data: "type_defs.DeletePartitionIndexRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    IndexName = field("IndexName")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeletePartitionIndexRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeletePartitionIndexRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeletePartitionRequest:
    boto3_raw_data: "type_defs.DeletePartitionRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    PartitionValues = field("PartitionValues")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeletePartitionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeletePartitionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteResourcePolicyRequest:
    boto3_raw_data: "type_defs.DeleteResourcePolicyRequestTypeDef" = dataclasses.field()

    PolicyHashCondition = field("PolicyHashCondition")
    ResourceArn = field("ResourceArn")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteResourcePolicyRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteResourcePolicyRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SchemaId:
    boto3_raw_data: "type_defs.SchemaIdTypeDef" = dataclasses.field()

    SchemaArn = field("SchemaArn")
    SchemaName = field("SchemaName")
    RegistryName = field("RegistryName")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SchemaIdTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SchemaIdTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteSecurityConfigurationRequest:
    boto3_raw_data: "type_defs.DeleteSecurityConfigurationRequestTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.DeleteSecurityConfigurationRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteSecurityConfigurationRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteSessionRequest:
    boto3_raw_data: "type_defs.DeleteSessionRequestTypeDef" = dataclasses.field()

    Id = field("Id")
    RequestOrigin = field("RequestOrigin")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteSessionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteSessionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteTableOptimizerRequest:
    boto3_raw_data: "type_defs.DeleteTableOptimizerRequestTypeDef" = dataclasses.field()

    CatalogId = field("CatalogId")
    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    Type = field("Type")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteTableOptimizerRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteTableOptimizerRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteTableRequest:
    boto3_raw_data: "type_defs.DeleteTableRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    Name = field("Name")
    CatalogId = field("CatalogId")
    TransactionId = field("TransactionId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteTableRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteTableRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteTableVersionRequest:
    boto3_raw_data: "type_defs.DeleteTableVersionRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    VersionId = field("VersionId")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteTableVersionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteTableVersionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteTriggerRequest:
    boto3_raw_data: "type_defs.DeleteTriggerRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteTriggerRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteTriggerRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteUsageProfileRequest:
    boto3_raw_data: "type_defs.DeleteUsageProfileRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteUsageProfileRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteUsageProfileRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteUserDefinedFunctionRequest:
    boto3_raw_data: "type_defs.DeleteUserDefinedFunctionRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    FunctionName = field("FunctionName")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.DeleteUserDefinedFunctionRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteUserDefinedFunctionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteWorkflowRequest:
    boto3_raw_data: "type_defs.DeleteWorkflowRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteWorkflowRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteWorkflowRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DescribeConnectionTypeRequest:
    boto3_raw_data: "type_defs.DescribeConnectionTypeRequestTypeDef" = (
        dataclasses.field()
    )

    ConnectionType = field("ConnectionType")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.DescribeConnectionTypeRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DescribeConnectionTypeRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PaginatorConfig:
    boto3_raw_data: "type_defs.PaginatorConfigTypeDef" = dataclasses.field()

    MaxItems = field("MaxItems")
    PageSize = field("PageSize")
    StartingToken = field("StartingToken")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.PaginatorConfigTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.PaginatorConfigTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DescribeEntityRequest:
    boto3_raw_data: "type_defs.DescribeEntityRequestTypeDef" = dataclasses.field()

    ConnectionName = field("ConnectionName")
    EntityName = field("EntityName")
    CatalogId = field("CatalogId")
    NextToken = field("NextToken")
    DataStoreApiVersion = field("DataStoreApiVersion")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DescribeEntityRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DescribeEntityRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Field:
    boto3_raw_data: "type_defs.FieldTypeDef" = dataclasses.field()

    FieldName = field("FieldName")
    Label = field("Label")
    Description = field("Description")
    FieldType = field("FieldType")
    IsPrimaryKey = field("IsPrimaryKey")
    IsNullable = field("IsNullable")
    IsRetrievable = field("IsRetrievable")
    IsFilterable = field("IsFilterable")
    IsPartitionable = field("IsPartitionable")
    IsCreateable = field("IsCreateable")
    IsUpdateable = field("IsUpdateable")
    IsUpsertable = field("IsUpsertable")
    IsDefaultOnCreate = field("IsDefaultOnCreate")
    SupportedValues = field("SupportedValues")
    SupportedFilterOperators = field("SupportedFilterOperators")
    ParentField = field("ParentField")
    NativeDataType = field("NativeDataType")
    CustomProperties = field("CustomProperties")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.FieldTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.FieldTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DescribeInboundIntegrationsRequest:
    boto3_raw_data: "type_defs.DescribeInboundIntegrationsRequestTypeDef" = (
        dataclasses.field()
    )

    IntegrationArn = field("IntegrationArn")
    Marker = field("Marker")
    MaxRecords = field("MaxRecords")
    TargetArn = field("TargetArn")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.DescribeInboundIntegrationsRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DescribeInboundIntegrationsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IntegrationFilter:
    boto3_raw_data: "type_defs.IntegrationFilterTypeDef" = dataclasses.field()

    Name = field("Name")
    Values = field("Values")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.IntegrationFilterTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IntegrationFilterTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DevEndpointCustomLibraries:
    boto3_raw_data: "type_defs.DevEndpointCustomLibrariesTypeDef" = dataclasses.field()

    ExtraPythonLibsS3Path = field("ExtraPythonLibsS3Path")
    ExtraJarsS3Path = field("ExtraJarsS3Path")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DevEndpointCustomLibrariesTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DevEndpointCustomLibrariesTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DirectSchemaChangePolicy:
    boto3_raw_data: "type_defs.DirectSchemaChangePolicyTypeDef" = dataclasses.field()

    EnableUpdateCatalog = field("EnableUpdateCatalog")
    UpdateBehavior = field("UpdateBehavior")
    Table = field("Table")
    Database = field("Database")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DirectSchemaChangePolicyTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DirectSchemaChangePolicyTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DropDuplicates:
    boto3_raw_data: "type_defs.DropDuplicatesTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Columns = field("Columns")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DropDuplicatesTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.DropDuplicatesTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DropFields:
    boto3_raw_data: "type_defs.DropFieldsTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Paths = field("Paths")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DropFieldsTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.DropFieldsTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class NullCheckBoxList:
    boto3_raw_data: "type_defs.NullCheckBoxListTypeDef" = dataclasses.field()

    IsEmpty = field("IsEmpty")
    IsNullString = field("IsNullString")
    IsNegOne = field("IsNegOne")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.NullCheckBoxListTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.NullCheckBoxListTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TransformConfigParameterOutput:
    boto3_raw_data: "type_defs.TransformConfigParameterOutputTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    Type = field("Type")
    ValidationRule = field("ValidationRule")
    ValidationMessage = field("ValidationMessage")
    Value = field("Value")
    ListType = field("ListType")
    IsOptional = field("IsOptional")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.TransformConfigParameterOutputTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TransformConfigParameterOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Edge:
    boto3_raw_data: "type_defs.EdgeTypeDef" = dataclasses.field()

    SourceId = field("SourceId")
    DestinationId = field("DestinationId")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.EdgeTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.EdgeTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JobBookmarksEncryption:
    boto3_raw_data: "type_defs.JobBookmarksEncryptionTypeDef" = dataclasses.field()

    JobBookmarksEncryptionMode = field("JobBookmarksEncryptionMode")
    KmsKeyArn = field("KmsKeyArn")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.JobBookmarksEncryptionTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.JobBookmarksEncryptionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3Encryption:
    boto3_raw_data: "type_defs.S3EncryptionTypeDef" = dataclasses.field()

    S3EncryptionMode = field("S3EncryptionMode")
    KmsKeyArn = field("KmsKeyArn")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.S3EncryptionTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.S3EncryptionTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Entity:
    boto3_raw_data: "type_defs.EntityTypeDef" = dataclasses.field()

    EntityName = field("EntityName")
    Label = field("Label")
    IsParentEntity = field("IsParentEntity")
    Description = field("Description")
    Category = field("Category")
    CustomProperties = field("CustomProperties")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.EntityTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.EntityTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ErrorDetails:
    boto3_raw_data: "type_defs.ErrorDetailsTypeDef" = dataclasses.field()

    ErrorCode = field("ErrorCode")
    ErrorMessage = field("ErrorMessage")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ErrorDetailsTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ErrorDetailsTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ExportLabelsTaskRunProperties:
    boto3_raw_data: "type_defs.ExportLabelsTaskRunPropertiesTypeDef" = (
        dataclasses.field()
    )

    OutputS3Path = field("OutputS3Path")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.ExportLabelsTaskRunPropertiesTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ExportLabelsTaskRunPropertiesTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class FederatedTable:
    boto3_raw_data: "type_defs.FederatedTableTypeDef" = dataclasses.field()

    Identifier = field("Identifier")
    DatabaseIdentifier = field("DatabaseIdentifier")
    ConnectionName = field("ConnectionName")
    ConnectionType = field("ConnectionType")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.FederatedTableTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.FederatedTableTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class FillMissingValues:
    boto3_raw_data: "type_defs.FillMissingValuesTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    ImputedPath = field("ImputedPath")
    FilledPath = field("FilledPath")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.FillMissingValuesTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.FillMissingValuesTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class FilterValueOutput:
    boto3_raw_data: "type_defs.FilterValueOutputTypeDef" = dataclasses.field()

    Type = field("Type")
    Value = field("Value")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.FilterValueOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.FilterValueOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class FilterValue:
    boto3_raw_data: "type_defs.FilterValueTypeDef" = dataclasses.field()

    Type = field("Type")
    Value = field("Value")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.FilterValueTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.FilterValueTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class FindMatchesParameters:
    boto3_raw_data: "type_defs.FindMatchesParametersTypeDef" = dataclasses.field()

    PrimaryKeyColumnName = field("PrimaryKeyColumnName")
    PrecisionRecallTradeoff = field("PrecisionRecallTradeoff")
    AccuracyCostTradeoff = field("AccuracyCostTradeoff")
    EnforceProvidedLabels = field("EnforceProvidedLabels")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.FindMatchesParametersTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.FindMatchesParametersTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class FindMatchesTaskRunProperties:
    boto3_raw_data: "type_defs.FindMatchesTaskRunPropertiesTypeDef" = (
        dataclasses.field()
    )

    JobId = field("JobId")
    JobName = field("JobName")
    JobRunId = field("JobRunId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.FindMatchesTaskRunPropertiesTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.FindMatchesTaskRunPropertiesTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetBlueprintRequest:
    boto3_raw_data: "type_defs.GetBlueprintRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    IncludeBlueprint = field("IncludeBlueprint")
    IncludeParameterSpec = field("IncludeParameterSpec")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetBlueprintRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetBlueprintRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetBlueprintRunRequest:
    boto3_raw_data: "type_defs.GetBlueprintRunRequestTypeDef" = dataclasses.field()

    BlueprintName = field("BlueprintName")
    RunId = field("RunId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetBlueprintRunRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetBlueprintRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetBlueprintRunsRequest:
    boto3_raw_data: "type_defs.GetBlueprintRunsRequestTypeDef" = dataclasses.field()

    BlueprintName = field("BlueprintName")
    NextToken = field("NextToken")
    MaxResults = field("MaxResults")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetBlueprintRunsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetBlueprintRunsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetCatalogImportStatusRequest:
    boto3_raw_data: "type_defs.GetCatalogImportStatusRequestTypeDef" = (
        dataclasses.field()
    )

    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetCatalogImportStatusRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetCatalogImportStatusRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetCatalogRequest:
    boto3_raw_data: "type_defs.GetCatalogRequestTypeDef" = dataclasses.field()

    CatalogId = field("CatalogId")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetCatalogRequestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetCatalogRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetCatalogsRequest:
    boto3_raw_data: "type_defs.GetCatalogsRequestTypeDef" = dataclasses.field()

    ParentCatalogId = field("ParentCatalogId")
    NextToken = field("NextToken")
    MaxResults = field("MaxResults")
    Recursive = field("Recursive")
    IncludeRoot = field("IncludeRoot")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetCatalogsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetCatalogsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetClassifierRequest:
    boto3_raw_data: "type_defs.GetClassifierRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetClassifierRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetClassifierRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetClassifiersRequest:
    boto3_raw_data: "type_defs.GetClassifiersRequestTypeDef" = dataclasses.field()

    MaxResults = field("MaxResults")
    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetClassifiersRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetClassifiersRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetColumnStatisticsForPartitionRequest:
    boto3_raw_data: "type_defs.GetColumnStatisticsForPartitionRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    PartitionValues = field("PartitionValues")
    ColumnNames = field("ColumnNames")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetColumnStatisticsForPartitionRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetColumnStatisticsForPartitionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetColumnStatisticsForTableRequest:
    boto3_raw_data: "type_defs.GetColumnStatisticsForTableRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    ColumnNames = field("ColumnNames")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetColumnStatisticsForTableRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetColumnStatisticsForTableRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetColumnStatisticsTaskRunRequest:
    boto3_raw_data: "type_defs.GetColumnStatisticsTaskRunRequestTypeDef" = (
        dataclasses.field()
    )

    ColumnStatisticsTaskRunId = field("ColumnStatisticsTaskRunId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetColumnStatisticsTaskRunRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetColumnStatisticsTaskRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetColumnStatisticsTaskRunsRequest:
    boto3_raw_data: "type_defs.GetColumnStatisticsTaskRunsRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    MaxResults = field("MaxResults")
    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetColumnStatisticsTaskRunsRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetColumnStatisticsTaskRunsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetColumnStatisticsTaskSettingsRequest:
    boto3_raw_data: "type_defs.GetColumnStatisticsTaskSettingsRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetColumnStatisticsTaskSettingsRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetColumnStatisticsTaskSettingsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetConnectionRequest:
    boto3_raw_data: "type_defs.GetConnectionRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    CatalogId = field("CatalogId")
    HidePassword = field("HidePassword")
    ApplyOverrideForComputeEnvironment = field("ApplyOverrideForComputeEnvironment")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetConnectionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetConnectionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetConnectionsFilter:
    boto3_raw_data: "type_defs.GetConnectionsFilterTypeDef" = dataclasses.field()

    MatchCriteria = field("MatchCriteria")
    ConnectionType = field("ConnectionType")
    ConnectionSchemaVersion = field("ConnectionSchemaVersion")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetConnectionsFilterTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetConnectionsFilterTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetCrawlerMetricsRequest:
    boto3_raw_data: "type_defs.GetCrawlerMetricsRequestTypeDef" = dataclasses.field()

    CrawlerNameList = field("CrawlerNameList")
    MaxResults = field("MaxResults")
    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetCrawlerMetricsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetCrawlerMetricsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetCrawlerRequest:
    boto3_raw_data: "type_defs.GetCrawlerRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetCrawlerRequestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetCrawlerRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetCrawlersRequest:
    boto3_raw_data: "type_defs.GetCrawlersRequestTypeDef" = dataclasses.field()

    MaxResults = field("MaxResults")
    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetCrawlersRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetCrawlersRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetCustomEntityTypeRequest:
    boto3_raw_data: "type_defs.GetCustomEntityTypeRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetCustomEntityTypeRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetCustomEntityTypeRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDataCatalogEncryptionSettingsRequest:
    boto3_raw_data: "type_defs.GetDataCatalogEncryptionSettingsRequestTypeDef" = (
        dataclasses.field()
    )

    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetDataCatalogEncryptionSettingsRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDataCatalogEncryptionSettingsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDataQualityModelRequest:
    boto3_raw_data: "type_defs.GetDataQualityModelRequestTypeDef" = dataclasses.field()

    ProfileId = field("ProfileId")
    StatisticId = field("StatisticId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetDataQualityModelRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDataQualityModelRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDataQualityModelResultRequest:
    boto3_raw_data: "type_defs.GetDataQualityModelResultRequestTypeDef" = (
        dataclasses.field()
    )

    StatisticId = field("StatisticId")
    ProfileId = field("ProfileId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetDataQualityModelResultRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDataQualityModelResultRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StatisticModelResult:
    boto3_raw_data: "type_defs.StatisticModelResultTypeDef" = dataclasses.field()

    LowerBound = field("LowerBound")
    UpperBound = field("UpperBound")
    PredictedValue = field("PredictedValue")
    ActualValue = field("ActualValue")
    Date = field("Date")
    InclusionAnnotation = field("InclusionAnnotation")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StatisticModelResultTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StatisticModelResultTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDataQualityResultRequest:
    boto3_raw_data: "type_defs.GetDataQualityResultRequestTypeDef" = dataclasses.field()

    ResultId = field("ResultId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetDataQualityResultRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDataQualityResultRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDataQualityRuleRecommendationRunRequest:
    boto3_raw_data: "type_defs.GetDataQualityRuleRecommendationRunRequestTypeDef" = (
        dataclasses.field()
    )

    RunId = field("RunId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetDataQualityRuleRecommendationRunRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDataQualityRuleRecommendationRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDataQualityRulesetEvaluationRunRequest:
    boto3_raw_data: "type_defs.GetDataQualityRulesetEvaluationRunRequestTypeDef" = (
        dataclasses.field()
    )

    RunId = field("RunId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetDataQualityRulesetEvaluationRunRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDataQualityRulesetEvaluationRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDataQualityRulesetRequest:
    boto3_raw_data: "type_defs.GetDataQualityRulesetRequestTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetDataQualityRulesetRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDataQualityRulesetRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDatabaseRequest:
    boto3_raw_data: "type_defs.GetDatabaseRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetDatabaseRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDatabaseRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDatabasesRequest:
    boto3_raw_data: "type_defs.GetDatabasesRequestTypeDef" = dataclasses.field()

    CatalogId = field("CatalogId")
    NextToken = field("NextToken")
    MaxResults = field("MaxResults")
    ResourceShareType = field("ResourceShareType")
    AttributesToGet = field("AttributesToGet")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetDatabasesRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDatabasesRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDataflowGraphRequest:
    boto3_raw_data: "type_defs.GetDataflowGraphRequestTypeDef" = dataclasses.field()

    PythonScript = field("PythonScript")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetDataflowGraphRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDataflowGraphRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDevEndpointRequest:
    boto3_raw_data: "type_defs.GetDevEndpointRequestTypeDef" = dataclasses.field()

    EndpointName = field("EndpointName")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetDevEndpointRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDevEndpointRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDevEndpointsRequest:
    boto3_raw_data: "type_defs.GetDevEndpointsRequestTypeDef" = dataclasses.field()

    MaxResults = field("MaxResults")
    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetDevEndpointsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDevEndpointsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetEntityRecordsRequest:
    boto3_raw_data: "type_defs.GetEntityRecordsRequestTypeDef" = dataclasses.field()

    EntityName = field("EntityName")
    Limit = field("Limit")
    ConnectionName = field("ConnectionName")
    CatalogId = field("CatalogId")
    NextToken = field("NextToken")
    DataStoreApiVersion = field("DataStoreApiVersion")
    ConnectionOptions = field("ConnectionOptions")
    FilterPredicate = field("FilterPredicate")
    OrderBy = field("OrderBy")
    SelectedFields = field("SelectedFields")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetEntityRecordsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetEntityRecordsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetIntegrationResourcePropertyRequest:
    boto3_raw_data: "type_defs.GetIntegrationResourcePropertyRequestTypeDef" = (
        dataclasses.field()
    )

    ResourceArn = field("ResourceArn")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetIntegrationResourcePropertyRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetIntegrationResourcePropertyRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetIntegrationTablePropertiesRequest:
    boto3_raw_data: "type_defs.GetIntegrationTablePropertiesRequestTypeDef" = (
        dataclasses.field()
    )

    ResourceArn = field("ResourceArn")
    TableName = field("TableName")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetIntegrationTablePropertiesRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetIntegrationTablePropertiesRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SourceTableConfigOutput:
    boto3_raw_data: "type_defs.SourceTableConfigOutputTypeDef" = dataclasses.field()

    Fields = field("Fields")
    FilterPredicate = field("FilterPredicate")
    PrimaryKey = field("PrimaryKey")
    RecordUpdateField = field("RecordUpdateField")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SourceTableConfigOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SourceTableConfigOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetJobBookmarkRequest:
    boto3_raw_data: "type_defs.GetJobBookmarkRequestTypeDef" = dataclasses.field()

    JobName = field("JobName")
    RunId = field("RunId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetJobBookmarkRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetJobBookmarkRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JobBookmarkEntry:
    boto3_raw_data: "type_defs.JobBookmarkEntryTypeDef" = dataclasses.field()

    JobName = field("JobName")
    Version = field("Version")
    Run = field("Run")
    Attempt = field("Attempt")
    PreviousRunId = field("PreviousRunId")
    RunId = field("RunId")
    JobBookmark = field("JobBookmark")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.JobBookmarkEntryTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.JobBookmarkEntryTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetJobRequest:
    boto3_raw_data: "type_defs.GetJobRequestTypeDef" = dataclasses.field()

    JobName = field("JobName")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetJobRequestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.GetJobRequestTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetJobRunRequest:
    boto3_raw_data: "type_defs.GetJobRunRequestTypeDef" = dataclasses.field()

    JobName = field("JobName")
    RunId = field("RunId")
    PredecessorsIncluded = field("PredecessorsIncluded")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetJobRunRequestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetJobRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetJobRunsRequest:
    boto3_raw_data: "type_defs.GetJobRunsRequestTypeDef" = dataclasses.field()

    JobName = field("JobName")
    NextToken = field("NextToken")
    MaxResults = field("MaxResults")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetJobRunsRequestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetJobRunsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetJobsRequest:
    boto3_raw_data: "type_defs.GetJobsRequestTypeDef" = dataclasses.field()

    NextToken = field("NextToken")
    MaxResults = field("MaxResults")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetJobsRequestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.GetJobsRequestTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetMLTaskRunRequest:
    boto3_raw_data: "type_defs.GetMLTaskRunRequestTypeDef" = dataclasses.field()

    TransformId = field("TransformId")
    TaskRunId = field("TaskRunId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetMLTaskRunRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetMLTaskRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TaskRunSortCriteria:
    boto3_raw_data: "type_defs.TaskRunSortCriteriaTypeDef" = dataclasses.field()

    Column = field("Column")
    SortDirection = field("SortDirection")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.TaskRunSortCriteriaTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TaskRunSortCriteriaTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetMLTransformRequest:
    boto3_raw_data: "type_defs.GetMLTransformRequestTypeDef" = dataclasses.field()

    TransformId = field("TransformId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetMLTransformRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetMLTransformRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SchemaColumn:
    boto3_raw_data: "type_defs.SchemaColumnTypeDef" = dataclasses.field()

    Name = field("Name")
    DataType = field("DataType")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SchemaColumnTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SchemaColumnTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TransformSortCriteria:
    boto3_raw_data: "type_defs.TransformSortCriteriaTypeDef" = dataclasses.field()

    Column = field("Column")
    SortDirection = field("SortDirection")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.TransformSortCriteriaTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TransformSortCriteriaTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class MappingEntry:
    boto3_raw_data: "type_defs.MappingEntryTypeDef" = dataclasses.field()

    SourceTable = field("SourceTable")
    SourcePath = field("SourcePath")
    SourceType = field("SourceType")
    TargetTable = field("TargetTable")
    TargetPath = field("TargetPath")
    TargetType = field("TargetType")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.MappingEntryTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.MappingEntryTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetPartitionIndexesRequest:
    boto3_raw_data: "type_defs.GetPartitionIndexesRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    CatalogId = field("CatalogId")
    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetPartitionIndexesRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetPartitionIndexesRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetPartitionRequest:
    boto3_raw_data: "type_defs.GetPartitionRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    PartitionValues = field("PartitionValues")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetPartitionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetPartitionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Segment:
    boto3_raw_data: "type_defs.SegmentTypeDef" = dataclasses.field()

    SegmentNumber = field("SegmentNumber")
    TotalSegments = field("TotalSegments")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SegmentTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SegmentTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetResourcePoliciesRequest:
    boto3_raw_data: "type_defs.GetResourcePoliciesRequestTypeDef" = dataclasses.field()

    NextToken = field("NextToken")
    MaxResults = field("MaxResults")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetResourcePoliciesRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetResourcePoliciesRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GluePolicy:
    boto3_raw_data: "type_defs.GluePolicyTypeDef" = dataclasses.field()

    PolicyInJson = field("PolicyInJson")
    PolicyHash = field("PolicyHash")
    CreateTime = field("CreateTime")
    UpdateTime = field("UpdateTime")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GluePolicyTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.GluePolicyTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetResourcePolicyRequest:
    boto3_raw_data: "type_defs.GetResourcePolicyRequestTypeDef" = dataclasses.field()

    ResourceArn = field("ResourceArn")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetResourcePolicyRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetResourcePolicyRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SchemaVersionNumber:
    boto3_raw_data: "type_defs.SchemaVersionNumberTypeDef" = dataclasses.field()

    LatestVersion = field("LatestVersion")
    VersionNumber = field("VersionNumber")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SchemaVersionNumberTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SchemaVersionNumberTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetSecurityConfigurationRequest:
    boto3_raw_data: "type_defs.GetSecurityConfigurationRequestTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetSecurityConfigurationRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetSecurityConfigurationRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetSecurityConfigurationsRequest:
    boto3_raw_data: "type_defs.GetSecurityConfigurationsRequestTypeDef" = (
        dataclasses.field()
    )

    MaxResults = field("MaxResults")
    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetSecurityConfigurationsRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetSecurityConfigurationsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetSessionRequest:
    boto3_raw_data: "type_defs.GetSessionRequestTypeDef" = dataclasses.field()

    Id = field("Id")
    RequestOrigin = field("RequestOrigin")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetSessionRequestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetSessionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetStatementRequest:
    boto3_raw_data: "type_defs.GetStatementRequestTypeDef" = dataclasses.field()

    SessionId = field("SessionId")
    Id = field("Id")
    RequestOrigin = field("RequestOrigin")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetStatementRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetStatementRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTableOptimizerRequest:
    boto3_raw_data: "type_defs.GetTableOptimizerRequestTypeDef" = dataclasses.field()

    CatalogId = field("CatalogId")
    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    Type = field("Type")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetTableOptimizerRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetTableOptimizerRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTableVersionRequest:
    boto3_raw_data: "type_defs.GetTableVersionRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    CatalogId = field("CatalogId")
    VersionId = field("VersionId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetTableVersionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetTableVersionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTableVersionsRequest:
    boto3_raw_data: "type_defs.GetTableVersionsRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    CatalogId = field("CatalogId")
    NextToken = field("NextToken")
    MaxResults = field("MaxResults")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetTableVersionsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetTableVersionsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTagsRequest:
    boto3_raw_data: "type_defs.GetTagsRequestTypeDef" = dataclasses.field()

    ResourceArn = field("ResourceArn")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetTagsRequestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.GetTagsRequestTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTriggerRequest:
    boto3_raw_data: "type_defs.GetTriggerRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetTriggerRequestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetTriggerRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTriggersRequest:
    boto3_raw_data: "type_defs.GetTriggersRequestTypeDef" = dataclasses.field()

    NextToken = field("NextToken")
    DependentJobName = field("DependentJobName")
    MaxResults = field("MaxResults")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetTriggersRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetTriggersRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SupportedDialect:
    boto3_raw_data: "type_defs.SupportedDialectTypeDef" = dataclasses.field()

    Dialect = field("Dialect")
    DialectVersion = field("DialectVersion")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SupportedDialectTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SupportedDialectTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetUsageProfileRequest:
    boto3_raw_data: "type_defs.GetUsageProfileRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetUsageProfileRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetUsageProfileRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetUserDefinedFunctionRequest:
    boto3_raw_data: "type_defs.GetUserDefinedFunctionRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    FunctionName = field("FunctionName")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetUserDefinedFunctionRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetUserDefinedFunctionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetUserDefinedFunctionsRequest:
    boto3_raw_data: "type_defs.GetUserDefinedFunctionsRequestTypeDef" = (
        dataclasses.field()
    )

    Pattern = field("Pattern")
    CatalogId = field("CatalogId")
    DatabaseName = field("DatabaseName")
    NextToken = field("NextToken")
    MaxResults = field("MaxResults")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetUserDefinedFunctionsRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetUserDefinedFunctionsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetWorkflowRequest:
    boto3_raw_data: "type_defs.GetWorkflowRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    IncludeGraph = field("IncludeGraph")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetWorkflowRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetWorkflowRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetWorkflowRunPropertiesRequest:
    boto3_raw_data: "type_defs.GetWorkflowRunPropertiesRequestTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    RunId = field("RunId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetWorkflowRunPropertiesRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetWorkflowRunPropertiesRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetWorkflowRunRequest:
    boto3_raw_data: "type_defs.GetWorkflowRunRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    RunId = field("RunId")
    IncludeGraph = field("IncludeGraph")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetWorkflowRunRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetWorkflowRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetWorkflowRunsRequest:
    boto3_raw_data: "type_defs.GetWorkflowRunsRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    IncludeGraph = field("IncludeGraph")
    NextToken = field("NextToken")
    MaxResults = field("MaxResults")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetWorkflowRunsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetWorkflowRunsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GlueStudioSchemaColumn:
    boto3_raw_data: "type_defs.GlueStudioSchemaColumnTypeDef" = dataclasses.field()

    Name = field("Name")
    Type = field("Type")
    GlueStudioType = field("GlueStudioType")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GlueStudioSchemaColumnTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GlueStudioSchemaColumnTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GlueTable:
    boto3_raw_data: "type_defs.GlueTableTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    CatalogId = field("CatalogId")
    ConnectionName = field("ConnectionName")
    AdditionalOptions = field("AdditionalOptions")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GlueTableTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.GlueTableTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3SourceAdditionalOptions:
    boto3_raw_data: "type_defs.S3SourceAdditionalOptionsTypeDef" = dataclasses.field()

    BoundedSize = field("BoundedSize")
    BoundedFiles = field("BoundedFiles")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3SourceAdditionalOptionsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3SourceAdditionalOptionsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IcebergOrphanFileDeletionConfiguration:
    boto3_raw_data: "type_defs.IcebergOrphanFileDeletionConfigurationTypeDef" = (
        dataclasses.field()
    )

    orphanFileRetentionPeriodInDays = field("orphanFileRetentionPeriodInDays")
    location = field("location")
    runRateInHours = field("runRateInHours")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.IcebergOrphanFileDeletionConfigurationTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IcebergOrphanFileDeletionConfigurationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IcebergOrphanFileDeletionMetrics:
    boto3_raw_data: "type_defs.IcebergOrphanFileDeletionMetricsTypeDef" = (
        dataclasses.field()
    )

    NumberOfOrphanFilesDeleted = field("NumberOfOrphanFilesDeleted")
    DpuHours = field("DpuHours")
    NumberOfDpus = field("NumberOfDpus")
    JobDurationInHour = field("JobDurationInHour")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.IcebergOrphanFileDeletionMetricsTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IcebergOrphanFileDeletionMetricsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IcebergPartitionField:
    boto3_raw_data: "type_defs.IcebergPartitionFieldTypeDef" = dataclasses.field()

    SourceId = field("SourceId")
    Transform = field("Transform")
    Name = field("Name")
    FieldId = field("FieldId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.IcebergPartitionFieldTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IcebergPartitionFieldTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IcebergRetentionConfiguration:
    boto3_raw_data: "type_defs.IcebergRetentionConfigurationTypeDef" = (
        dataclasses.field()
    )

    snapshotRetentionPeriodInDays = field("snapshotRetentionPeriodInDays")
    numberOfSnapshotsToRetain = field("numberOfSnapshotsToRetain")
    cleanExpiredFiles = field("cleanExpiredFiles")
    runRateInHours = field("runRateInHours")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.IcebergRetentionConfigurationTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IcebergRetentionConfigurationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IcebergRetentionMetrics:
    boto3_raw_data: "type_defs.IcebergRetentionMetricsTypeDef" = dataclasses.field()

    NumberOfDataFilesDeleted = field("NumberOfDataFilesDeleted")
    NumberOfManifestFilesDeleted = field("NumberOfManifestFilesDeleted")
    NumberOfManifestListsDeleted = field("NumberOfManifestListsDeleted")
    DpuHours = field("DpuHours")
    NumberOfDpus = field("NumberOfDpus")
    JobDurationInHour = field("JobDurationInHour")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.IcebergRetentionMetricsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IcebergRetentionMetricsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IcebergStructField:
    boto3_raw_data: "type_defs.IcebergStructFieldTypeDef" = dataclasses.field()

    Id = field("Id")
    Name = field("Name")
    Type = field("Type")
    Required = field("Required")
    Doc = field("Doc")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.IcebergStructFieldTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IcebergStructFieldTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IcebergSortField:
    boto3_raw_data: "type_defs.IcebergSortFieldTypeDef" = dataclasses.field()

    SourceId = field("SourceId")
    Transform = field("Transform")
    Direction = field("Direction")
    NullOrder = field("NullOrder")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.IcebergSortFieldTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IcebergSortFieldTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ImportCatalogToGlueRequest:
    boto3_raw_data: "type_defs.ImportCatalogToGlueRequestTypeDef" = dataclasses.field()

    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ImportCatalogToGlueRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ImportCatalogToGlueRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ImportLabelsTaskRunProperties:
    boto3_raw_data: "type_defs.ImportLabelsTaskRunPropertiesTypeDef" = (
        dataclasses.field()
    )

    InputS3Path = field("InputS3Path")
    Replace = field("Replace")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.ImportLabelsTaskRunPropertiesTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ImportLabelsTaskRunPropertiesTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IntegrationConfig:
    boto3_raw_data: "type_defs.IntegrationConfigTypeDef" = dataclasses.field()

    RefreshInterval = field("RefreshInterval")
    SourceProperties = field("SourceProperties")
    ContinuousSync = field("ContinuousSync")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.IntegrationConfigTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IntegrationConfigTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IntegrationPartition:
    boto3_raw_data: "type_defs.IntegrationPartitionTypeDef" = dataclasses.field()

    FieldName = field("FieldName")
    FunctionSpec = field("FunctionSpec")
    ConversionSpec = field("ConversionSpec")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.IntegrationPartitionTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IntegrationPartitionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JDBCConnectorOptionsOutput:
    boto3_raw_data: "type_defs.JDBCConnectorOptionsOutputTypeDef" = dataclasses.field()

    FilterPredicate = field("FilterPredicate")
    PartitionColumn = field("PartitionColumn")
    LowerBound = field("LowerBound")
    UpperBound = field("UpperBound")
    NumPartitions = field("NumPartitions")
    JobBookmarkKeys = field("JobBookmarkKeys")
    JobBookmarkKeysSortOrder = field("JobBookmarkKeysSortOrder")
    DataTypeMapping = field("DataTypeMapping")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.JDBCConnectorOptionsOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.JDBCConnectorOptionsOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JDBCConnectorOptions:
    boto3_raw_data: "type_defs.JDBCConnectorOptionsTypeDef" = dataclasses.field()

    FilterPredicate = field("FilterPredicate")
    PartitionColumn = field("PartitionColumn")
    LowerBound = field("LowerBound")
    UpperBound = field("UpperBound")
    NumPartitions = field("NumPartitions")
    JobBookmarkKeys = field("JobBookmarkKeys")
    JobBookmarkKeysSortOrder = field("JobBookmarkKeysSortOrder")
    DataTypeMapping = field("DataTypeMapping")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.JDBCConnectorOptionsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.JDBCConnectorOptionsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Predecessor:
    boto3_raw_data: "type_defs.PredecessorTypeDef" = dataclasses.field()

    JobName = field("JobName")
    RunId = field("RunId")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.PredecessorTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.PredecessorTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JoinColumnOutput:
    boto3_raw_data: "type_defs.JoinColumnOutputTypeDef" = dataclasses.field()

    From = field("From")
    Keys = field("Keys")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.JoinColumnOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.JoinColumnOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JoinColumn:
    boto3_raw_data: "type_defs.JoinColumnTypeDef" = dataclasses.field()

    From = field("From")
    Keys = field("Keys")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.JoinColumnTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.JoinColumnTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class KeySchemaElement:
    boto3_raw_data: "type_defs.KeySchemaElementTypeDef" = dataclasses.field()

    Name = field("Name")
    Type = field("Type")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.KeySchemaElementTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.KeySchemaElementTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class LabelingSetGenerationTaskRunProperties:
    boto3_raw_data: "type_defs.LabelingSetGenerationTaskRunPropertiesTypeDef" = (
        dataclasses.field()
    )

    OutputS3Path = field("OutputS3Path")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.LabelingSetGenerationTaskRunPropertiesTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.LabelingSetGenerationTaskRunPropertiesTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListBlueprintsRequest:
    boto3_raw_data: "type_defs.ListBlueprintsRequestTypeDef" = dataclasses.field()

    NextToken = field("NextToken")
    MaxResults = field("MaxResults")
    Tags = field("Tags")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListBlueprintsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListBlueprintsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListColumnStatisticsTaskRunsRequest:
    boto3_raw_data: "type_defs.ListColumnStatisticsTaskRunsRequestTypeDef" = (
        dataclasses.field()
    )

    MaxResults = field("MaxResults")
    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.ListColumnStatisticsTaskRunsRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListColumnStatisticsTaskRunsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListConnectionTypesRequest:
    boto3_raw_data: "type_defs.ListConnectionTypesRequestTypeDef" = dataclasses.field()

    MaxResults = field("MaxResults")
    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListConnectionTypesRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListConnectionTypesRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListCrawlersRequest:
    boto3_raw_data: "type_defs.ListCrawlersRequestTypeDef" = dataclasses.field()

    MaxResults = field("MaxResults")
    NextToken = field("NextToken")
    Tags = field("Tags")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListCrawlersRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListCrawlersRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListCustomEntityTypesRequest:
    boto3_raw_data: "type_defs.ListCustomEntityTypesRequestTypeDef" = (
        dataclasses.field()
    )

    NextToken = field("NextToken")
    MaxResults = field("MaxResults")
    Tags = field("Tags")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListCustomEntityTypesRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListCustomEntityTypesRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListDevEndpointsRequest:
    boto3_raw_data: "type_defs.ListDevEndpointsRequestTypeDef" = dataclasses.field()

    NextToken = field("NextToken")
    MaxResults = field("MaxResults")
    Tags = field("Tags")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListDevEndpointsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListDevEndpointsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListEntitiesRequest:
    boto3_raw_data: "type_defs.ListEntitiesRequestTypeDef" = dataclasses.field()

    ConnectionName = field("ConnectionName")
    CatalogId = field("CatalogId")
    ParentEntityName = field("ParentEntityName")
    NextToken = field("NextToken")
    DataStoreApiVersion = field("DataStoreApiVersion")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListEntitiesRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListEntitiesRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListJobsRequest:
    boto3_raw_data: "type_defs.ListJobsRequestTypeDef" = dataclasses.field()

    NextToken = field("NextToken")
    MaxResults = field("MaxResults")
    Tags = field("Tags")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ListJobsRequestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ListJobsRequestTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListRegistriesInput:
    boto3_raw_data: "type_defs.ListRegistriesInputTypeDef" = dataclasses.field()

    MaxResults = field("MaxResults")
    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListRegistriesInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListRegistriesInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RegistryListItem:
    boto3_raw_data: "type_defs.RegistryListItemTypeDef" = dataclasses.field()

    RegistryName = field("RegistryName")
    RegistryArn = field("RegistryArn")
    Description = field("Description")
    Status = field("Status")
    CreatedTime = field("CreatedTime")
    UpdatedTime = field("UpdatedTime")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.RegistryListItemTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.RegistryListItemTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SchemaVersionListItem:
    boto3_raw_data: "type_defs.SchemaVersionListItemTypeDef" = dataclasses.field()

    SchemaArn = field("SchemaArn")
    SchemaVersionId = field("SchemaVersionId")
    VersionNumber = field("VersionNumber")
    Status = field("Status")
    CreatedTime = field("CreatedTime")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SchemaVersionListItemTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SchemaVersionListItemTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SchemaListItem:
    boto3_raw_data: "type_defs.SchemaListItemTypeDef" = dataclasses.field()

    RegistryName = field("RegistryName")
    SchemaName = field("SchemaName")
    SchemaArn = field("SchemaArn")
    Description = field("Description")
    SchemaStatus = field("SchemaStatus")
    CreatedTime = field("CreatedTime")
    UpdatedTime = field("UpdatedTime")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SchemaListItemTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SchemaListItemTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListSessionsRequest:
    boto3_raw_data: "type_defs.ListSessionsRequestTypeDef" = dataclasses.field()

    NextToken = field("NextToken")
    MaxResults = field("MaxResults")
    Tags = field("Tags")
    RequestOrigin = field("RequestOrigin")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListSessionsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListSessionsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListStatementsRequest:
    boto3_raw_data: "type_defs.ListStatementsRequestTypeDef" = dataclasses.field()

    SessionId = field("SessionId")
    RequestOrigin = field("RequestOrigin")
    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListStatementsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListStatementsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListTableOptimizerRunsRequest:
    boto3_raw_data: "type_defs.ListTableOptimizerRunsRequestTypeDef" = (
        dataclasses.field()
    )

    CatalogId = field("CatalogId")
    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    Type = field("Type")
    MaxResults = field("MaxResults")
    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.ListTableOptimizerRunsRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListTableOptimizerRunsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListTriggersRequest:
    boto3_raw_data: "type_defs.ListTriggersRequestTypeDef" = dataclasses.field()

    NextToken = field("NextToken")
    DependentJobName = field("DependentJobName")
    MaxResults = field("MaxResults")
    Tags = field("Tags")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListTriggersRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListTriggersRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListUsageProfilesRequest:
    boto3_raw_data: "type_defs.ListUsageProfilesRequestTypeDef" = dataclasses.field()

    NextToken = field("NextToken")
    MaxResults = field("MaxResults")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListUsageProfilesRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListUsageProfilesRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UsageProfileDefinition:
    boto3_raw_data: "type_defs.UsageProfileDefinitionTypeDef" = dataclasses.field()

    Name = field("Name")
    Description = field("Description")
    CreatedOn = field("CreatedOn")
    LastModifiedOn = field("LastModifiedOn")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UsageProfileDefinitionTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UsageProfileDefinitionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListWorkflowsRequest:
    boto3_raw_data: "type_defs.ListWorkflowsRequestTypeDef" = dataclasses.field()

    NextToken = field("NextToken")
    MaxResults = field("MaxResults")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListWorkflowsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListWorkflowsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class MLUserDataEncryption:
    boto3_raw_data: "type_defs.MLUserDataEncryptionTypeDef" = dataclasses.field()

    MlUserDataEncryptionMode = field("MlUserDataEncryptionMode")
    KmsKeyId = field("KmsKeyId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.MLUserDataEncryptionTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.MLUserDataEncryptionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Mapping:
    boto3_raw_data: "type_defs.MappingTypeDef" = dataclasses.field()

    ToKey = field("ToKey")
    FromPath = field("FromPath")
    FromType = field("FromType")
    ToType = field("ToType")
    Dropped = field("Dropped")
    Children = field("Children")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.MappingTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.MappingTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Merge:
    boto3_raw_data: "type_defs.MergeTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Source = field("Source")
    PrimaryKeys = field("PrimaryKeys")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.MergeTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.MergeTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class OtherMetadataValueListItem:
    boto3_raw_data: "type_defs.OtherMetadataValueListItemTypeDef" = dataclasses.field()

    MetadataValue = field("MetadataValue")
    CreatedTime = field("CreatedTime")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.OtherMetadataValueListItemTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.OtherMetadataValueListItemTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class MetadataKeyValuePair:
    boto3_raw_data: "type_defs.MetadataKeyValuePairTypeDef" = dataclasses.field()

    MetadataKey = field("MetadataKey")
    MetadataValue = field("MetadataValue")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.MetadataKeyValuePairTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.MetadataKeyValuePairTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class MicrosoftSQLServerCatalogTarget:
    boto3_raw_data: "type_defs.MicrosoftSQLServerCatalogTargetTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    Inputs = field("Inputs")
    Database = field("Database")
    Table = field("Table")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.MicrosoftSQLServerCatalogTargetTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.MicrosoftSQLServerCatalogTargetTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class MySQLCatalogTarget:
    boto3_raw_data: "type_defs.MySQLCatalogTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Database = field("Database")
    Table = field("Table")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.MySQLCatalogTargetTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.MySQLCatalogTargetTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class OAuth2ClientApplication:
    boto3_raw_data: "type_defs.OAuth2ClientApplicationTypeDef" = dataclasses.field()

    UserManagedClientApplicationClientId = field("UserManagedClientApplicationClientId")
    AWSManagedClientApplicationReference = field("AWSManagedClientApplicationReference")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.OAuth2ClientApplicationTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.OAuth2ClientApplicationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class OAuth2Credentials:
    boto3_raw_data: "type_defs.OAuth2CredentialsTypeDef" = dataclasses.field()

    UserManagedClientApplicationClientSecret = field(
        "UserManagedClientApplicationClientSecret"
    )
    AccessToken = field("AccessToken")
    RefreshToken = field("RefreshToken")
    JwtToken = field("JwtToken")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.OAuth2CredentialsTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.OAuth2CredentialsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class OracleSQLCatalogTarget:
    boto3_raw_data: "type_defs.OracleSQLCatalogTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Database = field("Database")
    Table = field("Table")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.OracleSQLCatalogTargetTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.OracleSQLCatalogTargetTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Order:
    boto3_raw_data: "type_defs.OrderTypeDef" = dataclasses.field()

    Column = field("Column")
    SortOrder = field("SortOrder")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.OrderTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.OrderTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PIIDetection:
    boto3_raw_data: "type_defs.PIIDetectionTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    PiiType = field("PiiType")
    EntityTypesToDetect = field("EntityTypesToDetect")
    OutputColumnName = field("OutputColumnName")
    SampleFraction = field("SampleFraction")
    ThresholdFraction = field("ThresholdFraction")
    MaskValue = field("MaskValue")
    RedactText = field("RedactText")
    RedactChar = field("RedactChar")
    MatchPattern = field("MatchPattern")
    NumLeftCharsToExclude = field("NumLeftCharsToExclude")
    NumRightCharsToExclude = field("NumRightCharsToExclude")
    DetectionParameters = field("DetectionParameters")
    DetectionSensitivity = field("DetectionSensitivity")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.PIIDetectionTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.PIIDetectionTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PartitionValueList:
    boto3_raw_data: "type_defs.PartitionValueListTypeDef" = dataclasses.field()

    Values = field("Values")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.PartitionValueListTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PartitionValueListTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PhysicalConnectionRequirements:
    boto3_raw_data: "type_defs.PhysicalConnectionRequirementsTypeDef" = (
        dataclasses.field()
    )

    SubnetId = field("SubnetId")
    SecurityGroupIdList = field("SecurityGroupIdList")
    AvailabilityZone = field("AvailabilityZone")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.PhysicalConnectionRequirementsTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PhysicalConnectionRequirementsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PostgreSQLCatalogTarget:
    boto3_raw_data: "type_defs.PostgreSQLCatalogTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Database = field("Database")
    Table = field("Table")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.PostgreSQLCatalogTargetTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PostgreSQLCatalogTargetTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PropertyPredicate:
    boto3_raw_data: "type_defs.PropertyPredicateTypeDef" = dataclasses.field()

    Key = field("Key")
    Value = field("Value")
    Comparator = field("Comparator")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.PropertyPredicateTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PropertyPredicateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PutDataQualityProfileAnnotationRequest:
    boto3_raw_data: "type_defs.PutDataQualityProfileAnnotationRequestTypeDef" = (
        dataclasses.field()
    )

    ProfileId = field("ProfileId")
    InclusionAnnotation = field("InclusionAnnotation")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.PutDataQualityProfileAnnotationRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PutDataQualityProfileAnnotationRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PutResourcePolicyRequest:
    boto3_raw_data: "type_defs.PutResourcePolicyRequestTypeDef" = dataclasses.field()

    PolicyInJson = field("PolicyInJson")
    ResourceArn = field("ResourceArn")
    PolicyHashCondition = field("PolicyHashCondition")
    PolicyExistsCondition = field("PolicyExistsCondition")
    EnableHybrid = field("EnableHybrid")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.PutResourcePolicyRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PutResourcePolicyRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PutWorkflowRunPropertiesRequest:
    boto3_raw_data: "type_defs.PutWorkflowRunPropertiesRequestTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    RunId = field("RunId")
    RunProperties = field("RunProperties")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.PutWorkflowRunPropertiesRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PutWorkflowRunPropertiesRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RecipeActionOutput:
    boto3_raw_data: "type_defs.RecipeActionOutputTypeDef" = dataclasses.field()

    Operation = field("Operation")
    Parameters = field("Parameters")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.RecipeActionOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.RecipeActionOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RecipeAction:
    boto3_raw_data: "type_defs.RecipeActionTypeDef" = dataclasses.field()

    Operation = field("Operation")
    Parameters = field("Parameters")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.RecipeActionTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.RecipeActionTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RecipeReference:
    boto3_raw_data: "type_defs.RecipeReferenceTypeDef" = dataclasses.field()

    RecipeArn = field("RecipeArn")
    RecipeVersion = field("RecipeVersion")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.RecipeReferenceTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.RecipeReferenceTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpsertRedshiftTargetOptionsOutput:
    boto3_raw_data: "type_defs.UpsertRedshiftTargetOptionsOutputTypeDef" = (
        dataclasses.field()
    )

    TableLocation = field("TableLocation")
    ConnectionName = field("ConnectionName")
    UpsertKeys = field("UpsertKeys")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.UpsertRedshiftTargetOptionsOutputTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpsertRedshiftTargetOptionsOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RenameField:
    boto3_raw_data: "type_defs.RenameFieldTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    SourcePath = field("SourcePath")
    TargetPath = field("TargetPath")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.RenameFieldTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.RenameFieldTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ResetJobBookmarkRequest:
    boto3_raw_data: "type_defs.ResetJobBookmarkRequestTypeDef" = dataclasses.field()

    JobName = field("JobName")
    RunId = field("RunId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ResetJobBookmarkRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ResetJobBookmarkRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ResourceUri:
    boto3_raw_data: "type_defs.ResourceUriTypeDef" = dataclasses.field()

    ResourceType = field("ResourceType")
    Uri = field("Uri")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ResourceUriTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ResourceUriTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ResumeWorkflowRunRequest:
    boto3_raw_data: "type_defs.ResumeWorkflowRunRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    RunId = field("RunId")
    NodeIds = field("NodeIds")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ResumeWorkflowRunRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ResumeWorkflowRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RunIdentifier:
    boto3_raw_data: "type_defs.RunIdentifierTypeDef" = dataclasses.field()

    RunId = field("RunId")
    JobRunId = field("JobRunId")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.RunIdentifierTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.RunIdentifierTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RunMetrics:
    boto3_raw_data: "type_defs.RunMetricsTypeDef" = dataclasses.field()

    NumberOfBytesCompacted = field("NumberOfBytesCompacted")
    NumberOfFilesCompacted = field("NumberOfFilesCompacted")
    NumberOfDpus = field("NumberOfDpus")
    JobDurationInHour = field("JobDurationInHour")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.RunMetricsTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.RunMetricsTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RunStatementRequest:
    boto3_raw_data: "type_defs.RunStatementRequestTypeDef" = dataclasses.field()

    SessionId = field("SessionId")
    Code = field("Code")
    RequestOrigin = field("RequestOrigin")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.RunStatementRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.RunStatementRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3DirectSourceAdditionalOptions:
    boto3_raw_data: "type_defs.S3DirectSourceAdditionalOptionsTypeDef" = (
        dataclasses.field()
    )

    BoundedSize = field("BoundedSize")
    BoundedFiles = field("BoundedFiles")
    EnableSamplePath = field("EnableSamplePath")
    SamplePath = field("SamplePath")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.S3DirectSourceAdditionalOptionsTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3DirectSourceAdditionalOptionsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SortCriterion:
    boto3_raw_data: "type_defs.SortCriterionTypeDef" = dataclasses.field()

    FieldName = field("FieldName")
    Sort = field("Sort")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SortCriterionTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SortCriterionTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SelectFields:
    boto3_raw_data: "type_defs.SelectFieldsTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Paths = field("Paths")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SelectFieldsTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SelectFieldsTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SelectFromCollection:
    boto3_raw_data: "type_defs.SelectFromCollectionTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Index = field("Index")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SelectFromCollectionTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SelectFromCollectionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SerDeInfoOutput:
    boto3_raw_data: "type_defs.SerDeInfoOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    SerializationLibrary = field("SerializationLibrary")
    Parameters = field("Parameters")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SerDeInfoOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SerDeInfoOutputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SerDeInfo:
    boto3_raw_data: "type_defs.SerDeInfoTypeDef" = dataclasses.field()

    Name = field("Name")
    SerializationLibrary = field("SerializationLibrary")
    Parameters = field("Parameters")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SerDeInfoTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SerDeInfoTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SkewedInfoOutput:
    boto3_raw_data: "type_defs.SkewedInfoOutputTypeDef" = dataclasses.field()

    SkewedColumnNames = field("SkewedColumnNames")
    SkewedColumnValues = field("SkewedColumnValues")
    SkewedColumnValueLocationMaps = field("SkewedColumnValueLocationMaps")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SkewedInfoOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SkewedInfoOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SkewedInfo:
    boto3_raw_data: "type_defs.SkewedInfoTypeDef" = dataclasses.field()

    SkewedColumnNames = field("SkewedColumnNames")
    SkewedColumnValues = field("SkewedColumnValues")
    SkewedColumnValueLocationMaps = field("SkewedColumnValueLocationMaps")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SkewedInfoTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SkewedInfoTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SourceTableConfig:
    boto3_raw_data: "type_defs.SourceTableConfigTypeDef" = dataclasses.field()

    Fields = field("Fields")
    FilterPredicate = field("FilterPredicate")
    PrimaryKey = field("PrimaryKey")
    RecordUpdateField = field("RecordUpdateField")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SourceTableConfigTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SourceTableConfigTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SqlAlias:
    boto3_raw_data: "type_defs.SqlAliasTypeDef" = dataclasses.field()

    From = field("From")
    Alias = field("Alias")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SqlAliasTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SqlAliasTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Spigot:
    boto3_raw_data: "type_defs.SpigotTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Path = field("Path")
    Topk = field("Topk")
    Prob = field("Prob")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SpigotTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SpigotTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SplitFields:
    boto3_raw_data: "type_defs.SplitFieldsTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Paths = field("Paths")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SplitFieldsTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SplitFieldsTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartBlueprintRunRequest:
    boto3_raw_data: "type_defs.StartBlueprintRunRequestTypeDef" = dataclasses.field()

    BlueprintName = field("BlueprintName")
    RoleArn = field("RoleArn")
    Parameters = field("Parameters")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StartBlueprintRunRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartBlueprintRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartColumnStatisticsTaskRunRequest:
    boto3_raw_data: "type_defs.StartColumnStatisticsTaskRunRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    Role = field("Role")
    ColumnNameList = field("ColumnNameList")
    SampleSize = field("SampleSize")
    CatalogID = field("CatalogID")
    SecurityConfiguration = field("SecurityConfiguration")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.StartColumnStatisticsTaskRunRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartColumnStatisticsTaskRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartColumnStatisticsTaskRunScheduleRequest:
    boto3_raw_data: "type_defs.StartColumnStatisticsTaskRunScheduleRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.StartColumnStatisticsTaskRunScheduleRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartColumnStatisticsTaskRunScheduleRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartCrawlerRequest:
    boto3_raw_data: "type_defs.StartCrawlerRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StartCrawlerRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartCrawlerRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartCrawlerScheduleRequest:
    boto3_raw_data: "type_defs.StartCrawlerScheduleRequestTypeDef" = dataclasses.field()

    CrawlerName = field("CrawlerName")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StartCrawlerScheduleRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartCrawlerScheduleRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartExportLabelsTaskRunRequest:
    boto3_raw_data: "type_defs.StartExportLabelsTaskRunRequestTypeDef" = (
        dataclasses.field()
    )

    TransformId = field("TransformId")
    OutputS3Path = field("OutputS3Path")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.StartExportLabelsTaskRunRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartExportLabelsTaskRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartImportLabelsTaskRunRequest:
    boto3_raw_data: "type_defs.StartImportLabelsTaskRunRequestTypeDef" = (
        dataclasses.field()
    )

    TransformId = field("TransformId")
    InputS3Path = field("InputS3Path")
    ReplaceAllLabels = field("ReplaceAllLabels")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.StartImportLabelsTaskRunRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartImportLabelsTaskRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartMLEvaluationTaskRunRequest:
    boto3_raw_data: "type_defs.StartMLEvaluationTaskRunRequestTypeDef" = (
        dataclasses.field()
    )

    TransformId = field("TransformId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.StartMLEvaluationTaskRunRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartMLEvaluationTaskRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartMLLabelingSetGenerationTaskRunRequest:
    boto3_raw_data: "type_defs.StartMLLabelingSetGenerationTaskRunRequestTypeDef" = (
        dataclasses.field()
    )

    TransformId = field("TransformId")
    OutputS3Path = field("OutputS3Path")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.StartMLLabelingSetGenerationTaskRunRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartMLLabelingSetGenerationTaskRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartTriggerRequest:
    boto3_raw_data: "type_defs.StartTriggerRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StartTriggerRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartTriggerRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartWorkflowRunRequest:
    boto3_raw_data: "type_defs.StartWorkflowRunRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    RunProperties = field("RunProperties")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StartWorkflowRunRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartWorkflowRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartingEventBatchCondition:
    boto3_raw_data: "type_defs.StartingEventBatchConditionTypeDef" = dataclasses.field()

    BatchSize = field("BatchSize")
    BatchWindow = field("BatchWindow")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StartingEventBatchConditionTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartingEventBatchConditionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StatementOutputData:
    boto3_raw_data: "type_defs.StatementOutputDataTypeDef" = dataclasses.field()

    TextPlain = field("TextPlain")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StatementOutputDataTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StatementOutputDataTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TimestampedInclusionAnnotation:
    boto3_raw_data: "type_defs.TimestampedInclusionAnnotationTypeDef" = (
        dataclasses.field()
    )

    Value = field("Value")
    LastModifiedOn = field("LastModifiedOn")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.TimestampedInclusionAnnotationTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TimestampedInclusionAnnotationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StopColumnStatisticsTaskRunRequest:
    boto3_raw_data: "type_defs.StopColumnStatisticsTaskRunRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.StopColumnStatisticsTaskRunRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StopColumnStatisticsTaskRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StopColumnStatisticsTaskRunScheduleRequest:
    boto3_raw_data: "type_defs.StopColumnStatisticsTaskRunScheduleRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.StopColumnStatisticsTaskRunScheduleRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StopColumnStatisticsTaskRunScheduleRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StopCrawlerRequest:
    boto3_raw_data: "type_defs.StopCrawlerRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StopCrawlerRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StopCrawlerRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StopCrawlerScheduleRequest:
    boto3_raw_data: "type_defs.StopCrawlerScheduleRequestTypeDef" = dataclasses.field()

    CrawlerName = field("CrawlerName")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StopCrawlerScheduleRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StopCrawlerScheduleRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StopSessionRequest:
    boto3_raw_data: "type_defs.StopSessionRequestTypeDef" = dataclasses.field()

    Id = field("Id")
    RequestOrigin = field("RequestOrigin")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StopSessionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StopSessionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StopTriggerRequest:
    boto3_raw_data: "type_defs.StopTriggerRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StopTriggerRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StopTriggerRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StopWorkflowRunRequest:
    boto3_raw_data: "type_defs.StopWorkflowRunRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    RunId = field("RunId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StopWorkflowRunRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StopWorkflowRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TableIdentifier:
    boto3_raw_data: "type_defs.TableIdentifierTypeDef" = dataclasses.field()

    CatalogId = field("CatalogId")
    DatabaseName = field("DatabaseName")
    Name = field("Name")
    Region = field("Region")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.TableIdentifierTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.TableIdentifierTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TableOptimizerVpcConfiguration:
    boto3_raw_data: "type_defs.TableOptimizerVpcConfigurationTypeDef" = (
        dataclasses.field()
    )

    glueConnectionName = field("glueConnectionName")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.TableOptimizerVpcConfigurationTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TableOptimizerVpcConfigurationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TagResourceRequest:
    boto3_raw_data: "type_defs.TagResourceRequestTypeDef" = dataclasses.field()

    ResourceArn = field("ResourceArn")
    TagsToAdd = field("TagsToAdd")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.TagResourceRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TagResourceRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TransformConfigParameter:
    boto3_raw_data: "type_defs.TransformConfigParameterTypeDef" = dataclasses.field()

    Name = field("Name")
    Type = field("Type")
    ValidationRule = field("ValidationRule")
    ValidationMessage = field("ValidationMessage")
    Value = field("Value")
    ListType = field("ListType")
    IsOptional = field("IsOptional")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.TransformConfigParameterTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TransformConfigParameterTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Union:
    boto3_raw_data: "type_defs.UnionTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    UnionType = field("UnionType")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.UnionTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.UnionTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UntagResourceRequest:
    boto3_raw_data: "type_defs.UntagResourceRequestTypeDef" = dataclasses.field()

    ResourceArn = field("ResourceArn")
    TagsToRemove = field("TagsToRemove")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UntagResourceRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UntagResourceRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateBlueprintRequest:
    boto3_raw_data: "type_defs.UpdateBlueprintRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    BlueprintLocation = field("BlueprintLocation")
    Description = field("Description")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateBlueprintRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateBlueprintRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateCsvClassifierRequest:
    boto3_raw_data: "type_defs.UpdateCsvClassifierRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    Delimiter = field("Delimiter")
    QuoteSymbol = field("QuoteSymbol")
    ContainsHeader = field("ContainsHeader")
    Header = field("Header")
    DisableValueTrimming = field("DisableValueTrimming")
    AllowSingleColumn = field("AllowSingleColumn")
    CustomDatatypeConfigured = field("CustomDatatypeConfigured")
    CustomDatatypes = field("CustomDatatypes")
    Serde = field("Serde")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateCsvClassifierRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateCsvClassifierRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateGrokClassifierRequest:
    boto3_raw_data: "type_defs.UpdateGrokClassifierRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    Classification = field("Classification")
    GrokPattern = field("GrokPattern")
    CustomPatterns = field("CustomPatterns")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateGrokClassifierRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateGrokClassifierRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateJsonClassifierRequest:
    boto3_raw_data: "type_defs.UpdateJsonClassifierRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    JsonPath = field("JsonPath")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateJsonClassifierRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateJsonClassifierRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateXMLClassifierRequest:
    boto3_raw_data: "type_defs.UpdateXMLClassifierRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    Classification = field("Classification")
    RowTag = field("RowTag")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateXMLClassifierRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateXMLClassifierRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateColumnStatisticsTaskSettingsRequest:
    boto3_raw_data: "type_defs.UpdateColumnStatisticsTaskSettingsRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    Role = field("Role")
    Schedule = field("Schedule")
    ColumnNameList = field("ColumnNameList")
    SampleSize = field("SampleSize")
    CatalogID = field("CatalogID")
    SecurityConfiguration = field("SecurityConfiguration")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.UpdateColumnStatisticsTaskSettingsRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateColumnStatisticsTaskSettingsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateCrawlerScheduleRequest:
    boto3_raw_data: "type_defs.UpdateCrawlerScheduleRequestTypeDef" = (
        dataclasses.field()
    )

    CrawlerName = field("CrawlerName")
    Schedule = field("Schedule")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateCrawlerScheduleRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateCrawlerScheduleRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateDataQualityRulesetRequest:
    boto3_raw_data: "type_defs.UpdateDataQualityRulesetRequestTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    Description = field("Description")
    Ruleset = field("Ruleset")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.UpdateDataQualityRulesetRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateDataQualityRulesetRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateGlueIdentityCenterConfigurationRequest:
    boto3_raw_data: "type_defs.UpdateGlueIdentityCenterConfigurationRequestTypeDef" = (
        dataclasses.field()
    )

    Scopes = field("Scopes")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.UpdateGlueIdentityCenterConfigurationRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateGlueIdentityCenterConfigurationRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateJobFromSourceControlRequest:
    boto3_raw_data: "type_defs.UpdateJobFromSourceControlRequestTypeDef" = (
        dataclasses.field()
    )

    JobName = field("JobName")
    Provider = field("Provider")
    RepositoryName = field("RepositoryName")
    RepositoryOwner = field("RepositoryOwner")
    BranchName = field("BranchName")
    Folder = field("Folder")
    CommitId = field("CommitId")
    AuthStrategy = field("AuthStrategy")
    AuthToken = field("AuthToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.UpdateJobFromSourceControlRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateJobFromSourceControlRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateSourceControlFromJobRequest:
    boto3_raw_data: "type_defs.UpdateSourceControlFromJobRequestTypeDef" = (
        dataclasses.field()
    )

    JobName = field("JobName")
    Provider = field("Provider")
    RepositoryName = field("RepositoryName")
    RepositoryOwner = field("RepositoryOwner")
    BranchName = field("BranchName")
    Folder = field("Folder")
    CommitId = field("CommitId")
    AuthStrategy = field("AuthStrategy")
    AuthToken = field("AuthToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.UpdateSourceControlFromJobRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateSourceControlFromJobRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateWorkflowRequest:
    boto3_raw_data: "type_defs.UpdateWorkflowRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    Description = field("Description")
    DefaultRunProperties = field("DefaultRunProperties")
    MaxConcurrentRuns = field("MaxConcurrentRuns")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateWorkflowRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateWorkflowRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpsertRedshiftTargetOptions:
    boto3_raw_data: "type_defs.UpsertRedshiftTargetOptionsTypeDef" = dataclasses.field()

    TableLocation = field("TableLocation")
    ConnectionName = field("ConnectionName")
    UpsertKeys = field("UpsertKeys")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpsertRedshiftTargetOptionsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpsertRedshiftTargetOptionsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ViewRepresentationInput:
    boto3_raw_data: "type_defs.ViewRepresentationInputTypeDef" = dataclasses.field()

    Dialect = field("Dialect")
    DialectVersion = field("DialectVersion")
    ViewOriginalText = field("ViewOriginalText")
    ValidationConnection = field("ValidationConnection")
    ViewExpandedText = field("ViewExpandedText")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ViewRepresentationInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ViewRepresentationInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ViewRepresentation:
    boto3_raw_data: "type_defs.ViewRepresentationTypeDef" = dataclasses.field()

    Dialect = field("Dialect")
    DialectVersion = field("DialectVersion")
    ViewOriginalText = field("ViewOriginalText")
    ViewExpandedText = field("ViewExpandedText")
    ValidationConnection = field("ValidationConnection")
    IsStale = field("IsStale")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ViewRepresentationTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ViewRepresentationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class WorkflowRunStatistics:
    boto3_raw_data: "type_defs.WorkflowRunStatisticsTypeDef" = dataclasses.field()

    TotalActions = field("TotalActions")
    TimeoutActions = field("TimeoutActions")
    FailedActions = field("FailedActions")
    StoppedActions = field("StoppedActions")
    SucceededActions = field("SucceededActions")
    RunningActions = field("RunningActions")
    ErroredActions = field("ErroredActions")
    WaitingActions = field("WaitingActions")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.WorkflowRunStatisticsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.WorkflowRunStatisticsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ActionOutput:
    boto3_raw_data: "type_defs.ActionOutputTypeDef" = dataclasses.field()

    JobName = field("JobName")
    Arguments = field("Arguments")
    Timeout = field("Timeout")
    SecurityConfiguration = field("SecurityConfiguration")

    @cached_property
    def NotificationProperty(self):  # pragma: no cover
        return NotificationProperty.make_one(
            self.boto3_raw_data["NotificationProperty"]
        )

    CrawlerName = field("CrawlerName")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ActionOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ActionOutputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Action:
    boto3_raw_data: "type_defs.ActionTypeDef" = dataclasses.field()

    JobName = field("JobName")
    Arguments = field("Arguments")
    Timeout = field("Timeout")
    SecurityConfiguration = field("SecurityConfiguration")

    @cached_property
    def NotificationProperty(self):  # pragma: no cover
        return NotificationProperty.make_one(
            self.boto3_raw_data["NotificationProperty"]
        )

    CrawlerName = field("CrawlerName")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ActionTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ActionTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartJobRunRequest:
    boto3_raw_data: "type_defs.StartJobRunRequestTypeDef" = dataclasses.field()

    JobName = field("JobName")
    JobRunQueuingEnabled = field("JobRunQueuingEnabled")
    JobRunId = field("JobRunId")
    Arguments = field("Arguments")
    AllocatedCapacity = field("AllocatedCapacity")
    Timeout = field("Timeout")
    MaxCapacity = field("MaxCapacity")
    SecurityConfiguration = field("SecurityConfiguration")

    @cached_property
    def NotificationProperty(self):  # pragma: no cover
        return NotificationProperty.make_one(
            self.boto3_raw_data["NotificationProperty"]
        )

    WorkerType = field("WorkerType")
    NumberOfWorkers = field("NumberOfWorkers")
    ExecutionClass = field("ExecutionClass")
    ExecutionRoleSessionPolicy = field("ExecutionRoleSessionPolicy")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StartJobRunRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartJobRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AggregateOutput:
    boto3_raw_data: "type_defs.AggregateOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Groups = field("Groups")

    @cached_property
    def Aggs(self):  # pragma: no cover
        return AggregateOperationOutput.make_many(self.boto3_raw_data["Aggs"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.AggregateOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.AggregateOutputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Property:
    boto3_raw_data: "type_defs.PropertyTypeDef" = dataclasses.field()

    Name = field("Name")
    Description = field("Description")
    Required = field("Required")
    PropertyTypes = field("PropertyTypes")
    DefaultValue = field("DefaultValue")

    @cached_property
    def AllowedValues(self):  # pragma: no cover
        return AllowedValue.make_many(self.boto3_raw_data["AllowedValues"])

    DataOperationScopes = field("DataOperationScopes")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.PropertyTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.PropertyTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AmazonRedshiftNodeDataOutput:
    boto3_raw_data: "type_defs.AmazonRedshiftNodeDataOutputTypeDef" = (
        dataclasses.field()
    )

    AccessType = field("AccessType")
    SourceType = field("SourceType")

    @cached_property
    def Connection(self):  # pragma: no cover
        return Option.make_one(self.boto3_raw_data["Connection"])

    @cached_property
    def Schema(self):  # pragma: no cover
        return Option.make_one(self.boto3_raw_data["Schema"])

    @cached_property
    def Table(self):  # pragma: no cover
        return Option.make_one(self.boto3_raw_data["Table"])

    @cached_property
    def CatalogDatabase(self):  # pragma: no cover
        return Option.make_one(self.boto3_raw_data["CatalogDatabase"])

    @cached_property
    def CatalogTable(self):  # pragma: no cover
        return Option.make_one(self.boto3_raw_data["CatalogTable"])

    CatalogRedshiftSchema = field("CatalogRedshiftSchema")
    CatalogRedshiftTable = field("CatalogRedshiftTable")
    TempDir = field("TempDir")

    @cached_property
    def IamRole(self):  # pragma: no cover
        return Option.make_one(self.boto3_raw_data["IamRole"])

    @cached_property
    def AdvancedOptions(self):  # pragma: no cover
        return AmazonRedshiftAdvancedOption.make_many(
            self.boto3_raw_data["AdvancedOptions"]
        )

    SampleQuery = field("SampleQuery")
    PreAction = field("PreAction")
    PostAction = field("PostAction")
    Action = field("Action")
    TablePrefix = field("TablePrefix")
    Upsert = field("Upsert")
    MergeAction = field("MergeAction")
    MergeWhenMatched = field("MergeWhenMatched")
    MergeWhenNotMatched = field("MergeWhenNotMatched")
    MergeClause = field("MergeClause")
    CrawlerConnection = field("CrawlerConnection")

    @cached_property
    def TableSchema(self):  # pragma: no cover
        return Option.make_many(self.boto3_raw_data["TableSchema"])

    StagingTable = field("StagingTable")

    @cached_property
    def SelectedColumns(self):  # pragma: no cover
        return Option.make_many(self.boto3_raw_data["SelectedColumns"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.AmazonRedshiftNodeDataOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.AmazonRedshiftNodeDataOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AmazonRedshiftNodeData:
    boto3_raw_data: "type_defs.AmazonRedshiftNodeDataTypeDef" = dataclasses.field()

    AccessType = field("AccessType")
    SourceType = field("SourceType")

    @cached_property
    def Connection(self):  # pragma: no cover
        return Option.make_one(self.boto3_raw_data["Connection"])

    @cached_property
    def Schema(self):  # pragma: no cover
        return Option.make_one(self.boto3_raw_data["Schema"])

    @cached_property
    def Table(self):  # pragma: no cover
        return Option.make_one(self.boto3_raw_data["Table"])

    @cached_property
    def CatalogDatabase(self):  # pragma: no cover
        return Option.make_one(self.boto3_raw_data["CatalogDatabase"])

    @cached_property
    def CatalogTable(self):  # pragma: no cover
        return Option.make_one(self.boto3_raw_data["CatalogTable"])

    CatalogRedshiftSchema = field("CatalogRedshiftSchema")
    CatalogRedshiftTable = field("CatalogRedshiftTable")
    TempDir = field("TempDir")

    @cached_property
    def IamRole(self):  # pragma: no cover
        return Option.make_one(self.boto3_raw_data["IamRole"])

    @cached_property
    def AdvancedOptions(self):  # pragma: no cover
        return AmazonRedshiftAdvancedOption.make_many(
            self.boto3_raw_data["AdvancedOptions"]
        )

    SampleQuery = field("SampleQuery")
    PreAction = field("PreAction")
    PostAction = field("PostAction")
    Action = field("Action")
    TablePrefix = field("TablePrefix")
    Upsert = field("Upsert")
    MergeAction = field("MergeAction")
    MergeWhenMatched = field("MergeWhenMatched")
    MergeWhenNotMatched = field("MergeWhenNotMatched")
    MergeClause = field("MergeClause")
    CrawlerConnection = field("CrawlerConnection")

    @cached_property
    def TableSchema(self):  # pragma: no cover
        return Option.make_many(self.boto3_raw_data["TableSchema"])

    StagingTable = field("StagingTable")

    @cached_property
    def SelectedColumns(self):  # pragma: no cover
        return Option.make_many(self.boto3_raw_data["SelectedColumns"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.AmazonRedshiftNodeDataTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.AmazonRedshiftNodeDataTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SnowflakeNodeDataOutput:
    boto3_raw_data: "type_defs.SnowflakeNodeDataOutputTypeDef" = dataclasses.field()

    SourceType = field("SourceType")

    @cached_property
    def Connection(self):  # pragma: no cover
        return Option.make_one(self.boto3_raw_data["Connection"])

    Schema = field("Schema")
    Table = field("Table")
    Database = field("Database")
    TempDir = field("TempDir")

    @cached_property
    def IamRole(self):  # pragma: no cover
        return Option.make_one(self.boto3_raw_data["IamRole"])

    AdditionalOptions = field("AdditionalOptions")
    SampleQuery = field("SampleQuery")
    PreAction = field("PreAction")
    PostAction = field("PostAction")
    Action = field("Action")
    Upsert = field("Upsert")
    MergeAction = field("MergeAction")
    MergeWhenMatched = field("MergeWhenMatched")
    MergeWhenNotMatched = field("MergeWhenNotMatched")
    MergeClause = field("MergeClause")
    StagingTable = field("StagingTable")

    @cached_property
    def SelectedColumns(self):  # pragma: no cover
        return Option.make_many(self.boto3_raw_data["SelectedColumns"])

    AutoPushdown = field("AutoPushdown")

    @cached_property
    def TableSchema(self):  # pragma: no cover
        return Option.make_many(self.boto3_raw_data["TableSchema"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SnowflakeNodeDataOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SnowflakeNodeDataOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SnowflakeNodeData:
    boto3_raw_data: "type_defs.SnowflakeNodeDataTypeDef" = dataclasses.field()

    SourceType = field("SourceType")

    @cached_property
    def Connection(self):  # pragma: no cover
        return Option.make_one(self.boto3_raw_data["Connection"])

    Schema = field("Schema")
    Table = field("Table")
    Database = field("Database")
    TempDir = field("TempDir")

    @cached_property
    def IamRole(self):  # pragma: no cover
        return Option.make_one(self.boto3_raw_data["IamRole"])

    AdditionalOptions = field("AdditionalOptions")
    SampleQuery = field("SampleQuery")
    PreAction = field("PreAction")
    PostAction = field("PostAction")
    Action = field("Action")
    Upsert = field("Upsert")
    MergeAction = field("MergeAction")
    MergeWhenMatched = field("MergeWhenMatched")
    MergeWhenNotMatched = field("MergeWhenNotMatched")
    MergeClause = field("MergeClause")
    StagingTable = field("StagingTable")

    @cached_property
    def SelectedColumns(self):  # pragma: no cover
        return Option.make_many(self.boto3_raw_data["SelectedColumns"])

    AutoPushdown = field("AutoPushdown")

    @cached_property
    def TableSchema(self):  # pragma: no cover
        return Option.make_many(self.boto3_raw_data["TableSchema"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SnowflakeNodeDataTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SnowflakeNodeDataTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ApplyMappingOutput:
    boto3_raw_data: "type_defs.ApplyMappingOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")

    @cached_property
    def Mapping(self):  # pragma: no cover
        return MappingOutput.make_many(self.boto3_raw_data["Mapping"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ApplyMappingOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ApplyMappingOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ApplyMappingPaginator:
    boto3_raw_data: "type_defs.ApplyMappingPaginatorTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")

    @cached_property
    def Mapping(self):  # pragma: no cover
        return MappingPaginator.make_many(self.boto3_raw_data["Mapping"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ApplyMappingPaginatorTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ApplyMappingPaginatorTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BackfillError:
    boto3_raw_data: "type_defs.BackfillErrorTypeDef" = dataclasses.field()

    Code = field("Code")

    @cached_property
    def Partitions(self):  # pragma: no cover
        return PartitionValueListOutput.make_many(self.boto3_raw_data["Partitions"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.BackfillErrorTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.BackfillErrorTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchPutDataQualityStatisticAnnotationResponse:
    boto3_raw_data: (
        "type_defs.BatchPutDataQualityStatisticAnnotationResponseTypeDef"
    ) = dataclasses.field()

    @cached_property
    def FailedInclusionAnnotations(self):  # pragma: no cover
        return AnnotationError.make_many(
            self.boto3_raw_data["FailedInclusionAnnotations"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.BatchPutDataQualityStatisticAnnotationResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable[
                "type_defs.BatchPutDataQualityStatisticAnnotationResponseTypeDef"
            ]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CancelMLTaskRunResponse:
    boto3_raw_data: "type_defs.CancelMLTaskRunResponseTypeDef" = dataclasses.field()

    TransformId = field("TransformId")
    TaskRunId = field("TaskRunId")
    Status = field("Status")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CancelMLTaskRunResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CancelMLTaskRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CheckSchemaVersionValidityResponse:
    boto3_raw_data: "type_defs.CheckSchemaVersionValidityResponseTypeDef" = (
        dataclasses.field()
    )

    Valid = field("Valid")
    Error = field("Error")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.CheckSchemaVersionValidityResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CheckSchemaVersionValidityResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateBlueprintResponse:
    boto3_raw_data: "type_defs.CreateBlueprintResponseTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateBlueprintResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateBlueprintResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateConnectionResponse:
    boto3_raw_data: "type_defs.CreateConnectionResponseTypeDef" = dataclasses.field()

    CreateConnectionStatus = field("CreateConnectionStatus")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateConnectionResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateConnectionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateCustomEntityTypeResponse:
    boto3_raw_data: "type_defs.CreateCustomEntityTypeResponseTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.CreateCustomEntityTypeResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateCustomEntityTypeResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateDataQualityRulesetResponse:
    boto3_raw_data: "type_defs.CreateDataQualityRulesetResponseTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.CreateDataQualityRulesetResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateDataQualityRulesetResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateDevEndpointResponse:
    boto3_raw_data: "type_defs.CreateDevEndpointResponseTypeDef" = dataclasses.field()

    EndpointName = field("EndpointName")
    Status = field("Status")
    SecurityGroupIds = field("SecurityGroupIds")
    SubnetId = field("SubnetId")
    RoleArn = field("RoleArn")
    YarnEndpointAddress = field("YarnEndpointAddress")
    ZeppelinRemoteSparkInterpreterPort = field("ZeppelinRemoteSparkInterpreterPort")
    NumberOfNodes = field("NumberOfNodes")
    WorkerType = field("WorkerType")
    GlueVersion = field("GlueVersion")
    NumberOfWorkers = field("NumberOfWorkers")
    AvailabilityZone = field("AvailabilityZone")
    VpcId = field("VpcId")
    ExtraPythonLibsS3Path = field("ExtraPythonLibsS3Path")
    ExtraJarsS3Path = field("ExtraJarsS3Path")
    FailureReason = field("FailureReason")
    SecurityConfiguration = field("SecurityConfiguration")
    CreatedTimestamp = field("CreatedTimestamp")
    Arguments = field("Arguments")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateDevEndpointResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateDevEndpointResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateGlueIdentityCenterConfigurationResponse:
    boto3_raw_data: "type_defs.CreateGlueIdentityCenterConfigurationResponseTypeDef" = (
        dataclasses.field()
    )

    ApplicationArn = field("ApplicationArn")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.CreateGlueIdentityCenterConfigurationResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateGlueIdentityCenterConfigurationResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateJobResponse:
    boto3_raw_data: "type_defs.CreateJobResponseTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CreateJobResponseTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateJobResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateMLTransformResponse:
    boto3_raw_data: "type_defs.CreateMLTransformResponseTypeDef" = dataclasses.field()

    TransformId = field("TransformId")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateMLTransformResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateMLTransformResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateRegistryResponse:
    boto3_raw_data: "type_defs.CreateRegistryResponseTypeDef" = dataclasses.field()

    RegistryArn = field("RegistryArn")
    RegistryName = field("RegistryName")
    Description = field("Description")
    Tags = field("Tags")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateRegistryResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateRegistryResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateSchemaResponse:
    boto3_raw_data: "type_defs.CreateSchemaResponseTypeDef" = dataclasses.field()

    RegistryName = field("RegistryName")
    RegistryArn = field("RegistryArn")
    SchemaName = field("SchemaName")
    SchemaArn = field("SchemaArn")
    Description = field("Description")
    DataFormat = field("DataFormat")
    Compatibility = field("Compatibility")
    SchemaCheckpoint = field("SchemaCheckpoint")
    LatestSchemaVersion = field("LatestSchemaVersion")
    NextSchemaVersion = field("NextSchemaVersion")
    SchemaStatus = field("SchemaStatus")
    Tags = field("Tags")
    SchemaVersionId = field("SchemaVersionId")
    SchemaVersionStatus = field("SchemaVersionStatus")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateSchemaResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateSchemaResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateScriptResponse:
    boto3_raw_data: "type_defs.CreateScriptResponseTypeDef" = dataclasses.field()

    PythonScript = field("PythonScript")
    ScalaCode = field("ScalaCode")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateScriptResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateScriptResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateSecurityConfigurationResponse:
    boto3_raw_data: "type_defs.CreateSecurityConfigurationResponseTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    CreatedTimestamp = field("CreatedTimestamp")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.CreateSecurityConfigurationResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateSecurityConfigurationResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateTriggerResponse:
    boto3_raw_data: "type_defs.CreateTriggerResponseTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateTriggerResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateTriggerResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateUsageProfileResponse:
    boto3_raw_data: "type_defs.CreateUsageProfileResponseTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateUsageProfileResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateUsageProfileResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateWorkflowResponse:
    boto3_raw_data: "type_defs.CreateWorkflowResponseTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateWorkflowResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateWorkflowResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteBlueprintResponse:
    boto3_raw_data: "type_defs.DeleteBlueprintResponseTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteBlueprintResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteBlueprintResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteCustomEntityTypeResponse:
    boto3_raw_data: "type_defs.DeleteCustomEntityTypeResponseTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.DeleteCustomEntityTypeResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteCustomEntityTypeResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteJobResponse:
    boto3_raw_data: "type_defs.DeleteJobResponseTypeDef" = dataclasses.field()

    JobName = field("JobName")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DeleteJobResponseTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteJobResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteMLTransformResponse:
    boto3_raw_data: "type_defs.DeleteMLTransformResponseTypeDef" = dataclasses.field()

    TransformId = field("TransformId")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteMLTransformResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteMLTransformResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteRegistryResponse:
    boto3_raw_data: "type_defs.DeleteRegistryResponseTypeDef" = dataclasses.field()

    RegistryName = field("RegistryName")
    RegistryArn = field("RegistryArn")
    Status = field("Status")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteRegistryResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteRegistryResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteSchemaResponse:
    boto3_raw_data: "type_defs.DeleteSchemaResponseTypeDef" = dataclasses.field()

    SchemaArn = field("SchemaArn")
    SchemaName = field("SchemaName")
    Status = field("Status")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteSchemaResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteSchemaResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteSessionResponse:
    boto3_raw_data: "type_defs.DeleteSessionResponseTypeDef" = dataclasses.field()

    Id = field("Id")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteSessionResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteSessionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteTriggerResponse:
    boto3_raw_data: "type_defs.DeleteTriggerResponseTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteTriggerResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteTriggerResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteWorkflowResponse:
    boto3_raw_data: "type_defs.DeleteWorkflowResponseTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteWorkflowResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteWorkflowResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetCustomEntityTypeResponse:
    boto3_raw_data: "type_defs.GetCustomEntityTypeResponseTypeDef" = dataclasses.field()

    Name = field("Name")
    RegexString = field("RegexString")
    ContextWords = field("ContextWords")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetCustomEntityTypeResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetCustomEntityTypeResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDataQualityModelResponse:
    boto3_raw_data: "type_defs.GetDataQualityModelResponseTypeDef" = dataclasses.field()

    Status = field("Status")
    StartedOn = field("StartedOn")
    CompletedOn = field("CompletedOn")
    FailureReason = field("FailureReason")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetDataQualityModelResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDataQualityModelResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetEntityRecordsResponse:
    boto3_raw_data: "type_defs.GetEntityRecordsResponseTypeDef" = dataclasses.field()

    Records = field("Records")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetEntityRecordsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetEntityRecordsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetGlueIdentityCenterConfigurationResponse:
    boto3_raw_data: "type_defs.GetGlueIdentityCenterConfigurationResponseTypeDef" = (
        dataclasses.field()
    )

    ApplicationArn = field("ApplicationArn")
    InstanceArn = field("InstanceArn")
    Scopes = field("Scopes")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetGlueIdentityCenterConfigurationResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetGlueIdentityCenterConfigurationResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetPlanResponse:
    boto3_raw_data: "type_defs.GetPlanResponseTypeDef" = dataclasses.field()

    PythonScript = field("PythonScript")
    ScalaCode = field("ScalaCode")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetPlanResponseTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.GetPlanResponseTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetRegistryResponse:
    boto3_raw_data: "type_defs.GetRegistryResponseTypeDef" = dataclasses.field()

    RegistryName = field("RegistryName")
    RegistryArn = field("RegistryArn")
    Description = field("Description")
    Status = field("Status")
    CreatedTime = field("CreatedTime")
    UpdatedTime = field("UpdatedTime")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetRegistryResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetRegistryResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetResourcePolicyResponse:
    boto3_raw_data: "type_defs.GetResourcePolicyResponseTypeDef" = dataclasses.field()

    PolicyInJson = field("PolicyInJson")
    PolicyHash = field("PolicyHash")
    CreateTime = field("CreateTime")
    UpdateTime = field("UpdateTime")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetResourcePolicyResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetResourcePolicyResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetSchemaByDefinitionResponse:
    boto3_raw_data: "type_defs.GetSchemaByDefinitionResponseTypeDef" = (
        dataclasses.field()
    )

    SchemaVersionId = field("SchemaVersionId")
    SchemaArn = field("SchemaArn")
    DataFormat = field("DataFormat")
    Status = field("Status")
    CreatedTime = field("CreatedTime")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetSchemaByDefinitionResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetSchemaByDefinitionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetSchemaResponse:
    boto3_raw_data: "type_defs.GetSchemaResponseTypeDef" = dataclasses.field()

    RegistryName = field("RegistryName")
    RegistryArn = field("RegistryArn")
    SchemaName = field("SchemaName")
    SchemaArn = field("SchemaArn")
    Description = field("Description")
    DataFormat = field("DataFormat")
    Compatibility = field("Compatibility")
    SchemaCheckpoint = field("SchemaCheckpoint")
    LatestSchemaVersion = field("LatestSchemaVersion")
    NextSchemaVersion = field("NextSchemaVersion")
    SchemaStatus = field("SchemaStatus")
    CreatedTime = field("CreatedTime")
    UpdatedTime = field("UpdatedTime")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetSchemaResponseTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetSchemaResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetSchemaVersionResponse:
    boto3_raw_data: "type_defs.GetSchemaVersionResponseTypeDef" = dataclasses.field()

    SchemaVersionId = field("SchemaVersionId")
    SchemaDefinition = field("SchemaDefinition")
    DataFormat = field("DataFormat")
    SchemaArn = field("SchemaArn")
    VersionNumber = field("VersionNumber")
    Status = field("Status")
    CreatedTime = field("CreatedTime")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetSchemaVersionResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetSchemaVersionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetSchemaVersionsDiffResponse:
    boto3_raw_data: "type_defs.GetSchemaVersionsDiffResponseTypeDef" = (
        dataclasses.field()
    )

    Diff = field("Diff")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetSchemaVersionsDiffResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetSchemaVersionsDiffResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTagsResponse:
    boto3_raw_data: "type_defs.GetTagsResponseTypeDef" = dataclasses.field()

    Tags = field("Tags")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetTagsResponseTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.GetTagsResponseTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetWorkflowRunPropertiesResponse:
    boto3_raw_data: "type_defs.GetWorkflowRunPropertiesResponseTypeDef" = (
        dataclasses.field()
    )

    RunProperties = field("RunProperties")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetWorkflowRunPropertiesResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetWorkflowRunPropertiesResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListBlueprintsResponse:
    boto3_raw_data: "type_defs.ListBlueprintsResponseTypeDef" = dataclasses.field()

    Blueprints = field("Blueprints")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListBlueprintsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListBlueprintsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListColumnStatisticsTaskRunsResponse:
    boto3_raw_data: "type_defs.ListColumnStatisticsTaskRunsResponseTypeDef" = (
        dataclasses.field()
    )

    ColumnStatisticsTaskRunIds = field("ColumnStatisticsTaskRunIds")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.ListColumnStatisticsTaskRunsResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListColumnStatisticsTaskRunsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListCrawlersResponse:
    boto3_raw_data: "type_defs.ListCrawlersResponseTypeDef" = dataclasses.field()

    CrawlerNames = field("CrawlerNames")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListCrawlersResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListCrawlersResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListDevEndpointsResponse:
    boto3_raw_data: "type_defs.ListDevEndpointsResponseTypeDef" = dataclasses.field()

    DevEndpointNames = field("DevEndpointNames")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListDevEndpointsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListDevEndpointsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListJobsResponse:
    boto3_raw_data: "type_defs.ListJobsResponseTypeDef" = dataclasses.field()

    JobNames = field("JobNames")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ListJobsResponseTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListJobsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListMLTransformsResponse:
    boto3_raw_data: "type_defs.ListMLTransformsResponseTypeDef" = dataclasses.field()

    TransformIds = field("TransformIds")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListMLTransformsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListMLTransformsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListTriggersResponse:
    boto3_raw_data: "type_defs.ListTriggersResponseTypeDef" = dataclasses.field()

    TriggerNames = field("TriggerNames")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListTriggersResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListTriggersResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListWorkflowsResponse:
    boto3_raw_data: "type_defs.ListWorkflowsResponseTypeDef" = dataclasses.field()

    Workflows = field("Workflows")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListWorkflowsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListWorkflowsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PutResourcePolicyResponse:
    boto3_raw_data: "type_defs.PutResourcePolicyResponseTypeDef" = dataclasses.field()

    PolicyHash = field("PolicyHash")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.PutResourcePolicyResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PutResourcePolicyResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PutSchemaVersionMetadataResponse:
    boto3_raw_data: "type_defs.PutSchemaVersionMetadataResponseTypeDef" = (
        dataclasses.field()
    )

    SchemaArn = field("SchemaArn")
    SchemaName = field("SchemaName")
    RegistryName = field("RegistryName")
    LatestVersion = field("LatestVersion")
    VersionNumber = field("VersionNumber")
    SchemaVersionId = field("SchemaVersionId")
    MetadataKey = field("MetadataKey")
    MetadataValue = field("MetadataValue")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.PutSchemaVersionMetadataResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PutSchemaVersionMetadataResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RegisterSchemaVersionResponse:
    boto3_raw_data: "type_defs.RegisterSchemaVersionResponseTypeDef" = (
        dataclasses.field()
    )

    SchemaVersionId = field("SchemaVersionId")
    VersionNumber = field("VersionNumber")
    Status = field("Status")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.RegisterSchemaVersionResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.RegisterSchemaVersionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RemoveSchemaVersionMetadataResponse:
    boto3_raw_data: "type_defs.RemoveSchemaVersionMetadataResponseTypeDef" = (
        dataclasses.field()
    )

    SchemaArn = field("SchemaArn")
    SchemaName = field("SchemaName")
    RegistryName = field("RegistryName")
    LatestVersion = field("LatestVersion")
    VersionNumber = field("VersionNumber")
    SchemaVersionId = field("SchemaVersionId")
    MetadataKey = field("MetadataKey")
    MetadataValue = field("MetadataValue")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.RemoveSchemaVersionMetadataResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.RemoveSchemaVersionMetadataResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ResumeWorkflowRunResponse:
    boto3_raw_data: "type_defs.ResumeWorkflowRunResponseTypeDef" = dataclasses.field()

    RunId = field("RunId")
    NodeIds = field("NodeIds")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ResumeWorkflowRunResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ResumeWorkflowRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RunStatementResponse:
    boto3_raw_data: "type_defs.RunStatementResponseTypeDef" = dataclasses.field()

    Id = field("Id")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.RunStatementResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.RunStatementResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartBlueprintRunResponse:
    boto3_raw_data: "type_defs.StartBlueprintRunResponseTypeDef" = dataclasses.field()

    RunId = field("RunId")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StartBlueprintRunResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartBlueprintRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartColumnStatisticsTaskRunResponse:
    boto3_raw_data: "type_defs.StartColumnStatisticsTaskRunResponseTypeDef" = (
        dataclasses.field()
    )

    ColumnStatisticsTaskRunId = field("ColumnStatisticsTaskRunId")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.StartColumnStatisticsTaskRunResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartColumnStatisticsTaskRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartDataQualityRuleRecommendationRunResponse:
    boto3_raw_data: "type_defs.StartDataQualityRuleRecommendationRunResponseTypeDef" = (
        dataclasses.field()
    )

    RunId = field("RunId")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.StartDataQualityRuleRecommendationRunResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartDataQualityRuleRecommendationRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartDataQualityRulesetEvaluationRunResponse:
    boto3_raw_data: "type_defs.StartDataQualityRulesetEvaluationRunResponseTypeDef" = (
        dataclasses.field()
    )

    RunId = field("RunId")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.StartDataQualityRulesetEvaluationRunResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartDataQualityRulesetEvaluationRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartExportLabelsTaskRunResponse:
    boto3_raw_data: "type_defs.StartExportLabelsTaskRunResponseTypeDef" = (
        dataclasses.field()
    )

    TaskRunId = field("TaskRunId")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.StartExportLabelsTaskRunResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartExportLabelsTaskRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartImportLabelsTaskRunResponse:
    boto3_raw_data: "type_defs.StartImportLabelsTaskRunResponseTypeDef" = (
        dataclasses.field()
    )

    TaskRunId = field("TaskRunId")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.StartImportLabelsTaskRunResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartImportLabelsTaskRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartJobRunResponse:
    boto3_raw_data: "type_defs.StartJobRunResponseTypeDef" = dataclasses.field()

    JobRunId = field("JobRunId")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StartJobRunResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartJobRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartMLEvaluationTaskRunResponse:
    boto3_raw_data: "type_defs.StartMLEvaluationTaskRunResponseTypeDef" = (
        dataclasses.field()
    )

    TaskRunId = field("TaskRunId")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.StartMLEvaluationTaskRunResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartMLEvaluationTaskRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartMLLabelingSetGenerationTaskRunResponse:
    boto3_raw_data: "type_defs.StartMLLabelingSetGenerationTaskRunResponseTypeDef" = (
        dataclasses.field()
    )

    TaskRunId = field("TaskRunId")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.StartMLLabelingSetGenerationTaskRunResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartMLLabelingSetGenerationTaskRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartTriggerResponse:
    boto3_raw_data: "type_defs.StartTriggerResponseTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StartTriggerResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartTriggerResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartWorkflowRunResponse:
    boto3_raw_data: "type_defs.StartWorkflowRunResponseTypeDef" = dataclasses.field()

    RunId = field("RunId")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StartWorkflowRunResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartWorkflowRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StopSessionResponse:
    boto3_raw_data: "type_defs.StopSessionResponseTypeDef" = dataclasses.field()

    Id = field("Id")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StopSessionResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StopSessionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StopTriggerResponse:
    boto3_raw_data: "type_defs.StopTriggerResponseTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StopTriggerResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StopTriggerResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateBlueprintResponse:
    boto3_raw_data: "type_defs.UpdateBlueprintResponseTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateBlueprintResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateBlueprintResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateDataQualityRulesetResponse:
    boto3_raw_data: "type_defs.UpdateDataQualityRulesetResponseTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    Description = field("Description")
    Ruleset = field("Ruleset")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.UpdateDataQualityRulesetResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateDataQualityRulesetResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateJobFromSourceControlResponse:
    boto3_raw_data: "type_defs.UpdateJobFromSourceControlResponseTypeDef" = (
        dataclasses.field()
    )

    JobName = field("JobName")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.UpdateJobFromSourceControlResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateJobFromSourceControlResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateJobResponse:
    boto3_raw_data: "type_defs.UpdateJobResponseTypeDef" = dataclasses.field()

    JobName = field("JobName")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.UpdateJobResponseTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateJobResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateMLTransformResponse:
    boto3_raw_data: "type_defs.UpdateMLTransformResponseTypeDef" = dataclasses.field()

    TransformId = field("TransformId")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateMLTransformResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateMLTransformResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateRegistryResponse:
    boto3_raw_data: "type_defs.UpdateRegistryResponseTypeDef" = dataclasses.field()

    RegistryName = field("RegistryName")
    RegistryArn = field("RegistryArn")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateRegistryResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateRegistryResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateSchemaResponse:
    boto3_raw_data: "type_defs.UpdateSchemaResponseTypeDef" = dataclasses.field()

    SchemaArn = field("SchemaArn")
    SchemaName = field("SchemaName")
    RegistryName = field("RegistryName")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateSchemaResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateSchemaResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateSourceControlFromJobResponse:
    boto3_raw_data: "type_defs.UpdateSourceControlFromJobResponseTypeDef" = (
        dataclasses.field()
    )

    JobName = field("JobName")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.UpdateSourceControlFromJobResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateSourceControlFromJobResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateUsageProfileResponse:
    boto3_raw_data: "type_defs.UpdateUsageProfileResponseTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateUsageProfileResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateUsageProfileResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateWorkflowResponse:
    boto3_raw_data: "type_defs.UpdateWorkflowResponseTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateWorkflowResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateWorkflowResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchDeleteConnectionResponse:
    boto3_raw_data: "type_defs.BatchDeleteConnectionResponseTypeDef" = (
        dataclasses.field()
    )

    Succeeded = field("Succeeded")
    Errors = field("Errors")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.BatchDeleteConnectionResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchDeleteConnectionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetTableOptimizerError:
    boto3_raw_data: "type_defs.BatchGetTableOptimizerErrorTypeDef" = dataclasses.field()

    @cached_property
    def error(self):  # pragma: no cover
        return ErrorDetail.make_one(self.boto3_raw_data["error"])

    catalogId = field("catalogId")
    databaseName = field("databaseName")
    tableName = field("tableName")
    type = field("type")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchGetTableOptimizerErrorTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetTableOptimizerErrorTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchStopJobRunError:
    boto3_raw_data: "type_defs.BatchStopJobRunErrorTypeDef" = dataclasses.field()

    JobName = field("JobName")
    JobRunId = field("JobRunId")

    @cached_property
    def ErrorDetail(self):  # pragma: no cover
        return ErrorDetail.make_one(self.boto3_raw_data["ErrorDetail"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchStopJobRunErrorTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchStopJobRunErrorTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchUpdatePartitionFailureEntry:
    boto3_raw_data: "type_defs.BatchUpdatePartitionFailureEntryTypeDef" = (
        dataclasses.field()
    )

    PartitionValueList = field("PartitionValueList")

    @cached_property
    def ErrorDetail(self):  # pragma: no cover
        return ErrorDetail.make_one(self.boto3_raw_data["ErrorDetail"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.BatchUpdatePartitionFailureEntryTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchUpdatePartitionFailureEntryTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ColumnError:
    boto3_raw_data: "type_defs.ColumnErrorTypeDef" = dataclasses.field()

    ColumnName = field("ColumnName")

    @cached_property
    def Error(self):  # pragma: no cover
        return ErrorDetail.make_one(self.boto3_raw_data["Error"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ColumnErrorTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ColumnErrorTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PartitionError:
    boto3_raw_data: "type_defs.PartitionErrorTypeDef" = dataclasses.field()

    PartitionValues = field("PartitionValues")

    @cached_property
    def ErrorDetail(self):  # pragma: no cover
        return ErrorDetail.make_one(self.boto3_raw_data["ErrorDetail"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.PartitionErrorTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.PartitionErrorTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TableError:
    boto3_raw_data: "type_defs.TableErrorTypeDef" = dataclasses.field()

    TableName = field("TableName")

    @cached_property
    def ErrorDetail(self):  # pragma: no cover
        return ErrorDetail.make_one(self.boto3_raw_data["ErrorDetail"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.TableErrorTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.TableErrorTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TableVersionError:
    boto3_raw_data: "type_defs.TableVersionErrorTypeDef" = dataclasses.field()

    TableName = field("TableName")
    VersionId = field("VersionId")

    @cached_property
    def ErrorDetail(self):  # pragma: no cover
        return ErrorDetail.make_one(self.boto3_raw_data["ErrorDetail"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.TableVersionErrorTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TableVersionErrorTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ViewValidation:
    boto3_raw_data: "type_defs.ViewValidationTypeDef" = dataclasses.field()

    Dialect = field("Dialect")
    DialectVersion = field("DialectVersion")
    ViewValidationText = field("ViewValidationText")
    UpdateTime = field("UpdateTime")
    State = field("State")

    @cached_property
    def Error(self):  # pragma: no cover
        return ErrorDetail.make_one(self.boto3_raw_data["Error"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ViewValidationTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ViewValidationTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetCustomEntityTypesResponse:
    boto3_raw_data: "type_defs.BatchGetCustomEntityTypesResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def CustomEntityTypes(self):  # pragma: no cover
        return CustomEntityType.make_many(self.boto3_raw_data["CustomEntityTypes"])

    CustomEntityTypesNotFound = field("CustomEntityTypesNotFound")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.BatchGetCustomEntityTypesResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetCustomEntityTypesResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListCustomEntityTypesResponse:
    boto3_raw_data: "type_defs.ListCustomEntityTypesResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def CustomEntityTypes(self):  # pragma: no cover
        return CustomEntityType.make_many(self.boto3_raw_data["CustomEntityTypes"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.ListCustomEntityTypesResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListCustomEntityTypesResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetDevEndpointsResponse:
    boto3_raw_data: "type_defs.BatchGetDevEndpointsResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def DevEndpoints(self):  # pragma: no cover
        return DevEndpoint.make_many(self.boto3_raw_data["DevEndpoints"])

    DevEndpointsNotFound = field("DevEndpointsNotFound")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchGetDevEndpointsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetDevEndpointsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDevEndpointResponse:
    boto3_raw_data: "type_defs.GetDevEndpointResponseTypeDef" = dataclasses.field()

    @cached_property
    def DevEndpoint(self):  # pragma: no cover
        return DevEndpoint.make_one(self.boto3_raw_data["DevEndpoint"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetDevEndpointResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDevEndpointResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDevEndpointsResponse:
    boto3_raw_data: "type_defs.GetDevEndpointsResponseTypeDef" = dataclasses.field()

    @cached_property
    def DevEndpoints(self):  # pragma: no cover
        return DevEndpoint.make_many(self.boto3_raw_data["DevEndpoints"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetDevEndpointsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDevEndpointsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetTableOptimizerRequest:
    boto3_raw_data: "type_defs.BatchGetTableOptimizerRequestTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Entries(self):  # pragma: no cover
        return BatchGetTableOptimizerEntry.make_many(self.boto3_raw_data["Entries"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.BatchGetTableOptimizerRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetTableOptimizerRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchPutDataQualityStatisticAnnotationRequest:
    boto3_raw_data: "type_defs.BatchPutDataQualityStatisticAnnotationRequestTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def InclusionAnnotations(self):  # pragma: no cover
        return DatapointInclusionAnnotation.make_many(
            self.boto3_raw_data["InclusionAnnotations"]
        )

    ClientToken = field("ClientToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.BatchPutDataQualityStatisticAnnotationRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchPutDataQualityStatisticAnnotationRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DecimalNumber:
    boto3_raw_data: "type_defs.DecimalNumberTypeDef" = dataclasses.field()

    UnscaledValue = field("UnscaledValue")
    Scale = field("Scale")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DecimalNumberTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.DecimalNumberTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetBlueprintRunResponse:
    boto3_raw_data: "type_defs.GetBlueprintRunResponseTypeDef" = dataclasses.field()

    @cached_property
    def BlueprintRun(self):  # pragma: no cover
        return BlueprintRun.make_one(self.boto3_raw_data["BlueprintRun"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetBlueprintRunResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetBlueprintRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetBlueprintRunsResponse:
    boto3_raw_data: "type_defs.GetBlueprintRunsResponseTypeDef" = dataclasses.field()

    @cached_property
    def BlueprintRuns(self):  # pragma: no cover
        return BlueprintRun.make_many(self.boto3_raw_data["BlueprintRuns"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetBlueprintRunsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetBlueprintRunsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Blueprint:
    boto3_raw_data: "type_defs.BlueprintTypeDef" = dataclasses.field()

    Name = field("Name")
    Description = field("Description")
    CreatedOn = field("CreatedOn")
    LastModifiedOn = field("LastModifiedOn")
    ParameterSpec = field("ParameterSpec")
    BlueprintLocation = field("BlueprintLocation")
    BlueprintServiceLocation = field("BlueprintServiceLocation")
    Status = field("Status")
    ErrorMessage = field("ErrorMessage")

    @cached_property
    def LastActiveDefinition(self):  # pragma: no cover
        return LastActiveDefinition.make_one(
            self.boto3_raw_data["LastActiveDefinition"]
        )

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.BlueprintTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.BlueprintTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetCatalogImportStatusResponse:
    boto3_raw_data: "type_defs.GetCatalogImportStatusResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def ImportStatus(self):  # pragma: no cover
        return CatalogImportStatus.make_one(self.boto3_raw_data["ImportStatus"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetCatalogImportStatusResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetCatalogImportStatusResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogKafkaSourceOutput:
    boto3_raw_data: "type_defs.CatalogKafkaSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Table = field("Table")
    Database = field("Database")
    WindowSize = field("WindowSize")
    DetectSchema = field("DetectSchema")

    @cached_property
    def StreamingOptions(self):  # pragma: no cover
        return KafkaStreamingSourceOptionsOutput.make_one(
            self.boto3_raw_data["StreamingOptions"]
        )

    @cached_property
    def DataPreviewOptions(self):  # pragma: no cover
        return StreamingDataPreviewOptions.make_one(
            self.boto3_raw_data["DataPreviewOptions"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CatalogKafkaSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CatalogKafkaSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DirectKafkaSourceOutput:
    boto3_raw_data: "type_defs.DirectKafkaSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def StreamingOptions(self):  # pragma: no cover
        return KafkaStreamingSourceOptionsOutput.make_one(
            self.boto3_raw_data["StreamingOptions"]
        )

    WindowSize = field("WindowSize")
    DetectSchema = field("DetectSchema")

    @cached_property
    def DataPreviewOptions(self):  # pragma: no cover
        return StreamingDataPreviewOptions.make_one(
            self.boto3_raw_data["DataPreviewOptions"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DirectKafkaSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DirectKafkaSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogKinesisSourceOutput:
    boto3_raw_data: "type_defs.CatalogKinesisSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Table = field("Table")
    Database = field("Database")
    WindowSize = field("WindowSize")
    DetectSchema = field("DetectSchema")

    @cached_property
    def StreamingOptions(self):  # pragma: no cover
        return KinesisStreamingSourceOptionsOutput.make_one(
            self.boto3_raw_data["StreamingOptions"]
        )

    @cached_property
    def DataPreviewOptions(self):  # pragma: no cover
        return StreamingDataPreviewOptions.make_one(
            self.boto3_raw_data["DataPreviewOptions"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CatalogKinesisSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CatalogKinesisSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DirectKinesisSourceOutput:
    boto3_raw_data: "type_defs.DirectKinesisSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    WindowSize = field("WindowSize")
    DetectSchema = field("DetectSchema")

    @cached_property
    def StreamingOptions(self):  # pragma: no cover
        return KinesisStreamingSourceOptionsOutput.make_one(
            self.boto3_raw_data["StreamingOptions"]
        )

    @cached_property
    def DataPreviewOptions(self):  # pragma: no cover
        return StreamingDataPreviewOptions.make_one(
            self.boto3_raw_data["DataPreviewOptions"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DirectKinesisSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DirectKinesisSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogPropertiesOutput:
    boto3_raw_data: "type_defs.CatalogPropertiesOutputTypeDef" = dataclasses.field()

    @cached_property
    def DataLakeAccessProperties(self):  # pragma: no cover
        return DataLakeAccessPropertiesOutput.make_one(
            self.boto3_raw_data["DataLakeAccessProperties"]
        )

    @cached_property
    def IcebergOptimizationProperties(self):  # pragma: no cover
        return IcebergOptimizationPropertiesOutput.make_one(
            self.boto3_raw_data["IcebergOptimizationProperties"]
        )

    CustomProperties = field("CustomProperties")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CatalogPropertiesOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CatalogPropertiesOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogProperties:
    boto3_raw_data: "type_defs.CatalogPropertiesTypeDef" = dataclasses.field()

    @cached_property
    def DataLakeAccessProperties(self):  # pragma: no cover
        return DataLakeAccessProperties.make_one(
            self.boto3_raw_data["DataLakeAccessProperties"]
        )

    @cached_property
    def IcebergOptimizationProperties(self):  # pragma: no cover
        return IcebergOptimizationProperties.make_one(
            self.boto3_raw_data["IcebergOptimizationProperties"]
        )

    CustomProperties = field("CustomProperties")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CatalogPropertiesTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CatalogPropertiesTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GovernedCatalogTargetOutput:
    boto3_raw_data: "type_defs.GovernedCatalogTargetOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Table = field("Table")
    Database = field("Database")
    PartitionKeys = field("PartitionKeys")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return CatalogSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GovernedCatalogTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GovernedCatalogTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GovernedCatalogTarget:
    boto3_raw_data: "type_defs.GovernedCatalogTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Table = field("Table")
    Database = field("Database")
    PartitionKeys = field("PartitionKeys")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return CatalogSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GovernedCatalogTargetTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GovernedCatalogTargetTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3CatalogTargetOutput:
    boto3_raw_data: "type_defs.S3CatalogTargetOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Table = field("Table")
    Database = field("Database")
    PartitionKeys = field("PartitionKeys")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return CatalogSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3CatalogTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3CatalogTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3CatalogTarget:
    boto3_raw_data: "type_defs.S3CatalogTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Table = field("Table")
    Database = field("Database")
    PartitionKeys = field("PartitionKeys")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return CatalogSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.S3CatalogTargetTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.S3CatalogTargetTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3IcebergCatalogTargetOutput:
    boto3_raw_data: "type_defs.S3IcebergCatalogTargetOutputTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    Inputs = field("Inputs")
    Table = field("Table")
    Database = field("Database")
    PartitionKeys = field("PartitionKeys")
    AdditionalOptions = field("AdditionalOptions")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return CatalogSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3IcebergCatalogTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3IcebergCatalogTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3IcebergCatalogTarget:
    boto3_raw_data: "type_defs.S3IcebergCatalogTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Table = field("Table")
    Database = field("Database")
    PartitionKeys = field("PartitionKeys")
    AdditionalOptions = field("AdditionalOptions")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return CatalogSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3IcebergCatalogTargetTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3IcebergCatalogTargetTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Classifier:
    boto3_raw_data: "type_defs.ClassifierTypeDef" = dataclasses.field()

    @cached_property
    def GrokClassifier(self):  # pragma: no cover
        return GrokClassifier.make_one(self.boto3_raw_data["GrokClassifier"])

    @cached_property
    def XMLClassifier(self):  # pragma: no cover
        return XMLClassifier.make_one(self.boto3_raw_data["XMLClassifier"])

    @cached_property
    def JsonClassifier(self):  # pragma: no cover
        return JsonClassifier.make_one(self.boto3_raw_data["JsonClassifier"])

    @cached_property
    def CsvClassifier(self):  # pragma: no cover
        return CsvClassifier.make_one(self.boto3_raw_data["CsvClassifier"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ClassifierTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ClassifierTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CodeGenNodeOutput:
    boto3_raw_data: "type_defs.CodeGenNodeOutputTypeDef" = dataclasses.field()

    Id = field("Id")
    NodeType = field("NodeType")

    @cached_property
    def Args(self):  # pragma: no cover
        return CodeGenNodeArg.make_many(self.boto3_raw_data["Args"])

    LineNumber = field("LineNumber")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CodeGenNodeOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CodeGenNodeOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CodeGenNode:
    boto3_raw_data: "type_defs.CodeGenNodeTypeDef" = dataclasses.field()

    Id = field("Id")
    NodeType = field("NodeType")

    @cached_property
    def Args(self):  # pragma: no cover
        return CodeGenNodeArg.make_many(self.boto3_raw_data["Args"])

    LineNumber = field("LineNumber")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CodeGenNodeTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.CodeGenNodeTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Location:
    boto3_raw_data: "type_defs.LocationTypeDef" = dataclasses.field()

    @cached_property
    def Jdbc(self):  # pragma: no cover
        return CodeGenNodeArg.make_many(self.boto3_raw_data["Jdbc"])

    @cached_property
    def S3(self):  # pragma: no cover
        return CodeGenNodeArg.make_many(self.boto3_raw_data["S3"])

    @cached_property
    def DynamoDB(self):  # pragma: no cover
        return CodeGenNodeArg.make_many(self.boto3_raw_data["DynamoDB"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.LocationTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.LocationTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetColumnStatisticsTaskRunResponse:
    boto3_raw_data: "type_defs.GetColumnStatisticsTaskRunResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def ColumnStatisticsTaskRun(self):  # pragma: no cover
        return ColumnStatisticsTaskRun.make_one(
            self.boto3_raw_data["ColumnStatisticsTaskRun"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetColumnStatisticsTaskRunResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetColumnStatisticsTaskRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetColumnStatisticsTaskRunsResponse:
    boto3_raw_data: "type_defs.GetColumnStatisticsTaskRunsResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def ColumnStatisticsTaskRuns(self):  # pragma: no cover
        return ColumnStatisticsTaskRun.make_many(
            self.boto3_raw_data["ColumnStatisticsTaskRuns"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetColumnStatisticsTaskRunsResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetColumnStatisticsTaskRunsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ColumnStatisticsTaskSettings:
    boto3_raw_data: "type_defs.ColumnStatisticsTaskSettingsTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")

    @cached_property
    def Schedule(self):  # pragma: no cover
        return Schedule.make_one(self.boto3_raw_data["Schedule"])

    ColumnNameList = field("ColumnNameList")
    CatalogID = field("CatalogID")
    Role = field("Role")
    SampleSize = field("SampleSize")
    SecurityConfiguration = field("SecurityConfiguration")
    ScheduleType = field("ScheduleType")
    SettingSource = field("SettingSource")

    @cached_property
    def LastExecutionAttempt(self):  # pragma: no cover
        return ExecutionAttempt.make_one(self.boto3_raw_data["LastExecutionAttempt"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ColumnStatisticsTaskSettingsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ColumnStatisticsTaskSettingsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DateColumnStatisticsData:
    boto3_raw_data: "type_defs.DateColumnStatisticsDataTypeDef" = dataclasses.field()

    NumberOfNulls = field("NumberOfNulls")
    NumberOfDistinctValues = field("NumberOfDistinctValues")
    MinimumValue = field("MinimumValue")
    MaximumValue = field("MaximumValue")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DateColumnStatisticsDataTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DateColumnStatisticsDataTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTableRequest:
    boto3_raw_data: "type_defs.GetTableRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    Name = field("Name")
    CatalogId = field("CatalogId")
    TransactionId = field("TransactionId")
    QueryAsOfTime = field("QueryAsOfTime")
    IncludeStatusDetails = field("IncludeStatusDetails")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetTableRequestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.GetTableRequestTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTablesRequest:
    boto3_raw_data: "type_defs.GetTablesRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    CatalogId = field("CatalogId")
    Expression = field("Expression")
    NextToken = field("NextToken")
    MaxResults = field("MaxResults")
    TransactionId = field("TransactionId")
    QueryAsOfTime = field("QueryAsOfTime")
    IncludeStatusDetails = field("IncludeStatusDetails")
    AttributesToGet = field("AttributesToGet")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetTablesRequestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetTablesRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class KafkaStreamingSourceOptions:
    boto3_raw_data: "type_defs.KafkaStreamingSourceOptionsTypeDef" = dataclasses.field()

    BootstrapServers = field("BootstrapServers")
    SecurityProtocol = field("SecurityProtocol")
    ConnectionName = field("ConnectionName")
    TopicName = field("TopicName")
    Assign = field("Assign")
    SubscribePattern = field("SubscribePattern")
    Classification = field("Classification")
    Delimiter = field("Delimiter")
    StartingOffsets = field("StartingOffsets")
    EndingOffsets = field("EndingOffsets")
    PollTimeoutMs = field("PollTimeoutMs")
    NumRetries = field("NumRetries")
    RetryIntervalMs = field("RetryIntervalMs")
    MaxOffsetsPerTrigger = field("MaxOffsetsPerTrigger")
    MinPartitions = field("MinPartitions")
    IncludeHeaders = field("IncludeHeaders")
    AddRecordTimestamp = field("AddRecordTimestamp")
    EmitConsumerLagMetrics = field("EmitConsumerLagMetrics")
    StartingTimestamp = field("StartingTimestamp")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.KafkaStreamingSourceOptionsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.KafkaStreamingSourceOptionsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class KinesisStreamingSourceOptions:
    boto3_raw_data: "type_defs.KinesisStreamingSourceOptionsTypeDef" = (
        dataclasses.field()
    )

    EndpointUrl = field("EndpointUrl")
    StreamName = field("StreamName")
    Classification = field("Classification")
    Delimiter = field("Delimiter")
    StartingPosition = field("StartingPosition")
    MaxFetchTimeInMs = field("MaxFetchTimeInMs")
    MaxFetchRecordsPerShard = field("MaxFetchRecordsPerShard")
    MaxRecordPerRead = field("MaxRecordPerRead")
    AddIdleTimeBetweenReads = field("AddIdleTimeBetweenReads")
    IdleTimeBetweenReadsInMs = field("IdleTimeBetweenReadsInMs")
    DescribeShardInterval = field("DescribeShardInterval")
    NumRetries = field("NumRetries")
    RetryIntervalMs = field("RetryIntervalMs")
    MaxRetryIntervalMs = field("MaxRetryIntervalMs")
    AvoidEmptyBatches = field("AvoidEmptyBatches")
    StreamArn = field("StreamArn")
    RoleArn = field("RoleArn")
    RoleSessionName = field("RoleSessionName")
    AddRecordTimestamp = field("AddRecordTimestamp")
    EmitConsumerLagMetrics = field("EmitConsumerLagMetrics")
    StartingTimestamp = field("StartingTimestamp")
    FanoutConsumerARN = field("FanoutConsumerARN")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.KinesisStreamingSourceOptionsTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.KinesisStreamingSourceOptionsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class QuerySessionContext:
    boto3_raw_data: "type_defs.QuerySessionContextTypeDef" = dataclasses.field()

    QueryId = field("QueryId")
    QueryStartTime = field("QueryStartTime")
    ClusterId = field("ClusterId")
    QueryAuthorizationId = field("QueryAuthorizationId")
    AdditionalContext = field("AdditionalContext")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.QuerySessionContextTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.QuerySessionContextTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TaskRunFilterCriteria:
    boto3_raw_data: "type_defs.TaskRunFilterCriteriaTypeDef" = dataclasses.field()

    TaskRunType = field("TaskRunType")
    Status = field("Status")
    StartedBefore = field("StartedBefore")
    StartedAfter = field("StartedAfter")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.TaskRunFilterCriteriaTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TaskRunFilterCriteriaTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TimestampFilter:
    boto3_raw_data: "type_defs.TimestampFilterTypeDef" = dataclasses.field()

    RecordedBefore = field("RecordedBefore")
    RecordedAfter = field("RecordedAfter")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.TimestampFilterTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.TimestampFilterTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CompactionConfiguration:
    boto3_raw_data: "type_defs.CompactionConfigurationTypeDef" = dataclasses.field()

    @cached_property
    def icebergConfiguration(self):  # pragma: no cover
        return IcebergCompactionConfiguration.make_one(
            self.boto3_raw_data["icebergConfiguration"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CompactionConfigurationTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CompactionConfigurationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CompactionMetrics:
    boto3_raw_data: "type_defs.CompactionMetricsTypeDef" = dataclasses.field()

    @cached_property
    def IcebergMetrics(self):  # pragma: no cover
        return IcebergCompactionMetrics.make_one(self.boto3_raw_data["IcebergMetrics"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CompactionMetricsTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CompactionMetricsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PredicateOutput:
    boto3_raw_data: "type_defs.PredicateOutputTypeDef" = dataclasses.field()

    Logical = field("Logical")

    @cached_property
    def Conditions(self):  # pragma: no cover
        return Condition.make_many(self.boto3_raw_data["Conditions"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.PredicateOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.PredicateOutputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Predicate:
    boto3_raw_data: "type_defs.PredicateTypeDef" = dataclasses.field()

    Logical = field("Logical")

    @cached_property
    def Conditions(self):  # pragma: no cover
        return Condition.make_many(self.boto3_raw_data["Conditions"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.PredicateTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.PredicateTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ProfileConfigurationOutput:
    boto3_raw_data: "type_defs.ProfileConfigurationOutputTypeDef" = dataclasses.field()

    SessionConfiguration = field("SessionConfiguration")
    JobConfiguration = field("JobConfiguration")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ProfileConfigurationOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ProfileConfigurationOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ProfileConfiguration:
    boto3_raw_data: "type_defs.ProfileConfigurationTypeDef" = dataclasses.field()

    SessionConfiguration = field("SessionConfiguration")
    JobConfiguration = field("JobConfiguration")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ProfileConfigurationTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ProfileConfigurationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class FindMatchesMetrics:
    boto3_raw_data: "type_defs.FindMatchesMetricsTypeDef" = dataclasses.field()

    AreaUnderPRCurve = field("AreaUnderPRCurve")
    Precision = field("Precision")
    Recall = field("Recall")
    F1 = field("F1")

    @cached_property
    def ConfusionMatrix(self):  # pragma: no cover
        return ConfusionMatrix.make_one(self.boto3_raw_data["ConfusionMatrix"])

    @cached_property
    def ColumnImportances(self):  # pragma: no cover
        return ColumnImportance.make_many(self.boto3_raw_data["ColumnImportances"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.FindMatchesMetricsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.FindMatchesMetricsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ConnectionTypeBrief:
    boto3_raw_data: "type_defs.ConnectionTypeBriefTypeDef" = dataclasses.field()

    ConnectionType = field("ConnectionType")
    DisplayName = field("DisplayName")
    Vendor = field("Vendor")
    Description = field("Description")
    Categories = field("Categories")

    @cached_property
    def Capabilities(self):  # pragma: no cover
        return Capabilities.make_one(self.boto3_raw_data["Capabilities"])

    LogoUrl = field("LogoUrl")

    @cached_property
    def ConnectionTypeVariants(self):  # pragma: no cover
        return ConnectionTypeVariant.make_many(
            self.boto3_raw_data["ConnectionTypeVariants"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ConnectionTypeBriefTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ConnectionTypeBriefTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CrawlerNodeDetails:
    boto3_raw_data: "type_defs.CrawlerNodeDetailsTypeDef" = dataclasses.field()

    @cached_property
    def Crawls(self):  # pragma: no cover
        return Crawl.make_many(self.boto3_raw_data["Crawls"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CrawlerNodeDetailsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CrawlerNodeDetailsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListCrawlsResponse:
    boto3_raw_data: "type_defs.ListCrawlsResponseTypeDef" = dataclasses.field()

    @cached_property
    def Crawls(self):  # pragma: no cover
        return CrawlerHistory.make_many(self.boto3_raw_data["Crawls"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListCrawlsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListCrawlsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetCrawlerMetricsResponse:
    boto3_raw_data: "type_defs.GetCrawlerMetricsResponseTypeDef" = dataclasses.field()

    @cached_property
    def CrawlerMetricsList(self):  # pragma: no cover
        return CrawlerMetrics.make_many(self.boto3_raw_data["CrawlerMetricsList"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetCrawlerMetricsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetCrawlerMetricsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CrawlerTargetsOutput:
    boto3_raw_data: "type_defs.CrawlerTargetsOutputTypeDef" = dataclasses.field()

    @cached_property
    def S3Targets(self):  # pragma: no cover
        return S3TargetOutput.make_many(self.boto3_raw_data["S3Targets"])

    @cached_property
    def JdbcTargets(self):  # pragma: no cover
        return JdbcTargetOutput.make_many(self.boto3_raw_data["JdbcTargets"])

    @cached_property
    def MongoDBTargets(self):  # pragma: no cover
        return MongoDBTarget.make_many(self.boto3_raw_data["MongoDBTargets"])

    @cached_property
    def DynamoDBTargets(self):  # pragma: no cover
        return DynamoDBTarget.make_many(self.boto3_raw_data["DynamoDBTargets"])

    @cached_property
    def CatalogTargets(self):  # pragma: no cover
        return CatalogTargetOutput.make_many(self.boto3_raw_data["CatalogTargets"])

    @cached_property
    def DeltaTargets(self):  # pragma: no cover
        return DeltaTargetOutput.make_many(self.boto3_raw_data["DeltaTargets"])

    @cached_property
    def IcebergTargets(self):  # pragma: no cover
        return IcebergTargetOutput.make_many(self.boto3_raw_data["IcebergTargets"])

    @cached_property
    def HudiTargets(self):  # pragma: no cover
        return HudiTargetOutput.make_many(self.boto3_raw_data["HudiTargets"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CrawlerTargetsOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CrawlerTargetsOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CrawlerTargets:
    boto3_raw_data: "type_defs.CrawlerTargetsTypeDef" = dataclasses.field()

    @cached_property
    def S3Targets(self):  # pragma: no cover
        return S3Target.make_many(self.boto3_raw_data["S3Targets"])

    @cached_property
    def JdbcTargets(self):  # pragma: no cover
        return JdbcTarget.make_many(self.boto3_raw_data["JdbcTargets"])

    @cached_property
    def MongoDBTargets(self):  # pragma: no cover
        return MongoDBTarget.make_many(self.boto3_raw_data["MongoDBTargets"])

    @cached_property
    def DynamoDBTargets(self):  # pragma: no cover
        return DynamoDBTarget.make_many(self.boto3_raw_data["DynamoDBTargets"])

    @cached_property
    def CatalogTargets(self):  # pragma: no cover
        return CatalogTarget.make_many(self.boto3_raw_data["CatalogTargets"])

    @cached_property
    def DeltaTargets(self):  # pragma: no cover
        return DeltaTarget.make_many(self.boto3_raw_data["DeltaTargets"])

    @cached_property
    def IcebergTargets(self):  # pragma: no cover
        return IcebergTarget.make_many(self.boto3_raw_data["IcebergTargets"])

    @cached_property
    def HudiTargets(self):  # pragma: no cover
        return HudiTarget.make_many(self.boto3_raw_data["HudiTargets"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CrawlerTargetsTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.CrawlerTargetsTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListCrawlsRequest:
    boto3_raw_data: "type_defs.ListCrawlsRequestTypeDef" = dataclasses.field()

    CrawlerName = field("CrawlerName")
    MaxResults = field("MaxResults")

    @cached_property
    def Filters(self):  # pragma: no cover
        return CrawlsFilter.make_many(self.boto3_raw_data["Filters"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ListCrawlsRequestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListCrawlsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateClassifierRequest:
    boto3_raw_data: "type_defs.CreateClassifierRequestTypeDef" = dataclasses.field()

    @cached_property
    def GrokClassifier(self):  # pragma: no cover
        return CreateGrokClassifierRequest.make_one(
            self.boto3_raw_data["GrokClassifier"]
        )

    @cached_property
    def XMLClassifier(self):  # pragma: no cover
        return CreateXMLClassifierRequest.make_one(self.boto3_raw_data["XMLClassifier"])

    @cached_property
    def JsonClassifier(self):  # pragma: no cover
        return CreateJsonClassifierRequest.make_one(
            self.boto3_raw_data["JsonClassifier"]
        )

    @cached_property
    def CsvClassifier(self):  # pragma: no cover
        return CreateCsvClassifierRequest.make_one(self.boto3_raw_data["CsvClassifier"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateClassifierRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateClassifierRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateDataQualityRulesetRequest:
    boto3_raw_data: "type_defs.CreateDataQualityRulesetRequestTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    Ruleset = field("Ruleset")
    Description = field("Description")
    Tags = field("Tags")

    @cached_property
    def TargetTable(self):  # pragma: no cover
        return DataQualityTargetTable.make_one(self.boto3_raw_data["TargetTable"])

    DataQualitySecurityConfiguration = field("DataQualitySecurityConfiguration")
    ClientToken = field("ClientToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.CreateDataQualityRulesetRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateDataQualityRulesetRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityRulesetFilterCriteria:
    boto3_raw_data: "type_defs.DataQualityRulesetFilterCriteriaTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    Description = field("Description")
    CreatedBefore = field("CreatedBefore")
    CreatedAfter = field("CreatedAfter")
    LastModifiedBefore = field("LastModifiedBefore")
    LastModifiedAfter = field("LastModifiedAfter")

    @cached_property
    def TargetTable(self):  # pragma: no cover
        return DataQualityTargetTable.make_one(self.boto3_raw_data["TargetTable"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.DataQualityRulesetFilterCriteriaTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityRulesetFilterCriteriaTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityRulesetListDetails:
    boto3_raw_data: "type_defs.DataQualityRulesetListDetailsTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    Description = field("Description")
    CreatedOn = field("CreatedOn")
    LastModifiedOn = field("LastModifiedOn")

    @cached_property
    def TargetTable(self):  # pragma: no cover
        return DataQualityTargetTable.make_one(self.boto3_raw_data["TargetTable"])

    RecommendationRunId = field("RecommendationRunId")
    RuleCount = field("RuleCount")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.DataQualityRulesetListDetailsTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityRulesetListDetailsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDataQualityRulesetResponse:
    boto3_raw_data: "type_defs.GetDataQualityRulesetResponseTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    Description = field("Description")
    Ruleset = field("Ruleset")

    @cached_property
    def TargetTable(self):  # pragma: no cover
        return DataQualityTargetTable.make_one(self.boto3_raw_data["TargetTable"])

    CreatedOn = field("CreatedOn")
    LastModifiedOn = field("LastModifiedOn")
    RecommendationRunId = field("RecommendationRunId")
    DataQualitySecurityConfiguration = field("DataQualitySecurityConfiguration")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetDataQualityRulesetResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDataQualityRulesetResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateIntegrationResourcePropertyRequest:
    boto3_raw_data: "type_defs.CreateIntegrationResourcePropertyRequestTypeDef" = (
        dataclasses.field()
    )

    ResourceArn = field("ResourceArn")

    @cached_property
    def SourceProcessingProperties(self):  # pragma: no cover
        return SourceProcessingProperties.make_one(
            self.boto3_raw_data["SourceProcessingProperties"]
        )

    @cached_property
    def TargetProcessingProperties(self):  # pragma: no cover
        return TargetProcessingProperties.make_one(
            self.boto3_raw_data["TargetProcessingProperties"]
        )

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.CreateIntegrationResourcePropertyRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateIntegrationResourcePropertyRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateIntegrationResourcePropertyResponse:
    boto3_raw_data: "type_defs.CreateIntegrationResourcePropertyResponseTypeDef" = (
        dataclasses.field()
    )

    ResourceArn = field("ResourceArn")

    @cached_property
    def SourceProcessingProperties(self):  # pragma: no cover
        return SourceProcessingProperties.make_one(
            self.boto3_raw_data["SourceProcessingProperties"]
        )

    @cached_property
    def TargetProcessingProperties(self):  # pragma: no cover
        return TargetProcessingProperties.make_one(
            self.boto3_raw_data["TargetProcessingProperties"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.CreateIntegrationResourcePropertyResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateIntegrationResourcePropertyResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetIntegrationResourcePropertyResponse:
    boto3_raw_data: "type_defs.GetIntegrationResourcePropertyResponseTypeDef" = (
        dataclasses.field()
    )

    ResourceArn = field("ResourceArn")

    @cached_property
    def SourceProcessingProperties(self):  # pragma: no cover
        return SourceProcessingProperties.make_one(
            self.boto3_raw_data["SourceProcessingProperties"]
        )

    @cached_property
    def TargetProcessingProperties(self):  # pragma: no cover
        return TargetProcessingProperties.make_one(
            self.boto3_raw_data["TargetProcessingProperties"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetIntegrationResourcePropertyResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetIntegrationResourcePropertyResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateIntegrationResourcePropertyRequest:
    boto3_raw_data: "type_defs.UpdateIntegrationResourcePropertyRequestTypeDef" = (
        dataclasses.field()
    )

    ResourceArn = field("ResourceArn")

    @cached_property
    def SourceProcessingProperties(self):  # pragma: no cover
        return SourceProcessingProperties.make_one(
            self.boto3_raw_data["SourceProcessingProperties"]
        )

    @cached_property
    def TargetProcessingProperties(self):  # pragma: no cover
        return TargetProcessingProperties.make_one(
            self.boto3_raw_data["TargetProcessingProperties"]
        )

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.UpdateIntegrationResourcePropertyRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateIntegrationResourcePropertyRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateIntegrationResourcePropertyResponse:
    boto3_raw_data: "type_defs.UpdateIntegrationResourcePropertyResponseTypeDef" = (
        dataclasses.field()
    )

    ResourceArn = field("ResourceArn")

    @cached_property
    def SourceProcessingProperties(self):  # pragma: no cover
        return SourceProcessingProperties.make_one(
            self.boto3_raw_data["SourceProcessingProperties"]
        )

    @cached_property
    def TargetProcessingProperties(self):  # pragma: no cover
        return TargetProcessingProperties.make_one(
            self.boto3_raw_data["TargetProcessingProperties"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.UpdateIntegrationResourcePropertyResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateIntegrationResourcePropertyResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateIntegrationResponse:
    boto3_raw_data: "type_defs.CreateIntegrationResponseTypeDef" = dataclasses.field()

    SourceArn = field("SourceArn")
    TargetArn = field("TargetArn")
    IntegrationName = field("IntegrationName")
    Description = field("Description")
    IntegrationArn = field("IntegrationArn")
    KmsKeyId = field("KmsKeyId")
    AdditionalEncryptionContext = field("AdditionalEncryptionContext")

    @cached_property
    def Tags(self):  # pragma: no cover
        return Tag.make_many(self.boto3_raw_data["Tags"])

    Status = field("Status")
    CreateTime = field("CreateTime")

    @cached_property
    def Errors(self):  # pragma: no cover
        return IntegrationError.make_many(self.boto3_raw_data["Errors"])

    DataFilter = field("DataFilter")

    @cached_property
    def IntegrationConfig(self):  # pragma: no cover
        return IntegrationConfigOutput.make_one(
            self.boto3_raw_data["IntegrationConfig"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateIntegrationResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateIntegrationResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteIntegrationResponse:
    boto3_raw_data: "type_defs.DeleteIntegrationResponseTypeDef" = dataclasses.field()

    SourceArn = field("SourceArn")
    TargetArn = field("TargetArn")
    IntegrationName = field("IntegrationName")
    Description = field("Description")
    IntegrationArn = field("IntegrationArn")
    KmsKeyId = field("KmsKeyId")
    AdditionalEncryptionContext = field("AdditionalEncryptionContext")

    @cached_property
    def Tags(self):  # pragma: no cover
        return Tag.make_many(self.boto3_raw_data["Tags"])

    Status = field("Status")
    CreateTime = field("CreateTime")

    @cached_property
    def Errors(self):  # pragma: no cover
        return IntegrationError.make_many(self.boto3_raw_data["Errors"])

    DataFilter = field("DataFilter")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteIntegrationResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteIntegrationResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class InboundIntegration:
    boto3_raw_data: "type_defs.InboundIntegrationTypeDef" = dataclasses.field()

    SourceArn = field("SourceArn")
    TargetArn = field("TargetArn")
    IntegrationArn = field("IntegrationArn")
    Status = field("Status")
    CreateTime = field("CreateTime")

    @cached_property
    def IntegrationConfig(self):  # pragma: no cover
        return IntegrationConfigOutput.make_one(
            self.boto3_raw_data["IntegrationConfig"]
        )

    @cached_property
    def Errors(self):  # pragma: no cover
        return IntegrationError.make_many(self.boto3_raw_data["Errors"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.InboundIntegrationTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.InboundIntegrationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Integration:
    boto3_raw_data: "type_defs.IntegrationTypeDef" = dataclasses.field()

    SourceArn = field("SourceArn")
    TargetArn = field("TargetArn")
    IntegrationName = field("IntegrationName")
    IntegrationArn = field("IntegrationArn")
    Status = field("Status")
    CreateTime = field("CreateTime")
    Description = field("Description")
    KmsKeyId = field("KmsKeyId")
    AdditionalEncryptionContext = field("AdditionalEncryptionContext")

    @cached_property
    def Tags(self):  # pragma: no cover
        return Tag.make_many(self.boto3_raw_data["Tags"])

    @cached_property
    def IntegrationConfig(self):  # pragma: no cover
        return IntegrationConfigOutput.make_one(
            self.boto3_raw_data["IntegrationConfig"]
        )

    @cached_property
    def Errors(self):  # pragma: no cover
        return IntegrationError.make_many(self.boto3_raw_data["Errors"])

    DataFilter = field("DataFilter")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.IntegrationTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.IntegrationTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ModifyIntegrationResponse:
    boto3_raw_data: "type_defs.ModifyIntegrationResponseTypeDef" = dataclasses.field()

    SourceArn = field("SourceArn")
    TargetArn = field("TargetArn")
    IntegrationName = field("IntegrationName")
    Description = field("Description")
    IntegrationArn = field("IntegrationArn")
    KmsKeyId = field("KmsKeyId")
    AdditionalEncryptionContext = field("AdditionalEncryptionContext")

    @cached_property
    def Tags(self):  # pragma: no cover
        return Tag.make_many(self.boto3_raw_data["Tags"])

    Status = field("Status")
    CreateTime = field("CreateTime")

    @cached_property
    def Errors(self):  # pragma: no cover
        return IntegrationError.make_many(self.boto3_raw_data["Errors"])

    DataFilter = field("DataFilter")

    @cached_property
    def IntegrationConfig(self):  # pragma: no cover
        return IntegrationConfigOutput.make_one(
            self.boto3_raw_data["IntegrationConfig"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ModifyIntegrationResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ModifyIntegrationResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreatePartitionIndexRequest:
    boto3_raw_data: "type_defs.CreatePartitionIndexRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")

    @cached_property
    def PartitionIndex(self):  # pragma: no cover
        return PartitionIndex.make_one(self.boto3_raw_data["PartitionIndex"])

    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreatePartitionIndexRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreatePartitionIndexRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateSchemaInput:
    boto3_raw_data: "type_defs.CreateSchemaInputTypeDef" = dataclasses.field()

    SchemaName = field("SchemaName")
    DataFormat = field("DataFormat")

    @cached_property
    def RegistryId(self):  # pragma: no cover
        return RegistryId.make_one(self.boto3_raw_data["RegistryId"])

    Compatibility = field("Compatibility")
    Description = field("Description")
    Tags = field("Tags")
    SchemaDefinition = field("SchemaDefinition")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CreateSchemaInputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateSchemaInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteRegistryInput:
    boto3_raw_data: "type_defs.DeleteRegistryInputTypeDef" = dataclasses.field()

    @cached_property
    def RegistryId(self):  # pragma: no cover
        return RegistryId.make_one(self.boto3_raw_data["RegistryId"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteRegistryInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteRegistryInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetRegistryInput:
    boto3_raw_data: "type_defs.GetRegistryInputTypeDef" = dataclasses.field()

    @cached_property
    def RegistryId(self):  # pragma: no cover
        return RegistryId.make_one(self.boto3_raw_data["RegistryId"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetRegistryInputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetRegistryInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListSchemasInput:
    boto3_raw_data: "type_defs.ListSchemasInputTypeDef" = dataclasses.field()

    @cached_property
    def RegistryId(self):  # pragma: no cover
        return RegistryId.make_one(self.boto3_raw_data["RegistryId"])

    MaxResults = field("MaxResults")
    NextToken = field("NextToken")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ListSchemasInputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListSchemasInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateRegistryInput:
    boto3_raw_data: "type_defs.UpdateRegistryInputTypeDef" = dataclasses.field()

    @cached_property
    def RegistryId(self):  # pragma: no cover
        return RegistryId.make_one(self.boto3_raw_data["RegistryId"])

    Description = field("Description")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateRegistryInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateRegistryInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Session:
    boto3_raw_data: "type_defs.SessionTypeDef" = dataclasses.field()

    Id = field("Id")
    CreatedOn = field("CreatedOn")
    Status = field("Status")
    ErrorMessage = field("ErrorMessage")
    Description = field("Description")
    Role = field("Role")

    @cached_property
    def Command(self):  # pragma: no cover
        return SessionCommand.make_one(self.boto3_raw_data["Command"])

    DefaultArguments = field("DefaultArguments")

    @cached_property
    def Connections(self):  # pragma: no cover
        return ConnectionsListOutput.make_one(self.boto3_raw_data["Connections"])

    Progress = field("Progress")
    MaxCapacity = field("MaxCapacity")
    SecurityConfiguration = field("SecurityConfiguration")
    GlueVersion = field("GlueVersion")
    NumberOfWorkers = field("NumberOfWorkers")
    WorkerType = field("WorkerType")
    CompletedOn = field("CompletedOn")
    ExecutionTime = field("ExecutionTime")
    DPUSeconds = field("DPUSeconds")
    IdleTimeout = field("IdleTimeout")
    ProfileName = field("ProfileName")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SessionTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SessionTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DynamoDBCatalogSource:
    boto3_raw_data: "type_defs.DynamoDBCatalogSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    PitrEnabled = field("PitrEnabled")

    @cached_property
    def AdditionalOptions(self):  # pragma: no cover
        return DDBELTCatalogAdditionalOptions.make_one(
            self.boto3_raw_data["AdditionalOptions"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DynamoDBCatalogSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DynamoDBCatalogSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class EvaluateDataQualityMultiFrameOutput:
    boto3_raw_data: "type_defs.EvaluateDataQualityMultiFrameOutputTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    Inputs = field("Inputs")
    Ruleset = field("Ruleset")
    AdditionalDataSources = field("AdditionalDataSources")

    @cached_property
    def PublishingOptions(self):  # pragma: no cover
        return DQResultsPublishingOptions.make_one(
            self.boto3_raw_data["PublishingOptions"]
        )

    AdditionalOptions = field("AdditionalOptions")

    @cached_property
    def StopJobOnFailureOptions(self):  # pragma: no cover
        return DQStopJobOnFailureOptions.make_one(
            self.boto3_raw_data["StopJobOnFailureOptions"]
        )

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.EvaluateDataQualityMultiFrameOutputTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.EvaluateDataQualityMultiFrameOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class EvaluateDataQualityMultiFrame:
    boto3_raw_data: "type_defs.EvaluateDataQualityMultiFrameTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    Inputs = field("Inputs")
    Ruleset = field("Ruleset")
    AdditionalDataSources = field("AdditionalDataSources")

    @cached_property
    def PublishingOptions(self):  # pragma: no cover
        return DQResultsPublishingOptions.make_one(
            self.boto3_raw_data["PublishingOptions"]
        )

    AdditionalOptions = field("AdditionalOptions")

    @cached_property
    def StopJobOnFailureOptions(self):  # pragma: no cover
        return DQStopJobOnFailureOptions.make_one(
            self.boto3_raw_data["StopJobOnFailureOptions"]
        )

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.EvaluateDataQualityMultiFrameTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.EvaluateDataQualityMultiFrameTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class EvaluateDataQualityOutput:
    boto3_raw_data: "type_defs.EvaluateDataQualityOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Ruleset = field("Ruleset")
    Output = field("Output")

    @cached_property
    def PublishingOptions(self):  # pragma: no cover
        return DQResultsPublishingOptions.make_one(
            self.boto3_raw_data["PublishingOptions"]
        )

    @cached_property
    def StopJobOnFailureOptions(self):  # pragma: no cover
        return DQStopJobOnFailureOptions.make_one(
            self.boto3_raw_data["StopJobOnFailureOptions"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.EvaluateDataQualityOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.EvaluateDataQualityOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class EvaluateDataQuality:
    boto3_raw_data: "type_defs.EvaluateDataQualityTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Ruleset = field("Ruleset")
    Output = field("Output")

    @cached_property
    def PublishingOptions(self):  # pragma: no cover
        return DQResultsPublishingOptions.make_one(
            self.boto3_raw_data["PublishingOptions"]
        )

    @cached_property
    def StopJobOnFailureOptions(self):  # pragma: no cover
        return DQStopJobOnFailureOptions.make_one(
            self.boto3_raw_data["StopJobOnFailureOptions"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.EvaluateDataQualityTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.EvaluateDataQualityTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataCatalogEncryptionSettings:
    boto3_raw_data: "type_defs.DataCatalogEncryptionSettingsTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def EncryptionAtRest(self):  # pragma: no cover
        return EncryptionAtRest.make_one(self.boto3_raw_data["EncryptionAtRest"])

    @cached_property
    def ConnectionPasswordEncryption(self):  # pragma: no cover
        return ConnectionPasswordEncryption.make_one(
            self.boto3_raw_data["ConnectionPasswordEncryption"]
        )

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.DataCatalogEncryptionSettingsTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataCatalogEncryptionSettingsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PrincipalPermissionsOutput:
    boto3_raw_data: "type_defs.PrincipalPermissionsOutputTypeDef" = dataclasses.field()

    @cached_property
    def Principal(self):  # pragma: no cover
        return DataLakePrincipal.make_one(self.boto3_raw_data["Principal"])

    Permissions = field("Permissions")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.PrincipalPermissionsOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PrincipalPermissionsOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PrincipalPermissions:
    boto3_raw_data: "type_defs.PrincipalPermissionsTypeDef" = dataclasses.field()

    @cached_property
    def Principal(self):  # pragma: no cover
        return DataLakePrincipal.make_one(self.boto3_raw_data["Principal"])

    Permissions = field("Permissions")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.PrincipalPermissionsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PrincipalPermissionsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class MetricBasedObservation:
    boto3_raw_data: "type_defs.MetricBasedObservationTypeDef" = dataclasses.field()

    MetricName = field("MetricName")
    StatisticId = field("StatisticId")

    @cached_property
    def MetricValues(self):  # pragma: no cover
        return DataQualityMetricValues.make_one(self.boto3_raw_data["MetricValues"])

    NewRules = field("NewRules")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.MetricBasedObservationTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.MetricBasedObservationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataSourceOutput:
    boto3_raw_data: "type_defs.DataSourceOutputTypeDef" = dataclasses.field()

    @cached_property
    def GlueTable(self):  # pragma: no cover
        return GlueTableOutput.make_one(self.boto3_raw_data["GlueTable"])

    @cached_property
    def DataQualityGlueTable(self):  # pragma: no cover
        return DataQualityGlueTableOutput.make_one(
            self.boto3_raw_data["DataQualityGlueTable"]
        )

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DataSourceOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class NullValueField:
    boto3_raw_data: "type_defs.NullValueFieldTypeDef" = dataclasses.field()

    Value = field("Value")

    @cached_property
    def Datatype(self):  # pragma: no cover
        return Datatype.make_one(self.boto3_raw_data["Datatype"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.NullValueFieldTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.NullValueFieldTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DecimalColumnStatisticsDataOutput:
    boto3_raw_data: "type_defs.DecimalColumnStatisticsDataOutputTypeDef" = (
        dataclasses.field()
    )

    NumberOfNulls = field("NumberOfNulls")
    NumberOfDistinctValues = field("NumberOfDistinctValues")

    @cached_property
    def MinimumValue(self):  # pragma: no cover
        return DecimalNumberOutput.make_one(self.boto3_raw_data["MinimumValue"])

    @cached_property
    def MaximumValue(self):  # pragma: no cover
        return DecimalNumberOutput.make_one(self.boto3_raw_data["MaximumValue"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.DecimalColumnStatisticsDataOutputTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DecimalColumnStatisticsDataOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteSchemaInput:
    boto3_raw_data: "type_defs.DeleteSchemaInputTypeDef" = dataclasses.field()

    @cached_property
    def SchemaId(self):  # pragma: no cover
        return SchemaId.make_one(self.boto3_raw_data["SchemaId"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DeleteSchemaInputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteSchemaInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteSchemaVersionsInput:
    boto3_raw_data: "type_defs.DeleteSchemaVersionsInputTypeDef" = dataclasses.field()

    @cached_property
    def SchemaId(self):  # pragma: no cover
        return SchemaId.make_one(self.boto3_raw_data["SchemaId"])

    Versions = field("Versions")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteSchemaVersionsInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteSchemaVersionsInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetSchemaByDefinitionInput:
    boto3_raw_data: "type_defs.GetSchemaByDefinitionInputTypeDef" = dataclasses.field()

    @cached_property
    def SchemaId(self):  # pragma: no cover
        return SchemaId.make_one(self.boto3_raw_data["SchemaId"])

    SchemaDefinition = field("SchemaDefinition")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetSchemaByDefinitionInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetSchemaByDefinitionInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetSchemaInput:
    boto3_raw_data: "type_defs.GetSchemaInputTypeDef" = dataclasses.field()

    @cached_property
    def SchemaId(self):  # pragma: no cover
        return SchemaId.make_one(self.boto3_raw_data["SchemaId"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetSchemaInputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.GetSchemaInputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListSchemaVersionsInput:
    boto3_raw_data: "type_defs.ListSchemaVersionsInputTypeDef" = dataclasses.field()

    @cached_property
    def SchemaId(self):  # pragma: no cover
        return SchemaId.make_one(self.boto3_raw_data["SchemaId"])

    MaxResults = field("MaxResults")
    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListSchemaVersionsInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListSchemaVersionsInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RegisterSchemaVersionInput:
    boto3_raw_data: "type_defs.RegisterSchemaVersionInputTypeDef" = dataclasses.field()

    @cached_property
    def SchemaId(self):  # pragma: no cover
        return SchemaId.make_one(self.boto3_raw_data["SchemaId"])

    SchemaDefinition = field("SchemaDefinition")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.RegisterSchemaVersionInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.RegisterSchemaVersionInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SchemaReference:
    boto3_raw_data: "type_defs.SchemaReferenceTypeDef" = dataclasses.field()

    @cached_property
    def SchemaId(self):  # pragma: no cover
        return SchemaId.make_one(self.boto3_raw_data["SchemaId"])

    SchemaVersionId = field("SchemaVersionId")
    SchemaVersionNumber = field("SchemaVersionNumber")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SchemaReferenceTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SchemaReferenceTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DescribeEntityRequestPaginate:
    boto3_raw_data: "type_defs.DescribeEntityRequestPaginateTypeDef" = (
        dataclasses.field()
    )

    ConnectionName = field("ConnectionName")
    EntityName = field("EntityName")
    CatalogId = field("CatalogId")
    DataStoreApiVersion = field("DataStoreApiVersion")

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.DescribeEntityRequestPaginateTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DescribeEntityRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetClassifiersRequestPaginate:
    boto3_raw_data: "type_defs.GetClassifiersRequestPaginateTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetClassifiersRequestPaginateTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetClassifiersRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetCrawlerMetricsRequestPaginate:
    boto3_raw_data: "type_defs.GetCrawlerMetricsRequestPaginateTypeDef" = (
        dataclasses.field()
    )

    CrawlerNameList = field("CrawlerNameList")

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetCrawlerMetricsRequestPaginateTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetCrawlerMetricsRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetCrawlersRequestPaginate:
    boto3_raw_data: "type_defs.GetCrawlersRequestPaginateTypeDef" = dataclasses.field()

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetCrawlersRequestPaginateTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetCrawlersRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDatabasesRequestPaginate:
    boto3_raw_data: "type_defs.GetDatabasesRequestPaginateTypeDef" = dataclasses.field()

    CatalogId = field("CatalogId")
    ResourceShareType = field("ResourceShareType")
    AttributesToGet = field("AttributesToGet")

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetDatabasesRequestPaginateTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDatabasesRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDevEndpointsRequestPaginate:
    boto3_raw_data: "type_defs.GetDevEndpointsRequestPaginateTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetDevEndpointsRequestPaginateTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDevEndpointsRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetJobRunsRequestPaginate:
    boto3_raw_data: "type_defs.GetJobRunsRequestPaginateTypeDef" = dataclasses.field()

    JobName = field("JobName")

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetJobRunsRequestPaginateTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetJobRunsRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetJobsRequestPaginate:
    boto3_raw_data: "type_defs.GetJobsRequestPaginateTypeDef" = dataclasses.field()

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetJobsRequestPaginateTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetJobsRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetPartitionIndexesRequestPaginate:
    boto3_raw_data: "type_defs.GetPartitionIndexesRequestPaginateTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    CatalogId = field("CatalogId")

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetPartitionIndexesRequestPaginateTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetPartitionIndexesRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetResourcePoliciesRequestPaginate:
    boto3_raw_data: "type_defs.GetResourcePoliciesRequestPaginateTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetResourcePoliciesRequestPaginateTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetResourcePoliciesRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetSecurityConfigurationsRequestPaginate:
    boto3_raw_data: "type_defs.GetSecurityConfigurationsRequestPaginateTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetSecurityConfigurationsRequestPaginateTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetSecurityConfigurationsRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTableVersionsRequestPaginate:
    boto3_raw_data: "type_defs.GetTableVersionsRequestPaginateTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    CatalogId = field("CatalogId")

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetTableVersionsRequestPaginateTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetTableVersionsRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTablesRequestPaginate:
    boto3_raw_data: "type_defs.GetTablesRequestPaginateTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    CatalogId = field("CatalogId")
    Expression = field("Expression")
    TransactionId = field("TransactionId")
    QueryAsOfTime = field("QueryAsOfTime")
    IncludeStatusDetails = field("IncludeStatusDetails")
    AttributesToGet = field("AttributesToGet")

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetTablesRequestPaginateTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetTablesRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTriggersRequestPaginate:
    boto3_raw_data: "type_defs.GetTriggersRequestPaginateTypeDef" = dataclasses.field()

    DependentJobName = field("DependentJobName")

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetTriggersRequestPaginateTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetTriggersRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetUserDefinedFunctionsRequestPaginate:
    boto3_raw_data: "type_defs.GetUserDefinedFunctionsRequestPaginateTypeDef" = (
        dataclasses.field()
    )

    Pattern = field("Pattern")
    CatalogId = field("CatalogId")
    DatabaseName = field("DatabaseName")

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetUserDefinedFunctionsRequestPaginateTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetUserDefinedFunctionsRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetWorkflowRunsRequestPaginate:
    boto3_raw_data: "type_defs.GetWorkflowRunsRequestPaginateTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    IncludeGraph = field("IncludeGraph")

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetWorkflowRunsRequestPaginateTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetWorkflowRunsRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListBlueprintsRequestPaginate:
    boto3_raw_data: "type_defs.ListBlueprintsRequestPaginateTypeDef" = (
        dataclasses.field()
    )

    Tags = field("Tags")

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.ListBlueprintsRequestPaginateTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListBlueprintsRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListConnectionTypesRequestPaginate:
    boto3_raw_data: "type_defs.ListConnectionTypesRequestPaginateTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.ListConnectionTypesRequestPaginateTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListConnectionTypesRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListEntitiesRequestPaginate:
    boto3_raw_data: "type_defs.ListEntitiesRequestPaginateTypeDef" = dataclasses.field()

    ConnectionName = field("ConnectionName")
    CatalogId = field("CatalogId")
    ParentEntityName = field("ParentEntityName")
    DataStoreApiVersion = field("DataStoreApiVersion")

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListEntitiesRequestPaginateTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListEntitiesRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListJobsRequestPaginate:
    boto3_raw_data: "type_defs.ListJobsRequestPaginateTypeDef" = dataclasses.field()

    Tags = field("Tags")

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListJobsRequestPaginateTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListJobsRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListRegistriesInputPaginate:
    boto3_raw_data: "type_defs.ListRegistriesInputPaginateTypeDef" = dataclasses.field()

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListRegistriesInputPaginateTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListRegistriesInputPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListSchemaVersionsInputPaginate:
    boto3_raw_data: "type_defs.ListSchemaVersionsInputPaginateTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def SchemaId(self):  # pragma: no cover
        return SchemaId.make_one(self.boto3_raw_data["SchemaId"])

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.ListSchemaVersionsInputPaginateTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListSchemaVersionsInputPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListSchemasInputPaginate:
    boto3_raw_data: "type_defs.ListSchemasInputPaginateTypeDef" = dataclasses.field()

    @cached_property
    def RegistryId(self):  # pragma: no cover
        return RegistryId.make_one(self.boto3_raw_data["RegistryId"])

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListSchemasInputPaginateTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListSchemasInputPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListTableOptimizerRunsRequestPaginate:
    boto3_raw_data: "type_defs.ListTableOptimizerRunsRequestPaginateTypeDef" = (
        dataclasses.field()
    )

    CatalogId = field("CatalogId")
    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    Type = field("Type")

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.ListTableOptimizerRunsRequestPaginateTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListTableOptimizerRunsRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListTriggersRequestPaginate:
    boto3_raw_data: "type_defs.ListTriggersRequestPaginateTypeDef" = dataclasses.field()

    DependentJobName = field("DependentJobName")
    Tags = field("Tags")

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListTriggersRequestPaginateTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListTriggersRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListUsageProfilesRequestPaginate:
    boto3_raw_data: "type_defs.ListUsageProfilesRequestPaginateTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.ListUsageProfilesRequestPaginateTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListUsageProfilesRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListWorkflowsRequestPaginate:
    boto3_raw_data: "type_defs.ListWorkflowsRequestPaginateTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListWorkflowsRequestPaginateTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListWorkflowsRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DescribeEntityResponse:
    boto3_raw_data: "type_defs.DescribeEntityResponseTypeDef" = dataclasses.field()

    @cached_property
    def Fields(self):  # pragma: no cover
        return Field.make_many(self.boto3_raw_data["Fields"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DescribeEntityResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DescribeEntityResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DescribeIntegrationsRequest:
    boto3_raw_data: "type_defs.DescribeIntegrationsRequestTypeDef" = dataclasses.field()

    IntegrationIdentifier = field("IntegrationIdentifier")
    Marker = field("Marker")
    MaxRecords = field("MaxRecords")

    @cached_property
    def Filters(self):  # pragma: no cover
        return IntegrationFilter.make_many(self.boto3_raw_data["Filters"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DescribeIntegrationsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DescribeIntegrationsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateDevEndpointRequest:
    boto3_raw_data: "type_defs.UpdateDevEndpointRequestTypeDef" = dataclasses.field()

    EndpointName = field("EndpointName")
    PublicKey = field("PublicKey")
    AddPublicKeys = field("AddPublicKeys")
    DeletePublicKeys = field("DeletePublicKeys")

    @cached_property
    def CustomLibraries(self):  # pragma: no cover
        return DevEndpointCustomLibraries.make_one(
            self.boto3_raw_data["CustomLibraries"]
        )

    UpdateEtlLibraries = field("UpdateEtlLibraries")
    DeleteArguments = field("DeleteArguments")
    AddArguments = field("AddArguments")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateDevEndpointRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateDevEndpointRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3DeltaDirectTargetOutput:
    boto3_raw_data: "type_defs.S3DeltaDirectTargetOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Path = field("Path")
    Compression = field("Compression")
    Format = field("Format")
    PartitionKeys = field("PartitionKeys")
    NumberTargetPartitions = field("NumberTargetPartitions")
    AdditionalOptions = field("AdditionalOptions")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return DirectSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3DeltaDirectTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3DeltaDirectTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3DeltaDirectTarget:
    boto3_raw_data: "type_defs.S3DeltaDirectTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Path = field("Path")
    Compression = field("Compression")
    Format = field("Format")
    PartitionKeys = field("PartitionKeys")
    NumberTargetPartitions = field("NumberTargetPartitions")
    AdditionalOptions = field("AdditionalOptions")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return DirectSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3DeltaDirectTargetTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3DeltaDirectTargetTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3GlueParquetTargetOutput:
    boto3_raw_data: "type_defs.S3GlueParquetTargetOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Path = field("Path")
    PartitionKeys = field("PartitionKeys")
    Compression = field("Compression")
    NumberTargetPartitions = field("NumberTargetPartitions")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return DirectSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3GlueParquetTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3GlueParquetTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3GlueParquetTarget:
    boto3_raw_data: "type_defs.S3GlueParquetTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Path = field("Path")
    PartitionKeys = field("PartitionKeys")
    Compression = field("Compression")
    NumberTargetPartitions = field("NumberTargetPartitions")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return DirectSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3GlueParquetTargetTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3GlueParquetTargetTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3HudiDirectTargetOutput:
    boto3_raw_data: "type_defs.S3HudiDirectTargetOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Path = field("Path")
    Compression = field("Compression")
    Format = field("Format")
    AdditionalOptions = field("AdditionalOptions")
    NumberTargetPartitions = field("NumberTargetPartitions")
    PartitionKeys = field("PartitionKeys")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return DirectSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3HudiDirectTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3HudiDirectTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3HudiDirectTarget:
    boto3_raw_data: "type_defs.S3HudiDirectTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Path = field("Path")
    Compression = field("Compression")
    Format = field("Format")
    AdditionalOptions = field("AdditionalOptions")
    NumberTargetPartitions = field("NumberTargetPartitions")
    PartitionKeys = field("PartitionKeys")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return DirectSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3HudiDirectTargetTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3HudiDirectTargetTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class EncryptionConfigurationOutput:
    boto3_raw_data: "type_defs.EncryptionConfigurationOutputTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def S3Encryption(self):  # pragma: no cover
        return S3Encryption.make_many(self.boto3_raw_data["S3Encryption"])

    @cached_property
    def CloudWatchEncryption(self):  # pragma: no cover
        return CloudWatchEncryption.make_one(
            self.boto3_raw_data["CloudWatchEncryption"]
        )

    @cached_property
    def JobBookmarksEncryption(self):  # pragma: no cover
        return JobBookmarksEncryption.make_one(
            self.boto3_raw_data["JobBookmarksEncryption"]
        )

    @cached_property
    def DataQualityEncryption(self):  # pragma: no cover
        return DataQualityEncryption.make_one(
            self.boto3_raw_data["DataQualityEncryption"]
        )

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.EncryptionConfigurationOutputTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.EncryptionConfigurationOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class EncryptionConfiguration:
    boto3_raw_data: "type_defs.EncryptionConfigurationTypeDef" = dataclasses.field()

    @cached_property
    def S3Encryption(self):  # pragma: no cover
        return S3Encryption.make_many(self.boto3_raw_data["S3Encryption"])

    @cached_property
    def CloudWatchEncryption(self):  # pragma: no cover
        return CloudWatchEncryption.make_one(
            self.boto3_raw_data["CloudWatchEncryption"]
        )

    @cached_property
    def JobBookmarksEncryption(self):  # pragma: no cover
        return JobBookmarksEncryption.make_one(
            self.boto3_raw_data["JobBookmarksEncryption"]
        )

    @cached_property
    def DataQualityEncryption(self):  # pragma: no cover
        return DataQualityEncryption.make_one(
            self.boto3_raw_data["DataQualityEncryption"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.EncryptionConfigurationTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.EncryptionConfigurationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListEntitiesResponse:
    boto3_raw_data: "type_defs.ListEntitiesResponseTypeDef" = dataclasses.field()

    @cached_property
    def Entities(self):  # pragma: no cover
        return Entity.make_many(self.boto3_raw_data["Entities"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListEntitiesResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListEntitiesResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SchemaVersionErrorItem:
    boto3_raw_data: "type_defs.SchemaVersionErrorItemTypeDef" = dataclasses.field()

    VersionNumber = field("VersionNumber")

    @cached_property
    def ErrorDetails(self):  # pragma: no cover
        return ErrorDetails.make_one(self.boto3_raw_data["ErrorDetails"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SchemaVersionErrorItemTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SchemaVersionErrorItemTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class FilterExpressionOutput:
    boto3_raw_data: "type_defs.FilterExpressionOutputTypeDef" = dataclasses.field()

    Operation = field("Operation")

    @cached_property
    def Values(self):  # pragma: no cover
        return FilterValueOutput.make_many(self.boto3_raw_data["Values"])

    Negated = field("Negated")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.FilterExpressionOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.FilterExpressionOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TransformParameters:
    boto3_raw_data: "type_defs.TransformParametersTypeDef" = dataclasses.field()

    TransformType = field("TransformType")

    @cached_property
    def FindMatchesParameters(self):  # pragma: no cover
        return FindMatchesParameters.make_one(
            self.boto3_raw_data["FindMatchesParameters"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.TransformParametersTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TransformParametersTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetConnectionsRequestPaginate:
    boto3_raw_data: "type_defs.GetConnectionsRequestPaginateTypeDef" = (
        dataclasses.field()
    )

    CatalogId = field("CatalogId")

    @cached_property
    def Filter(self):  # pragma: no cover
        return GetConnectionsFilter.make_one(self.boto3_raw_data["Filter"])

    HidePassword = field("HidePassword")

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetConnectionsRequestPaginateTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetConnectionsRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetConnectionsRequest:
    boto3_raw_data: "type_defs.GetConnectionsRequestTypeDef" = dataclasses.field()

    CatalogId = field("CatalogId")

    @cached_property
    def Filter(self):  # pragma: no cover
        return GetConnectionsFilter.make_one(self.boto3_raw_data["Filter"])

    HidePassword = field("HidePassword")
    NextToken = field("NextToken")
    MaxResults = field("MaxResults")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetConnectionsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetConnectionsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDataQualityModelResultResponse:
    boto3_raw_data: "type_defs.GetDataQualityModelResultResponseTypeDef" = (
        dataclasses.field()
    )

    CompletedOn = field("CompletedOn")

    @cached_property
    def Model(self):  # pragma: no cover
        return StatisticModelResult.make_many(self.boto3_raw_data["Model"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetDataQualityModelResultResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDataQualityModelResultResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetJobBookmarkResponse:
    boto3_raw_data: "type_defs.GetJobBookmarkResponseTypeDef" = dataclasses.field()

    @cached_property
    def JobBookmarkEntry(self):  # pragma: no cover
        return JobBookmarkEntry.make_one(self.boto3_raw_data["JobBookmarkEntry"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetJobBookmarkResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetJobBookmarkResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ResetJobBookmarkResponse:
    boto3_raw_data: "type_defs.ResetJobBookmarkResponseTypeDef" = dataclasses.field()

    @cached_property
    def JobBookmarkEntry(self):  # pragma: no cover
        return JobBookmarkEntry.make_one(self.boto3_raw_data["JobBookmarkEntry"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ResetJobBookmarkResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ResetJobBookmarkResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TransformFilterCriteria:
    boto3_raw_data: "type_defs.TransformFilterCriteriaTypeDef" = dataclasses.field()

    Name = field("Name")
    TransformType = field("TransformType")
    Status = field("Status")
    GlueVersion = field("GlueVersion")
    CreatedBefore = field("CreatedBefore")
    CreatedAfter = field("CreatedAfter")
    LastModifiedBefore = field("LastModifiedBefore")
    LastModifiedAfter = field("LastModifiedAfter")

    @cached_property
    def Schema(self):  # pragma: no cover
        return SchemaColumn.make_many(self.boto3_raw_data["Schema"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.TransformFilterCriteriaTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TransformFilterCriteriaTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetMappingResponse:
    boto3_raw_data: "type_defs.GetMappingResponseTypeDef" = dataclasses.field()

    @cached_property
    def Mapping(self):  # pragma: no cover
        return MappingEntry.make_many(self.boto3_raw_data["Mapping"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetMappingResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetMappingResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetPartitionsRequestPaginate:
    boto3_raw_data: "type_defs.GetPartitionsRequestPaginateTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    CatalogId = field("CatalogId")
    Expression = field("Expression")

    @cached_property
    def Segment(self):  # pragma: no cover
        return Segment.make_one(self.boto3_raw_data["Segment"])

    ExcludeColumnSchema = field("ExcludeColumnSchema")
    TransactionId = field("TransactionId")
    QueryAsOfTime = field("QueryAsOfTime")

    @cached_property
    def PaginationConfig(self):  # pragma: no cover
        return PaginatorConfig.make_one(self.boto3_raw_data["PaginationConfig"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetPartitionsRequestPaginateTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetPartitionsRequestPaginateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetPartitionsRequest:
    boto3_raw_data: "type_defs.GetPartitionsRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    CatalogId = field("CatalogId")
    Expression = field("Expression")
    NextToken = field("NextToken")

    @cached_property
    def Segment(self):  # pragma: no cover
        return Segment.make_one(self.boto3_raw_data["Segment"])

    MaxResults = field("MaxResults")
    ExcludeColumnSchema = field("ExcludeColumnSchema")
    TransactionId = field("TransactionId")
    QueryAsOfTime = field("QueryAsOfTime")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetPartitionsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetPartitionsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetResourcePoliciesResponse:
    boto3_raw_data: "type_defs.GetResourcePoliciesResponseTypeDef" = dataclasses.field()

    @cached_property
    def GetResourcePoliciesResponseList(self):  # pragma: no cover
        return GluePolicy.make_many(
            self.boto3_raw_data["GetResourcePoliciesResponseList"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetResourcePoliciesResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetResourcePoliciesResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetSchemaVersionInput:
    boto3_raw_data: "type_defs.GetSchemaVersionInputTypeDef" = dataclasses.field()

    @cached_property
    def SchemaId(self):  # pragma: no cover
        return SchemaId.make_one(self.boto3_raw_data["SchemaId"])

    SchemaVersionId = field("SchemaVersionId")

    @cached_property
    def SchemaVersionNumber(self):  # pragma: no cover
        return SchemaVersionNumber.make_one(self.boto3_raw_data["SchemaVersionNumber"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetSchemaVersionInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetSchemaVersionInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetSchemaVersionsDiffInput:
    boto3_raw_data: "type_defs.GetSchemaVersionsDiffInputTypeDef" = dataclasses.field()

    @cached_property
    def SchemaId(self):  # pragma: no cover
        return SchemaId.make_one(self.boto3_raw_data["SchemaId"])

    @cached_property
    def FirstSchemaVersionNumber(self):  # pragma: no cover
        return SchemaVersionNumber.make_one(
            self.boto3_raw_data["FirstSchemaVersionNumber"]
        )

    @cached_property
    def SecondSchemaVersionNumber(self):  # pragma: no cover
        return SchemaVersionNumber.make_one(
            self.boto3_raw_data["SecondSchemaVersionNumber"]
        )

    SchemaDiffType = field("SchemaDiffType")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetSchemaVersionsDiffInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetSchemaVersionsDiffInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateSchemaInput:
    boto3_raw_data: "type_defs.UpdateSchemaInputTypeDef" = dataclasses.field()

    @cached_property
    def SchemaId(self):  # pragma: no cover
        return SchemaId.make_one(self.boto3_raw_data["SchemaId"])

    @cached_property
    def SchemaVersionNumber(self):  # pragma: no cover
        return SchemaVersionNumber.make_one(self.boto3_raw_data["SchemaVersionNumber"])

    Compatibility = field("Compatibility")
    Description = field("Description")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.UpdateSchemaInputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateSchemaInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GlueSchemaOutput:
    boto3_raw_data: "type_defs.GlueSchemaOutputTypeDef" = dataclasses.field()

    @cached_property
    def Columns(self):  # pragma: no cover
        return GlueStudioSchemaColumn.make_many(self.boto3_raw_data["Columns"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GlueSchemaOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GlueSchemaOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GlueSchema:
    boto3_raw_data: "type_defs.GlueSchemaTypeDef" = dataclasses.field()

    @cached_property
    def Columns(self):  # pragma: no cover
        return GlueStudioSchemaColumn.make_many(self.boto3_raw_data["Columns"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GlueSchemaTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.GlueSchemaTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GovernedCatalogSource:
    boto3_raw_data: "type_defs.GovernedCatalogSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    PartitionPredicate = field("PartitionPredicate")

    @cached_property
    def AdditionalOptions(self):  # pragma: no cover
        return S3SourceAdditionalOptions.make_one(
            self.boto3_raw_data["AdditionalOptions"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GovernedCatalogSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GovernedCatalogSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3CatalogSource:
    boto3_raw_data: "type_defs.S3CatalogSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    PartitionPredicate = field("PartitionPredicate")

    @cached_property
    def AdditionalOptions(self):  # pragma: no cover
        return S3SourceAdditionalOptions.make_one(
            self.boto3_raw_data["AdditionalOptions"]
        )

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.S3CatalogSourceTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.S3CatalogSourceTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class OrphanFileDeletionConfiguration:
    boto3_raw_data: "type_defs.OrphanFileDeletionConfigurationTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def icebergConfiguration(self):  # pragma: no cover
        return IcebergOrphanFileDeletionConfiguration.make_one(
            self.boto3_raw_data["icebergConfiguration"]
        )

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.OrphanFileDeletionConfigurationTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.OrphanFileDeletionConfigurationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class OrphanFileDeletionMetrics:
    boto3_raw_data: "type_defs.OrphanFileDeletionMetricsTypeDef" = dataclasses.field()

    @cached_property
    def IcebergMetrics(self):  # pragma: no cover
        return IcebergOrphanFileDeletionMetrics.make_one(
            self.boto3_raw_data["IcebergMetrics"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.OrphanFileDeletionMetricsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.OrphanFileDeletionMetricsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IcebergPartitionSpec:
    boto3_raw_data: "type_defs.IcebergPartitionSpecTypeDef" = dataclasses.field()

    @cached_property
    def Fields(self):  # pragma: no cover
        return IcebergPartitionField.make_many(self.boto3_raw_data["Fields"])

    SpecId = field("SpecId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.IcebergPartitionSpecTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IcebergPartitionSpecTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RetentionConfiguration:
    boto3_raw_data: "type_defs.RetentionConfigurationTypeDef" = dataclasses.field()

    @cached_property
    def icebergConfiguration(self):  # pragma: no cover
        return IcebergRetentionConfiguration.make_one(
            self.boto3_raw_data["icebergConfiguration"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.RetentionConfigurationTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.RetentionConfigurationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RetentionMetrics:
    boto3_raw_data: "type_defs.RetentionMetricsTypeDef" = dataclasses.field()

    @cached_property
    def IcebergMetrics(self):  # pragma: no cover
        return IcebergRetentionMetrics.make_one(self.boto3_raw_data["IcebergMetrics"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.RetentionMetricsTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.RetentionMetricsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IcebergSchema:
    boto3_raw_data: "type_defs.IcebergSchemaTypeDef" = dataclasses.field()

    @cached_property
    def Fields(self):  # pragma: no cover
        return IcebergStructField.make_many(self.boto3_raw_data["Fields"])

    SchemaId = field("SchemaId")
    IdentifierFieldIds = field("IdentifierFieldIds")
    Type = field("Type")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.IcebergSchemaTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.IcebergSchemaTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IcebergSortOrder:
    boto3_raw_data: "type_defs.IcebergSortOrderTypeDef" = dataclasses.field()

    OrderId = field("OrderId")

    @cached_property
    def Fields(self):  # pragma: no cover
        return IcebergSortField.make_many(self.boto3_raw_data["Fields"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.IcebergSortOrderTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IcebergSortOrderTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TargetTableConfigOutput:
    boto3_raw_data: "type_defs.TargetTableConfigOutputTypeDef" = dataclasses.field()

    UnnestSpec = field("UnnestSpec")

    @cached_property
    def PartitionSpec(self):  # pragma: no cover
        return IntegrationPartition.make_many(self.boto3_raw_data["PartitionSpec"])

    TargetTableName = field("TargetTableName")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.TargetTableConfigOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TargetTableConfigOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TargetTableConfig:
    boto3_raw_data: "type_defs.TargetTableConfigTypeDef" = dataclasses.field()

    UnnestSpec = field("UnnestSpec")

    @cached_property
    def PartitionSpec(self):  # pragma: no cover
        return IntegrationPartition.make_many(self.boto3_raw_data["PartitionSpec"])

    TargetTableName = field("TargetTableName")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.TargetTableConfigTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TargetTableConfigTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JobRun:
    boto3_raw_data: "type_defs.JobRunTypeDef" = dataclasses.field()

    Id = field("Id")
    Attempt = field("Attempt")
    PreviousRunId = field("PreviousRunId")
    TriggerName = field("TriggerName")
    JobName = field("JobName")
    JobMode = field("JobMode")
    JobRunQueuingEnabled = field("JobRunQueuingEnabled")
    StartedOn = field("StartedOn")
    LastModifiedOn = field("LastModifiedOn")
    CompletedOn = field("CompletedOn")
    JobRunState = field("JobRunState")
    Arguments = field("Arguments")
    ErrorMessage = field("ErrorMessage")

    @cached_property
    def PredecessorRuns(self):  # pragma: no cover
        return Predecessor.make_many(self.boto3_raw_data["PredecessorRuns"])

    AllocatedCapacity = field("AllocatedCapacity")
    ExecutionTime = field("ExecutionTime")
    Timeout = field("Timeout")
    MaxCapacity = field("MaxCapacity")
    WorkerType = field("WorkerType")
    NumberOfWorkers = field("NumberOfWorkers")
    SecurityConfiguration = field("SecurityConfiguration")
    LogGroupName = field("LogGroupName")

    @cached_property
    def NotificationProperty(self):  # pragma: no cover
        return NotificationProperty.make_one(
            self.boto3_raw_data["NotificationProperty"]
        )

    GlueVersion = field("GlueVersion")
    DPUSeconds = field("DPUSeconds")
    ExecutionClass = field("ExecutionClass")
    MaintenanceWindow = field("MaintenanceWindow")
    ProfileName = field("ProfileName")
    StateDetail = field("StateDetail")
    ExecutionRoleSessionPolicy = field("ExecutionRoleSessionPolicy")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.JobRunTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.JobRunTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JoinOutput:
    boto3_raw_data: "type_defs.JoinOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    JoinType = field("JoinType")

    @cached_property
    def Columns(self):  # pragma: no cover
        return JoinColumnOutput.make_many(self.boto3_raw_data["Columns"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.JoinOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.JoinOutputTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TaskRunProperties:
    boto3_raw_data: "type_defs.TaskRunPropertiesTypeDef" = dataclasses.field()

    TaskType = field("TaskType")

    @cached_property
    def ImportLabelsTaskRunProperties(self):  # pragma: no cover
        return ImportLabelsTaskRunProperties.make_one(
            self.boto3_raw_data["ImportLabelsTaskRunProperties"]
        )

    @cached_property
    def ExportLabelsTaskRunProperties(self):  # pragma: no cover
        return ExportLabelsTaskRunProperties.make_one(
            self.boto3_raw_data["ExportLabelsTaskRunProperties"]
        )

    @cached_property
    def LabelingSetGenerationTaskRunProperties(self):  # pragma: no cover
        return LabelingSetGenerationTaskRunProperties.make_one(
            self.boto3_raw_data["LabelingSetGenerationTaskRunProperties"]
        )

    @cached_property
    def FindMatchesTaskRunProperties(self):  # pragma: no cover
        return FindMatchesTaskRunProperties.make_one(
            self.boto3_raw_data["FindMatchesTaskRunProperties"]
        )

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.TaskRunPropertiesTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TaskRunPropertiesTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListRegistriesResponse:
    boto3_raw_data: "type_defs.ListRegistriesResponseTypeDef" = dataclasses.field()

    @cached_property
    def Registries(self):  # pragma: no cover
        return RegistryListItem.make_many(self.boto3_raw_data["Registries"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListRegistriesResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListRegistriesResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListSchemaVersionsResponse:
    boto3_raw_data: "type_defs.ListSchemaVersionsResponseTypeDef" = dataclasses.field()

    @cached_property
    def Schemas(self):  # pragma: no cover
        return SchemaVersionListItem.make_many(self.boto3_raw_data["Schemas"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListSchemaVersionsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListSchemaVersionsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListSchemasResponse:
    boto3_raw_data: "type_defs.ListSchemasResponseTypeDef" = dataclasses.field()

    @cached_property
    def Schemas(self):  # pragma: no cover
        return SchemaListItem.make_many(self.boto3_raw_data["Schemas"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListSchemasResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListSchemasResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListUsageProfilesResponse:
    boto3_raw_data: "type_defs.ListUsageProfilesResponseTypeDef" = dataclasses.field()

    @cached_property
    def Profiles(self):  # pragma: no cover
        return UsageProfileDefinition.make_many(self.boto3_raw_data["Profiles"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListUsageProfilesResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListUsageProfilesResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TransformEncryption:
    boto3_raw_data: "type_defs.TransformEncryptionTypeDef" = dataclasses.field()

    @cached_property
    def MlUserDataEncryption(self):  # pragma: no cover
        return MLUserDataEncryption.make_one(
            self.boto3_raw_data["MlUserDataEncryption"]
        )

    TaskRunSecurityConfigurationName = field("TaskRunSecurityConfigurationName")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.TransformEncryptionTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TransformEncryptionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class MetadataInfo:
    boto3_raw_data: "type_defs.MetadataInfoTypeDef" = dataclasses.field()

    MetadataValue = field("MetadataValue")
    CreatedTime = field("CreatedTime")

    @cached_property
    def OtherMetadataValueList(self):  # pragma: no cover
        return OtherMetadataValueListItem.make_many(
            self.boto3_raw_data["OtherMetadataValueList"]
        )

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.MetadataInfoTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.MetadataInfoTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PutSchemaVersionMetadataInput:
    boto3_raw_data: "type_defs.PutSchemaVersionMetadataInputTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def MetadataKeyValue(self):  # pragma: no cover
        return MetadataKeyValuePair.make_one(self.boto3_raw_data["MetadataKeyValue"])

    @cached_property
    def SchemaId(self):  # pragma: no cover
        return SchemaId.make_one(self.boto3_raw_data["SchemaId"])

    @cached_property
    def SchemaVersionNumber(self):  # pragma: no cover
        return SchemaVersionNumber.make_one(self.boto3_raw_data["SchemaVersionNumber"])

    SchemaVersionId = field("SchemaVersionId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.PutSchemaVersionMetadataInputTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PutSchemaVersionMetadataInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class QuerySchemaVersionMetadataInput:
    boto3_raw_data: "type_defs.QuerySchemaVersionMetadataInputTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def SchemaId(self):  # pragma: no cover
        return SchemaId.make_one(self.boto3_raw_data["SchemaId"])

    @cached_property
    def SchemaVersionNumber(self):  # pragma: no cover
        return SchemaVersionNumber.make_one(self.boto3_raw_data["SchemaVersionNumber"])

    SchemaVersionId = field("SchemaVersionId")

    @cached_property
    def MetadataList(self):  # pragma: no cover
        return MetadataKeyValuePair.make_many(self.boto3_raw_data["MetadataList"])

    MaxResults = field("MaxResults")
    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.QuerySchemaVersionMetadataInputTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.QuerySchemaVersionMetadataInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RemoveSchemaVersionMetadataInput:
    boto3_raw_data: "type_defs.RemoveSchemaVersionMetadataInputTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def MetadataKeyValue(self):  # pragma: no cover
        return MetadataKeyValuePair.make_one(self.boto3_raw_data["MetadataKeyValue"])

    @cached_property
    def SchemaId(self):  # pragma: no cover
        return SchemaId.make_one(self.boto3_raw_data["SchemaId"])

    @cached_property
    def SchemaVersionNumber(self):  # pragma: no cover
        return SchemaVersionNumber.make_one(self.boto3_raw_data["SchemaVersionNumber"])

    SchemaVersionId = field("SchemaVersionId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.RemoveSchemaVersionMetadataInputTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.RemoveSchemaVersionMetadataInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class OAuth2Properties:
    boto3_raw_data: "type_defs.OAuth2PropertiesTypeDef" = dataclasses.field()

    OAuth2GrantType = field("OAuth2GrantType")

    @cached_property
    def OAuth2ClientApplication(self):  # pragma: no cover
        return OAuth2ClientApplication.make_one(
            self.boto3_raw_data["OAuth2ClientApplication"]
        )

    TokenUrl = field("TokenUrl")
    TokenUrlParametersMap = field("TokenUrlParametersMap")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.OAuth2PropertiesTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.OAuth2PropertiesTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class OAuth2PropertiesInput:
    boto3_raw_data: "type_defs.OAuth2PropertiesInputTypeDef" = dataclasses.field()

    OAuth2GrantType = field("OAuth2GrantType")

    @cached_property
    def OAuth2ClientApplication(self):  # pragma: no cover
        return OAuth2ClientApplication.make_one(
            self.boto3_raw_data["OAuth2ClientApplication"]
        )

    TokenUrl = field("TokenUrl")
    TokenUrlParametersMap = field("TokenUrlParametersMap")

    @cached_property
    def AuthorizationCodeProperties(self):  # pragma: no cover
        return AuthorizationCodeProperties.make_one(
            self.boto3_raw_data["AuthorizationCodeProperties"]
        )

    @cached_property
    def OAuth2Credentials(self):  # pragma: no cover
        return OAuth2Credentials.make_one(self.boto3_raw_data["OAuth2Credentials"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.OAuth2PropertiesInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.OAuth2PropertiesInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RecipeStepOutput:
    boto3_raw_data: "type_defs.RecipeStepOutputTypeDef" = dataclasses.field()

    @cached_property
    def Action(self):  # pragma: no cover
        return RecipeActionOutput.make_one(self.boto3_raw_data["Action"])

    @cached_property
    def ConditionExpressions(self):  # pragma: no cover
        return ConditionExpression.make_many(
            self.boto3_raw_data["ConditionExpressions"]
        )

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.RecipeStepOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.RecipeStepOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RedshiftTargetOutput:
    boto3_raw_data: "type_defs.RedshiftTargetOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Database = field("Database")
    Table = field("Table")
    RedshiftTmpDir = field("RedshiftTmpDir")
    TmpDirIAMRole = field("TmpDirIAMRole")

    @cached_property
    def UpsertRedshiftOptions(self):  # pragma: no cover
        return UpsertRedshiftTargetOptionsOutput.make_one(
            self.boto3_raw_data["UpsertRedshiftOptions"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.RedshiftTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.RedshiftTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UserDefinedFunctionInput:
    boto3_raw_data: "type_defs.UserDefinedFunctionInputTypeDef" = dataclasses.field()

    FunctionName = field("FunctionName")
    ClassName = field("ClassName")
    OwnerName = field("OwnerName")
    OwnerType = field("OwnerType")

    @cached_property
    def ResourceUris(self):  # pragma: no cover
        return ResourceUri.make_many(self.boto3_raw_data["ResourceUris"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UserDefinedFunctionInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UserDefinedFunctionInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UserDefinedFunction:
    boto3_raw_data: "type_defs.UserDefinedFunctionTypeDef" = dataclasses.field()

    FunctionName = field("FunctionName")
    DatabaseName = field("DatabaseName")
    ClassName = field("ClassName")
    OwnerName = field("OwnerName")
    OwnerType = field("OwnerType")
    CreateTime = field("CreateTime")

    @cached_property
    def ResourceUris(self):  # pragma: no cover
        return ResourceUri.make_many(self.boto3_raw_data["ResourceUris"])

    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UserDefinedFunctionTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UserDefinedFunctionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SearchTablesRequest:
    boto3_raw_data: "type_defs.SearchTablesRequestTypeDef" = dataclasses.field()

    CatalogId = field("CatalogId")
    NextToken = field("NextToken")

    @cached_property
    def Filters(self):  # pragma: no cover
        return PropertyPredicate.make_many(self.boto3_raw_data["Filters"])

    SearchText = field("SearchText")

    @cached_property
    def SortCriteria(self):  # pragma: no cover
        return SortCriterion.make_many(self.boto3_raw_data["SortCriteria"])

    MaxResults = field("MaxResults")
    ResourceShareType = field("ResourceShareType")
    IncludeStatusDetails = field("IncludeStatusDetails")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SearchTablesRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SearchTablesRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StatementOutput:
    boto3_raw_data: "type_defs.StatementOutputTypeDef" = dataclasses.field()

    @cached_property
    def Data(self):  # pragma: no cover
        return StatementOutputData.make_one(self.boto3_raw_data["Data"])

    ExecutionCount = field("ExecutionCount")
    Status = field("Status")
    ErrorName = field("ErrorName")
    ErrorValue = field("ErrorValue")
    Traceback = field("Traceback")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.StatementOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.StatementOutputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StatisticAnnotation:
    boto3_raw_data: "type_defs.StatisticAnnotationTypeDef" = dataclasses.field()

    ProfileId = field("ProfileId")
    StatisticId = field("StatisticId")
    StatisticRecordedOn = field("StatisticRecordedOn")

    @cached_property
    def InclusionAnnotation(self):  # pragma: no cover
        return TimestampedInclusionAnnotation.make_one(
            self.boto3_raw_data["InclusionAnnotation"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StatisticAnnotationTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StatisticAnnotationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StatisticSummary:
    boto3_raw_data: "type_defs.StatisticSummaryTypeDef" = dataclasses.field()

    StatisticId = field("StatisticId")
    ProfileId = field("ProfileId")

    @cached_property
    def RunIdentifier(self):  # pragma: no cover
        return RunIdentifier.make_one(self.boto3_raw_data["RunIdentifier"])

    StatisticName = field("StatisticName")
    DoubleValue = field("DoubleValue")
    EvaluationLevel = field("EvaluationLevel")
    ColumnsReferenced = field("ColumnsReferenced")
    ReferencedDatasets = field("ReferencedDatasets")
    StatisticProperties = field("StatisticProperties")
    RecordedOn = field("RecordedOn")

    @cached_property
    def InclusionAnnotation(self):  # pragma: no cover
        return TimestampedInclusionAnnotation.make_one(
            self.boto3_raw_data["InclusionAnnotation"]
        )

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.StatisticSummaryTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StatisticSummaryTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateClassifierRequest:
    boto3_raw_data: "type_defs.UpdateClassifierRequestTypeDef" = dataclasses.field()

    @cached_property
    def GrokClassifier(self):  # pragma: no cover
        return UpdateGrokClassifierRequest.make_one(
            self.boto3_raw_data["GrokClassifier"]
        )

    @cached_property
    def XMLClassifier(self):  # pragma: no cover
        return UpdateXMLClassifierRequest.make_one(self.boto3_raw_data["XMLClassifier"])

    @cached_property
    def JsonClassifier(self):  # pragma: no cover
        return UpdateJsonClassifierRequest.make_one(
            self.boto3_raw_data["JsonClassifier"]
        )

    @cached_property
    def CsvClassifier(self):  # pragma: no cover
        return UpdateCsvClassifierRequest.make_one(self.boto3_raw_data["CsvClassifier"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateClassifierRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateClassifierRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ViewDefinitionInput:
    boto3_raw_data: "type_defs.ViewDefinitionInputTypeDef" = dataclasses.field()

    IsProtected = field("IsProtected")
    Definer = field("Definer")

    @cached_property
    def Representations(self):  # pragma: no cover
        return ViewRepresentationInput.make_many(self.boto3_raw_data["Representations"])

    SubObjects = field("SubObjects")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ViewDefinitionInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ViewDefinitionInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ViewDefinition:
    boto3_raw_data: "type_defs.ViewDefinitionTypeDef" = dataclasses.field()

    IsProtected = field("IsProtected")
    Definer = field("Definer")
    SubObjects = field("SubObjects")

    @cached_property
    def Representations(self):  # pragma: no cover
        return ViewRepresentation.make_many(self.boto3_raw_data["Representations"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ViewDefinitionTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ViewDefinitionTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Aggregate:
    boto3_raw_data: "type_defs.AggregateTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Groups = field("Groups")
    Aggs = field("Aggs")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.AggregateTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.AggregateTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AuthConfiguration:
    boto3_raw_data: "type_defs.AuthConfigurationTypeDef" = dataclasses.field()

    @cached_property
    def AuthenticationType(self):  # pragma: no cover
        return Property.make_one(self.boto3_raw_data["AuthenticationType"])

    @cached_property
    def SecretArn(self):  # pragma: no cover
        return Property.make_one(self.boto3_raw_data["SecretArn"])

    OAuth2Properties = field("OAuth2Properties")
    BasicAuthenticationProperties = field("BasicAuthenticationProperties")
    CustomAuthenticationProperties = field("CustomAuthenticationProperties")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.AuthConfigurationTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.AuthConfigurationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ComputeEnvironmentConfiguration:
    boto3_raw_data: "type_defs.ComputeEnvironmentConfigurationTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    Description = field("Description")
    ComputeEnvironment = field("ComputeEnvironment")
    SupportedAuthenticationTypes = field("SupportedAuthenticationTypes")
    ConnectionOptions = field("ConnectionOptions")
    ConnectionPropertyNameOverrides = field("ConnectionPropertyNameOverrides")
    ConnectionOptionNameOverrides = field("ConnectionOptionNameOverrides")
    ConnectionPropertiesRequiredOverrides = field(
        "ConnectionPropertiesRequiredOverrides"
    )
    PhysicalConnectionPropertiesRequired = field("PhysicalConnectionPropertiesRequired")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.ComputeEnvironmentConfigurationTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ComputeEnvironmentConfigurationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AmazonRedshiftSourceOutput:
    boto3_raw_data: "type_defs.AmazonRedshiftSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def Data(self):  # pragma: no cover
        return AmazonRedshiftNodeDataOutput.make_one(self.boto3_raw_data["Data"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.AmazonRedshiftSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.AmazonRedshiftSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AmazonRedshiftTargetOutput:
    boto3_raw_data: "type_defs.AmazonRedshiftTargetOutputTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def Data(self):  # pragma: no cover
        return AmazonRedshiftNodeDataOutput.make_one(self.boto3_raw_data["Data"])

    Inputs = field("Inputs")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.AmazonRedshiftTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.AmazonRedshiftTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SnowflakeTargetOutput:
    boto3_raw_data: "type_defs.SnowflakeTargetOutputTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def Data(self):  # pragma: no cover
        return SnowflakeNodeDataOutput.make_one(self.boto3_raw_data["Data"])

    Inputs = field("Inputs")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SnowflakeTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SnowflakeTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PartitionIndexDescriptor:
    boto3_raw_data: "type_defs.PartitionIndexDescriptorTypeDef" = dataclasses.field()

    IndexName = field("IndexName")

    @cached_property
    def Keys(self):  # pragma: no cover
        return KeySchemaElement.make_many(self.boto3_raw_data["Keys"])

    IndexStatus = field("IndexStatus")

    @cached_property
    def BackfillErrors(self):  # pragma: no cover
        return BackfillError.make_many(self.boto3_raw_data["BackfillErrors"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.PartitionIndexDescriptorTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PartitionIndexDescriptorTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchStopJobRunResponse:
    boto3_raw_data: "type_defs.BatchStopJobRunResponseTypeDef" = dataclasses.field()

    @cached_property
    def SuccessfulSubmissions(self):  # pragma: no cover
        return BatchStopJobRunSuccessfulSubmission.make_many(
            self.boto3_raw_data["SuccessfulSubmissions"]
        )

    @cached_property
    def Errors(self):  # pragma: no cover
        return BatchStopJobRunError.make_many(self.boto3_raw_data["Errors"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchStopJobRunResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchStopJobRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchUpdatePartitionResponse:
    boto3_raw_data: "type_defs.BatchUpdatePartitionResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Errors(self):  # pragma: no cover
        return BatchUpdatePartitionFailureEntry.make_many(self.boto3_raw_data["Errors"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchUpdatePartitionResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchUpdatePartitionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchCreatePartitionResponse:
    boto3_raw_data: "type_defs.BatchCreatePartitionResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Errors(self):  # pragma: no cover
        return PartitionError.make_many(self.boto3_raw_data["Errors"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchCreatePartitionResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchCreatePartitionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchDeletePartitionResponse:
    boto3_raw_data: "type_defs.BatchDeletePartitionResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Errors(self):  # pragma: no cover
        return PartitionError.make_many(self.boto3_raw_data["Errors"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchDeletePartitionResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchDeletePartitionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchDeleteTableResponse:
    boto3_raw_data: "type_defs.BatchDeleteTableResponseTypeDef" = dataclasses.field()

    @cached_property
    def Errors(self):  # pragma: no cover
        return TableError.make_many(self.boto3_raw_data["Errors"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchDeleteTableResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchDeleteTableResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchDeleteTableVersionResponse:
    boto3_raw_data: "type_defs.BatchDeleteTableVersionResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Errors(self):  # pragma: no cover
        return TableVersionError.make_many(self.boto3_raw_data["Errors"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.BatchDeleteTableVersionResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchDeleteTableVersionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StatusDetailsPaginator:
    boto3_raw_data: "type_defs.StatusDetailsPaginatorTypeDef" = dataclasses.field()

    RequestedChange = field("RequestedChange")

    @cached_property
    def ViewValidations(self):  # pragma: no cover
        return ViewValidation.make_many(self.boto3_raw_data["ViewValidations"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StatusDetailsPaginatorTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StatusDetailsPaginatorTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StatusDetails:
    boto3_raw_data: "type_defs.StatusDetailsTypeDef" = dataclasses.field()

    RequestedChange = field("RequestedChange")

    @cached_property
    def ViewValidations(self):  # pragma: no cover
        return ViewValidation.make_many(self.boto3_raw_data["ViewValidations"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.StatusDetailsTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.StatusDetailsTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetBlueprintsResponse:
    boto3_raw_data: "type_defs.BatchGetBlueprintsResponseTypeDef" = dataclasses.field()

    @cached_property
    def Blueprints(self):  # pragma: no cover
        return Blueprint.make_many(self.boto3_raw_data["Blueprints"])

    MissingBlueprints = field("MissingBlueprints")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchGetBlueprintsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetBlueprintsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetBlueprintResponse:
    boto3_raw_data: "type_defs.GetBlueprintResponseTypeDef" = dataclasses.field()

    @cached_property
    def Blueprint(self):  # pragma: no cover
        return Blueprint.make_one(self.boto3_raw_data["Blueprint"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetBlueprintResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetBlueprintResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetClassifierResponse:
    boto3_raw_data: "type_defs.GetClassifierResponseTypeDef" = dataclasses.field()

    @cached_property
    def Classifier(self):  # pragma: no cover
        return Classifier.make_one(self.boto3_raw_data["Classifier"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetClassifierResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetClassifierResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetClassifiersResponse:
    boto3_raw_data: "type_defs.GetClassifiersResponseTypeDef" = dataclasses.field()

    @cached_property
    def Classifiers(self):  # pragma: no cover
        return Classifier.make_many(self.boto3_raw_data["Classifiers"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetClassifiersResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetClassifiersResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDataflowGraphResponse:
    boto3_raw_data: "type_defs.GetDataflowGraphResponseTypeDef" = dataclasses.field()

    @cached_property
    def DagNodes(self):  # pragma: no cover
        return CodeGenNodeOutput.make_many(self.boto3_raw_data["DagNodes"])

    @cached_property
    def DagEdges(self):  # pragma: no cover
        return CodeGenEdge.make_many(self.boto3_raw_data["DagEdges"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetDataflowGraphResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDataflowGraphResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetMappingRequest:
    boto3_raw_data: "type_defs.GetMappingRequestTypeDef" = dataclasses.field()

    @cached_property
    def Source(self):  # pragma: no cover
        return CatalogEntry.make_one(self.boto3_raw_data["Source"])

    @cached_property
    def Sinks(self):  # pragma: no cover
        return CatalogEntry.make_many(self.boto3_raw_data["Sinks"])

    @cached_property
    def Location(self):  # pragma: no cover
        return Location.make_one(self.boto3_raw_data["Location"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetMappingRequestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetMappingRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetPlanRequest:
    boto3_raw_data: "type_defs.GetPlanRequestTypeDef" = dataclasses.field()

    @cached_property
    def Mapping(self):  # pragma: no cover
        return MappingEntry.make_many(self.boto3_raw_data["Mapping"])

    @cached_property
    def Source(self):  # pragma: no cover
        return CatalogEntry.make_one(self.boto3_raw_data["Source"])

    @cached_property
    def Sinks(self):  # pragma: no cover
        return CatalogEntry.make_many(self.boto3_raw_data["Sinks"])

    @cached_property
    def Location(self):  # pragma: no cover
        return Location.make_one(self.boto3_raw_data["Location"])

    Language = field("Language")
    AdditionalPlanOptionsMap = field("AdditionalPlanOptionsMap")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetPlanRequestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.GetPlanRequestTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetColumnStatisticsTaskSettingsResponse:
    boto3_raw_data: "type_defs.GetColumnStatisticsTaskSettingsResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def ColumnStatisticsTaskSettings(self):  # pragma: no cover
        return ColumnStatisticsTaskSettings.make_one(
            self.boto3_raw_data["ColumnStatisticsTaskSettings"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetColumnStatisticsTaskSettingsResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetColumnStatisticsTaskSettingsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetUnfilteredPartitionMetadataRequest:
    boto3_raw_data: "type_defs.GetUnfilteredPartitionMetadataRequestTypeDef" = (
        dataclasses.field()
    )

    CatalogId = field("CatalogId")
    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    PartitionValues = field("PartitionValues")
    SupportedPermissionTypes = field("SupportedPermissionTypes")
    Region = field("Region")

    @cached_property
    def AuditContext(self):  # pragma: no cover
        return AuditContext.make_one(self.boto3_raw_data["AuditContext"])

    @cached_property
    def QuerySessionContext(self):  # pragma: no cover
        return QuerySessionContext.make_one(self.boto3_raw_data["QuerySessionContext"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetUnfilteredPartitionMetadataRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetUnfilteredPartitionMetadataRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetUnfilteredPartitionsMetadataRequest:
    boto3_raw_data: "type_defs.GetUnfilteredPartitionsMetadataRequestTypeDef" = (
        dataclasses.field()
    )

    CatalogId = field("CatalogId")
    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    SupportedPermissionTypes = field("SupportedPermissionTypes")
    Region = field("Region")
    Expression = field("Expression")

    @cached_property
    def AuditContext(self):  # pragma: no cover
        return AuditContext.make_one(self.boto3_raw_data["AuditContext"])

    NextToken = field("NextToken")

    @cached_property
    def Segment(self):  # pragma: no cover
        return Segment.make_one(self.boto3_raw_data["Segment"])

    MaxResults = field("MaxResults")

    @cached_property
    def QuerySessionContext(self):  # pragma: no cover
        return QuerySessionContext.make_one(self.boto3_raw_data["QuerySessionContext"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetUnfilteredPartitionsMetadataRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetUnfilteredPartitionsMetadataRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetUnfilteredTableMetadataRequest:
    boto3_raw_data: "type_defs.GetUnfilteredTableMetadataRequestTypeDef" = (
        dataclasses.field()
    )

    CatalogId = field("CatalogId")
    DatabaseName = field("DatabaseName")
    Name = field("Name")
    SupportedPermissionTypes = field("SupportedPermissionTypes")
    Region = field("Region")

    @cached_property
    def AuditContext(self):  # pragma: no cover
        return AuditContext.make_one(self.boto3_raw_data["AuditContext"])

    ParentResourceArn = field("ParentResourceArn")
    RootResourceArn = field("RootResourceArn")

    @cached_property
    def SupportedDialect(self):  # pragma: no cover
        return SupportedDialect.make_one(self.boto3_raw_data["SupportedDialect"])

    Permissions = field("Permissions")

    @cached_property
    def QuerySessionContext(self):  # pragma: no cover
        return QuerySessionContext.make_one(self.boto3_raw_data["QuerySessionContext"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetUnfilteredTableMetadataRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetUnfilteredTableMetadataRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetMLTaskRunsRequest:
    boto3_raw_data: "type_defs.GetMLTaskRunsRequestTypeDef" = dataclasses.field()

    TransformId = field("TransformId")
    NextToken = field("NextToken")
    MaxResults = field("MaxResults")

    @cached_property
    def Filter(self):  # pragma: no cover
        return TaskRunFilterCriteria.make_one(self.boto3_raw_data["Filter"])

    @cached_property
    def Sort(self):  # pragma: no cover
        return TaskRunSortCriteria.make_one(self.boto3_raw_data["Sort"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetMLTaskRunsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetMLTaskRunsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListDataQualityStatisticAnnotationsRequest:
    boto3_raw_data: "type_defs.ListDataQualityStatisticAnnotationsRequestTypeDef" = (
        dataclasses.field()
    )

    StatisticId = field("StatisticId")
    ProfileId = field("ProfileId")

    @cached_property
    def TimestampFilter(self):  # pragma: no cover
        return TimestampFilter.make_one(self.boto3_raw_data["TimestampFilter"])

    MaxResults = field("MaxResults")
    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.ListDataQualityStatisticAnnotationsRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListDataQualityStatisticAnnotationsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListDataQualityStatisticsRequest:
    boto3_raw_data: "type_defs.ListDataQualityStatisticsRequestTypeDef" = (
        dataclasses.field()
    )

    StatisticId = field("StatisticId")
    ProfileId = field("ProfileId")

    @cached_property
    def TimestampFilter(self):  # pragma: no cover
        return TimestampFilter.make_one(self.boto3_raw_data["TimestampFilter"])

    MaxResults = field("MaxResults")
    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.ListDataQualityStatisticsRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListDataQualityStatisticsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Trigger:
    boto3_raw_data: "type_defs.TriggerTypeDef" = dataclasses.field()

    Name = field("Name")
    WorkflowName = field("WorkflowName")
    Id = field("Id")
    Type = field("Type")
    State = field("State")
    Description = field("Description")
    Schedule = field("Schedule")

    @cached_property
    def Actions(self):  # pragma: no cover
        return ActionOutput.make_many(self.boto3_raw_data["Actions"])

    @cached_property
    def Predicate(self):  # pragma: no cover
        return PredicateOutput.make_one(self.boto3_raw_data["Predicate"])

    @cached_property
    def EventBatchingCondition(self):  # pragma: no cover
        return EventBatchingCondition.make_one(
            self.boto3_raw_data["EventBatchingCondition"]
        )

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.TriggerTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.TriggerTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetUsageProfileResponse:
    boto3_raw_data: "type_defs.GetUsageProfileResponseTypeDef" = dataclasses.field()

    Name = field("Name")
    Description = field("Description")

    @cached_property
    def Configuration(self):  # pragma: no cover
        return ProfileConfigurationOutput.make_one(self.boto3_raw_data["Configuration"])

    CreatedOn = field("CreatedOn")
    LastModifiedOn = field("LastModifiedOn")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetUsageProfileResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetUsageProfileResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class EvaluationMetrics:
    boto3_raw_data: "type_defs.EvaluationMetricsTypeDef" = dataclasses.field()

    TransformType = field("TransformType")

    @cached_property
    def FindMatchesMetrics(self):  # pragma: no cover
        return FindMatchesMetrics.make_one(self.boto3_raw_data["FindMatchesMetrics"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.EvaluationMetricsTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.EvaluationMetricsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListConnectionTypesResponse:
    boto3_raw_data: "type_defs.ListConnectionTypesResponseTypeDef" = dataclasses.field()

    @cached_property
    def ConnectionTypes(self):  # pragma: no cover
        return ConnectionTypeBrief.make_many(self.boto3_raw_data["ConnectionTypes"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListConnectionTypesResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListConnectionTypesResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateSessionRequest:
    boto3_raw_data: "type_defs.CreateSessionRequestTypeDef" = dataclasses.field()

    Id = field("Id")
    Role = field("Role")

    @cached_property
    def Command(self):  # pragma: no cover
        return SessionCommand.make_one(self.boto3_raw_data["Command"])

    Description = field("Description")
    Timeout = field("Timeout")
    IdleTimeout = field("IdleTimeout")
    DefaultArguments = field("DefaultArguments")
    Connections = field("Connections")
    MaxCapacity = field("MaxCapacity")
    NumberOfWorkers = field("NumberOfWorkers")
    WorkerType = field("WorkerType")
    SecurityConfiguration = field("SecurityConfiguration")
    GlueVersion = field("GlueVersion")
    Tags = field("Tags")
    RequestOrigin = field("RequestOrigin")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateSessionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateSessionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Crawler:
    boto3_raw_data: "type_defs.CrawlerTypeDef" = dataclasses.field()

    Name = field("Name")
    Role = field("Role")

    @cached_property
    def Targets(self):  # pragma: no cover
        return CrawlerTargetsOutput.make_one(self.boto3_raw_data["Targets"])

    DatabaseName = field("DatabaseName")
    Description = field("Description")
    Classifiers = field("Classifiers")

    @cached_property
    def RecrawlPolicy(self):  # pragma: no cover
        return RecrawlPolicy.make_one(self.boto3_raw_data["RecrawlPolicy"])

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return SchemaChangePolicy.make_one(self.boto3_raw_data["SchemaChangePolicy"])

    @cached_property
    def LineageConfiguration(self):  # pragma: no cover
        return LineageConfiguration.make_one(
            self.boto3_raw_data["LineageConfiguration"]
        )

    State = field("State")
    TablePrefix = field("TablePrefix")

    @cached_property
    def Schedule(self):  # pragma: no cover
        return Schedule.make_one(self.boto3_raw_data["Schedule"])

    CrawlElapsedTime = field("CrawlElapsedTime")
    CreationTime = field("CreationTime")
    LastUpdated = field("LastUpdated")

    @cached_property
    def LastCrawl(self):  # pragma: no cover
        return LastCrawlInfo.make_one(self.boto3_raw_data["LastCrawl"])

    Version = field("Version")
    Configuration = field("Configuration")
    CrawlerSecurityConfiguration = field("CrawlerSecurityConfiguration")

    @cached_property
    def LakeFormationConfiguration(self):  # pragma: no cover
        return LakeFormationConfiguration.make_one(
            self.boto3_raw_data["LakeFormationConfiguration"]
        )

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CrawlerTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.CrawlerTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListDataQualityRulesetsRequest:
    boto3_raw_data: "type_defs.ListDataQualityRulesetsRequestTypeDef" = (
        dataclasses.field()
    )

    NextToken = field("NextToken")
    MaxResults = field("MaxResults")

    @cached_property
    def Filter(self):  # pragma: no cover
        return DataQualityRulesetFilterCriteria.make_one(self.boto3_raw_data["Filter"])

    Tags = field("Tags")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.ListDataQualityRulesetsRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListDataQualityRulesetsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListDataQualityRulesetsResponse:
    boto3_raw_data: "type_defs.ListDataQualityRulesetsResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Rulesets(self):  # pragma: no cover
        return DataQualityRulesetListDetails.make_many(self.boto3_raw_data["Rulesets"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.ListDataQualityRulesetsResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListDataQualityRulesetsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DescribeInboundIntegrationsResponse:
    boto3_raw_data: "type_defs.DescribeInboundIntegrationsResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def InboundIntegrations(self):  # pragma: no cover
        return InboundIntegration.make_many(self.boto3_raw_data["InboundIntegrations"])

    Marker = field("Marker")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.DescribeInboundIntegrationsResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DescribeInboundIntegrationsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DescribeIntegrationsResponse:
    boto3_raw_data: "type_defs.DescribeIntegrationsResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Integrations(self):  # pragma: no cover
        return Integration.make_many(self.boto3_raw_data["Integrations"])

    Marker = field("Marker")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DescribeIntegrationsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DescribeIntegrationsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateSessionResponse:
    boto3_raw_data: "type_defs.CreateSessionResponseTypeDef" = dataclasses.field()

    @cached_property
    def Session(self):  # pragma: no cover
        return Session.make_one(self.boto3_raw_data["Session"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateSessionResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateSessionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetSessionResponse:
    boto3_raw_data: "type_defs.GetSessionResponseTypeDef" = dataclasses.field()

    @cached_property
    def Session(self):  # pragma: no cover
        return Session.make_one(self.boto3_raw_data["Session"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetSessionResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetSessionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListSessionsResponse:
    boto3_raw_data: "type_defs.ListSessionsResponseTypeDef" = dataclasses.field()

    Ids = field("Ids")

    @cached_property
    def Sessions(self):  # pragma: no cover
        return Session.make_many(self.boto3_raw_data["Sessions"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListSessionsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListSessionsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDataCatalogEncryptionSettingsResponse:
    boto3_raw_data: "type_defs.GetDataCatalogEncryptionSettingsResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def DataCatalogEncryptionSettings(self):  # pragma: no cover
        return DataCatalogEncryptionSettings.make_one(
            self.boto3_raw_data["DataCatalogEncryptionSettings"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetDataCatalogEncryptionSettingsResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDataCatalogEncryptionSettingsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PutDataCatalogEncryptionSettingsRequest:
    boto3_raw_data: "type_defs.PutDataCatalogEncryptionSettingsRequestTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def DataCatalogEncryptionSettings(self):  # pragma: no cover
        return DataCatalogEncryptionSettings.make_one(
            self.boto3_raw_data["DataCatalogEncryptionSettings"]
        )

    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.PutDataCatalogEncryptionSettingsRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.PutDataCatalogEncryptionSettingsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Catalog:
    boto3_raw_data: "type_defs.CatalogTypeDef" = dataclasses.field()

    Name = field("Name")
    CatalogId = field("CatalogId")
    ResourceArn = field("ResourceArn")
    Description = field("Description")
    Parameters = field("Parameters")
    CreateTime = field("CreateTime")
    UpdateTime = field("UpdateTime")

    @cached_property
    def TargetRedshiftCatalog(self):  # pragma: no cover
        return TargetRedshiftCatalog.make_one(
            self.boto3_raw_data["TargetRedshiftCatalog"]
        )

    @cached_property
    def FederatedCatalog(self):  # pragma: no cover
        return FederatedCatalog.make_one(self.boto3_raw_data["FederatedCatalog"])

    @cached_property
    def CatalogProperties(self):  # pragma: no cover
        return CatalogPropertiesOutput.make_one(
            self.boto3_raw_data["CatalogProperties"]
        )

    @cached_property
    def CreateTableDefaultPermissions(self):  # pragma: no cover
        return PrincipalPermissionsOutput.make_many(
            self.boto3_raw_data["CreateTableDefaultPermissions"]
        )

    @cached_property
    def CreateDatabaseDefaultPermissions(self):  # pragma: no cover
        return PrincipalPermissionsOutput.make_many(
            self.boto3_raw_data["CreateDatabaseDefaultPermissions"]
        )

    AllowFullTableExternalDataAccess = field("AllowFullTableExternalDataAccess")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CatalogTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.CatalogTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Database:
    boto3_raw_data: "type_defs.DatabaseTypeDef" = dataclasses.field()

    Name = field("Name")
    Description = field("Description")
    LocationUri = field("LocationUri")
    Parameters = field("Parameters")
    CreateTime = field("CreateTime")

    @cached_property
    def CreateTableDefaultPermissions(self):  # pragma: no cover
        return PrincipalPermissionsOutput.make_many(
            self.boto3_raw_data["CreateTableDefaultPermissions"]
        )

    @cached_property
    def TargetDatabase(self):  # pragma: no cover
        return DatabaseIdentifier.make_one(self.boto3_raw_data["TargetDatabase"])

    CatalogId = field("CatalogId")

    @cached_property
    def FederatedDatabase(self):  # pragma: no cover
        return FederatedDatabase.make_one(self.boto3_raw_data["FederatedDatabase"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DatabaseTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.DatabaseTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityObservation:
    boto3_raw_data: "type_defs.DataQualityObservationTypeDef" = dataclasses.field()

    Description = field("Description")

    @cached_property
    def MetricBasedObservation(self):  # pragma: no cover
        return MetricBasedObservation.make_one(
            self.boto3_raw_data["MetricBasedObservation"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DataQualityObservationTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityObservationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityResultDescription:
    boto3_raw_data: "type_defs.DataQualityResultDescriptionTypeDef" = (
        dataclasses.field()
    )

    ResultId = field("ResultId")

    @cached_property
    def DataSource(self):  # pragma: no cover
        return DataSourceOutput.make_one(self.boto3_raw_data["DataSource"])

    JobName = field("JobName")
    JobRunId = field("JobRunId")
    StartedOn = field("StartedOn")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DataQualityResultDescriptionTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityResultDescriptionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityRuleRecommendationRunDescription:
    boto3_raw_data: "type_defs.DataQualityRuleRecommendationRunDescriptionTypeDef" = (
        dataclasses.field()
    )

    RunId = field("RunId")
    Status = field("Status")
    StartedOn = field("StartedOn")

    @cached_property
    def DataSource(self):  # pragma: no cover
        return DataSourceOutput.make_one(self.boto3_raw_data["DataSource"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.DataQualityRuleRecommendationRunDescriptionTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityRuleRecommendationRunDescriptionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityRulesetEvaluationRunDescription:
    boto3_raw_data: "type_defs.DataQualityRulesetEvaluationRunDescriptionTypeDef" = (
        dataclasses.field()
    )

    RunId = field("RunId")
    Status = field("Status")
    StartedOn = field("StartedOn")

    @cached_property
    def DataSource(self):  # pragma: no cover
        return DataSourceOutput.make_one(self.boto3_raw_data["DataSource"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.DataQualityRulesetEvaluationRunDescriptionTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityRulesetEvaluationRunDescriptionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDataQualityRuleRecommendationRunResponse:
    boto3_raw_data: "type_defs.GetDataQualityRuleRecommendationRunResponseTypeDef" = (
        dataclasses.field()
    )

    RunId = field("RunId")

    @cached_property
    def DataSource(self):  # pragma: no cover
        return DataSourceOutput.make_one(self.boto3_raw_data["DataSource"])

    Role = field("Role")
    NumberOfWorkers = field("NumberOfWorkers")
    Timeout = field("Timeout")
    Status = field("Status")
    ErrorString = field("ErrorString")
    StartedOn = field("StartedOn")
    LastModifiedOn = field("LastModifiedOn")
    CompletedOn = field("CompletedOn")
    ExecutionTime = field("ExecutionTime")
    RecommendedRuleset = field("RecommendedRuleset")
    CreatedRulesetName = field("CreatedRulesetName")
    DataQualitySecurityConfiguration = field("DataQualitySecurityConfiguration")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetDataQualityRuleRecommendationRunResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDataQualityRuleRecommendationRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDataQualityRulesetEvaluationRunResponse:
    boto3_raw_data: "type_defs.GetDataQualityRulesetEvaluationRunResponseTypeDef" = (
        dataclasses.field()
    )

    RunId = field("RunId")

    @cached_property
    def DataSource(self):  # pragma: no cover
        return DataSourceOutput.make_one(self.boto3_raw_data["DataSource"])

    Role = field("Role")
    NumberOfWorkers = field("NumberOfWorkers")
    Timeout = field("Timeout")

    @cached_property
    def AdditionalRunOptions(self):  # pragma: no cover
        return DataQualityEvaluationRunAdditionalRunOptions.make_one(
            self.boto3_raw_data["AdditionalRunOptions"]
        )

    Status = field("Status")
    ErrorString = field("ErrorString")
    StartedOn = field("StartedOn")
    LastModifiedOn = field("LastModifiedOn")
    CompletedOn = field("CompletedOn")
    ExecutionTime = field("ExecutionTime")
    RulesetNames = field("RulesetNames")
    ResultIds = field("ResultIds")
    AdditionalDataSources = field("AdditionalDataSources")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetDataQualityRulesetEvaluationRunResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDataQualityRulesetEvaluationRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DropNullFieldsOutput:
    boto3_raw_data: "type_defs.DropNullFieldsOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")

    @cached_property
    def NullCheckBoxList(self):  # pragma: no cover
        return NullCheckBoxList.make_one(self.boto3_raw_data["NullCheckBoxList"])

    @cached_property
    def NullTextList(self):  # pragma: no cover
        return NullValueField.make_many(self.boto3_raw_data["NullTextList"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DropNullFieldsOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DropNullFieldsOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DropNullFields:
    boto3_raw_data: "type_defs.DropNullFieldsTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")

    @cached_property
    def NullCheckBoxList(self):  # pragma: no cover
        return NullCheckBoxList.make_one(self.boto3_raw_data["NullCheckBoxList"])

    @cached_property
    def NullTextList(self):  # pragma: no cover
        return NullValueField.make_many(self.boto3_raw_data["NullTextList"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DropNullFieldsTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.DropNullFieldsTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ColumnStatisticsDataOutput:
    boto3_raw_data: "type_defs.ColumnStatisticsDataOutputTypeDef" = dataclasses.field()

    Type = field("Type")

    @cached_property
    def BooleanColumnStatisticsData(self):  # pragma: no cover
        return BooleanColumnStatisticsData.make_one(
            self.boto3_raw_data["BooleanColumnStatisticsData"]
        )

    @cached_property
    def DateColumnStatisticsData(self):  # pragma: no cover
        return DateColumnStatisticsDataOutput.make_one(
            self.boto3_raw_data["DateColumnStatisticsData"]
        )

    @cached_property
    def DecimalColumnStatisticsData(self):  # pragma: no cover
        return DecimalColumnStatisticsDataOutput.make_one(
            self.boto3_raw_data["DecimalColumnStatisticsData"]
        )

    @cached_property
    def DoubleColumnStatisticsData(self):  # pragma: no cover
        return DoubleColumnStatisticsData.make_one(
            self.boto3_raw_data["DoubleColumnStatisticsData"]
        )

    @cached_property
    def LongColumnStatisticsData(self):  # pragma: no cover
        return LongColumnStatisticsData.make_one(
            self.boto3_raw_data["LongColumnStatisticsData"]
        )

    @cached_property
    def StringColumnStatisticsData(self):  # pragma: no cover
        return StringColumnStatisticsData.make_one(
            self.boto3_raw_data["StringColumnStatisticsData"]
        )

    @cached_property
    def BinaryColumnStatisticsData(self):  # pragma: no cover
        return BinaryColumnStatisticsData.make_one(
            self.boto3_raw_data["BinaryColumnStatisticsData"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ColumnStatisticsDataOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ColumnStatisticsDataOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StorageDescriptorOutput:
    boto3_raw_data: "type_defs.StorageDescriptorOutputTypeDef" = dataclasses.field()

    @cached_property
    def Columns(self):  # pragma: no cover
        return ColumnOutput.make_many(self.boto3_raw_data["Columns"])

    Location = field("Location")
    AdditionalLocations = field("AdditionalLocations")
    InputFormat = field("InputFormat")
    OutputFormat = field("OutputFormat")
    Compressed = field("Compressed")
    NumberOfBuckets = field("NumberOfBuckets")

    @cached_property
    def SerdeInfo(self):  # pragma: no cover
        return SerDeInfoOutput.make_one(self.boto3_raw_data["SerdeInfo"])

    BucketColumns = field("BucketColumns")

    @cached_property
    def SortColumns(self):  # pragma: no cover
        return Order.make_many(self.boto3_raw_data["SortColumns"])

    Parameters = field("Parameters")

    @cached_property
    def SkewedInfo(self):  # pragma: no cover
        return SkewedInfoOutput.make_one(self.boto3_raw_data["SkewedInfo"])

    StoredAsSubDirectories = field("StoredAsSubDirectories")

    @cached_property
    def SchemaReference(self):  # pragma: no cover
        return SchemaReference.make_one(self.boto3_raw_data["SchemaReference"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.StorageDescriptorOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StorageDescriptorOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SecurityConfiguration:
    boto3_raw_data: "type_defs.SecurityConfigurationTypeDef" = dataclasses.field()

    Name = field("Name")
    CreatedTimeStamp = field("CreatedTimeStamp")

    @cached_property
    def EncryptionConfiguration(self):  # pragma: no cover
        return EncryptionConfigurationOutput.make_one(
            self.boto3_raw_data["EncryptionConfiguration"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SecurityConfigurationTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SecurityConfigurationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DeleteSchemaVersionsResponse:
    boto3_raw_data: "type_defs.DeleteSchemaVersionsResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def SchemaVersionErrors(self):  # pragma: no cover
        return SchemaVersionErrorItem.make_many(
            self.boto3_raw_data["SchemaVersionErrors"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DeleteSchemaVersionsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DeleteSchemaVersionsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class FilterOutput:
    boto3_raw_data: "type_defs.FilterOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    LogicalOperator = field("LogicalOperator")

    @cached_property
    def Filters(self):  # pragma: no cover
        return FilterExpressionOutput.make_many(self.boto3_raw_data["Filters"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.FilterOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.FilterOutputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GroupFiltersOutput:
    boto3_raw_data: "type_defs.GroupFiltersOutputTypeDef" = dataclasses.field()

    GroupName = field("GroupName")

    @cached_property
    def Filters(self):  # pragma: no cover
        return FilterExpressionOutput.make_many(self.boto3_raw_data["Filters"])

    LogicalOperator = field("LogicalOperator")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GroupFiltersOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GroupFiltersOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class FilterExpression:
    boto3_raw_data: "type_defs.FilterExpressionTypeDef" = dataclasses.field()

    Operation = field("Operation")
    Values = field("Values")
    Negated = field("Negated")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.FilterExpressionTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.FilterExpressionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateMLTransformRequest:
    boto3_raw_data: "type_defs.UpdateMLTransformRequestTypeDef" = dataclasses.field()

    TransformId = field("TransformId")
    Name = field("Name")
    Description = field("Description")

    @cached_property
    def Parameters(self):  # pragma: no cover
        return TransformParameters.make_one(self.boto3_raw_data["Parameters"])

    Role = field("Role")
    GlueVersion = field("GlueVersion")
    MaxCapacity = field("MaxCapacity")
    WorkerType = field("WorkerType")
    NumberOfWorkers = field("NumberOfWorkers")
    Timeout = field("Timeout")
    MaxRetries = field("MaxRetries")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateMLTransformRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateMLTransformRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetMLTransformsRequest:
    boto3_raw_data: "type_defs.GetMLTransformsRequestTypeDef" = dataclasses.field()

    NextToken = field("NextToken")
    MaxResults = field("MaxResults")

    @cached_property
    def Filter(self):  # pragma: no cover
        return TransformFilterCriteria.make_one(self.boto3_raw_data["Filter"])

    @cached_property
    def Sort(self):  # pragma: no cover
        return TransformSortCriteria.make_one(self.boto3_raw_data["Sort"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetMLTransformsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetMLTransformsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListMLTransformsRequest:
    boto3_raw_data: "type_defs.ListMLTransformsRequestTypeDef" = dataclasses.field()

    NextToken = field("NextToken")
    MaxResults = field("MaxResults")

    @cached_property
    def Filter(self):  # pragma: no cover
        return TransformFilterCriteria.make_one(self.boto3_raw_data["Filter"])

    @cached_property
    def Sort(self):  # pragma: no cover
        return TransformSortCriteria.make_one(self.boto3_raw_data["Sort"])

    Tags = field("Tags")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListMLTransformsRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListMLTransformsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AthenaConnectorSourceOutput:
    boto3_raw_data: "type_defs.AthenaConnectorSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    ConnectionName = field("ConnectionName")
    ConnectorName = field("ConnectorName")
    ConnectionType = field("ConnectionType")
    SchemaName = field("SchemaName")
    ConnectionTable = field("ConnectionTable")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.AthenaConnectorSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.AthenaConnectorSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogDeltaSourceOutput:
    boto3_raw_data: "type_defs.CatalogDeltaSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    AdditionalDeltaOptions = field("AdditionalDeltaOptions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CatalogDeltaSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CatalogDeltaSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogHudiSourceOutput:
    boto3_raw_data: "type_defs.CatalogHudiSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    AdditionalHudiOptions = field("AdditionalHudiOptions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CatalogHudiSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CatalogHudiSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogIcebergSourceOutput:
    boto3_raw_data: "type_defs.CatalogIcebergSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    AdditionalIcebergOptions = field("AdditionalIcebergOptions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CatalogIcebergSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CatalogIcebergSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogSourceOutput:
    boto3_raw_data: "type_defs.CatalogSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    PartitionPredicate = field("PartitionPredicate")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CatalogSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CatalogSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ConnectorDataSourceOutput:
    boto3_raw_data: "type_defs.ConnectorDataSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    ConnectionType = field("ConnectionType")
    Data = field("Data")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ConnectorDataSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ConnectorDataSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CustomCodeOutput:
    boto3_raw_data: "type_defs.CustomCodeOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Code = field("Code")
    ClassName = field("ClassName")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CustomCodeOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CustomCodeOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DirectJDBCSourceOutput:
    boto3_raw_data: "type_defs.DirectJDBCSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    ConnectionName = field("ConnectionName")
    ConnectionType = field("ConnectionType")
    RedshiftTmpDir = field("RedshiftTmpDir")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DirectJDBCSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DirectJDBCSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DynamicTransformOutput:
    boto3_raw_data: "type_defs.DynamicTransformOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    TransformName = field("TransformName")
    Inputs = field("Inputs")
    FunctionName = field("FunctionName")
    Path = field("Path")

    @cached_property
    def Parameters(self):  # pragma: no cover
        return TransformConfigParameterOutput.make_many(
            self.boto3_raw_data["Parameters"]
        )

    Version = field("Version")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DynamicTransformOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DynamicTransformOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DynamoDBELTConnectorSourceOutput:
    boto3_raw_data: "type_defs.DynamoDBELTConnectorSourceOutputTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")

    @cached_property
    def ConnectionOptions(self):  # pragma: no cover
        return DDBELTConnectionOptions.make_one(
            self.boto3_raw_data["ConnectionOptions"]
        )

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.DynamoDBELTConnectorSourceOutputTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DynamoDBELTConnectorSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JDBCConnectorSourceOutput:
    boto3_raw_data: "type_defs.JDBCConnectorSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    ConnectionName = field("ConnectionName")
    ConnectorName = field("ConnectorName")
    ConnectionType = field("ConnectionType")

    @cached_property
    def AdditionalOptions(self):  # pragma: no cover
        return JDBCConnectorOptionsOutput.make_one(
            self.boto3_raw_data["AdditionalOptions"]
        )

    ConnectionTable = field("ConnectionTable")
    Query = field("Query")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.JDBCConnectorSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.JDBCConnectorSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JDBCConnectorTargetOutput:
    boto3_raw_data: "type_defs.JDBCConnectorTargetOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    ConnectionName = field("ConnectionName")
    ConnectionTable = field("ConnectionTable")
    ConnectorName = field("ConnectorName")
    ConnectionType = field("ConnectionType")
    AdditionalOptions = field("AdditionalOptions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.JDBCConnectorTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.JDBCConnectorTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3CatalogDeltaSourceOutput:
    boto3_raw_data: "type_defs.S3CatalogDeltaSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    AdditionalDeltaOptions = field("AdditionalDeltaOptions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3CatalogDeltaSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3CatalogDeltaSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3CatalogHudiSourceOutput:
    boto3_raw_data: "type_defs.S3CatalogHudiSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    AdditionalHudiOptions = field("AdditionalHudiOptions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3CatalogHudiSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3CatalogHudiSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3CatalogIcebergSourceOutput:
    boto3_raw_data: "type_defs.S3CatalogIcebergSourceOutputTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    AdditionalIcebergOptions = field("AdditionalIcebergOptions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3CatalogIcebergSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3CatalogIcebergSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3CsvSourceOutput:
    boto3_raw_data: "type_defs.S3CsvSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Paths = field("Paths")
    Separator = field("Separator")
    QuoteChar = field("QuoteChar")
    CompressionType = field("CompressionType")
    Exclusions = field("Exclusions")
    GroupSize = field("GroupSize")
    GroupFiles = field("GroupFiles")
    Recurse = field("Recurse")
    MaxBand = field("MaxBand")
    MaxFilesInBand = field("MaxFilesInBand")

    @cached_property
    def AdditionalOptions(self):  # pragma: no cover
        return S3DirectSourceAdditionalOptions.make_one(
            self.boto3_raw_data["AdditionalOptions"]
        )

    Escaper = field("Escaper")
    Multiline = field("Multiline")
    WithHeader = field("WithHeader")
    WriteHeader = field("WriteHeader")
    SkipFirst = field("SkipFirst")
    OptimizePerformance = field("OptimizePerformance")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.S3CsvSourceOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3CsvSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3DeltaCatalogTargetOutput:
    boto3_raw_data: "type_defs.S3DeltaCatalogTargetOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Table = field("Table")
    Database = field("Database")
    PartitionKeys = field("PartitionKeys")
    AdditionalOptions = field("AdditionalOptions")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return CatalogSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3DeltaCatalogTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3DeltaCatalogTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3DeltaSourceOutput:
    boto3_raw_data: "type_defs.S3DeltaSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Paths = field("Paths")
    AdditionalDeltaOptions = field("AdditionalDeltaOptions")

    @cached_property
    def AdditionalOptions(self):  # pragma: no cover
        return S3DirectSourceAdditionalOptions.make_one(
            self.boto3_raw_data["AdditionalOptions"]
        )

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3DeltaSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3DeltaSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3DirectTargetOutput:
    boto3_raw_data: "type_defs.S3DirectTargetOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Path = field("Path")
    Format = field("Format")
    PartitionKeys = field("PartitionKeys")
    Compression = field("Compression")
    NumberTargetPartitions = field("NumberTargetPartitions")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return DirectSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3DirectTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3DirectTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3ExcelSourceOutput:
    boto3_raw_data: "type_defs.S3ExcelSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Paths = field("Paths")
    CompressionType = field("CompressionType")
    Exclusions = field("Exclusions")
    GroupSize = field("GroupSize")
    GroupFiles = field("GroupFiles")
    Recurse = field("Recurse")
    MaxBand = field("MaxBand")
    MaxFilesInBand = field("MaxFilesInBand")

    @cached_property
    def AdditionalOptions(self):  # pragma: no cover
        return S3DirectSourceAdditionalOptions.make_one(
            self.boto3_raw_data["AdditionalOptions"]
        )

    NumberRows = field("NumberRows")
    SkipFooter = field("SkipFooter")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3ExcelSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3ExcelSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3HudiCatalogTargetOutput:
    boto3_raw_data: "type_defs.S3HudiCatalogTargetOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Table = field("Table")
    Database = field("Database")
    AdditionalOptions = field("AdditionalOptions")
    PartitionKeys = field("PartitionKeys")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return CatalogSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3HudiCatalogTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3HudiCatalogTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3HudiSourceOutput:
    boto3_raw_data: "type_defs.S3HudiSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Paths = field("Paths")
    AdditionalHudiOptions = field("AdditionalHudiOptions")

    @cached_property
    def AdditionalOptions(self):  # pragma: no cover
        return S3DirectSourceAdditionalOptions.make_one(
            self.boto3_raw_data["AdditionalOptions"]
        )

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3HudiSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3HudiSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3HyperDirectTargetOutput:
    boto3_raw_data: "type_defs.S3HyperDirectTargetOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Path = field("Path")
    Format = field("Format")
    PartitionKeys = field("PartitionKeys")
    Compression = field("Compression")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return DirectSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3HyperDirectTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3HyperDirectTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3IcebergDirectTargetOutput:
    boto3_raw_data: "type_defs.S3IcebergDirectTargetOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Path = field("Path")
    Format = field("Format")
    Compression = field("Compression")
    PartitionKeys = field("PartitionKeys")
    AdditionalOptions = field("AdditionalOptions")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return DirectSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    NumberTargetPartitions = field("NumberTargetPartitions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3IcebergDirectTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3IcebergDirectTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3JsonSourceOutput:
    boto3_raw_data: "type_defs.S3JsonSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Paths = field("Paths")
    CompressionType = field("CompressionType")
    Exclusions = field("Exclusions")
    GroupSize = field("GroupSize")
    GroupFiles = field("GroupFiles")
    Recurse = field("Recurse")
    MaxBand = field("MaxBand")
    MaxFilesInBand = field("MaxFilesInBand")

    @cached_property
    def AdditionalOptions(self):  # pragma: no cover
        return S3DirectSourceAdditionalOptions.make_one(
            self.boto3_raw_data["AdditionalOptions"]
        )

    JsonPath = field("JsonPath")
    Multiline = field("Multiline")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3JsonSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3JsonSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3ParquetSourceOutput:
    boto3_raw_data: "type_defs.S3ParquetSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Paths = field("Paths")
    CompressionType = field("CompressionType")
    Exclusions = field("Exclusions")
    GroupSize = field("GroupSize")
    GroupFiles = field("GroupFiles")
    Recurse = field("Recurse")
    MaxBand = field("MaxBand")
    MaxFilesInBand = field("MaxFilesInBand")

    @cached_property
    def AdditionalOptions(self):  # pragma: no cover
        return S3DirectSourceAdditionalOptions.make_one(
            self.boto3_raw_data["AdditionalOptions"]
        )

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3ParquetSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3ParquetSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SnowflakeSourceOutput:
    boto3_raw_data: "type_defs.SnowflakeSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def Data(self):  # pragma: no cover
        return SnowflakeNodeDataOutput.make_one(self.boto3_raw_data["Data"])

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SnowflakeSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SnowflakeSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SparkConnectorSourceOutput:
    boto3_raw_data: "type_defs.SparkConnectorSourceOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    ConnectionName = field("ConnectionName")
    ConnectorName = field("ConnectorName")
    ConnectionType = field("ConnectionType")
    AdditionalOptions = field("AdditionalOptions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SparkConnectorSourceOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SparkConnectorSourceOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SparkConnectorTargetOutput:
    boto3_raw_data: "type_defs.SparkConnectorTargetOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    ConnectionName = field("ConnectionName")
    ConnectorName = field("ConnectorName")
    ConnectionType = field("ConnectionType")
    AdditionalOptions = field("AdditionalOptions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SparkConnectorTargetOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SparkConnectorTargetOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SparkSQLOutput:
    boto3_raw_data: "type_defs.SparkSQLOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    SqlQuery = field("SqlQuery")

    @cached_property
    def SqlAliases(self):  # pragma: no cover
        return SqlAlias.make_many(self.boto3_raw_data["SqlAliases"])

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchemaOutput.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SparkSQLOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SparkSQLOutputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AthenaConnectorSource:
    boto3_raw_data: "type_defs.AthenaConnectorSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    ConnectionName = field("ConnectionName")
    ConnectorName = field("ConnectorName")
    ConnectionType = field("ConnectionType")
    SchemaName = field("SchemaName")
    ConnectionTable = field("ConnectionTable")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.AthenaConnectorSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.AthenaConnectorSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogDeltaSource:
    boto3_raw_data: "type_defs.CatalogDeltaSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    AdditionalDeltaOptions = field("AdditionalDeltaOptions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CatalogDeltaSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CatalogDeltaSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogHudiSource:
    boto3_raw_data: "type_defs.CatalogHudiSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    AdditionalHudiOptions = field("AdditionalHudiOptions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CatalogHudiSourceTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CatalogHudiSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogIcebergSource:
    boto3_raw_data: "type_defs.CatalogIcebergSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    AdditionalIcebergOptions = field("AdditionalIcebergOptions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CatalogIcebergSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CatalogIcebergSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogSource:
    boto3_raw_data: "type_defs.CatalogSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    PartitionPredicate = field("PartitionPredicate")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CatalogSourceTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.CatalogSourceTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ConnectorDataSource:
    boto3_raw_data: "type_defs.ConnectorDataSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    ConnectionType = field("ConnectionType")
    Data = field("Data")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ConnectorDataSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ConnectorDataSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CustomCode:
    boto3_raw_data: "type_defs.CustomCodeTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Code = field("Code")
    ClassName = field("ClassName")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CustomCodeTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.CustomCodeTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DirectJDBCSource:
    boto3_raw_data: "type_defs.DirectJDBCSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    ConnectionName = field("ConnectionName")
    ConnectionType = field("ConnectionType")
    RedshiftTmpDir = field("RedshiftTmpDir")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DirectJDBCSourceTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DirectJDBCSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JDBCConnectorTarget:
    boto3_raw_data: "type_defs.JDBCConnectorTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    ConnectionName = field("ConnectionName")
    ConnectionTable = field("ConnectionTable")
    ConnectorName = field("ConnectorName")
    ConnectionType = field("ConnectionType")
    AdditionalOptions = field("AdditionalOptions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.JDBCConnectorTargetTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.JDBCConnectorTargetTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3CatalogDeltaSource:
    boto3_raw_data: "type_defs.S3CatalogDeltaSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    AdditionalDeltaOptions = field("AdditionalDeltaOptions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3CatalogDeltaSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3CatalogDeltaSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3CatalogHudiSource:
    boto3_raw_data: "type_defs.S3CatalogHudiSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    AdditionalHudiOptions = field("AdditionalHudiOptions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3CatalogHudiSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3CatalogHudiSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3CatalogIcebergSource:
    boto3_raw_data: "type_defs.S3CatalogIcebergSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Database = field("Database")
    Table = field("Table")
    AdditionalIcebergOptions = field("AdditionalIcebergOptions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3CatalogIcebergSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3CatalogIcebergSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3CsvSource:
    boto3_raw_data: "type_defs.S3CsvSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Paths = field("Paths")
    Separator = field("Separator")
    QuoteChar = field("QuoteChar")
    CompressionType = field("CompressionType")
    Exclusions = field("Exclusions")
    GroupSize = field("GroupSize")
    GroupFiles = field("GroupFiles")
    Recurse = field("Recurse")
    MaxBand = field("MaxBand")
    MaxFilesInBand = field("MaxFilesInBand")

    @cached_property
    def AdditionalOptions(self):  # pragma: no cover
        return S3DirectSourceAdditionalOptions.make_one(
            self.boto3_raw_data["AdditionalOptions"]
        )

    Escaper = field("Escaper")
    Multiline = field("Multiline")
    WithHeader = field("WithHeader")
    WriteHeader = field("WriteHeader")
    SkipFirst = field("SkipFirst")
    OptimizePerformance = field("OptimizePerformance")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.S3CsvSourceTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.S3CsvSourceTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3DeltaCatalogTarget:
    boto3_raw_data: "type_defs.S3DeltaCatalogTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Table = field("Table")
    Database = field("Database")
    PartitionKeys = field("PartitionKeys")
    AdditionalOptions = field("AdditionalOptions")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return CatalogSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3DeltaCatalogTargetTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3DeltaCatalogTargetTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3DeltaSource:
    boto3_raw_data: "type_defs.S3DeltaSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Paths = field("Paths")
    AdditionalDeltaOptions = field("AdditionalDeltaOptions")

    @cached_property
    def AdditionalOptions(self):  # pragma: no cover
        return S3DirectSourceAdditionalOptions.make_one(
            self.boto3_raw_data["AdditionalOptions"]
        )

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.S3DeltaSourceTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.S3DeltaSourceTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3DirectTarget:
    boto3_raw_data: "type_defs.S3DirectTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Path = field("Path")
    Format = field("Format")
    PartitionKeys = field("PartitionKeys")
    Compression = field("Compression")
    NumberTargetPartitions = field("NumberTargetPartitions")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return DirectSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.S3DirectTargetTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.S3DirectTargetTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3ExcelSource:
    boto3_raw_data: "type_defs.S3ExcelSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Paths = field("Paths")
    CompressionType = field("CompressionType")
    Exclusions = field("Exclusions")
    GroupSize = field("GroupSize")
    GroupFiles = field("GroupFiles")
    Recurse = field("Recurse")
    MaxBand = field("MaxBand")
    MaxFilesInBand = field("MaxFilesInBand")

    @cached_property
    def AdditionalOptions(self):  # pragma: no cover
        return S3DirectSourceAdditionalOptions.make_one(
            self.boto3_raw_data["AdditionalOptions"]
        )

    NumberRows = field("NumberRows")
    SkipFooter = field("SkipFooter")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.S3ExcelSourceTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.S3ExcelSourceTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3HudiCatalogTarget:
    boto3_raw_data: "type_defs.S3HudiCatalogTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Table = field("Table")
    Database = field("Database")
    AdditionalOptions = field("AdditionalOptions")
    PartitionKeys = field("PartitionKeys")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return CatalogSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3HudiCatalogTargetTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3HudiCatalogTargetTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3HudiSource:
    boto3_raw_data: "type_defs.S3HudiSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Paths = field("Paths")
    AdditionalHudiOptions = field("AdditionalHudiOptions")

    @cached_property
    def AdditionalOptions(self):  # pragma: no cover
        return S3DirectSourceAdditionalOptions.make_one(
            self.boto3_raw_data["AdditionalOptions"]
        )

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.S3HudiSourceTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.S3HudiSourceTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3IcebergDirectTarget:
    boto3_raw_data: "type_defs.S3IcebergDirectTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Path = field("Path")
    Format = field("Format")
    Compression = field("Compression")
    PartitionKeys = field("PartitionKeys")
    AdditionalOptions = field("AdditionalOptions")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return DirectSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    NumberTargetPartitions = field("NumberTargetPartitions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3IcebergDirectTargetTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3IcebergDirectTargetTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3JsonSource:
    boto3_raw_data: "type_defs.S3JsonSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Paths = field("Paths")
    CompressionType = field("CompressionType")
    Exclusions = field("Exclusions")
    GroupSize = field("GroupSize")
    GroupFiles = field("GroupFiles")
    Recurse = field("Recurse")
    MaxBand = field("MaxBand")
    MaxFilesInBand = field("MaxFilesInBand")

    @cached_property
    def AdditionalOptions(self):  # pragma: no cover
        return S3DirectSourceAdditionalOptions.make_one(
            self.boto3_raw_data["AdditionalOptions"]
        )

    JsonPath = field("JsonPath")
    Multiline = field("Multiline")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.S3JsonSourceTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.S3JsonSourceTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3ParquetSource:
    boto3_raw_data: "type_defs.S3ParquetSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Paths = field("Paths")
    CompressionType = field("CompressionType")
    Exclusions = field("Exclusions")
    GroupSize = field("GroupSize")
    GroupFiles = field("GroupFiles")
    Recurse = field("Recurse")
    MaxBand = field("MaxBand")
    MaxFilesInBand = field("MaxFilesInBand")

    @cached_property
    def AdditionalOptions(self):  # pragma: no cover
        return S3DirectSourceAdditionalOptions.make_one(
            self.boto3_raw_data["AdditionalOptions"]
        )

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.S3ParquetSourceTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.S3ParquetSourceTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SparkConnectorSource:
    boto3_raw_data: "type_defs.SparkConnectorSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    ConnectionName = field("ConnectionName")
    ConnectorName = field("ConnectorName")
    ConnectionType = field("ConnectionType")
    AdditionalOptions = field("AdditionalOptions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SparkConnectorSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SparkConnectorSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SparkConnectorTarget:
    boto3_raw_data: "type_defs.SparkConnectorTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    ConnectionName = field("ConnectionName")
    ConnectorName = field("ConnectorName")
    ConnectionType = field("ConnectionType")
    AdditionalOptions = field("AdditionalOptions")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SparkConnectorTargetTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SparkConnectorTargetTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SparkSQL:
    boto3_raw_data: "type_defs.SparkSQLTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    SqlQuery = field("SqlQuery")

    @cached_property
    def SqlAliases(self):  # pragma: no cover
        return SqlAlias.make_many(self.boto3_raw_data["SqlAliases"])

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SparkSQLTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SparkSQLTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataSource:
    boto3_raw_data: "type_defs.DataSourceTypeDef" = dataclasses.field()

    GlueTable = field("GlueTable")
    DataQualityGlueTable = field("DataQualityGlueTable")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DataSourceTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.DataSourceTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TableOptimizerConfiguration:
    boto3_raw_data: "type_defs.TableOptimizerConfigurationTypeDef" = dataclasses.field()

    roleArn = field("roleArn")
    enabled = field("enabled")

    @cached_property
    def vpcConfiguration(self):  # pragma: no cover
        return TableOptimizerVpcConfiguration.make_one(
            self.boto3_raw_data["vpcConfiguration"]
        )

    @cached_property
    def compactionConfiguration(self):  # pragma: no cover
        return CompactionConfiguration.make_one(
            self.boto3_raw_data["compactionConfiguration"]
        )

    @cached_property
    def retentionConfiguration(self):  # pragma: no cover
        return RetentionConfiguration.make_one(
            self.boto3_raw_data["retentionConfiguration"]
        )

    @cached_property
    def orphanFileDeletionConfiguration(self):  # pragma: no cover
        return OrphanFileDeletionConfiguration.make_one(
            self.boto3_raw_data["orphanFileDeletionConfiguration"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.TableOptimizerConfigurationTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TableOptimizerConfigurationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TableOptimizerRun:
    boto3_raw_data: "type_defs.TableOptimizerRunTypeDef" = dataclasses.field()

    eventType = field("eventType")
    startTimestamp = field("startTimestamp")
    endTimestamp = field("endTimestamp")

    @cached_property
    def metrics(self):  # pragma: no cover
        return RunMetrics.make_one(self.boto3_raw_data["metrics"])

    error = field("error")

    @cached_property
    def compactionMetrics(self):  # pragma: no cover
        return CompactionMetrics.make_one(self.boto3_raw_data["compactionMetrics"])

    compactionStrategy = field("compactionStrategy")

    @cached_property
    def retentionMetrics(self):  # pragma: no cover
        return RetentionMetrics.make_one(self.boto3_raw_data["retentionMetrics"])

    @cached_property
    def orphanFileDeletionMetrics(self):  # pragma: no cover
        return OrphanFileDeletionMetrics.make_one(
            self.boto3_raw_data["orphanFileDeletionMetrics"]
        )

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.TableOptimizerRunTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TableOptimizerRunTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateIcebergTableInput:
    boto3_raw_data: "type_defs.CreateIcebergTableInputTypeDef" = dataclasses.field()

    Location = field("Location")

    @cached_property
    def Schema(self):  # pragma: no cover
        return IcebergSchema.make_one(self.boto3_raw_data["Schema"])

    @cached_property
    def PartitionSpec(self):  # pragma: no cover
        return IcebergPartitionSpec.make_one(self.boto3_raw_data["PartitionSpec"])

    @cached_property
    def WriteOrder(self):  # pragma: no cover
        return IcebergSortOrder.make_one(self.boto3_raw_data["WriteOrder"])

    Properties = field("Properties")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateIcebergTableInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateIcebergTableInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IcebergTableUpdate:
    boto3_raw_data: "type_defs.IcebergTableUpdateTypeDef" = dataclasses.field()

    @cached_property
    def Schema(self):  # pragma: no cover
        return IcebergSchema.make_one(self.boto3_raw_data["Schema"])

    Location = field("Location")

    @cached_property
    def PartitionSpec(self):  # pragma: no cover
        return IcebergPartitionSpec.make_one(self.boto3_raw_data["PartitionSpec"])

    @cached_property
    def SortOrder(self):  # pragma: no cover
        return IcebergSortOrder.make_one(self.boto3_raw_data["SortOrder"])

    Properties = field("Properties")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.IcebergTableUpdateTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.IcebergTableUpdateTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateIntegrationRequest:
    boto3_raw_data: "type_defs.CreateIntegrationRequestTypeDef" = dataclasses.field()

    IntegrationName = field("IntegrationName")
    SourceArn = field("SourceArn")
    TargetArn = field("TargetArn")
    Description = field("Description")
    DataFilter = field("DataFilter")
    KmsKeyId = field("KmsKeyId")
    AdditionalEncryptionContext = field("AdditionalEncryptionContext")

    @cached_property
    def Tags(self):  # pragma: no cover
        return Tag.make_many(self.boto3_raw_data["Tags"])

    IntegrationConfig = field("IntegrationConfig")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateIntegrationRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateIntegrationRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ModifyIntegrationRequest:
    boto3_raw_data: "type_defs.ModifyIntegrationRequestTypeDef" = dataclasses.field()

    IntegrationIdentifier = field("IntegrationIdentifier")
    Description = field("Description")
    DataFilter = field("DataFilter")
    IntegrationConfig = field("IntegrationConfig")
    IntegrationName = field("IntegrationName")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ModifyIntegrationRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ModifyIntegrationRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetIntegrationTablePropertiesResponse:
    boto3_raw_data: "type_defs.GetIntegrationTablePropertiesResponseTypeDef" = (
        dataclasses.field()
    )

    ResourceArn = field("ResourceArn")
    TableName = field("TableName")

    @cached_property
    def SourceTableConfig(self):  # pragma: no cover
        return SourceTableConfigOutput.make_one(
            self.boto3_raw_data["SourceTableConfig"]
        )

    @cached_property
    def TargetTableConfig(self):  # pragma: no cover
        return TargetTableConfigOutput.make_one(
            self.boto3_raw_data["TargetTableConfig"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetIntegrationTablePropertiesResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetIntegrationTablePropertiesResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JDBCConnectorSource:
    boto3_raw_data: "type_defs.JDBCConnectorSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    ConnectionName = field("ConnectionName")
    ConnectorName = field("ConnectorName")
    ConnectionType = field("ConnectionType")
    AdditionalOptions = field("AdditionalOptions")
    ConnectionTable = field("ConnectionTable")
    Query = field("Query")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.JDBCConnectorSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.JDBCConnectorSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetJobRunResponse:
    boto3_raw_data: "type_defs.GetJobRunResponseTypeDef" = dataclasses.field()

    @cached_property
    def JobRun(self):  # pragma: no cover
        return JobRun.make_one(self.boto3_raw_data["JobRun"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetJobRunResponseTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetJobRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetJobRunsResponse:
    boto3_raw_data: "type_defs.GetJobRunsResponseTypeDef" = dataclasses.field()

    @cached_property
    def JobRuns(self):  # pragma: no cover
        return JobRun.make_many(self.boto3_raw_data["JobRuns"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetJobRunsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetJobRunsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JobNodeDetails:
    boto3_raw_data: "type_defs.JobNodeDetailsTypeDef" = dataclasses.field()

    @cached_property
    def JobRuns(self):  # pragma: no cover
        return JobRun.make_many(self.boto3_raw_data["JobRuns"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.JobNodeDetailsTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.JobNodeDetailsTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Join:
    boto3_raw_data: "type_defs.JoinTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    JoinType = field("JoinType")
    Columns = field("Columns")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.JoinTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.JoinTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetMLTaskRunResponse:
    boto3_raw_data: "type_defs.GetMLTaskRunResponseTypeDef" = dataclasses.field()

    TransformId = field("TransformId")
    TaskRunId = field("TaskRunId")
    Status = field("Status")
    LogGroupName = field("LogGroupName")

    @cached_property
    def Properties(self):  # pragma: no cover
        return TaskRunProperties.make_one(self.boto3_raw_data["Properties"])

    ErrorString = field("ErrorString")
    StartedOn = field("StartedOn")
    LastModifiedOn = field("LastModifiedOn")
    CompletedOn = field("CompletedOn")
    ExecutionTime = field("ExecutionTime")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetMLTaskRunResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetMLTaskRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TaskRun:
    boto3_raw_data: "type_defs.TaskRunTypeDef" = dataclasses.field()

    TransformId = field("TransformId")
    TaskRunId = field("TaskRunId")
    Status = field("Status")
    LogGroupName = field("LogGroupName")

    @cached_property
    def Properties(self):  # pragma: no cover
        return TaskRunProperties.make_one(self.boto3_raw_data["Properties"])

    ErrorString = field("ErrorString")
    StartedOn = field("StartedOn")
    LastModifiedOn = field("LastModifiedOn")
    CompletedOn = field("CompletedOn")
    ExecutionTime = field("ExecutionTime")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.TaskRunTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.TaskRunTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateMLTransformRequest:
    boto3_raw_data: "type_defs.CreateMLTransformRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    InputRecordTables = field("InputRecordTables")

    @cached_property
    def Parameters(self):  # pragma: no cover
        return TransformParameters.make_one(self.boto3_raw_data["Parameters"])

    Role = field("Role")
    Description = field("Description")
    GlueVersion = field("GlueVersion")
    MaxCapacity = field("MaxCapacity")
    WorkerType = field("WorkerType")
    NumberOfWorkers = field("NumberOfWorkers")
    Timeout = field("Timeout")
    MaxRetries = field("MaxRetries")
    Tags = field("Tags")

    @cached_property
    def TransformEncryption(self):  # pragma: no cover
        return TransformEncryption.make_one(self.boto3_raw_data["TransformEncryption"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateMLTransformRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateMLTransformRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ApplyMapping:
    boto3_raw_data: "type_defs.ApplyMappingTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Mapping = field("Mapping")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ApplyMappingTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ApplyMappingTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class QuerySchemaVersionMetadataResponse:
    boto3_raw_data: "type_defs.QuerySchemaVersionMetadataResponseTypeDef" = (
        dataclasses.field()
    )

    MetadataInfoMap = field("MetadataInfoMap")
    SchemaVersionId = field("SchemaVersionId")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.QuerySchemaVersionMetadataResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.QuerySchemaVersionMetadataResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AuthenticationConfiguration:
    boto3_raw_data: "type_defs.AuthenticationConfigurationTypeDef" = dataclasses.field()

    AuthenticationType = field("AuthenticationType")
    SecretArn = field("SecretArn")
    KmsKeyArn = field("KmsKeyArn")

    @cached_property
    def OAuth2Properties(self):  # pragma: no cover
        return OAuth2Properties.make_one(self.boto3_raw_data["OAuth2Properties"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.AuthenticationConfigurationTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.AuthenticationConfigurationTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AuthenticationConfigurationInput:
    boto3_raw_data: "type_defs.AuthenticationConfigurationInputTypeDef" = (
        dataclasses.field()
    )

    AuthenticationType = field("AuthenticationType")

    @cached_property
    def OAuth2Properties(self):  # pragma: no cover
        return OAuth2PropertiesInput.make_one(self.boto3_raw_data["OAuth2Properties"])

    SecretArn = field("SecretArn")
    KmsKeyArn = field("KmsKeyArn")

    @cached_property
    def BasicAuthenticationCredentials(self):  # pragma: no cover
        return BasicAuthenticationCredentials.make_one(
            self.boto3_raw_data["BasicAuthenticationCredentials"]
        )

    CustomAuthenticationCredentials = field("CustomAuthenticationCredentials")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.AuthenticationConfigurationInputTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.AuthenticationConfigurationInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchDeletePartitionRequest:
    boto3_raw_data: "type_defs.BatchDeletePartitionRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    PartitionsToDelete = field("PartitionsToDelete")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchDeletePartitionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchDeletePartitionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetPartitionRequest:
    boto3_raw_data: "type_defs.BatchGetPartitionRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    PartitionsToGet = field("PartitionsToGet")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchGetPartitionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetPartitionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RecipeOutput:
    boto3_raw_data: "type_defs.RecipeOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")

    @cached_property
    def RecipeReference(self):  # pragma: no cover
        return RecipeReference.make_one(self.boto3_raw_data["RecipeReference"])

    @cached_property
    def RecipeSteps(self):  # pragma: no cover
        return RecipeStepOutput.make_many(self.boto3_raw_data["RecipeSteps"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.RecipeOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.RecipeOutputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RecipeStep:
    boto3_raw_data: "type_defs.RecipeStepTypeDef" = dataclasses.field()

    Action = field("Action")

    @cached_property
    def ConditionExpressions(self):  # pragma: no cover
        return ConditionExpression.make_many(
            self.boto3_raw_data["ConditionExpressions"]
        )

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.RecipeStepTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.RecipeStepTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateUserDefinedFunctionRequest:
    boto3_raw_data: "type_defs.CreateUserDefinedFunctionRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")

    @cached_property
    def FunctionInput(self):  # pragma: no cover
        return UserDefinedFunctionInput.make_one(self.boto3_raw_data["FunctionInput"])

    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.CreateUserDefinedFunctionRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateUserDefinedFunctionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateUserDefinedFunctionRequest:
    boto3_raw_data: "type_defs.UpdateUserDefinedFunctionRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    FunctionName = field("FunctionName")

    @cached_property
    def FunctionInput(self):  # pragma: no cover
        return UserDefinedFunctionInput.make_one(self.boto3_raw_data["FunctionInput"])

    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.UpdateUserDefinedFunctionRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateUserDefinedFunctionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetUserDefinedFunctionResponse:
    boto3_raw_data: "type_defs.GetUserDefinedFunctionResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def UserDefinedFunction(self):  # pragma: no cover
        return UserDefinedFunction.make_one(self.boto3_raw_data["UserDefinedFunction"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetUserDefinedFunctionResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetUserDefinedFunctionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetUserDefinedFunctionsResponse:
    boto3_raw_data: "type_defs.GetUserDefinedFunctionsResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def UserDefinedFunctions(self):  # pragma: no cover
        return UserDefinedFunction.make_many(
            self.boto3_raw_data["UserDefinedFunctions"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetUserDefinedFunctionsResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetUserDefinedFunctionsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StorageDescriptor:
    boto3_raw_data: "type_defs.StorageDescriptorTypeDef" = dataclasses.field()

    Columns = field("Columns")
    Location = field("Location")
    AdditionalLocations = field("AdditionalLocations")
    InputFormat = field("InputFormat")
    OutputFormat = field("OutputFormat")
    Compressed = field("Compressed")
    NumberOfBuckets = field("NumberOfBuckets")
    SerdeInfo = field("SerdeInfo")
    BucketColumns = field("BucketColumns")

    @cached_property
    def SortColumns(self):  # pragma: no cover
        return Order.make_many(self.boto3_raw_data["SortColumns"])

    Parameters = field("Parameters")
    SkewedInfo = field("SkewedInfo")
    StoredAsSubDirectories = field("StoredAsSubDirectories")

    @cached_property
    def SchemaReference(self):  # pragma: no cover
        return SchemaReference.make_one(self.boto3_raw_data["SchemaReference"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.StorageDescriptorTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StorageDescriptorTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Statement:
    boto3_raw_data: "type_defs.StatementTypeDef" = dataclasses.field()

    Id = field("Id")
    Code = field("Code")
    State = field("State")

    @cached_property
    def Output(self):  # pragma: no cover
        return StatementOutput.make_one(self.boto3_raw_data["Output"])

    Progress = field("Progress")
    StartedOn = field("StartedOn")
    CompletedOn = field("CompletedOn")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.StatementTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.StatementTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListDataQualityStatisticAnnotationsResponse:
    boto3_raw_data: "type_defs.ListDataQualityStatisticAnnotationsResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Annotations(self):  # pragma: no cover
        return StatisticAnnotation.make_many(self.boto3_raw_data["Annotations"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.ListDataQualityStatisticAnnotationsResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListDataQualityStatisticAnnotationsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListDataQualityStatisticsResponse:
    boto3_raw_data: "type_defs.ListDataQualityStatisticsResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Statistics(self):  # pragma: no cover
        return StatisticSummary.make_many(self.boto3_raw_data["Statistics"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.ListDataQualityStatisticsResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListDataQualityStatisticsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DynamicTransform:
    boto3_raw_data: "type_defs.DynamicTransformTypeDef" = dataclasses.field()

    Name = field("Name")
    TransformName = field("TransformName")
    Inputs = field("Inputs")
    FunctionName = field("FunctionName")
    Path = field("Path")
    Parameters = field("Parameters")
    Version = field("Version")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DynamicTransformTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DynamicTransformTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RedshiftTarget:
    boto3_raw_data: "type_defs.RedshiftTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Database = field("Database")
    Table = field("Table")
    RedshiftTmpDir = field("RedshiftTmpDir")
    TmpDirIAMRole = field("TmpDirIAMRole")
    UpsertRedshiftOptions = field("UpsertRedshiftOptions")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.RedshiftTargetTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.RedshiftTargetTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DescribeConnectionTypeResponse:
    boto3_raw_data: "type_defs.DescribeConnectionTypeResponseTypeDef" = (
        dataclasses.field()
    )

    ConnectionType = field("ConnectionType")
    Description = field("Description")

    @cached_property
    def Capabilities(self):  # pragma: no cover
        return Capabilities.make_one(self.boto3_raw_data["Capabilities"])

    ConnectionProperties = field("ConnectionProperties")
    ConnectionOptions = field("ConnectionOptions")

    @cached_property
    def AuthenticationConfiguration(self):  # pragma: no cover
        return AuthConfiguration.make_one(
            self.boto3_raw_data["AuthenticationConfiguration"]
        )

    ComputeEnvironmentConfigurations = field("ComputeEnvironmentConfigurations")
    PhysicalConnectionRequirements = field("PhysicalConnectionRequirements")
    AthenaConnectionProperties = field("AthenaConnectionProperties")
    PythonConnectionProperties = field("PythonConnectionProperties")
    SparkConnectionProperties = field("SparkConnectionProperties")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.DescribeConnectionTypeResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DescribeConnectionTypeResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AmazonRedshiftSource:
    boto3_raw_data: "type_defs.AmazonRedshiftSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Data = field("Data")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.AmazonRedshiftSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.AmazonRedshiftSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class AmazonRedshiftTarget:
    boto3_raw_data: "type_defs.AmazonRedshiftTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Data = field("Data")
    Inputs = field("Inputs")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.AmazonRedshiftTargetTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.AmazonRedshiftTargetTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SnowflakeSource:
    boto3_raw_data: "type_defs.SnowflakeSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Data = field("Data")

    @cached_property
    def OutputSchemas(self):  # pragma: no cover
        return GlueSchema.make_many(self.boto3_raw_data["OutputSchemas"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SnowflakeSourceTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SnowflakeSourceTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SnowflakeTarget:
    boto3_raw_data: "type_defs.SnowflakeTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Data = field("Data")
    Inputs = field("Inputs")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.SnowflakeTargetTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.SnowflakeTargetTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetPartitionIndexesResponse:
    boto3_raw_data: "type_defs.GetPartitionIndexesResponseTypeDef" = dataclasses.field()

    @cached_property
    def PartitionIndexDescriptorList(self):  # pragma: no cover
        return PartitionIndexDescriptor.make_many(
            self.boto3_raw_data["PartitionIndexDescriptorList"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetPartitionIndexesResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetPartitionIndexesResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TableStatusPaginator:
    boto3_raw_data: "type_defs.TableStatusPaginatorTypeDef" = dataclasses.field()

    RequestedBy = field("RequestedBy")
    UpdatedBy = field("UpdatedBy")
    RequestTime = field("RequestTime")
    UpdateTime = field("UpdateTime")
    Action = field("Action")
    State = field("State")

    @cached_property
    def Error(self):  # pragma: no cover
        return ErrorDetail.make_one(self.boto3_raw_data["Error"])

    @cached_property
    def Details(self):  # pragma: no cover
        return StatusDetailsPaginator.make_one(self.boto3_raw_data["Details"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.TableStatusPaginatorTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TableStatusPaginatorTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TableStatus:
    boto3_raw_data: "type_defs.TableStatusTypeDef" = dataclasses.field()

    RequestedBy = field("RequestedBy")
    UpdatedBy = field("UpdatedBy")
    RequestTime = field("RequestTime")
    UpdateTime = field("UpdateTime")
    Action = field("Action")
    State = field("State")

    @cached_property
    def Error(self):  # pragma: no cover
        return ErrorDetail.make_one(self.boto3_raw_data["Error"])

    @cached_property
    def Details(self):  # pragma: no cover
        return StatusDetails.make_one(self.boto3_raw_data["Details"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.TableStatusTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.TableStatusTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DecimalColumnStatisticsData:
    boto3_raw_data: "type_defs.DecimalColumnStatisticsDataTypeDef" = dataclasses.field()

    NumberOfNulls = field("NumberOfNulls")
    NumberOfDistinctValues = field("NumberOfDistinctValues")
    MinimumValue = field("MinimumValue")
    MaximumValue = field("MaximumValue")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DecimalColumnStatisticsDataTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DecimalColumnStatisticsDataTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateScriptRequest:
    boto3_raw_data: "type_defs.CreateScriptRequestTypeDef" = dataclasses.field()

    DagNodes = field("DagNodes")

    @cached_property
    def DagEdges(self):  # pragma: no cover
        return CodeGenEdge.make_many(self.boto3_raw_data["DagEdges"])

    Language = field("Language")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateScriptRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateScriptRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogKafkaSource:
    boto3_raw_data: "type_defs.CatalogKafkaSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Table = field("Table")
    Database = field("Database")
    WindowSize = field("WindowSize")
    DetectSchema = field("DetectSchema")
    StreamingOptions = field("StreamingOptions")

    @cached_property
    def DataPreviewOptions(self):  # pragma: no cover
        return StreamingDataPreviewOptions.make_one(
            self.boto3_raw_data["DataPreviewOptions"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CatalogKafkaSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CatalogKafkaSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DirectKafkaSource:
    boto3_raw_data: "type_defs.DirectKafkaSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    StreamingOptions = field("StreamingOptions")
    WindowSize = field("WindowSize")
    DetectSchema = field("DetectSchema")

    @cached_property
    def DataPreviewOptions(self):  # pragma: no cover
        return StreamingDataPreviewOptions.make_one(
            self.boto3_raw_data["DataPreviewOptions"]
        )

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DirectKafkaSourceTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DirectKafkaSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogKinesisSource:
    boto3_raw_data: "type_defs.CatalogKinesisSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    Table = field("Table")
    Database = field("Database")
    WindowSize = field("WindowSize")
    DetectSchema = field("DetectSchema")
    StreamingOptions = field("StreamingOptions")

    @cached_property
    def DataPreviewOptions(self):  # pragma: no cover
        return StreamingDataPreviewOptions.make_one(
            self.boto3_raw_data["DataPreviewOptions"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CatalogKinesisSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CatalogKinesisSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DirectKinesisSource:
    boto3_raw_data: "type_defs.DirectKinesisSourceTypeDef" = dataclasses.field()

    Name = field("Name")
    WindowSize = field("WindowSize")
    DetectSchema = field("DetectSchema")
    StreamingOptions = field("StreamingOptions")

    @cached_property
    def DataPreviewOptions(self):  # pragma: no cover
        return StreamingDataPreviewOptions.make_one(
            self.boto3_raw_data["DataPreviewOptions"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DirectKinesisSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DirectKinesisSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetTriggersResponse:
    boto3_raw_data: "type_defs.BatchGetTriggersResponseTypeDef" = dataclasses.field()

    @cached_property
    def Triggers(self):  # pragma: no cover
        return Trigger.make_many(self.boto3_raw_data["Triggers"])

    TriggersNotFound = field("TriggersNotFound")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchGetTriggersResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetTriggersResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTriggerResponse:
    boto3_raw_data: "type_defs.GetTriggerResponseTypeDef" = dataclasses.field()

    @cached_property
    def Trigger(self):  # pragma: no cover
        return Trigger.make_one(self.boto3_raw_data["Trigger"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetTriggerResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetTriggerResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTriggersResponse:
    boto3_raw_data: "type_defs.GetTriggersResponseTypeDef" = dataclasses.field()

    @cached_property
    def Triggers(self):  # pragma: no cover
        return Trigger.make_many(self.boto3_raw_data["Triggers"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetTriggersResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetTriggersResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TriggerNodeDetails:
    boto3_raw_data: "type_defs.TriggerNodeDetailsTypeDef" = dataclasses.field()

    @cached_property
    def Trigger(self):  # pragma: no cover
        return Trigger.make_one(self.boto3_raw_data["Trigger"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.TriggerNodeDetailsTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TriggerNodeDetailsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateTriggerResponse:
    boto3_raw_data: "type_defs.UpdateTriggerResponseTypeDef" = dataclasses.field()

    @cached_property
    def Trigger(self):  # pragma: no cover
        return Trigger.make_one(self.boto3_raw_data["Trigger"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateTriggerResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateTriggerResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateTriggerRequest:
    boto3_raw_data: "type_defs.CreateTriggerRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    Type = field("Type")
    Actions = field("Actions")
    WorkflowName = field("WorkflowName")
    Schedule = field("Schedule")
    Predicate = field("Predicate")
    Description = field("Description")
    StartOnCreation = field("StartOnCreation")
    Tags = field("Tags")

    @cached_property
    def EventBatchingCondition(self):  # pragma: no cover
        return EventBatchingCondition.make_one(
            self.boto3_raw_data["EventBatchingCondition"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateTriggerRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateTriggerRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TriggerUpdate:
    boto3_raw_data: "type_defs.TriggerUpdateTypeDef" = dataclasses.field()

    Name = field("Name")
    Description = field("Description")
    Schedule = field("Schedule")
    Actions = field("Actions")
    Predicate = field("Predicate")

    @cached_property
    def EventBatchingCondition(self):  # pragma: no cover
        return EventBatchingCondition.make_one(
            self.boto3_raw_data["EventBatchingCondition"]
        )

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.TriggerUpdateTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.TriggerUpdateTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateUsageProfileRequest:
    boto3_raw_data: "type_defs.CreateUsageProfileRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    Configuration = field("Configuration")
    Description = field("Description")
    Tags = field("Tags")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateUsageProfileRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateUsageProfileRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateUsageProfileRequest:
    boto3_raw_data: "type_defs.UpdateUsageProfileRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    Configuration = field("Configuration")
    Description = field("Description")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateUsageProfileRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateUsageProfileRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetMLTransformResponse:
    boto3_raw_data: "type_defs.GetMLTransformResponseTypeDef" = dataclasses.field()

    TransformId = field("TransformId")
    Name = field("Name")
    Description = field("Description")
    Status = field("Status")
    CreatedOn = field("CreatedOn")
    LastModifiedOn = field("LastModifiedOn")

    @cached_property
    def InputRecordTables(self):  # pragma: no cover
        return GlueTableOutput.make_many(self.boto3_raw_data["InputRecordTables"])

    @cached_property
    def Parameters(self):  # pragma: no cover
        return TransformParameters.make_one(self.boto3_raw_data["Parameters"])

    @cached_property
    def EvaluationMetrics(self):  # pragma: no cover
        return EvaluationMetrics.make_one(self.boto3_raw_data["EvaluationMetrics"])

    LabelCount = field("LabelCount")

    @cached_property
    def Schema(self):  # pragma: no cover
        return SchemaColumn.make_many(self.boto3_raw_data["Schema"])

    Role = field("Role")
    GlueVersion = field("GlueVersion")
    MaxCapacity = field("MaxCapacity")
    WorkerType = field("WorkerType")
    NumberOfWorkers = field("NumberOfWorkers")
    Timeout = field("Timeout")
    MaxRetries = field("MaxRetries")

    @cached_property
    def TransformEncryption(self):  # pragma: no cover
        return TransformEncryption.make_one(self.boto3_raw_data["TransformEncryption"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetMLTransformResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetMLTransformResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class MLTransform:
    boto3_raw_data: "type_defs.MLTransformTypeDef" = dataclasses.field()

    TransformId = field("TransformId")
    Name = field("Name")
    Description = field("Description")
    Status = field("Status")
    CreatedOn = field("CreatedOn")
    LastModifiedOn = field("LastModifiedOn")

    @cached_property
    def InputRecordTables(self):  # pragma: no cover
        return GlueTableOutput.make_many(self.boto3_raw_data["InputRecordTables"])

    @cached_property
    def Parameters(self):  # pragma: no cover
        return TransformParameters.make_one(self.boto3_raw_data["Parameters"])

    @cached_property
    def EvaluationMetrics(self):  # pragma: no cover
        return EvaluationMetrics.make_one(self.boto3_raw_data["EvaluationMetrics"])

    LabelCount = field("LabelCount")

    @cached_property
    def Schema(self):  # pragma: no cover
        return SchemaColumn.make_many(self.boto3_raw_data["Schema"])

    Role = field("Role")
    GlueVersion = field("GlueVersion")
    MaxCapacity = field("MaxCapacity")
    WorkerType = field("WorkerType")
    NumberOfWorkers = field("NumberOfWorkers")
    Timeout = field("Timeout")
    MaxRetries = field("MaxRetries")

    @cached_property
    def TransformEncryption(self):  # pragma: no cover
        return TransformEncryption.make_one(self.boto3_raw_data["TransformEncryption"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.MLTransformTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.MLTransformTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetCrawlersResponse:
    boto3_raw_data: "type_defs.BatchGetCrawlersResponseTypeDef" = dataclasses.field()

    @cached_property
    def Crawlers(self):  # pragma: no cover
        return Crawler.make_many(self.boto3_raw_data["Crawlers"])

    CrawlersNotFound = field("CrawlersNotFound")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchGetCrawlersResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetCrawlersResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetCrawlerResponse:
    boto3_raw_data: "type_defs.GetCrawlerResponseTypeDef" = dataclasses.field()

    @cached_property
    def Crawler(self):  # pragma: no cover
        return Crawler.make_one(self.boto3_raw_data["Crawler"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetCrawlerResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetCrawlerResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetCrawlersResponse:
    boto3_raw_data: "type_defs.GetCrawlersResponseTypeDef" = dataclasses.field()

    @cached_property
    def Crawlers(self):  # pragma: no cover
        return Crawler.make_many(self.boto3_raw_data["Crawlers"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetCrawlersResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetCrawlersResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateCrawlerRequest:
    boto3_raw_data: "type_defs.CreateCrawlerRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    Role = field("Role")
    Targets = field("Targets")
    DatabaseName = field("DatabaseName")
    Description = field("Description")
    Schedule = field("Schedule")
    Classifiers = field("Classifiers")
    TablePrefix = field("TablePrefix")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return SchemaChangePolicy.make_one(self.boto3_raw_data["SchemaChangePolicy"])

    @cached_property
    def RecrawlPolicy(self):  # pragma: no cover
        return RecrawlPolicy.make_one(self.boto3_raw_data["RecrawlPolicy"])

    @cached_property
    def LineageConfiguration(self):  # pragma: no cover
        return LineageConfiguration.make_one(
            self.boto3_raw_data["LineageConfiguration"]
        )

    @cached_property
    def LakeFormationConfiguration(self):  # pragma: no cover
        return LakeFormationConfiguration.make_one(
            self.boto3_raw_data["LakeFormationConfiguration"]
        )

    Configuration = field("Configuration")
    CrawlerSecurityConfiguration = field("CrawlerSecurityConfiguration")
    Tags = field("Tags")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateCrawlerRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateCrawlerRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateCrawlerRequest:
    boto3_raw_data: "type_defs.UpdateCrawlerRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    Role = field("Role")
    DatabaseName = field("DatabaseName")
    Description = field("Description")
    Targets = field("Targets")
    Schedule = field("Schedule")
    Classifiers = field("Classifiers")
    TablePrefix = field("TablePrefix")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return SchemaChangePolicy.make_one(self.boto3_raw_data["SchemaChangePolicy"])

    @cached_property
    def RecrawlPolicy(self):  # pragma: no cover
        return RecrawlPolicy.make_one(self.boto3_raw_data["RecrawlPolicy"])

    @cached_property
    def LineageConfiguration(self):  # pragma: no cover
        return LineageConfiguration.make_one(
            self.boto3_raw_data["LineageConfiguration"]
        )

    @cached_property
    def LakeFormationConfiguration(self):  # pragma: no cover
        return LakeFormationConfiguration.make_one(
            self.boto3_raw_data["LakeFormationConfiguration"]
        )

    Configuration = field("Configuration")
    CrawlerSecurityConfiguration = field("CrawlerSecurityConfiguration")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateCrawlerRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateCrawlerRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetCatalogResponse:
    boto3_raw_data: "type_defs.GetCatalogResponseTypeDef" = dataclasses.field()

    @cached_property
    def Catalog(self):  # pragma: no cover
        return Catalog.make_one(self.boto3_raw_data["Catalog"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetCatalogResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetCatalogResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetCatalogsResponse:
    boto3_raw_data: "type_defs.GetCatalogsResponseTypeDef" = dataclasses.field()

    @cached_property
    def CatalogList(self):  # pragma: no cover
        return Catalog.make_many(self.boto3_raw_data["CatalogList"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetCatalogsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetCatalogsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDatabaseResponse:
    boto3_raw_data: "type_defs.GetDatabaseResponseTypeDef" = dataclasses.field()

    @cached_property
    def Database(self):  # pragma: no cover
        return Database.make_one(self.boto3_raw_data["Database"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetDatabaseResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDatabaseResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDatabasesResponse:
    boto3_raw_data: "type_defs.GetDatabasesResponseTypeDef" = dataclasses.field()

    @cached_property
    def DatabaseList(self):  # pragma: no cover
        return Database.make_many(self.boto3_raw_data["DatabaseList"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetDatabasesResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDatabasesResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CatalogInput:
    boto3_raw_data: "type_defs.CatalogInputTypeDef" = dataclasses.field()

    Description = field("Description")

    @cached_property
    def FederatedCatalog(self):  # pragma: no cover
        return FederatedCatalog.make_one(self.boto3_raw_data["FederatedCatalog"])

    Parameters = field("Parameters")

    @cached_property
    def TargetRedshiftCatalog(self):  # pragma: no cover
        return TargetRedshiftCatalog.make_one(
            self.boto3_raw_data["TargetRedshiftCatalog"]
        )

    @cached_property
    def CatalogProperties(self):  # pragma: no cover
        return CatalogProperties.make_one(self.boto3_raw_data["CatalogProperties"])

    CreateTableDefaultPermissions = field("CreateTableDefaultPermissions")
    CreateDatabaseDefaultPermissions = field("CreateDatabaseDefaultPermissions")
    AllowFullTableExternalDataAccess = field("AllowFullTableExternalDataAccess")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CatalogInputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.CatalogInputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DatabaseInput:
    boto3_raw_data: "type_defs.DatabaseInputTypeDef" = dataclasses.field()

    Name = field("Name")
    Description = field("Description")
    LocationUri = field("LocationUri")
    Parameters = field("Parameters")
    CreateTableDefaultPermissions = field("CreateTableDefaultPermissions")

    @cached_property
    def TargetDatabase(self):  # pragma: no cover
        return DatabaseIdentifier.make_one(self.boto3_raw_data["TargetDatabase"])

    @cached_property
    def FederatedDatabase(self):  # pragma: no cover
        return FederatedDatabase.make_one(self.boto3_raw_data["FederatedDatabase"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DatabaseInputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.DatabaseInputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityResult:
    boto3_raw_data: "type_defs.DataQualityResultTypeDef" = dataclasses.field()

    ResultId = field("ResultId")
    ProfileId = field("ProfileId")
    Score = field("Score")

    @cached_property
    def DataSource(self):  # pragma: no cover
        return DataSourceOutput.make_one(self.boto3_raw_data["DataSource"])

    RulesetName = field("RulesetName")
    EvaluationContext = field("EvaluationContext")
    StartedOn = field("StartedOn")
    CompletedOn = field("CompletedOn")
    JobName = field("JobName")
    JobRunId = field("JobRunId")
    RulesetEvaluationRunId = field("RulesetEvaluationRunId")

    @cached_property
    def RuleResults(self):  # pragma: no cover
        return DataQualityRuleResult.make_many(self.boto3_raw_data["RuleResults"])

    @cached_property
    def AnalyzerResults(self):  # pragma: no cover
        return DataQualityAnalyzerResult.make_many(
            self.boto3_raw_data["AnalyzerResults"]
        )

    @cached_property
    def Observations(self):  # pragma: no cover
        return DataQualityObservation.make_many(self.boto3_raw_data["Observations"])

    @cached_property
    def AggregatedMetrics(self):  # pragma: no cover
        return DataQualityAggregatedMetrics.make_one(
            self.boto3_raw_data["AggregatedMetrics"]
        )

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.DataQualityResultTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityResultTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetDataQualityResultResponse:
    boto3_raw_data: "type_defs.GetDataQualityResultResponseTypeDef" = (
        dataclasses.field()
    )

    ResultId = field("ResultId")
    ProfileId = field("ProfileId")
    Score = field("Score")

    @cached_property
    def DataSource(self):  # pragma: no cover
        return DataSourceOutput.make_one(self.boto3_raw_data["DataSource"])

    RulesetName = field("RulesetName")
    EvaluationContext = field("EvaluationContext")
    StartedOn = field("StartedOn")
    CompletedOn = field("CompletedOn")
    JobName = field("JobName")
    JobRunId = field("JobRunId")
    RulesetEvaluationRunId = field("RulesetEvaluationRunId")

    @cached_property
    def RuleResults(self):  # pragma: no cover
        return DataQualityRuleResult.make_many(self.boto3_raw_data["RuleResults"])

    @cached_property
    def AnalyzerResults(self):  # pragma: no cover
        return DataQualityAnalyzerResult.make_many(
            self.boto3_raw_data["AnalyzerResults"]
        )

    @cached_property
    def Observations(self):  # pragma: no cover
        return DataQualityObservation.make_many(self.boto3_raw_data["Observations"])

    @cached_property
    def AggregatedMetrics(self):  # pragma: no cover
        return DataQualityAggregatedMetrics.make_one(
            self.boto3_raw_data["AggregatedMetrics"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetDataQualityResultResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetDataQualityResultResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListDataQualityResultsResponse:
    boto3_raw_data: "type_defs.ListDataQualityResultsResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Results(self):  # pragma: no cover
        return DataQualityResultDescription.make_many(self.boto3_raw_data["Results"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.ListDataQualityResultsResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListDataQualityResultsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListDataQualityRuleRecommendationRunsResponse:
    boto3_raw_data: "type_defs.ListDataQualityRuleRecommendationRunsResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Runs(self):  # pragma: no cover
        return DataQualityRuleRecommendationRunDescription.make_many(
            self.boto3_raw_data["Runs"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.ListDataQualityRuleRecommendationRunsResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListDataQualityRuleRecommendationRunsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListDataQualityRulesetEvaluationRunsResponse:
    boto3_raw_data: "type_defs.ListDataQualityRulesetEvaluationRunsResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Runs(self):  # pragma: no cover
        return DataQualityRulesetEvaluationRunDescription.make_many(
            self.boto3_raw_data["Runs"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.ListDataQualityRulesetEvaluationRunsResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListDataQualityRulesetEvaluationRunsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ColumnStatisticsOutput:
    boto3_raw_data: "type_defs.ColumnStatisticsOutputTypeDef" = dataclasses.field()

    ColumnName = field("ColumnName")
    ColumnType = field("ColumnType")
    AnalyzedTime = field("AnalyzedTime")

    @cached_property
    def StatisticsData(self):  # pragma: no cover
        return ColumnStatisticsDataOutput.make_one(
            self.boto3_raw_data["StatisticsData"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ColumnStatisticsOutputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ColumnStatisticsOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Partition:
    boto3_raw_data: "type_defs.PartitionTypeDef" = dataclasses.field()

    Values = field("Values")
    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    CreationTime = field("CreationTime")
    LastAccessTime = field("LastAccessTime")

    @cached_property
    def StorageDescriptor(self):  # pragma: no cover
        return StorageDescriptorOutput.make_one(
            self.boto3_raw_data["StorageDescriptor"]
        )

    Parameters = field("Parameters")
    LastAnalyzedTime = field("LastAnalyzedTime")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.PartitionTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.PartitionTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetSecurityConfigurationResponse:
    boto3_raw_data: "type_defs.GetSecurityConfigurationResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def SecurityConfiguration(self):  # pragma: no cover
        return SecurityConfiguration.make_one(
            self.boto3_raw_data["SecurityConfiguration"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.GetSecurityConfigurationResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetSecurityConfigurationResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetSecurityConfigurationsResponse:
    boto3_raw_data: "type_defs.GetSecurityConfigurationsResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def SecurityConfigurations(self):  # pragma: no cover
        return SecurityConfiguration.make_many(
            self.boto3_raw_data["SecurityConfigurations"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetSecurityConfigurationsResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetSecurityConfigurationsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateSecurityConfigurationRequest:
    boto3_raw_data: "type_defs.CreateSecurityConfigurationRequestTypeDef" = (
        dataclasses.field()
    )

    Name = field("Name")
    EncryptionConfiguration = field("EncryptionConfiguration")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.CreateSecurityConfigurationRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateSecurityConfigurationRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class RouteOutput:
    boto3_raw_data: "type_defs.RouteOutputTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")

    @cached_property
    def GroupFiltersList(self):  # pragma: no cover
        return GroupFiltersOutput.make_many(self.boto3_raw_data["GroupFiltersList"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.RouteOutputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.RouteOutputTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DynamoDBELTConnectorSource:
    boto3_raw_data: "type_defs.DynamoDBELTConnectorSourceTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def ConnectionOptions(self):  # pragma: no cover
        return DDBELTConnectionOptions.make_one(
            self.boto3_raw_data["ConnectionOptions"]
        )

    OutputSchemas = field("OutputSchemas")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.DynamoDBELTConnectorSourceTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DynamoDBELTConnectorSourceTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class S3HyperDirectTarget:
    boto3_raw_data: "type_defs.S3HyperDirectTargetTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    Path = field("Path")
    Format = field("Format")
    PartitionKeys = field("PartitionKeys")
    Compression = field("Compression")

    @cached_property
    def SchemaChangePolicy(self):  # pragma: no cover
        return DirectSchemaChangePolicy.make_one(
            self.boto3_raw_data["SchemaChangePolicy"]
        )

    @cached_property
    def AutoDataQuality(self):  # pragma: no cover
        return AutoDataQuality.make_one(self.boto3_raw_data["AutoDataQuality"])

    OutputSchemas = field("OutputSchemas")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.S3HyperDirectTargetTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.S3HyperDirectTargetTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateTableOptimizerRequest:
    boto3_raw_data: "type_defs.CreateTableOptimizerRequestTypeDef" = dataclasses.field()

    CatalogId = field("CatalogId")
    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    Type = field("Type")

    @cached_property
    def TableOptimizerConfiguration(self):  # pragma: no cover
        return TableOptimizerConfiguration.make_one(
            self.boto3_raw_data["TableOptimizerConfiguration"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateTableOptimizerRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateTableOptimizerRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateTableOptimizerRequest:
    boto3_raw_data: "type_defs.UpdateTableOptimizerRequestTypeDef" = dataclasses.field()

    CatalogId = field("CatalogId")
    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    Type = field("Type")

    @cached_property
    def TableOptimizerConfiguration(self):  # pragma: no cover
        return TableOptimizerConfiguration.make_one(
            self.boto3_raw_data["TableOptimizerConfiguration"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateTableOptimizerRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateTableOptimizerRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListTableOptimizerRunsResponse:
    boto3_raw_data: "type_defs.ListTableOptimizerRunsResponseTypeDef" = (
        dataclasses.field()
    )

    CatalogId = field("CatalogId")
    DatabaseName = field("DatabaseName")
    TableName = field("TableName")

    @cached_property
    def TableOptimizerRuns(self):  # pragma: no cover
        return TableOptimizerRun.make_many(self.boto3_raw_data["TableOptimizerRuns"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.ListTableOptimizerRunsResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListTableOptimizerRunsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TableOptimizer:
    boto3_raw_data: "type_defs.TableOptimizerTypeDef" = dataclasses.field()

    type = field("type")

    @cached_property
    def configuration(self):  # pragma: no cover
        return TableOptimizerConfiguration.make_one(
            self.boto3_raw_data["configuration"]
        )

    @cached_property
    def lastRun(self):  # pragma: no cover
        return TableOptimizerRun.make_one(self.boto3_raw_data["lastRun"])

    configurationSource = field("configurationSource")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.TableOptimizerTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.TableOptimizerTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class IcebergInput:
    boto3_raw_data: "type_defs.IcebergInputTypeDef" = dataclasses.field()

    MetadataOperation = field("MetadataOperation")
    Version = field("Version")

    @cached_property
    def CreateIcebergTableInput(self):  # pragma: no cover
        return CreateIcebergTableInput.make_one(
            self.boto3_raw_data["CreateIcebergTableInput"]
        )

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.IcebergInputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.IcebergInputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateIcebergTableInput:
    boto3_raw_data: "type_defs.UpdateIcebergTableInputTypeDef" = dataclasses.field()

    @cached_property
    def Updates(self):  # pragma: no cover
        return IcebergTableUpdate.make_many(self.boto3_raw_data["Updates"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateIcebergTableInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateIcebergTableInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateIntegrationTablePropertiesRequest:
    boto3_raw_data: "type_defs.CreateIntegrationTablePropertiesRequestTypeDef" = (
        dataclasses.field()
    )

    ResourceArn = field("ResourceArn")
    TableName = field("TableName")
    SourceTableConfig = field("SourceTableConfig")
    TargetTableConfig = field("TargetTableConfig")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.CreateIntegrationTablePropertiesRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateIntegrationTablePropertiesRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateIntegrationTablePropertiesRequest:
    boto3_raw_data: "type_defs.UpdateIntegrationTablePropertiesRequestTypeDef" = (
        dataclasses.field()
    )

    ResourceArn = field("ResourceArn")
    TableName = field("TableName")
    SourceTableConfig = field("SourceTableConfig")
    TargetTableConfig = field("TargetTableConfig")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.UpdateIntegrationTablePropertiesRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateIntegrationTablePropertiesRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetMLTaskRunsResponse:
    boto3_raw_data: "type_defs.GetMLTaskRunsResponseTypeDef" = dataclasses.field()

    @cached_property
    def TaskRuns(self):  # pragma: no cover
        return TaskRun.make_many(self.boto3_raw_data["TaskRuns"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetMLTaskRunsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetMLTaskRunsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Connection:
    boto3_raw_data: "type_defs.ConnectionTypeDef" = dataclasses.field()

    Name = field("Name")
    Description = field("Description")
    ConnectionType = field("ConnectionType")
    MatchCriteria = field("MatchCriteria")
    ConnectionProperties = field("ConnectionProperties")
    SparkProperties = field("SparkProperties")
    AthenaProperties = field("AthenaProperties")
    PythonProperties = field("PythonProperties")

    @cached_property
    def PhysicalConnectionRequirements(self):  # pragma: no cover
        return PhysicalConnectionRequirementsOutput.make_one(
            self.boto3_raw_data["PhysicalConnectionRequirements"]
        )

    CreationTime = field("CreationTime")
    LastUpdatedTime = field("LastUpdatedTime")
    LastUpdatedBy = field("LastUpdatedBy")
    Status = field("Status")
    StatusReason = field("StatusReason")
    LastConnectionValidationTime = field("LastConnectionValidationTime")

    @cached_property
    def AuthenticationConfiguration(self):  # pragma: no cover
        return AuthenticationConfiguration.make_one(
            self.boto3_raw_data["AuthenticationConfiguration"]
        )

    ConnectionSchemaVersion = field("ConnectionSchemaVersion")
    CompatibleComputeEnvironments = field("CompatibleComputeEnvironments")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ConnectionTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ConnectionTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ConnectionInput:
    boto3_raw_data: "type_defs.ConnectionInputTypeDef" = dataclasses.field()

    Name = field("Name")
    ConnectionType = field("ConnectionType")
    ConnectionProperties = field("ConnectionProperties")
    Description = field("Description")
    MatchCriteria = field("MatchCriteria")
    SparkProperties = field("SparkProperties")
    AthenaProperties = field("AthenaProperties")
    PythonProperties = field("PythonProperties")
    PhysicalConnectionRequirements = field("PhysicalConnectionRequirements")

    @cached_property
    def AuthenticationConfiguration(self):  # pragma: no cover
        return AuthenticationConfigurationInput.make_one(
            self.boto3_raw_data["AuthenticationConfiguration"]
        )

    ValidateCredentials = field("ValidateCredentials")
    ValidateForComputeEnvironments = field("ValidateForComputeEnvironments")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ConnectionInputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.ConnectionInputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TestConnectionInput:
    boto3_raw_data: "type_defs.TestConnectionInputTypeDef" = dataclasses.field()

    ConnectionType = field("ConnectionType")
    ConnectionProperties = field("ConnectionProperties")

    @cached_property
    def AuthenticationConfiguration(self):  # pragma: no cover
        return AuthenticationConfigurationInput.make_one(
            self.boto3_raw_data["AuthenticationConfiguration"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.TestConnectionInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TestConnectionInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetStatementResponse:
    boto3_raw_data: "type_defs.GetStatementResponseTypeDef" = dataclasses.field()

    @cached_property
    def Statement(self):  # pragma: no cover
        return Statement.make_one(self.boto3_raw_data["Statement"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetStatementResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetStatementResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListStatementsResponse:
    boto3_raw_data: "type_defs.ListStatementsResponseTypeDef" = dataclasses.field()

    @cached_property
    def Statements(self):  # pragma: no cover
        return Statement.make_many(self.boto3_raw_data["Statements"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ListStatementsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListStatementsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TablePaginator:
    boto3_raw_data: "type_defs.TablePaginatorTypeDef" = dataclasses.field()

    Name = field("Name")
    DatabaseName = field("DatabaseName")
    Description = field("Description")
    Owner = field("Owner")
    CreateTime = field("CreateTime")
    UpdateTime = field("UpdateTime")
    LastAccessTime = field("LastAccessTime")
    LastAnalyzedTime = field("LastAnalyzedTime")
    Retention = field("Retention")

    @cached_property
    def StorageDescriptor(self):  # pragma: no cover
        return StorageDescriptorOutput.make_one(
            self.boto3_raw_data["StorageDescriptor"]
        )

    @cached_property
    def PartitionKeys(self):  # pragma: no cover
        return ColumnOutput.make_many(self.boto3_raw_data["PartitionKeys"])

    ViewOriginalText = field("ViewOriginalText")
    ViewExpandedText = field("ViewExpandedText")
    TableType = field("TableType")
    Parameters = field("Parameters")
    CreatedBy = field("CreatedBy")
    IsRegisteredWithLakeFormation = field("IsRegisteredWithLakeFormation")

    @cached_property
    def TargetTable(self):  # pragma: no cover
        return TableIdentifier.make_one(self.boto3_raw_data["TargetTable"])

    CatalogId = field("CatalogId")
    VersionId = field("VersionId")

    @cached_property
    def FederatedTable(self):  # pragma: no cover
        return FederatedTable.make_one(self.boto3_raw_data["FederatedTable"])

    @cached_property
    def ViewDefinition(self):  # pragma: no cover
        return ViewDefinition.make_one(self.boto3_raw_data["ViewDefinition"])

    IsMultiDialectView = field("IsMultiDialectView")

    @cached_property
    def Status(self):  # pragma: no cover
        return TableStatusPaginator.make_one(self.boto3_raw_data["Status"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.TablePaginatorTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.TablePaginatorTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Table:
    boto3_raw_data: "type_defs.TableTypeDef" = dataclasses.field()

    Name = field("Name")
    DatabaseName = field("DatabaseName")
    Description = field("Description")
    Owner = field("Owner")
    CreateTime = field("CreateTime")
    UpdateTime = field("UpdateTime")
    LastAccessTime = field("LastAccessTime")
    LastAnalyzedTime = field("LastAnalyzedTime")
    Retention = field("Retention")

    @cached_property
    def StorageDescriptor(self):  # pragma: no cover
        return StorageDescriptorOutput.make_one(
            self.boto3_raw_data["StorageDescriptor"]
        )

    @cached_property
    def PartitionKeys(self):  # pragma: no cover
        return ColumnOutput.make_many(self.boto3_raw_data["PartitionKeys"])

    ViewOriginalText = field("ViewOriginalText")
    ViewExpandedText = field("ViewExpandedText")
    TableType = field("TableType")
    Parameters = field("Parameters")
    CreatedBy = field("CreatedBy")
    IsRegisteredWithLakeFormation = field("IsRegisteredWithLakeFormation")

    @cached_property
    def TargetTable(self):  # pragma: no cover
        return TableIdentifier.make_one(self.boto3_raw_data["TargetTable"])

    CatalogId = field("CatalogId")
    VersionId = field("VersionId")

    @cached_property
    def FederatedTable(self):  # pragma: no cover
        return FederatedTable.make_one(self.boto3_raw_data["FederatedTable"])

    @cached_property
    def ViewDefinition(self):  # pragma: no cover
        return ViewDefinition.make_one(self.boto3_raw_data["ViewDefinition"])

    IsMultiDialectView = field("IsMultiDialectView")

    @cached_property
    def Status(self):  # pragma: no cover
        return TableStatus.make_one(self.boto3_raw_data["Status"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.TableTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.TableTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Node:
    boto3_raw_data: "type_defs.NodeTypeDef" = dataclasses.field()

    Type = field("Type")
    Name = field("Name")
    UniqueId = field("UniqueId")

    @cached_property
    def TriggerDetails(self):  # pragma: no cover
        return TriggerNodeDetails.make_one(self.boto3_raw_data["TriggerDetails"])

    @cached_property
    def JobDetails(self):  # pragma: no cover
        return JobNodeDetails.make_one(self.boto3_raw_data["JobDetails"])

    @cached_property
    def CrawlerDetails(self):  # pragma: no cover
        return CrawlerNodeDetails.make_one(self.boto3_raw_data["CrawlerDetails"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.NodeTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.NodeTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateTriggerRequest:
    boto3_raw_data: "type_defs.UpdateTriggerRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def TriggerUpdate(self):  # pragma: no cover
        return TriggerUpdate.make_one(self.boto3_raw_data["TriggerUpdate"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateTriggerRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateTriggerRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetMLTransformsResponse:
    boto3_raw_data: "type_defs.GetMLTransformsResponseTypeDef" = dataclasses.field()

    @cached_property
    def Transforms(self):  # pragma: no cover
        return MLTransform.make_many(self.boto3_raw_data["Transforms"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetMLTransformsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetMLTransformsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateCatalogRequest:
    boto3_raw_data: "type_defs.CreateCatalogRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def CatalogInput(self):  # pragma: no cover
        return CatalogInput.make_one(self.boto3_raw_data["CatalogInput"])

    Tags = field("Tags")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateCatalogRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateCatalogRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateCatalogRequest:
    boto3_raw_data: "type_defs.UpdateCatalogRequestTypeDef" = dataclasses.field()

    CatalogId = field("CatalogId")

    @cached_property
    def CatalogInput(self):  # pragma: no cover
        return CatalogInput.make_one(self.boto3_raw_data["CatalogInput"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateCatalogRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateCatalogRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateDatabaseRequest:
    boto3_raw_data: "type_defs.CreateDatabaseRequestTypeDef" = dataclasses.field()

    @cached_property
    def DatabaseInput(self):  # pragma: no cover
        return DatabaseInput.make_one(self.boto3_raw_data["DatabaseInput"])

    CatalogId = field("CatalogId")
    Tags = field("Tags")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateDatabaseRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateDatabaseRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateDatabaseRequest:
    boto3_raw_data: "type_defs.UpdateDatabaseRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def DatabaseInput(self):  # pragma: no cover
        return DatabaseInput.make_one(self.boto3_raw_data["DatabaseInput"])

    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateDatabaseRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateDatabaseRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetDataQualityResultResponse:
    boto3_raw_data: "type_defs.BatchGetDataQualityResultResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Results(self):  # pragma: no cover
        return DataQualityResult.make_many(self.boto3_raw_data["Results"])

    ResultsNotFound = field("ResultsNotFound")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.BatchGetDataQualityResultResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetDataQualityResultResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ColumnStatisticsError:
    boto3_raw_data: "type_defs.ColumnStatisticsErrorTypeDef" = dataclasses.field()

    @cached_property
    def ColumnStatistics(self):  # pragma: no cover
        return ColumnStatisticsOutput.make_one(self.boto3_raw_data["ColumnStatistics"])

    @cached_property
    def Error(self):  # pragma: no cover
        return ErrorDetail.make_one(self.boto3_raw_data["Error"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ColumnStatisticsErrorTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ColumnStatisticsErrorTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetColumnStatisticsForPartitionResponse:
    boto3_raw_data: "type_defs.GetColumnStatisticsForPartitionResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def ColumnStatisticsList(self):  # pragma: no cover
        return ColumnStatisticsOutput.make_many(
            self.boto3_raw_data["ColumnStatisticsList"]
        )

    @cached_property
    def Errors(self):  # pragma: no cover
        return ColumnError.make_many(self.boto3_raw_data["Errors"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetColumnStatisticsForPartitionResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetColumnStatisticsForPartitionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetColumnStatisticsForTableResponse:
    boto3_raw_data: "type_defs.GetColumnStatisticsForTableResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def ColumnStatisticsList(self):  # pragma: no cover
        return ColumnStatisticsOutput.make_many(
            self.boto3_raw_data["ColumnStatisticsList"]
        )

    @cached_property
    def Errors(self):  # pragma: no cover
        return ColumnError.make_many(self.boto3_raw_data["Errors"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetColumnStatisticsForTableResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetColumnStatisticsForTableResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetPartitionResponse:
    boto3_raw_data: "type_defs.BatchGetPartitionResponseTypeDef" = dataclasses.field()

    @cached_property
    def Partitions(self):  # pragma: no cover
        return Partition.make_many(self.boto3_raw_data["Partitions"])

    @cached_property
    def UnprocessedKeys(self):  # pragma: no cover
        return PartitionValueListOutput.make_many(
            self.boto3_raw_data["UnprocessedKeys"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchGetPartitionResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetPartitionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetPartitionResponse:
    boto3_raw_data: "type_defs.GetPartitionResponseTypeDef" = dataclasses.field()

    @cached_property
    def Partition(self):  # pragma: no cover
        return Partition.make_one(self.boto3_raw_data["Partition"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetPartitionResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetPartitionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetPartitionsResponse:
    boto3_raw_data: "type_defs.GetPartitionsResponseTypeDef" = dataclasses.field()

    @cached_property
    def Partitions(self):  # pragma: no cover
        return Partition.make_many(self.boto3_raw_data["Partitions"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetPartitionsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetPartitionsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetUnfilteredPartitionMetadataResponse:
    boto3_raw_data: "type_defs.GetUnfilteredPartitionMetadataResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Partition(self):  # pragma: no cover
        return Partition.make_one(self.boto3_raw_data["Partition"])

    AuthorizedColumns = field("AuthorizedColumns")
    IsRegisteredWithLakeFormation = field("IsRegisteredWithLakeFormation")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetUnfilteredPartitionMetadataResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetUnfilteredPartitionMetadataResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UnfilteredPartition:
    boto3_raw_data: "type_defs.UnfilteredPartitionTypeDef" = dataclasses.field()

    @cached_property
    def Partition(self):  # pragma: no cover
        return Partition.make_one(self.boto3_raw_data["Partition"])

    AuthorizedColumns = field("AuthorizedColumns")
    IsRegisteredWithLakeFormation = field("IsRegisteredWithLakeFormation")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UnfilteredPartitionTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UnfilteredPartitionTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CodeGenConfigurationNodeOutput:
    boto3_raw_data: "type_defs.CodeGenConfigurationNodeOutputTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def AthenaConnectorSource(self):  # pragma: no cover
        return AthenaConnectorSourceOutput.make_one(
            self.boto3_raw_data["AthenaConnectorSource"]
        )

    @cached_property
    def JDBCConnectorSource(self):  # pragma: no cover
        return JDBCConnectorSourceOutput.make_one(
            self.boto3_raw_data["JDBCConnectorSource"]
        )

    @cached_property
    def SparkConnectorSource(self):  # pragma: no cover
        return SparkConnectorSourceOutput.make_one(
            self.boto3_raw_data["SparkConnectorSource"]
        )

    @cached_property
    def CatalogSource(self):  # pragma: no cover
        return CatalogSourceOutput.make_one(self.boto3_raw_data["CatalogSource"])

    @cached_property
    def RedshiftSource(self):  # pragma: no cover
        return RedshiftSource.make_one(self.boto3_raw_data["RedshiftSource"])

    @cached_property
    def S3CatalogSource(self):  # pragma: no cover
        return S3CatalogSource.make_one(self.boto3_raw_data["S3CatalogSource"])

    @cached_property
    def S3CsvSource(self):  # pragma: no cover
        return S3CsvSourceOutput.make_one(self.boto3_raw_data["S3CsvSource"])

    @cached_property
    def S3JsonSource(self):  # pragma: no cover
        return S3JsonSourceOutput.make_one(self.boto3_raw_data["S3JsonSource"])

    @cached_property
    def S3ParquetSource(self):  # pragma: no cover
        return S3ParquetSourceOutput.make_one(self.boto3_raw_data["S3ParquetSource"])

    @cached_property
    def RelationalCatalogSource(self):  # pragma: no cover
        return RelationalCatalogSource.make_one(
            self.boto3_raw_data["RelationalCatalogSource"]
        )

    @cached_property
    def DynamoDBCatalogSource(self):  # pragma: no cover
        return DynamoDBCatalogSource.make_one(
            self.boto3_raw_data["DynamoDBCatalogSource"]
        )

    @cached_property
    def JDBCConnectorTarget(self):  # pragma: no cover
        return JDBCConnectorTargetOutput.make_one(
            self.boto3_raw_data["JDBCConnectorTarget"]
        )

    @cached_property
    def SparkConnectorTarget(self):  # pragma: no cover
        return SparkConnectorTargetOutput.make_one(
            self.boto3_raw_data["SparkConnectorTarget"]
        )

    @cached_property
    def CatalogTarget(self):  # pragma: no cover
        return BasicCatalogTargetOutput.make_one(self.boto3_raw_data["CatalogTarget"])

    @cached_property
    def RedshiftTarget(self):  # pragma: no cover
        return RedshiftTargetOutput.make_one(self.boto3_raw_data["RedshiftTarget"])

    @cached_property
    def S3CatalogTarget(self):  # pragma: no cover
        return S3CatalogTargetOutput.make_one(self.boto3_raw_data["S3CatalogTarget"])

    @cached_property
    def S3GlueParquetTarget(self):  # pragma: no cover
        return S3GlueParquetTargetOutput.make_one(
            self.boto3_raw_data["S3GlueParquetTarget"]
        )

    @cached_property
    def S3DirectTarget(self):  # pragma: no cover
        return S3DirectTargetOutput.make_one(self.boto3_raw_data["S3DirectTarget"])

    @cached_property
    def ApplyMapping(self):  # pragma: no cover
        return ApplyMappingOutput.make_one(self.boto3_raw_data["ApplyMapping"])

    @cached_property
    def SelectFields(self):  # pragma: no cover
        return SelectFieldsOutput.make_one(self.boto3_raw_data["SelectFields"])

    @cached_property
    def DropFields(self):  # pragma: no cover
        return DropFieldsOutput.make_one(self.boto3_raw_data["DropFields"])

    @cached_property
    def RenameField(self):  # pragma: no cover
        return RenameFieldOutput.make_one(self.boto3_raw_data["RenameField"])

    @cached_property
    def Spigot(self):  # pragma: no cover
        return SpigotOutput.make_one(self.boto3_raw_data["Spigot"])

    @cached_property
    def Join(self):  # pragma: no cover
        return JoinOutput.make_one(self.boto3_raw_data["Join"])

    @cached_property
    def SplitFields(self):  # pragma: no cover
        return SplitFieldsOutput.make_one(self.boto3_raw_data["SplitFields"])

    @cached_property
    def SelectFromCollection(self):  # pragma: no cover
        return SelectFromCollectionOutput.make_one(
            self.boto3_raw_data["SelectFromCollection"]
        )

    @cached_property
    def FillMissingValues(self):  # pragma: no cover
        return FillMissingValuesOutput.make_one(
            self.boto3_raw_data["FillMissingValues"]
        )

    @cached_property
    def Filter(self):  # pragma: no cover
        return FilterOutput.make_one(self.boto3_raw_data["Filter"])

    @cached_property
    def CustomCode(self):  # pragma: no cover
        return CustomCodeOutput.make_one(self.boto3_raw_data["CustomCode"])

    @cached_property
    def SparkSQL(self):  # pragma: no cover
        return SparkSQLOutput.make_one(self.boto3_raw_data["SparkSQL"])

    @cached_property
    def DirectKinesisSource(self):  # pragma: no cover
        return DirectKinesisSourceOutput.make_one(
            self.boto3_raw_data["DirectKinesisSource"]
        )

    @cached_property
    def DirectKafkaSource(self):  # pragma: no cover
        return DirectKafkaSourceOutput.make_one(
            self.boto3_raw_data["DirectKafkaSource"]
        )

    @cached_property
    def CatalogKinesisSource(self):  # pragma: no cover
        return CatalogKinesisSourceOutput.make_one(
            self.boto3_raw_data["CatalogKinesisSource"]
        )

    @cached_property
    def CatalogKafkaSource(self):  # pragma: no cover
        return CatalogKafkaSourceOutput.make_one(
            self.boto3_raw_data["CatalogKafkaSource"]
        )

    @cached_property
    def DropNullFields(self):  # pragma: no cover
        return DropNullFieldsOutput.make_one(self.boto3_raw_data["DropNullFields"])

    @cached_property
    def Merge(self):  # pragma: no cover
        return MergeOutput.make_one(self.boto3_raw_data["Merge"])

    @cached_property
    def Union(self):  # pragma: no cover
        return UnionOutput.make_one(self.boto3_raw_data["Union"])

    @cached_property
    def PIIDetection(self):  # pragma: no cover
        return PIIDetectionOutput.make_one(self.boto3_raw_data["PIIDetection"])

    @cached_property
    def Aggregate(self):  # pragma: no cover
        return AggregateOutput.make_one(self.boto3_raw_data["Aggregate"])

    @cached_property
    def DropDuplicates(self):  # pragma: no cover
        return DropDuplicatesOutput.make_one(self.boto3_raw_data["DropDuplicates"])

    @cached_property
    def GovernedCatalogTarget(self):  # pragma: no cover
        return GovernedCatalogTargetOutput.make_one(
            self.boto3_raw_data["GovernedCatalogTarget"]
        )

    @cached_property
    def GovernedCatalogSource(self):  # pragma: no cover
        return GovernedCatalogSource.make_one(
            self.boto3_raw_data["GovernedCatalogSource"]
        )

    @cached_property
    def MicrosoftSQLServerCatalogSource(self):  # pragma: no cover
        return MicrosoftSQLServerCatalogSource.make_one(
            self.boto3_raw_data["MicrosoftSQLServerCatalogSource"]
        )

    @cached_property
    def MySQLCatalogSource(self):  # pragma: no cover
        return MySQLCatalogSource.make_one(self.boto3_raw_data["MySQLCatalogSource"])

    @cached_property
    def OracleSQLCatalogSource(self):  # pragma: no cover
        return OracleSQLCatalogSource.make_one(
            self.boto3_raw_data["OracleSQLCatalogSource"]
        )

    @cached_property
    def PostgreSQLCatalogSource(self):  # pragma: no cover
        return PostgreSQLCatalogSource.make_one(
            self.boto3_raw_data["PostgreSQLCatalogSource"]
        )

    @cached_property
    def MicrosoftSQLServerCatalogTarget(self):  # pragma: no cover
        return MicrosoftSQLServerCatalogTargetOutput.make_one(
            self.boto3_raw_data["MicrosoftSQLServerCatalogTarget"]
        )

    @cached_property
    def MySQLCatalogTarget(self):  # pragma: no cover
        return MySQLCatalogTargetOutput.make_one(
            self.boto3_raw_data["MySQLCatalogTarget"]
        )

    @cached_property
    def OracleSQLCatalogTarget(self):  # pragma: no cover
        return OracleSQLCatalogTargetOutput.make_one(
            self.boto3_raw_data["OracleSQLCatalogTarget"]
        )

    @cached_property
    def PostgreSQLCatalogTarget(self):  # pragma: no cover
        return PostgreSQLCatalogTargetOutput.make_one(
            self.boto3_raw_data["PostgreSQLCatalogTarget"]
        )

    @cached_property
    def Route(self):  # pragma: no cover
        return RouteOutput.make_one(self.boto3_raw_data["Route"])

    @cached_property
    def DynamicTransform(self):  # pragma: no cover
        return DynamicTransformOutput.make_one(self.boto3_raw_data["DynamicTransform"])

    @cached_property
    def EvaluateDataQuality(self):  # pragma: no cover
        return EvaluateDataQualityOutput.make_one(
            self.boto3_raw_data["EvaluateDataQuality"]
        )

    @cached_property
    def S3CatalogHudiSource(self):  # pragma: no cover
        return S3CatalogHudiSourceOutput.make_one(
            self.boto3_raw_data["S3CatalogHudiSource"]
        )

    @cached_property
    def CatalogHudiSource(self):  # pragma: no cover
        return CatalogHudiSourceOutput.make_one(
            self.boto3_raw_data["CatalogHudiSource"]
        )

    @cached_property
    def S3HudiSource(self):  # pragma: no cover
        return S3HudiSourceOutput.make_one(self.boto3_raw_data["S3HudiSource"])

    @cached_property
    def S3HudiCatalogTarget(self):  # pragma: no cover
        return S3HudiCatalogTargetOutput.make_one(
            self.boto3_raw_data["S3HudiCatalogTarget"]
        )

    @cached_property
    def S3HudiDirectTarget(self):  # pragma: no cover
        return S3HudiDirectTargetOutput.make_one(
            self.boto3_raw_data["S3HudiDirectTarget"]
        )

    @cached_property
    def DirectJDBCSource(self):  # pragma: no cover
        return DirectJDBCSourceOutput.make_one(self.boto3_raw_data["DirectJDBCSource"])

    @cached_property
    def S3CatalogDeltaSource(self):  # pragma: no cover
        return S3CatalogDeltaSourceOutput.make_one(
            self.boto3_raw_data["S3CatalogDeltaSource"]
        )

    @cached_property
    def CatalogDeltaSource(self):  # pragma: no cover
        return CatalogDeltaSourceOutput.make_one(
            self.boto3_raw_data["CatalogDeltaSource"]
        )

    @cached_property
    def S3DeltaSource(self):  # pragma: no cover
        return S3DeltaSourceOutput.make_one(self.boto3_raw_data["S3DeltaSource"])

    @cached_property
    def S3DeltaCatalogTarget(self):  # pragma: no cover
        return S3DeltaCatalogTargetOutput.make_one(
            self.boto3_raw_data["S3DeltaCatalogTarget"]
        )

    @cached_property
    def S3DeltaDirectTarget(self):  # pragma: no cover
        return S3DeltaDirectTargetOutput.make_one(
            self.boto3_raw_data["S3DeltaDirectTarget"]
        )

    @cached_property
    def AmazonRedshiftSource(self):  # pragma: no cover
        return AmazonRedshiftSourceOutput.make_one(
            self.boto3_raw_data["AmazonRedshiftSource"]
        )

    @cached_property
    def AmazonRedshiftTarget(self):  # pragma: no cover
        return AmazonRedshiftTargetOutput.make_one(
            self.boto3_raw_data["AmazonRedshiftTarget"]
        )

    @cached_property
    def EvaluateDataQualityMultiFrame(self):  # pragma: no cover
        return EvaluateDataQualityMultiFrameOutput.make_one(
            self.boto3_raw_data["EvaluateDataQualityMultiFrame"]
        )

    @cached_property
    def Recipe(self):  # pragma: no cover
        return RecipeOutput.make_one(self.boto3_raw_data["Recipe"])

    @cached_property
    def SnowflakeSource(self):  # pragma: no cover
        return SnowflakeSourceOutput.make_one(self.boto3_raw_data["SnowflakeSource"])

    @cached_property
    def SnowflakeTarget(self):  # pragma: no cover
        return SnowflakeTargetOutput.make_one(self.boto3_raw_data["SnowflakeTarget"])

    @cached_property
    def ConnectorDataSource(self):  # pragma: no cover
        return ConnectorDataSourceOutput.make_one(
            self.boto3_raw_data["ConnectorDataSource"]
        )

    @cached_property
    def ConnectorDataTarget(self):  # pragma: no cover
        return ConnectorDataTargetOutput.make_one(
            self.boto3_raw_data["ConnectorDataTarget"]
        )

    @cached_property
    def S3CatalogIcebergSource(self):  # pragma: no cover
        return S3CatalogIcebergSourceOutput.make_one(
            self.boto3_raw_data["S3CatalogIcebergSource"]
        )

    @cached_property
    def CatalogIcebergSource(self):  # pragma: no cover
        return CatalogIcebergSourceOutput.make_one(
            self.boto3_raw_data["CatalogIcebergSource"]
        )

    @cached_property
    def S3IcebergCatalogTarget(self):  # pragma: no cover
        return S3IcebergCatalogTargetOutput.make_one(
            self.boto3_raw_data["S3IcebergCatalogTarget"]
        )

    @cached_property
    def S3IcebergDirectTarget(self):  # pragma: no cover
        return S3IcebergDirectTargetOutput.make_one(
            self.boto3_raw_data["S3IcebergDirectTarget"]
        )

    @cached_property
    def S3ExcelSource(self):  # pragma: no cover
        return S3ExcelSourceOutput.make_one(self.boto3_raw_data["S3ExcelSource"])

    @cached_property
    def S3HyperDirectTarget(self):  # pragma: no cover
        return S3HyperDirectTargetOutput.make_one(
            self.boto3_raw_data["S3HyperDirectTarget"]
        )

    @cached_property
    def DynamoDBELTConnectorSource(self):  # pragma: no cover
        return DynamoDBELTConnectorSourceOutput.make_one(
            self.boto3_raw_data["DynamoDBELTConnectorSource"]
        )

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.CodeGenConfigurationNodeOutputTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CodeGenConfigurationNodeOutputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CodeGenConfigurationNodePaginator:
    boto3_raw_data: "type_defs.CodeGenConfigurationNodePaginatorTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def AthenaConnectorSource(self):  # pragma: no cover
        return AthenaConnectorSourceOutput.make_one(
            self.boto3_raw_data["AthenaConnectorSource"]
        )

    @cached_property
    def JDBCConnectorSource(self):  # pragma: no cover
        return JDBCConnectorSourceOutput.make_one(
            self.boto3_raw_data["JDBCConnectorSource"]
        )

    @cached_property
    def SparkConnectorSource(self):  # pragma: no cover
        return SparkConnectorSourceOutput.make_one(
            self.boto3_raw_data["SparkConnectorSource"]
        )

    @cached_property
    def CatalogSource(self):  # pragma: no cover
        return CatalogSourceOutput.make_one(self.boto3_raw_data["CatalogSource"])

    @cached_property
    def RedshiftSource(self):  # pragma: no cover
        return RedshiftSource.make_one(self.boto3_raw_data["RedshiftSource"])

    @cached_property
    def S3CatalogSource(self):  # pragma: no cover
        return S3CatalogSource.make_one(self.boto3_raw_data["S3CatalogSource"])

    @cached_property
    def S3CsvSource(self):  # pragma: no cover
        return S3CsvSourceOutput.make_one(self.boto3_raw_data["S3CsvSource"])

    @cached_property
    def S3JsonSource(self):  # pragma: no cover
        return S3JsonSourceOutput.make_one(self.boto3_raw_data["S3JsonSource"])

    @cached_property
    def S3ParquetSource(self):  # pragma: no cover
        return S3ParquetSourceOutput.make_one(self.boto3_raw_data["S3ParquetSource"])

    @cached_property
    def RelationalCatalogSource(self):  # pragma: no cover
        return RelationalCatalogSource.make_one(
            self.boto3_raw_data["RelationalCatalogSource"]
        )

    @cached_property
    def DynamoDBCatalogSource(self):  # pragma: no cover
        return DynamoDBCatalogSource.make_one(
            self.boto3_raw_data["DynamoDBCatalogSource"]
        )

    @cached_property
    def JDBCConnectorTarget(self):  # pragma: no cover
        return JDBCConnectorTargetOutput.make_one(
            self.boto3_raw_data["JDBCConnectorTarget"]
        )

    @cached_property
    def SparkConnectorTarget(self):  # pragma: no cover
        return SparkConnectorTargetOutput.make_one(
            self.boto3_raw_data["SparkConnectorTarget"]
        )

    @cached_property
    def CatalogTarget(self):  # pragma: no cover
        return BasicCatalogTargetOutput.make_one(self.boto3_raw_data["CatalogTarget"])

    @cached_property
    def RedshiftTarget(self):  # pragma: no cover
        return RedshiftTargetOutput.make_one(self.boto3_raw_data["RedshiftTarget"])

    @cached_property
    def S3CatalogTarget(self):  # pragma: no cover
        return S3CatalogTargetOutput.make_one(self.boto3_raw_data["S3CatalogTarget"])

    @cached_property
    def S3GlueParquetTarget(self):  # pragma: no cover
        return S3GlueParquetTargetOutput.make_one(
            self.boto3_raw_data["S3GlueParquetTarget"]
        )

    @cached_property
    def S3DirectTarget(self):  # pragma: no cover
        return S3DirectTargetOutput.make_one(self.boto3_raw_data["S3DirectTarget"])

    @cached_property
    def ApplyMapping(self):  # pragma: no cover
        return ApplyMappingPaginator.make_one(self.boto3_raw_data["ApplyMapping"])

    @cached_property
    def SelectFields(self):  # pragma: no cover
        return SelectFieldsOutput.make_one(self.boto3_raw_data["SelectFields"])

    @cached_property
    def DropFields(self):  # pragma: no cover
        return DropFieldsOutput.make_one(self.boto3_raw_data["DropFields"])

    @cached_property
    def RenameField(self):  # pragma: no cover
        return RenameFieldOutput.make_one(self.boto3_raw_data["RenameField"])

    @cached_property
    def Spigot(self):  # pragma: no cover
        return SpigotOutput.make_one(self.boto3_raw_data["Spigot"])

    @cached_property
    def Join(self):  # pragma: no cover
        return JoinOutput.make_one(self.boto3_raw_data["Join"])

    @cached_property
    def SplitFields(self):  # pragma: no cover
        return SplitFieldsOutput.make_one(self.boto3_raw_data["SplitFields"])

    @cached_property
    def SelectFromCollection(self):  # pragma: no cover
        return SelectFromCollectionOutput.make_one(
            self.boto3_raw_data["SelectFromCollection"]
        )

    @cached_property
    def FillMissingValues(self):  # pragma: no cover
        return FillMissingValuesOutput.make_one(
            self.boto3_raw_data["FillMissingValues"]
        )

    @cached_property
    def Filter(self):  # pragma: no cover
        return FilterOutput.make_one(self.boto3_raw_data["Filter"])

    @cached_property
    def CustomCode(self):  # pragma: no cover
        return CustomCodeOutput.make_one(self.boto3_raw_data["CustomCode"])

    @cached_property
    def SparkSQL(self):  # pragma: no cover
        return SparkSQLOutput.make_one(self.boto3_raw_data["SparkSQL"])

    @cached_property
    def DirectKinesisSource(self):  # pragma: no cover
        return DirectKinesisSourceOutput.make_one(
            self.boto3_raw_data["DirectKinesisSource"]
        )

    @cached_property
    def DirectKafkaSource(self):  # pragma: no cover
        return DirectKafkaSourceOutput.make_one(
            self.boto3_raw_data["DirectKafkaSource"]
        )

    @cached_property
    def CatalogKinesisSource(self):  # pragma: no cover
        return CatalogKinesisSourceOutput.make_one(
            self.boto3_raw_data["CatalogKinesisSource"]
        )

    @cached_property
    def CatalogKafkaSource(self):  # pragma: no cover
        return CatalogKafkaSourceOutput.make_one(
            self.boto3_raw_data["CatalogKafkaSource"]
        )

    @cached_property
    def DropNullFields(self):  # pragma: no cover
        return DropNullFieldsOutput.make_one(self.boto3_raw_data["DropNullFields"])

    @cached_property
    def Merge(self):  # pragma: no cover
        return MergeOutput.make_one(self.boto3_raw_data["Merge"])

    @cached_property
    def Union(self):  # pragma: no cover
        return UnionOutput.make_one(self.boto3_raw_data["Union"])

    @cached_property
    def PIIDetection(self):  # pragma: no cover
        return PIIDetectionOutput.make_one(self.boto3_raw_data["PIIDetection"])

    @cached_property
    def Aggregate(self):  # pragma: no cover
        return AggregateOutput.make_one(self.boto3_raw_data["Aggregate"])

    @cached_property
    def DropDuplicates(self):  # pragma: no cover
        return DropDuplicatesOutput.make_one(self.boto3_raw_data["DropDuplicates"])

    @cached_property
    def GovernedCatalogTarget(self):  # pragma: no cover
        return GovernedCatalogTargetOutput.make_one(
            self.boto3_raw_data["GovernedCatalogTarget"]
        )

    @cached_property
    def GovernedCatalogSource(self):  # pragma: no cover
        return GovernedCatalogSource.make_one(
            self.boto3_raw_data["GovernedCatalogSource"]
        )

    @cached_property
    def MicrosoftSQLServerCatalogSource(self):  # pragma: no cover
        return MicrosoftSQLServerCatalogSource.make_one(
            self.boto3_raw_data["MicrosoftSQLServerCatalogSource"]
        )

    @cached_property
    def MySQLCatalogSource(self):  # pragma: no cover
        return MySQLCatalogSource.make_one(self.boto3_raw_data["MySQLCatalogSource"])

    @cached_property
    def OracleSQLCatalogSource(self):  # pragma: no cover
        return OracleSQLCatalogSource.make_one(
            self.boto3_raw_data["OracleSQLCatalogSource"]
        )

    @cached_property
    def PostgreSQLCatalogSource(self):  # pragma: no cover
        return PostgreSQLCatalogSource.make_one(
            self.boto3_raw_data["PostgreSQLCatalogSource"]
        )

    @cached_property
    def MicrosoftSQLServerCatalogTarget(self):  # pragma: no cover
        return MicrosoftSQLServerCatalogTargetOutput.make_one(
            self.boto3_raw_data["MicrosoftSQLServerCatalogTarget"]
        )

    @cached_property
    def MySQLCatalogTarget(self):  # pragma: no cover
        return MySQLCatalogTargetOutput.make_one(
            self.boto3_raw_data["MySQLCatalogTarget"]
        )

    @cached_property
    def OracleSQLCatalogTarget(self):  # pragma: no cover
        return OracleSQLCatalogTargetOutput.make_one(
            self.boto3_raw_data["OracleSQLCatalogTarget"]
        )

    @cached_property
    def PostgreSQLCatalogTarget(self):  # pragma: no cover
        return PostgreSQLCatalogTargetOutput.make_one(
            self.boto3_raw_data["PostgreSQLCatalogTarget"]
        )

    @cached_property
    def Route(self):  # pragma: no cover
        return RouteOutput.make_one(self.boto3_raw_data["Route"])

    @cached_property
    def DynamicTransform(self):  # pragma: no cover
        return DynamicTransformOutput.make_one(self.boto3_raw_data["DynamicTransform"])

    @cached_property
    def EvaluateDataQuality(self):  # pragma: no cover
        return EvaluateDataQualityOutput.make_one(
            self.boto3_raw_data["EvaluateDataQuality"]
        )

    @cached_property
    def S3CatalogHudiSource(self):  # pragma: no cover
        return S3CatalogHudiSourceOutput.make_one(
            self.boto3_raw_data["S3CatalogHudiSource"]
        )

    @cached_property
    def CatalogHudiSource(self):  # pragma: no cover
        return CatalogHudiSourceOutput.make_one(
            self.boto3_raw_data["CatalogHudiSource"]
        )

    @cached_property
    def S3HudiSource(self):  # pragma: no cover
        return S3HudiSourceOutput.make_one(self.boto3_raw_data["S3HudiSource"])

    @cached_property
    def S3HudiCatalogTarget(self):  # pragma: no cover
        return S3HudiCatalogTargetOutput.make_one(
            self.boto3_raw_data["S3HudiCatalogTarget"]
        )

    @cached_property
    def S3HudiDirectTarget(self):  # pragma: no cover
        return S3HudiDirectTargetOutput.make_one(
            self.boto3_raw_data["S3HudiDirectTarget"]
        )

    @cached_property
    def DirectJDBCSource(self):  # pragma: no cover
        return DirectJDBCSourceOutput.make_one(self.boto3_raw_data["DirectJDBCSource"])

    @cached_property
    def S3CatalogDeltaSource(self):  # pragma: no cover
        return S3CatalogDeltaSourceOutput.make_one(
            self.boto3_raw_data["S3CatalogDeltaSource"]
        )

    @cached_property
    def CatalogDeltaSource(self):  # pragma: no cover
        return CatalogDeltaSourceOutput.make_one(
            self.boto3_raw_data["CatalogDeltaSource"]
        )

    @cached_property
    def S3DeltaSource(self):  # pragma: no cover
        return S3DeltaSourceOutput.make_one(self.boto3_raw_data["S3DeltaSource"])

    @cached_property
    def S3DeltaCatalogTarget(self):  # pragma: no cover
        return S3DeltaCatalogTargetOutput.make_one(
            self.boto3_raw_data["S3DeltaCatalogTarget"]
        )

    @cached_property
    def S3DeltaDirectTarget(self):  # pragma: no cover
        return S3DeltaDirectTargetOutput.make_one(
            self.boto3_raw_data["S3DeltaDirectTarget"]
        )

    @cached_property
    def AmazonRedshiftSource(self):  # pragma: no cover
        return AmazonRedshiftSourceOutput.make_one(
            self.boto3_raw_data["AmazonRedshiftSource"]
        )

    @cached_property
    def AmazonRedshiftTarget(self):  # pragma: no cover
        return AmazonRedshiftTargetOutput.make_one(
            self.boto3_raw_data["AmazonRedshiftTarget"]
        )

    @cached_property
    def EvaluateDataQualityMultiFrame(self):  # pragma: no cover
        return EvaluateDataQualityMultiFrameOutput.make_one(
            self.boto3_raw_data["EvaluateDataQualityMultiFrame"]
        )

    @cached_property
    def Recipe(self):  # pragma: no cover
        return RecipeOutput.make_one(self.boto3_raw_data["Recipe"])

    @cached_property
    def SnowflakeSource(self):  # pragma: no cover
        return SnowflakeSourceOutput.make_one(self.boto3_raw_data["SnowflakeSource"])

    @cached_property
    def SnowflakeTarget(self):  # pragma: no cover
        return SnowflakeTargetOutput.make_one(self.boto3_raw_data["SnowflakeTarget"])

    @cached_property
    def ConnectorDataSource(self):  # pragma: no cover
        return ConnectorDataSourceOutput.make_one(
            self.boto3_raw_data["ConnectorDataSource"]
        )

    @cached_property
    def ConnectorDataTarget(self):  # pragma: no cover
        return ConnectorDataTargetOutput.make_one(
            self.boto3_raw_data["ConnectorDataTarget"]
        )

    @cached_property
    def S3CatalogIcebergSource(self):  # pragma: no cover
        return S3CatalogIcebergSourceOutput.make_one(
            self.boto3_raw_data["S3CatalogIcebergSource"]
        )

    @cached_property
    def CatalogIcebergSource(self):  # pragma: no cover
        return CatalogIcebergSourceOutput.make_one(
            self.boto3_raw_data["CatalogIcebergSource"]
        )

    @cached_property
    def S3IcebergCatalogTarget(self):  # pragma: no cover
        return S3IcebergCatalogTargetOutput.make_one(
            self.boto3_raw_data["S3IcebergCatalogTarget"]
        )

    @cached_property
    def S3IcebergDirectTarget(self):  # pragma: no cover
        return S3IcebergDirectTargetOutput.make_one(
            self.boto3_raw_data["S3IcebergDirectTarget"]
        )

    @cached_property
    def S3ExcelSource(self):  # pragma: no cover
        return S3ExcelSourceOutput.make_one(self.boto3_raw_data["S3ExcelSource"])

    @cached_property
    def S3HyperDirectTarget(self):  # pragma: no cover
        return S3HyperDirectTargetOutput.make_one(
            self.boto3_raw_data["S3HyperDirectTarget"]
        )

    @cached_property
    def DynamoDBELTConnectorSource(self):  # pragma: no cover
        return DynamoDBELTConnectorSourceOutput.make_one(
            self.boto3_raw_data["DynamoDBELTConnectorSource"]
        )

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.CodeGenConfigurationNodePaginatorTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CodeGenConfigurationNodePaginatorTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Filter:
    boto3_raw_data: "type_defs.FilterTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    LogicalOperator = field("LogicalOperator")
    Filters = field("Filters")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.FilterTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.FilterTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GroupFilters:
    boto3_raw_data: "type_defs.GroupFiltersTypeDef" = dataclasses.field()

    GroupName = field("GroupName")
    Filters = field("Filters")
    LogicalOperator = field("LogicalOperator")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GroupFiltersTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.GroupFiltersTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityResultFilterCriteria:
    boto3_raw_data: "type_defs.DataQualityResultFilterCriteriaTypeDef" = (
        dataclasses.field()
    )

    DataSource = field("DataSource")
    JobName = field("JobName")
    JobRunId = field("JobRunId")
    StartedAfter = field("StartedAfter")
    StartedBefore = field("StartedBefore")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.DataQualityResultFilterCriteriaTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityResultFilterCriteriaTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityRuleRecommendationRunFilter:
    boto3_raw_data: "type_defs.DataQualityRuleRecommendationRunFilterTypeDef" = (
        dataclasses.field()
    )

    DataSource = field("DataSource")
    StartedBefore = field("StartedBefore")
    StartedAfter = field("StartedAfter")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.DataQualityRuleRecommendationRunFilterTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityRuleRecommendationRunFilterTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class DataQualityRulesetEvaluationRunFilter:
    boto3_raw_data: "type_defs.DataQualityRulesetEvaluationRunFilterTypeDef" = (
        dataclasses.field()
    )

    DataSource = field("DataSource")
    StartedBefore = field("StartedBefore")
    StartedAfter = field("StartedAfter")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.DataQualityRulesetEvaluationRunFilterTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.DataQualityRulesetEvaluationRunFilterTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartDataQualityRuleRecommendationRunRequest:
    boto3_raw_data: "type_defs.StartDataQualityRuleRecommendationRunRequestTypeDef" = (
        dataclasses.field()
    )

    DataSource = field("DataSource")
    Role = field("Role")
    NumberOfWorkers = field("NumberOfWorkers")
    Timeout = field("Timeout")
    CreatedRulesetName = field("CreatedRulesetName")
    DataQualitySecurityConfiguration = field("DataQualitySecurityConfiguration")
    ClientToken = field("ClientToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.StartDataQualityRuleRecommendationRunRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartDataQualityRuleRecommendationRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class StartDataQualityRulesetEvaluationRunRequest:
    boto3_raw_data: "type_defs.StartDataQualityRulesetEvaluationRunRequestTypeDef" = (
        dataclasses.field()
    )

    DataSource = field("DataSource")
    Role = field("Role")
    RulesetNames = field("RulesetNames")
    NumberOfWorkers = field("NumberOfWorkers")
    Timeout = field("Timeout")
    ClientToken = field("ClientToken")

    @cached_property
    def AdditionalRunOptions(self):  # pragma: no cover
        return DataQualityEvaluationRunAdditionalRunOptions.make_one(
            self.boto3_raw_data["AdditionalRunOptions"]
        )

    AdditionalDataSources = field("AdditionalDataSources")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.StartDataQualityRulesetEvaluationRunRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.StartDataQualityRulesetEvaluationRunRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchTableOptimizer:
    boto3_raw_data: "type_defs.BatchTableOptimizerTypeDef" = dataclasses.field()

    catalogId = field("catalogId")
    databaseName = field("databaseName")
    tableName = field("tableName")

    @cached_property
    def tableOptimizer(self):  # pragma: no cover
        return TableOptimizer.make_one(self.boto3_raw_data["tableOptimizer"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchTableOptimizerTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchTableOptimizerTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTableOptimizerResponse:
    boto3_raw_data: "type_defs.GetTableOptimizerResponseTypeDef" = dataclasses.field()

    CatalogId = field("CatalogId")
    DatabaseName = field("DatabaseName")
    TableName = field("TableName")

    @cached_property
    def TableOptimizer(self):  # pragma: no cover
        return TableOptimizer.make_one(self.boto3_raw_data["TableOptimizer"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetTableOptimizerResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetTableOptimizerResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class OpenTableFormatInput:
    boto3_raw_data: "type_defs.OpenTableFormatInputTypeDef" = dataclasses.field()

    @cached_property
    def IcebergInput(self):  # pragma: no cover
        return IcebergInput.make_one(self.boto3_raw_data["IcebergInput"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.OpenTableFormatInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.OpenTableFormatInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateIcebergInput:
    boto3_raw_data: "type_defs.UpdateIcebergInputTypeDef" = dataclasses.field()

    @cached_property
    def UpdateIcebergTableInput(self):  # pragma: no cover
        return UpdateIcebergTableInput.make_one(
            self.boto3_raw_data["UpdateIcebergTableInput"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateIcebergInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateIcebergInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetConnectionResponse:
    boto3_raw_data: "type_defs.GetConnectionResponseTypeDef" = dataclasses.field()

    @cached_property
    def Connection(self):  # pragma: no cover
        return Connection.make_one(self.boto3_raw_data["Connection"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetConnectionResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetConnectionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetConnectionsResponse:
    boto3_raw_data: "type_defs.GetConnectionsResponseTypeDef" = dataclasses.field()

    @cached_property
    def ConnectionList(self):  # pragma: no cover
        return Connection.make_many(self.boto3_raw_data["ConnectionList"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetConnectionsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetConnectionsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateConnectionRequest:
    boto3_raw_data: "type_defs.CreateConnectionRequestTypeDef" = dataclasses.field()

    @cached_property
    def ConnectionInput(self):  # pragma: no cover
        return ConnectionInput.make_one(self.boto3_raw_data["ConnectionInput"])

    CatalogId = field("CatalogId")
    Tags = field("Tags")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateConnectionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateConnectionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateConnectionRequest:
    boto3_raw_data: "type_defs.UpdateConnectionRequestTypeDef" = dataclasses.field()

    Name = field("Name")

    @cached_property
    def ConnectionInput(self):  # pragma: no cover
        return ConnectionInput.make_one(self.boto3_raw_data["ConnectionInput"])

    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateConnectionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateConnectionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TestConnectionRequest:
    boto3_raw_data: "type_defs.TestConnectionRequestTypeDef" = dataclasses.field()

    ConnectionName = field("ConnectionName")
    CatalogId = field("CatalogId")

    @cached_property
    def TestConnectionInput(self):  # pragma: no cover
        return TestConnectionInput.make_one(self.boto3_raw_data["TestConnectionInput"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.TestConnectionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TestConnectionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Recipe:
    boto3_raw_data: "type_defs.RecipeTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")

    @cached_property
    def RecipeReference(self):  # pragma: no cover
        return RecipeReference.make_one(self.boto3_raw_data["RecipeReference"])

    RecipeSteps = field("RecipeSteps")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.RecipeTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.RecipeTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class PartitionInput:
    boto3_raw_data: "type_defs.PartitionInputTypeDef" = dataclasses.field()

    Values = field("Values")
    LastAccessTime = field("LastAccessTime")
    StorageDescriptor = field("StorageDescriptor")
    Parameters = field("Parameters")
    LastAnalyzedTime = field("LastAnalyzedTime")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.PartitionInputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.PartitionInputTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TableInput:
    boto3_raw_data: "type_defs.TableInputTypeDef" = dataclasses.field()

    Name = field("Name")
    Description = field("Description")
    Owner = field("Owner")
    LastAccessTime = field("LastAccessTime")
    LastAnalyzedTime = field("LastAnalyzedTime")
    Retention = field("Retention")
    StorageDescriptor = field("StorageDescriptor")
    PartitionKeys = field("PartitionKeys")
    ViewOriginalText = field("ViewOriginalText")
    ViewExpandedText = field("ViewExpandedText")
    TableType = field("TableType")
    Parameters = field("Parameters")

    @cached_property
    def TargetTable(self):  # pragma: no cover
        return TableIdentifier.make_one(self.boto3_raw_data["TargetTable"])

    @cached_property
    def ViewDefinition(self):  # pragma: no cover
        return ViewDefinitionInput.make_one(self.boto3_raw_data["ViewDefinition"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.TableInputTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.TableInputTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTablesResponsePaginator:
    boto3_raw_data: "type_defs.GetTablesResponsePaginatorTypeDef" = dataclasses.field()

    @cached_property
    def TableList(self):  # pragma: no cover
        return TablePaginator.make_many(self.boto3_raw_data["TableList"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetTablesResponsePaginatorTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetTablesResponsePaginatorTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TableVersionPaginator:
    boto3_raw_data: "type_defs.TableVersionPaginatorTypeDef" = dataclasses.field()

    @cached_property
    def Table(self):  # pragma: no cover
        return TablePaginator.make_one(self.boto3_raw_data["Table"])

    VersionId = field("VersionId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.TableVersionPaginatorTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.TableVersionPaginatorTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTableResponse:
    boto3_raw_data: "type_defs.GetTableResponseTypeDef" = dataclasses.field()

    @cached_property
    def Table(self):  # pragma: no cover
        return Table.make_one(self.boto3_raw_data["Table"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetTableResponseTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetTableResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTablesResponse:
    boto3_raw_data: "type_defs.GetTablesResponseTypeDef" = dataclasses.field()

    @cached_property
    def TableList(self):  # pragma: no cover
        return Table.make_many(self.boto3_raw_data["TableList"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetTablesResponseTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetTablesResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetUnfilteredTableMetadataResponse:
    boto3_raw_data: "type_defs.GetUnfilteredTableMetadataResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Table(self):  # pragma: no cover
        return Table.make_one(self.boto3_raw_data["Table"])

    AuthorizedColumns = field("AuthorizedColumns")
    IsRegisteredWithLakeFormation = field("IsRegisteredWithLakeFormation")

    @cached_property
    def CellFilters(self):  # pragma: no cover
        return ColumnRowFilter.make_many(self.boto3_raw_data["CellFilters"])

    QueryAuthorizationId = field("QueryAuthorizationId")
    IsMultiDialectView = field("IsMultiDialectView")
    ResourceArn = field("ResourceArn")
    IsProtected = field("IsProtected")
    Permissions = field("Permissions")
    RowFilter = field("RowFilter")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetUnfilteredTableMetadataResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetUnfilteredTableMetadataResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class SearchTablesResponse:
    boto3_raw_data: "type_defs.SearchTablesResponseTypeDef" = dataclasses.field()

    @cached_property
    def TableList(self):  # pragma: no cover
        return Table.make_many(self.boto3_raw_data["TableList"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.SearchTablesResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.SearchTablesResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class TableVersion:
    boto3_raw_data: "type_defs.TableVersionTypeDef" = dataclasses.field()

    @cached_property
    def Table(self):  # pragma: no cover
        return Table.make_one(self.boto3_raw_data["Table"])

    VersionId = field("VersionId")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.TableVersionTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.TableVersionTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ColumnStatisticsData:
    boto3_raw_data: "type_defs.ColumnStatisticsDataTypeDef" = dataclasses.field()

    Type = field("Type")

    @cached_property
    def BooleanColumnStatisticsData(self):  # pragma: no cover
        return BooleanColumnStatisticsData.make_one(
            self.boto3_raw_data["BooleanColumnStatisticsData"]
        )

    DateColumnStatisticsData = field("DateColumnStatisticsData")
    DecimalColumnStatisticsData = field("DecimalColumnStatisticsData")

    @cached_property
    def DoubleColumnStatisticsData(self):  # pragma: no cover
        return DoubleColumnStatisticsData.make_one(
            self.boto3_raw_data["DoubleColumnStatisticsData"]
        )

    @cached_property
    def LongColumnStatisticsData(self):  # pragma: no cover
        return LongColumnStatisticsData.make_one(
            self.boto3_raw_data["LongColumnStatisticsData"]
        )

    @cached_property
    def StringColumnStatisticsData(self):  # pragma: no cover
        return StringColumnStatisticsData.make_one(
            self.boto3_raw_data["StringColumnStatisticsData"]
        )

    @cached_property
    def BinaryColumnStatisticsData(self):  # pragma: no cover
        return BinaryColumnStatisticsData.make_one(
            self.boto3_raw_data["BinaryColumnStatisticsData"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.ColumnStatisticsDataTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ColumnStatisticsDataTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class WorkflowGraph:
    boto3_raw_data: "type_defs.WorkflowGraphTypeDef" = dataclasses.field()

    @cached_property
    def Nodes(self):  # pragma: no cover
        return Node.make_many(self.boto3_raw_data["Nodes"])

    @cached_property
    def Edges(self):  # pragma: no cover
        return Edge.make_many(self.boto3_raw_data["Edges"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.WorkflowGraphTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.WorkflowGraphTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateColumnStatisticsForPartitionResponse:
    boto3_raw_data: "type_defs.UpdateColumnStatisticsForPartitionResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Errors(self):  # pragma: no cover
        return ColumnStatisticsError.make_many(self.boto3_raw_data["Errors"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.UpdateColumnStatisticsForPartitionResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateColumnStatisticsForPartitionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateColumnStatisticsForTableResponse:
    boto3_raw_data: "type_defs.UpdateColumnStatisticsForTableResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Errors(self):  # pragma: no cover
        return ColumnStatisticsError.make_many(self.boto3_raw_data["Errors"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.UpdateColumnStatisticsForTableResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateColumnStatisticsForTableResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetUnfilteredPartitionsMetadataResponse:
    boto3_raw_data: "type_defs.GetUnfilteredPartitionsMetadataResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def UnfilteredPartitions(self):  # pragma: no cover
        return UnfilteredPartition.make_many(
            self.boto3_raw_data["UnfilteredPartitions"]
        )

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetUnfilteredPartitionsMetadataResponseTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetUnfilteredPartitionsMetadataResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Job:
    boto3_raw_data: "type_defs.JobTypeDef" = dataclasses.field()

    Name = field("Name")
    JobMode = field("JobMode")
    JobRunQueuingEnabled = field("JobRunQueuingEnabled")
    Description = field("Description")
    LogUri = field("LogUri")
    Role = field("Role")
    CreatedOn = field("CreatedOn")
    LastModifiedOn = field("LastModifiedOn")

    @cached_property
    def ExecutionProperty(self):  # pragma: no cover
        return ExecutionProperty.make_one(self.boto3_raw_data["ExecutionProperty"])

    @cached_property
    def Command(self):  # pragma: no cover
        return JobCommand.make_one(self.boto3_raw_data["Command"])

    DefaultArguments = field("DefaultArguments")
    NonOverridableArguments = field("NonOverridableArguments")

    @cached_property
    def Connections(self):  # pragma: no cover
        return ConnectionsListOutput.make_one(self.boto3_raw_data["Connections"])

    MaxRetries = field("MaxRetries")
    AllocatedCapacity = field("AllocatedCapacity")
    Timeout = field("Timeout")
    MaxCapacity = field("MaxCapacity")
    WorkerType = field("WorkerType")
    NumberOfWorkers = field("NumberOfWorkers")
    SecurityConfiguration = field("SecurityConfiguration")

    @cached_property
    def NotificationProperty(self):  # pragma: no cover
        return NotificationProperty.make_one(
            self.boto3_raw_data["NotificationProperty"]
        )

    GlueVersion = field("GlueVersion")
    CodeGenConfigurationNodes = field("CodeGenConfigurationNodes")
    ExecutionClass = field("ExecutionClass")

    @cached_property
    def SourceControlDetails(self):  # pragma: no cover
        return SourceControlDetails.make_one(
            self.boto3_raw_data["SourceControlDetails"]
        )

    MaintenanceWindow = field("MaintenanceWindow")
    ProfileName = field("ProfileName")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.JobTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.JobTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JobPaginator:
    boto3_raw_data: "type_defs.JobPaginatorTypeDef" = dataclasses.field()

    Name = field("Name")
    JobMode = field("JobMode")
    JobRunQueuingEnabled = field("JobRunQueuingEnabled")
    Description = field("Description")
    LogUri = field("LogUri")
    Role = field("Role")
    CreatedOn = field("CreatedOn")
    LastModifiedOn = field("LastModifiedOn")

    @cached_property
    def ExecutionProperty(self):  # pragma: no cover
        return ExecutionProperty.make_one(self.boto3_raw_data["ExecutionProperty"])

    @cached_property
    def Command(self):  # pragma: no cover
        return JobCommand.make_one(self.boto3_raw_data["Command"])

    DefaultArguments = field("DefaultArguments")
    NonOverridableArguments = field("NonOverridableArguments")

    @cached_property
    def Connections(self):  # pragma: no cover
        return ConnectionsListOutput.make_one(self.boto3_raw_data["Connections"])

    MaxRetries = field("MaxRetries")
    AllocatedCapacity = field("AllocatedCapacity")
    Timeout = field("Timeout")
    MaxCapacity = field("MaxCapacity")
    WorkerType = field("WorkerType")
    NumberOfWorkers = field("NumberOfWorkers")
    SecurityConfiguration = field("SecurityConfiguration")

    @cached_property
    def NotificationProperty(self):  # pragma: no cover
        return NotificationProperty.make_one(
            self.boto3_raw_data["NotificationProperty"]
        )

    GlueVersion = field("GlueVersion")
    CodeGenConfigurationNodes = field("CodeGenConfigurationNodes")
    ExecutionClass = field("ExecutionClass")

    @cached_property
    def SourceControlDetails(self):  # pragma: no cover
        return SourceControlDetails.make_one(
            self.boto3_raw_data["SourceControlDetails"]
        )

    MaintenanceWindow = field("MaintenanceWindow")
    ProfileName = field("ProfileName")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.JobPaginatorTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.JobPaginatorTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListDataQualityResultsRequest:
    boto3_raw_data: "type_defs.ListDataQualityResultsRequestTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Filter(self):  # pragma: no cover
        return DataQualityResultFilterCriteria.make_one(self.boto3_raw_data["Filter"])

    NextToken = field("NextToken")
    MaxResults = field("MaxResults")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.ListDataQualityResultsRequestTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListDataQualityResultsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListDataQualityRuleRecommendationRunsRequest:
    boto3_raw_data: "type_defs.ListDataQualityRuleRecommendationRunsRequestTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Filter(self):  # pragma: no cover
        return DataQualityRuleRecommendationRunFilter.make_one(
            self.boto3_raw_data["Filter"]
        )

    NextToken = field("NextToken")
    MaxResults = field("MaxResults")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.ListDataQualityRuleRecommendationRunsRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListDataQualityRuleRecommendationRunsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ListDataQualityRulesetEvaluationRunsRequest:
    boto3_raw_data: "type_defs.ListDataQualityRulesetEvaluationRunsRequestTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def Filter(self):  # pragma: no cover
        return DataQualityRulesetEvaluationRunFilter.make_one(
            self.boto3_raw_data["Filter"]
        )

    NextToken = field("NextToken")
    MaxResults = field("MaxResults")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.ListDataQualityRulesetEvaluationRunsRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ListDataQualityRulesetEvaluationRunsRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetTableOptimizerResponse:
    boto3_raw_data: "type_defs.BatchGetTableOptimizerResponseTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def TableOptimizers(self):  # pragma: no cover
        return BatchTableOptimizer.make_many(self.boto3_raw_data["TableOptimizers"])

    @cached_property
    def Failures(self):  # pragma: no cover
        return BatchGetTableOptimizerError.make_many(self.boto3_raw_data["Failures"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.BatchGetTableOptimizerResponseTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetTableOptimizerResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateOpenTableFormatInput:
    boto3_raw_data: "type_defs.UpdateOpenTableFormatInputTypeDef" = dataclasses.field()

    @cached_property
    def UpdateIcebergInput(self):  # pragma: no cover
        return UpdateIcebergInput.make_one(self.boto3_raw_data["UpdateIcebergInput"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateOpenTableFormatInputTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateOpenTableFormatInputTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchCreatePartitionRequest:
    boto3_raw_data: "type_defs.BatchCreatePartitionRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")

    @cached_property
    def PartitionInputList(self):  # pragma: no cover
        return PartitionInput.make_many(self.boto3_raw_data["PartitionInputList"])

    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchCreatePartitionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchCreatePartitionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchUpdatePartitionRequestEntry:
    boto3_raw_data: "type_defs.BatchUpdatePartitionRequestEntryTypeDef" = (
        dataclasses.field()
    )

    PartitionValueList = field("PartitionValueList")

    @cached_property
    def PartitionInput(self):  # pragma: no cover
        return PartitionInput.make_one(self.boto3_raw_data["PartitionInput"])

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional["type_defs.BatchUpdatePartitionRequestEntryTypeDef"],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchUpdatePartitionRequestEntryTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreatePartitionRequest:
    boto3_raw_data: "type_defs.CreatePartitionRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")

    @cached_property
    def PartitionInput(self):  # pragma: no cover
        return PartitionInput.make_one(self.boto3_raw_data["PartitionInput"])

    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreatePartitionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreatePartitionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdatePartitionRequest:
    boto3_raw_data: "type_defs.UpdatePartitionRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    PartitionValueList = field("PartitionValueList")

    @cached_property
    def PartitionInput(self):  # pragma: no cover
        return PartitionInput.make_one(self.boto3_raw_data["PartitionInput"])

    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdatePartitionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdatePartitionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateTableRequest:
    boto3_raw_data: "type_defs.CreateTableRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    CatalogId = field("CatalogId")
    Name = field("Name")

    @cached_property
    def TableInput(self):  # pragma: no cover
        return TableInput.make_one(self.boto3_raw_data["TableInput"])

    @cached_property
    def PartitionIndexes(self):  # pragma: no cover
        return PartitionIndex.make_many(self.boto3_raw_data["PartitionIndexes"])

    TransactionId = field("TransactionId")

    @cached_property
    def OpenTableFormatInput(self):  # pragma: no cover
        return OpenTableFormatInput.make_one(
            self.boto3_raw_data["OpenTableFormatInput"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CreateTableRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateTableRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTableVersionsResponsePaginator:
    boto3_raw_data: "type_defs.GetTableVersionsResponsePaginatorTypeDef" = (
        dataclasses.field()
    )

    @cached_property
    def TableVersions(self):  # pragma: no cover
        return TableVersionPaginator.make_many(self.boto3_raw_data["TableVersions"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.GetTableVersionsResponsePaginatorTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetTableVersionsResponsePaginatorTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTableVersionResponse:
    boto3_raw_data: "type_defs.GetTableVersionResponseTypeDef" = dataclasses.field()

    @cached_property
    def TableVersion(self):  # pragma: no cover
        return TableVersion.make_one(self.boto3_raw_data["TableVersion"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetTableVersionResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetTableVersionResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetTableVersionsResponse:
    boto3_raw_data: "type_defs.GetTableVersionsResponseTypeDef" = dataclasses.field()

    @cached_property
    def TableVersions(self):  # pragma: no cover
        return TableVersion.make_many(self.boto3_raw_data["TableVersions"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetTableVersionsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetTableVersionsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class WorkflowRun:
    boto3_raw_data: "type_defs.WorkflowRunTypeDef" = dataclasses.field()

    Name = field("Name")
    WorkflowRunId = field("WorkflowRunId")
    PreviousRunId = field("PreviousRunId")
    WorkflowRunProperties = field("WorkflowRunProperties")
    StartedOn = field("StartedOn")
    CompletedOn = field("CompletedOn")
    Status = field("Status")
    ErrorMessage = field("ErrorMessage")

    @cached_property
    def Statistics(self):  # pragma: no cover
        return WorkflowRunStatistics.make_one(self.boto3_raw_data["Statistics"])

    @cached_property
    def Graph(self):  # pragma: no cover
        return WorkflowGraph.make_one(self.boto3_raw_data["Graph"])

    @cached_property
    def StartingEventBatchCondition(self):  # pragma: no cover
        return StartingEventBatchCondition.make_one(
            self.boto3_raw_data["StartingEventBatchCondition"]
        )

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.WorkflowRunTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.WorkflowRunTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetJobsResponse:
    boto3_raw_data: "type_defs.BatchGetJobsResponseTypeDef" = dataclasses.field()

    @cached_property
    def Jobs(self):  # pragma: no cover
        return Job.make_many(self.boto3_raw_data["Jobs"])

    JobsNotFound = field("JobsNotFound")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchGetJobsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetJobsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetJobResponse:
    boto3_raw_data: "type_defs.GetJobResponseTypeDef" = dataclasses.field()

    @cached_property
    def Job(self):  # pragma: no cover
        return Job.make_one(self.boto3_raw_data["Job"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetJobResponseTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.GetJobResponseTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetJobsResponse:
    boto3_raw_data: "type_defs.GetJobsResponseTypeDef" = dataclasses.field()

    @cached_property
    def Jobs(self):  # pragma: no cover
        return Job.make_many(self.boto3_raw_data["Jobs"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.GetJobsResponseTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[T.Iterable["type_defs.GetJobsResponseTypeDef"]],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetJobsResponsePaginator:
    boto3_raw_data: "type_defs.GetJobsResponsePaginatorTypeDef" = dataclasses.field()

    @cached_property
    def Jobs(self):  # pragma: no cover
        return JobPaginator.make_many(self.boto3_raw_data["Jobs"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetJobsResponsePaginatorTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetJobsResponsePaginatorTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Route:
    boto3_raw_data: "type_defs.RouteTypeDef" = dataclasses.field()

    Name = field("Name")
    Inputs = field("Inputs")
    GroupFiltersList = field("GroupFiltersList")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.RouteTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.RouteTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateTableRequest:
    boto3_raw_data: "type_defs.UpdateTableRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    CatalogId = field("CatalogId")
    Name = field("Name")

    @cached_property
    def TableInput(self):  # pragma: no cover
        return TableInput.make_one(self.boto3_raw_data["TableInput"])

    SkipArchive = field("SkipArchive")
    TransactionId = field("TransactionId")
    VersionId = field("VersionId")
    ViewUpdateAction = field("ViewUpdateAction")
    Force = field("Force")

    @cached_property
    def UpdateOpenTableFormatInput(self):  # pragma: no cover
        return UpdateOpenTableFormatInput.make_one(
            self.boto3_raw_data["UpdateOpenTableFormatInput"]
        )

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.UpdateTableRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateTableRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchUpdatePartitionRequest:
    boto3_raw_data: "type_defs.BatchUpdatePartitionRequestTypeDef" = dataclasses.field()

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")

    @cached_property
    def Entries(self):  # pragma: no cover
        return BatchUpdatePartitionRequestEntry.make_many(
            self.boto3_raw_data["Entries"]
        )

    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchUpdatePartitionRequestTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchUpdatePartitionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class ColumnStatistics:
    boto3_raw_data: "type_defs.ColumnStatisticsTypeDef" = dataclasses.field()

    ColumnName = field("ColumnName")
    ColumnType = field("ColumnType")
    AnalyzedTime = field("AnalyzedTime")
    StatisticsData = field("StatisticsData")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.ColumnStatisticsTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.ColumnStatisticsTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetWorkflowRunResponse:
    boto3_raw_data: "type_defs.GetWorkflowRunResponseTypeDef" = dataclasses.field()

    @cached_property
    def Run(self):  # pragma: no cover
        return WorkflowRun.make_one(self.boto3_raw_data["Run"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetWorkflowRunResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetWorkflowRunResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetWorkflowRunsResponse:
    boto3_raw_data: "type_defs.GetWorkflowRunsResponseTypeDef" = dataclasses.field()

    @cached_property
    def Runs(self):  # pragma: no cover
        return WorkflowRun.make_many(self.boto3_raw_data["Runs"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    NextToken = field("NextToken")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetWorkflowRunsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetWorkflowRunsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class Workflow:
    boto3_raw_data: "type_defs.WorkflowTypeDef" = dataclasses.field()

    Name = field("Name")
    Description = field("Description")
    DefaultRunProperties = field("DefaultRunProperties")
    CreatedOn = field("CreatedOn")
    LastModifiedOn = field("LastModifiedOn")

    @cached_property
    def LastRun(self):  # pragma: no cover
        return WorkflowRun.make_one(self.boto3_raw_data["LastRun"])

    @cached_property
    def Graph(self):  # pragma: no cover
        return WorkflowGraph.make_one(self.boto3_raw_data["Graph"])

    MaxConcurrentRuns = field("MaxConcurrentRuns")

    @cached_property
    def BlueprintDetails(self):  # pragma: no cover
        return BlueprintDetails.make_one(self.boto3_raw_data["BlueprintDetails"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.WorkflowTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.WorkflowTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class BatchGetWorkflowsResponse:
    boto3_raw_data: "type_defs.BatchGetWorkflowsResponseTypeDef" = dataclasses.field()

    @cached_property
    def Workflows(self):  # pragma: no cover
        return Workflow.make_many(self.boto3_raw_data["Workflows"])

    MissingWorkflows = field("MissingWorkflows")

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.BatchGetWorkflowsResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.BatchGetWorkflowsResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class GetWorkflowResponse:
    boto3_raw_data: "type_defs.GetWorkflowResponseTypeDef" = dataclasses.field()

    @cached_property
    def Workflow(self):  # pragma: no cover
        return Workflow.make_one(self.boto3_raw_data["Workflow"])

    @cached_property
    def ResponseMetadata(self):  # pragma: no cover
        return ResponseMetadata.make_one(self.boto3_raw_data["ResponseMetadata"])

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.GetWorkflowResponseTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.GetWorkflowResponseTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CodeGenConfigurationNode:
    boto3_raw_data: "type_defs.CodeGenConfigurationNodeTypeDef" = dataclasses.field()

    AthenaConnectorSource = field("AthenaConnectorSource")
    JDBCConnectorSource = field("JDBCConnectorSource")
    SparkConnectorSource = field("SparkConnectorSource")
    CatalogSource = field("CatalogSource")

    @cached_property
    def RedshiftSource(self):  # pragma: no cover
        return RedshiftSource.make_one(self.boto3_raw_data["RedshiftSource"])

    @cached_property
    def S3CatalogSource(self):  # pragma: no cover
        return S3CatalogSource.make_one(self.boto3_raw_data["S3CatalogSource"])

    S3CsvSource = field("S3CsvSource")
    S3JsonSource = field("S3JsonSource")
    S3ParquetSource = field("S3ParquetSource")

    @cached_property
    def RelationalCatalogSource(self):  # pragma: no cover
        return RelationalCatalogSource.make_one(
            self.boto3_raw_data["RelationalCatalogSource"]
        )

    @cached_property
    def DynamoDBCatalogSource(self):  # pragma: no cover
        return DynamoDBCatalogSource.make_one(
            self.boto3_raw_data["DynamoDBCatalogSource"]
        )

    JDBCConnectorTarget = field("JDBCConnectorTarget")
    SparkConnectorTarget = field("SparkConnectorTarget")
    CatalogTarget = field("CatalogTarget")
    RedshiftTarget = field("RedshiftTarget")
    S3CatalogTarget = field("S3CatalogTarget")
    S3GlueParquetTarget = field("S3GlueParquetTarget")
    S3DirectTarget = field("S3DirectTarget")
    ApplyMapping = field("ApplyMapping")
    SelectFields = field("SelectFields")
    DropFields = field("DropFields")
    RenameField = field("RenameField")
    Spigot = field("Spigot")
    Join = field("Join")
    SplitFields = field("SplitFields")
    SelectFromCollection = field("SelectFromCollection")
    FillMissingValues = field("FillMissingValues")
    Filter = field("Filter")
    CustomCode = field("CustomCode")
    SparkSQL = field("SparkSQL")
    DirectKinesisSource = field("DirectKinesisSource")
    DirectKafkaSource = field("DirectKafkaSource")
    CatalogKinesisSource = field("CatalogKinesisSource")
    CatalogKafkaSource = field("CatalogKafkaSource")
    DropNullFields = field("DropNullFields")
    Merge = field("Merge")
    Union = field("Union")
    PIIDetection = field("PIIDetection")
    Aggregate = field("Aggregate")
    DropDuplicates = field("DropDuplicates")
    GovernedCatalogTarget = field("GovernedCatalogTarget")

    @cached_property
    def GovernedCatalogSource(self):  # pragma: no cover
        return GovernedCatalogSource.make_one(
            self.boto3_raw_data["GovernedCatalogSource"]
        )

    @cached_property
    def MicrosoftSQLServerCatalogSource(self):  # pragma: no cover
        return MicrosoftSQLServerCatalogSource.make_one(
            self.boto3_raw_data["MicrosoftSQLServerCatalogSource"]
        )

    @cached_property
    def MySQLCatalogSource(self):  # pragma: no cover
        return MySQLCatalogSource.make_one(self.boto3_raw_data["MySQLCatalogSource"])

    @cached_property
    def OracleSQLCatalogSource(self):  # pragma: no cover
        return OracleSQLCatalogSource.make_one(
            self.boto3_raw_data["OracleSQLCatalogSource"]
        )

    @cached_property
    def PostgreSQLCatalogSource(self):  # pragma: no cover
        return PostgreSQLCatalogSource.make_one(
            self.boto3_raw_data["PostgreSQLCatalogSource"]
        )

    MicrosoftSQLServerCatalogTarget = field("MicrosoftSQLServerCatalogTarget")
    MySQLCatalogTarget = field("MySQLCatalogTarget")
    OracleSQLCatalogTarget = field("OracleSQLCatalogTarget")
    PostgreSQLCatalogTarget = field("PostgreSQLCatalogTarget")
    Route = field("Route")
    DynamicTransform = field("DynamicTransform")
    EvaluateDataQuality = field("EvaluateDataQuality")
    S3CatalogHudiSource = field("S3CatalogHudiSource")
    CatalogHudiSource = field("CatalogHudiSource")
    S3HudiSource = field("S3HudiSource")
    S3HudiCatalogTarget = field("S3HudiCatalogTarget")
    S3HudiDirectTarget = field("S3HudiDirectTarget")
    DirectJDBCSource = field("DirectJDBCSource")
    S3CatalogDeltaSource = field("S3CatalogDeltaSource")
    CatalogDeltaSource = field("CatalogDeltaSource")
    S3DeltaSource = field("S3DeltaSource")
    S3DeltaCatalogTarget = field("S3DeltaCatalogTarget")
    S3DeltaDirectTarget = field("S3DeltaDirectTarget")
    AmazonRedshiftSource = field("AmazonRedshiftSource")
    AmazonRedshiftTarget = field("AmazonRedshiftTarget")
    EvaluateDataQualityMultiFrame = field("EvaluateDataQualityMultiFrame")
    Recipe = field("Recipe")
    SnowflakeSource = field("SnowflakeSource")
    SnowflakeTarget = field("SnowflakeTarget")
    ConnectorDataSource = field("ConnectorDataSource")
    ConnectorDataTarget = field("ConnectorDataTarget")
    S3CatalogIcebergSource = field("S3CatalogIcebergSource")
    CatalogIcebergSource = field("CatalogIcebergSource")
    S3IcebergCatalogTarget = field("S3IcebergCatalogTarget")
    S3IcebergDirectTarget = field("S3IcebergDirectTarget")
    S3ExcelSource = field("S3ExcelSource")
    S3HyperDirectTarget = field("S3HyperDirectTarget")
    DynamoDBELTConnectorSource = field("DynamoDBELTConnectorSource")

    @classmethod
    def make_one(
        cls, boto3_raw_data: T.Optional["type_defs.CodeGenConfigurationNodeTypeDef"]
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CodeGenConfigurationNodeTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateColumnStatisticsForPartitionRequest:
    boto3_raw_data: "type_defs.UpdateColumnStatisticsForPartitionRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    PartitionValues = field("PartitionValues")
    ColumnStatisticsList = field("ColumnStatisticsList")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.UpdateColumnStatisticsForPartitionRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateColumnStatisticsForPartitionRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateColumnStatisticsForTableRequest:
    boto3_raw_data: "type_defs.UpdateColumnStatisticsForTableRequestTypeDef" = (
        dataclasses.field()
    )

    DatabaseName = field("DatabaseName")
    TableName = field("TableName")
    ColumnStatisticsList = field("ColumnStatisticsList")
    CatalogId = field("CatalogId")

    @classmethod
    def make_one(
        cls,
        boto3_raw_data: T.Optional[
            "type_defs.UpdateColumnStatisticsForTableRequestTypeDef"
        ],
    ):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateColumnStatisticsForTableRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class CreateJobRequest:
    boto3_raw_data: "type_defs.CreateJobRequestTypeDef" = dataclasses.field()

    Name = field("Name")
    Role = field("Role")

    @cached_property
    def Command(self):  # pragma: no cover
        return JobCommand.make_one(self.boto3_raw_data["Command"])

    JobMode = field("JobMode")
    JobRunQueuingEnabled = field("JobRunQueuingEnabled")
    Description = field("Description")
    LogUri = field("LogUri")

    @cached_property
    def ExecutionProperty(self):  # pragma: no cover
        return ExecutionProperty.make_one(self.boto3_raw_data["ExecutionProperty"])

    DefaultArguments = field("DefaultArguments")
    NonOverridableArguments = field("NonOverridableArguments")
    Connections = field("Connections")
    MaxRetries = field("MaxRetries")
    AllocatedCapacity = field("AllocatedCapacity")
    Timeout = field("Timeout")
    MaxCapacity = field("MaxCapacity")
    SecurityConfiguration = field("SecurityConfiguration")
    Tags = field("Tags")

    @cached_property
    def NotificationProperty(self):  # pragma: no cover
        return NotificationProperty.make_one(
            self.boto3_raw_data["NotificationProperty"]
        )

    GlueVersion = field("GlueVersion")
    NumberOfWorkers = field("NumberOfWorkers")
    WorkerType = field("WorkerType")
    CodeGenConfigurationNodes = field("CodeGenConfigurationNodes")
    ExecutionClass = field("ExecutionClass")

    @cached_property
    def SourceControlDetails(self):  # pragma: no cover
        return SourceControlDetails.make_one(
            self.boto3_raw_data["SourceControlDetails"]
        )

    MaintenanceWindow = field("MaintenanceWindow")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.CreateJobRequestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.CreateJobRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class JobUpdate:
    boto3_raw_data: "type_defs.JobUpdateTypeDef" = dataclasses.field()

    JobMode = field("JobMode")
    JobRunQueuingEnabled = field("JobRunQueuingEnabled")
    Description = field("Description")
    LogUri = field("LogUri")
    Role = field("Role")

    @cached_property
    def ExecutionProperty(self):  # pragma: no cover
        return ExecutionProperty.make_one(self.boto3_raw_data["ExecutionProperty"])

    @cached_property
    def Command(self):  # pragma: no cover
        return JobCommand.make_one(self.boto3_raw_data["Command"])

    DefaultArguments = field("DefaultArguments")
    NonOverridableArguments = field("NonOverridableArguments")
    Connections = field("Connections")
    MaxRetries = field("MaxRetries")
    AllocatedCapacity = field("AllocatedCapacity")
    Timeout = field("Timeout")
    MaxCapacity = field("MaxCapacity")
    WorkerType = field("WorkerType")
    NumberOfWorkers = field("NumberOfWorkers")
    SecurityConfiguration = field("SecurityConfiguration")

    @cached_property
    def NotificationProperty(self):  # pragma: no cover
        return NotificationProperty.make_one(
            self.boto3_raw_data["NotificationProperty"]
        )

    GlueVersion = field("GlueVersion")
    CodeGenConfigurationNodes = field("CodeGenConfigurationNodes")
    ExecutionClass = field("ExecutionClass")

    @cached_property
    def SourceControlDetails(self):  # pragma: no cover
        return SourceControlDetails.make_one(
            self.boto3_raw_data["SourceControlDetails"]
        )

    MaintenanceWindow = field("MaintenanceWindow")

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.JobUpdateTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls, boto3_raw_data_list: T.Optional[T.Iterable["type_defs.JobUpdateTypeDef"]]
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]


@dataclasses.dataclass(frozen=True)
class UpdateJobRequest:
    boto3_raw_data: "type_defs.UpdateJobRequestTypeDef" = dataclasses.field()

    JobName = field("JobName")

    @cached_property
    def JobUpdate(self):  # pragma: no cover
        return JobUpdate.make_one(self.boto3_raw_data["JobUpdate"])

    @classmethod
    def make_one(cls, boto3_raw_data: T.Optional["type_defs.UpdateJobRequestTypeDef"]):
        if boto3_raw_data is None:
            return None
        return cls(boto3_raw_data=boto3_raw_data)

    @classmethod
    def make_many(
        cls,
        boto3_raw_data_list: T.Optional[
            T.Iterable["type_defs.UpdateJobRequestTypeDef"]
        ],
    ):
        if boto3_raw_data_list is None:
            return None
        return [
            cls(boto3_raw_data=boto3_raw_data) for boto3_raw_data in boto3_raw_data_list
        ]
