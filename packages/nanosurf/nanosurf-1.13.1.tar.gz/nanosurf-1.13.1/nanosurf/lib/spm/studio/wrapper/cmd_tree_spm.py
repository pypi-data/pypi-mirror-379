# studio_wrapper.py

import enum
from typing import Any, Self
import nanosurf.lib.spm.studio.wrapper as wrap

g_cmd_tree_hash = '48429f5f0f02c41ace82d5dc2519f6bc'
g_compiler_version = '2.5'

class RootUtil(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.util'

    def to_snake_case(self, *args, **kwargs) -> Any:
        return self._context.call('root.util.to_snake_case', *args, **kwargs)

    def to_string(self, *args, **kwargs) -> Any:
        return self._context.call('root.util.to_string', *args, **kwargs)

    def prequire(self, *args, **kwargs) -> Any:
        return self._context.call('root.util.prequire', *args, **kwargs)

    def list_table_elements(self, *args, **kwargs) -> Any:
        return self._context.call('root.util.list_table_elements', *args, **kwargs)

    def lock_table(self, *args, **kwargs) -> Any:
        return self._context.call('root.util.lock_table', *args, **kwargs)

    def table_append(self, *args, **kwargs) -> Any:
        return self._context.call('root.util.table_append', *args, **kwargs)

    def deep_copy(self, *args, **kwargs) -> Any:
        return self._context.call('root.util.deep_copy', *args, **kwargs)

    def deep_compare(self, *args, **kwargs) -> Any:
        return self._context.call('root.util.deep_compare', *args, **kwargs)

    def num_table_invert(self, *args, **kwargs) -> Any:
        return self._context.call('root.util.num_table_invert', *args, **kwargs)

    def make_property(self, *args, **kwargs) -> Any:
        return self._context.call('root.util.make_property', *args, **kwargs)

    def list_table_vars(self, *args, **kwargs) -> Any:
        return self._context.call('root.util.list_table_vars', *args, **kwargs)

    def list_table_tables(self, *args, **kwargs) -> Any:
        return self._context.call('root.util.list_table_tables', *args, **kwargs)

    def list_table_functions(self, *args, **kwargs) -> Any:
        return self._context.call('root.util.list_table_functions', *args, **kwargs)

    def array_concat(self, *args, **kwargs) -> Any:
        return self._context.call('root.util.array_concat', *args, **kwargs)

    def filter_string_array_begin(self, *args, **kwargs) -> Any:
        return self._context.call('root.util.filter_string_array_begin', *args, **kwargs)

    def list_table_all(self, *args, **kwargs) -> Any:
        return self._context.call('root.util.list_table_all', *args, **kwargs)


class RootSession(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.session'

    @property
    def current_connection(self) -> str:
        return str(self._context.get('root.session.current_connection'))

    @current_connection.setter
    def current_connection(self, new_val:str):
        self._context.set('root.session.current_connection', str(new_val))

    def list(self, *args, **kwargs) -> Any:
        return self._context.call('root.session.list', *args, **kwargs)

    @property
    def name(self) -> str:
        return str(self._context.get('root.session.name'))

    @name.setter
    def name(self, new_val:str):
        self._context.set('root.session.name', str(new_val))

    def select_main(self, *args, **kwargs) -> Any:
        return self._context.call('root.session.select_main', *args, **kwargs)

    def select(self, *args, **kwargs) -> Any:
        return self._context.call('root.session.select', *args, **kwargs)


class RootLuTimestamperInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timestamper.instance.trigger'

    def clear(self) -> None:
        return self._context.call('root.lu.timestamper.instance.trigger.clear')

    def stop(self) -> None:
        return self._context.call('root.lu.timestamper.instance.trigger.stop')

    def start(self) -> None:
        return self._context.call('root.lu.timestamper.instance.trigger.start')


class RootLuTimestamperInstanceAttributeTimestamp(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timestamper.instance.attribute.timestamp'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.timestamper.instance.attribute.timestamp.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.timestamper.instance.attribute.timestamp.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.timestamper.instance.attribute.timestamp.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.timestamper.instance.attribute.timestamp.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.timestamper.instance.attribute.timestamp.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.timestamper.instance.attribute.timestamp.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.timestamper.instance.attribute.timestamp.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.timestamper.instance.attribute.timestamp.min', float(new_val))


class RootLuTimestamperInstanceAttributeTrigger_event(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        both_edges = 4
        falling_edge = 3
        level = 0
        rising_edge = 2
        inverse = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timestamper.instance.attribute.trigger_event'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.timestamper.instance.attribute.trigger_event.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.timestamper.instance.attribute.trigger_event.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.timestamper.instance.attribute.trigger_event.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.timestamper.instance.attribute.trigger_event.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.timestamper.instance.attribute.trigger_event.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.timestamper.instance.attribute.trigger_event.value_raw', new_val.value)


class RootLuTimestamperInstanceAttributeTrigger_signal(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        data_sampling_done = 1
        timer_proc0_done = 11
        ramp_gen_maxz_done = 7
        z_ctrl_reached_min_z_true = 19
        mem_sig_gen_done = 12
        soft_event1_true = 25
        ramp_gen_user4_done = 14
        event_manager_done = 2
        ramp_gen_positionw_done = 16
        and_mask0_true = 28
        data_capture_done = 0
        z_ctrl_reached_error_limit_true = 18
        user_abort_event_true = 27
        comparator2_true = 30
        timer_dbg1_done = 15
        comparator1_true = 29
        static_value = 17
        ext_event1_true = 23
        z_ctrl_reached_max_z_true = 20
        soft_event0_true = 24
        ramp_gen_test_done = 13
        ramp_gen_ctrlz_done = 6
        ramp_gen_positiony_done = 4
        ramp_gen_tipvoltage_done = 9
        ramp_gen_approach_done = 10
        comparator3_true = 31
        ramp_gen_alternatez_done = 8
        ramp_gen_planez_done = 5
        ramp_gen_positionx_done = 3
        soft_event2_true = 26
        ext_event0_true = 22

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timestamper.instance.attribute.trigger_signal'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.timestamper.instance.attribute.trigger_signal.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.timestamper.instance.attribute.trigger_signal.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.timestamper.instance.attribute.trigger_signal.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.timestamper.instance.attribute.trigger_signal.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.timestamper.instance.attribute.trigger_signal.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.timestamper.instance.attribute.trigger_signal.value_raw', new_val.value)


class RootLuTimestamperInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timestamper.instance.attribute'
        self.trigger_signal = RootLuTimestamperInstanceAttributeTrigger_signal(self._context)
        self.trigger_event = RootLuTimestamperInstanceAttributeTrigger_event(self._context)
        self.timestamp = RootLuTimestamperInstanceAttributeTimestamp(self._context)


class RootLuTimestamperInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timestamper.instance'
        self.attribute = RootLuTimestamperInstanceAttribute(self._context)
        self.trigger = RootLuTimestamperInstanceTrigger(self._context)


class RootLuTimestamper(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timestamper'
        self.instance = RootLuTimestamperInstance(self._context)


class RootLuMainboard_relaysInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.mainboard_relays.instance.trigger'


class RootLuMainboard_relaysInstanceAttributeSet_state_mask(wrap.CmdTreeProp):

    class ValueMask(enum.IntEnum):
        fast_out_user = 256
        all = 4095
        dvi_pos_out_w = 2048
        hires_in_user4 = 128
        hires_in_user3 = 64
        hires_out_user4 = 8
        hires_out_user3 = 4
        hires_in_user2 = 32
        hires_out_user2 = 2
        hi_res_in6 = 1024
        fast_in_user = 512
        hires_out_user1 = 1
        none = 0
        hires_in_user1 = 16

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.mainboard_relays.instance.attribute.set_state_mask'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.mainboard_relays.instance.attribute.set_state_mask.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.mainboard_relays.instance.attribute.set_state_mask.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.mainboard_relays.instance.attribute.set_state_mask.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.mainboard_relays.instance.attribute.set_state_mask.enum', list(new_val))

    @property
    def value(self) -> int:
        return int(self._context.get('root.lu.mainboard_relays.instance.attribute.set_state_mask.value_raw'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.lu.mainboard_relays.instance.attribute.set_state_mask.value_raw', int(new_val))


class RootLuMainboard_relaysInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.mainboard_relays.instance.attribute'
        self.set_state_mask = RootLuMainboard_relaysInstanceAttributeSet_state_mask(self._context)


class RootLuMainboard_relaysInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.mainboard_relays.instance'
        self.attribute = RootLuMainboard_relaysInstanceAttribute(self._context)
        self.trigger = RootLuMainboard_relaysInstanceTrigger(self._context)


class RootLuMainboard_relays(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.mainboard_relays'
        self.instance = RootLuMainboard_relaysInstance(self._context)


class RootLuSensor_controlInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sensor_control.instance.trigger'

    def deflection_offset_calibration(self) -> None:
        return self._context.call('root.lu.sensor_control.instance.trigger.deflection_offset_calibration')

    def start_deflection_offset_calibration(self) -> None:
        return self._context.call('root.lu.sensor_control.instance.trigger.start_deflection_offset_calibration')

    def start_sensor_calibration(self) -> None:
        return self._context.call('root.lu.sensor_control.instance.trigger.start_sensor_calibration')

    def user_abort(self) -> None:
        return self._context.call('root.lu.sensor_control.instance.trigger.user_abort')

    def update_laser_spot_on_detector_status(self) -> None:
        return self._context.call('root.lu.sensor_control.instance.trigger.update_laser_spot_on_detector_status')

    def deflection_offset_calibration_with_retract(self) -> None:
        return self._context.call('root.lu.sensor_control.instance.trigger.deflection_offset_calibration_with_retract')

    def start_detector_auto_adjustment(self) -> None:
        return self._context.call('root.lu.sensor_control.instance.trigger.start_detector_auto_adjustment')

    def start_update_laser_spot_on_detector_status(self) -> None:
        return self._context.call('root.lu.sensor_control.instance.trigger.start_update_laser_spot_on_detector_status')

    def start_set_dynamic_amplitude(self) -> None:
        return self._context.call('root.lu.sensor_control.instance.trigger.start_set_dynamic_amplitude')


class RootLuSensor_controlInstanceAttributeOffset_calib_i_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sensor_control.instance.attribute.offset_calib_i_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.sensor_control.instance.attribute.offset_calib_i_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.sensor_control.instance.attribute.offset_calib_i_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.sensor_control.instance.attribute.offset_calib_i_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.sensor_control.instance.attribute.offset_calib_i_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.sensor_control.instance.attribute.offset_calib_i_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.sensor_control.instance.attribute.offset_calib_i_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.sensor_control.instance.attribute.offset_calib_i_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.sensor_control.instance.attribute.offset_calib_i_gain.min', float(new_val))


class RootLuSensor_controlInstanceAttributeDetector_adjustment_tolerance(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sensor_control.instance.attribute.detector_adjustment_tolerance'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.sensor_control.instance.attribute.detector_adjustment_tolerance.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.sensor_control.instance.attribute.detector_adjustment_tolerance.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.sensor_control.instance.attribute.detector_adjustment_tolerance.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.sensor_control.instance.attribute.detector_adjustment_tolerance.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.sensor_control.instance.attribute.detector_adjustment_tolerance.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.sensor_control.instance.attribute.detector_adjustment_tolerance.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.sensor_control.instance.attribute.detector_adjustment_tolerance.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.sensor_control.instance.attribute.detector_adjustment_tolerance.min', float(new_val))


class RootLuSensor_controlInstanceAttributeDetector_adjustment_duration_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sensor_control.instance.attribute.detector_adjustment_duration_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.sensor_control.instance.attribute.detector_adjustment_duration_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.sensor_control.instance.attribute.detector_adjustment_duration_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.sensor_control.instance.attribute.detector_adjustment_duration_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.sensor_control.instance.attribute.detector_adjustment_duration_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.sensor_control.instance.attribute.detector_adjustment_duration_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.sensor_control.instance.attribute.detector_adjustment_duration_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.sensor_control.instance.attribute.detector_adjustment_duration_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.sensor_control.instance.attribute.detector_adjustment_duration_limit.min', float(new_val))


class RootLuSensor_controlInstanceAttributeOffset_calib_i_gain_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        auto_from_head_typ = 1
        fix_from_attr = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sensor_control.instance.attribute.offset_calib_i_gain_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.sensor_control.instance.attribute.offset_calib_i_gain_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.sensor_control.instance.attribute.offset_calib_i_gain_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.sensor_control.instance.attribute.offset_calib_i_gain_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.sensor_control.instance.attribute.offset_calib_i_gain_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.sensor_control.instance.attribute.offset_calib_i_gain_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.sensor_control.instance.attribute.offset_calib_i_gain_mode.value_raw', new_val.value)


class RootLuSensor_controlInstanceAttributeDeflection_offset_calibration_status(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        sensor_signal_failed = 2
        no_error = 0
        calibration_error = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sensor_control.instance.attribute.deflection_offset_calibration_status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.sensor_control.instance.attribute.deflection_offset_calibration_status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.sensor_control.instance.attribute.deflection_offset_calibration_status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.sensor_control.instance.attribute.deflection_offset_calibration_status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.sensor_control.instance.attribute.deflection_offset_calibration_status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.sensor_control.instance.attribute.deflection_offset_calibration_status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.sensor_control.instance.attribute.deflection_offset_calibration_status.value_raw', new_val.value)


class RootLuSensor_controlInstanceAttributeOffset_calib_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        no_auto_calibration = 0
        auto_calibrate_z_ctrl_input = 2
        auto_calibrate_deflection = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sensor_control.instance.attribute.offset_calib_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.sensor_control.instance.attribute.offset_calib_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.sensor_control.instance.attribute.offset_calib_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.sensor_control.instance.attribute.offset_calib_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.sensor_control.instance.attribute.offset_calib_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.sensor_control.instance.attribute.offset_calib_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.sensor_control.instance.attribute.offset_calib_mode.value_raw', new_val.value)


class RootLuSensor_controlInstanceAttributeDetector_auto_adjustment_status(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        failed = 2
        running = 1
        idle = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sensor_control.instance.attribute.detector_auto_adjustment_status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.sensor_control.instance.attribute.detector_auto_adjustment_status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.sensor_control.instance.attribute.detector_auto_adjustment_status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.sensor_control.instance.attribute.detector_auto_adjustment_status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.sensor_control.instance.attribute.detector_auto_adjustment_status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.sensor_control.instance.attribute.detector_auto_adjustment_status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.sensor_control.instance.attribute.detector_auto_adjustment_status.value_raw', new_val.value)


class RootLuSensor_controlInstanceAttributeSensor_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sensor_control.instance.attribute.sensor_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.sensor_control.instance.attribute.sensor_amplitude.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.sensor_control.instance.attribute.sensor_amplitude.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.sensor_control.instance.attribute.sensor_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.sensor_control.instance.attribute.sensor_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.sensor_control.instance.attribute.sensor_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.sensor_control.instance.attribute.sensor_amplitude.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.sensor_control.instance.attribute.sensor_amplitude.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.sensor_control.instance.attribute.sensor_amplitude.min', float(new_val))


class RootLuSensor_controlInstanceAttributeEnable10_hz_update_laser_spot_on_detector_status(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sensor_control.instance.attribute.enable10_hz_update_laser_spot_on_detector_status'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.sensor_control.instance.attribute.enable10_hz_update_laser_spot_on_detector_status.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.sensor_control.instance.attribute.enable10_hz_update_laser_spot_on_detector_status.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.sensor_control.instance.attribute.enable10_hz_update_laser_spot_on_detector_status.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.sensor_control.instance.attribute.enable10_hz_update_laser_spot_on_detector_status.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.sensor_control.instance.attribute.enable10_hz_update_laser_spot_on_detector_status.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.sensor_control.instance.attribute.enable10_hz_update_laser_spot_on_detector_status.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.sensor_control.instance.attribute.enable10_hz_update_laser_spot_on_detector_status.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.sensor_control.instance.attribute.enable10_hz_update_laser_spot_on_detector_status.min', float(new_val))


class RootLuSensor_controlInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sensor_control.instance.attribute'
        self.enable10_hz_update_laser_spot_on_detector_status = RootLuSensor_controlInstanceAttributeEnable10_hz_update_laser_spot_on_detector_status(self._context)
        self.sensor_amplitude = RootLuSensor_controlInstanceAttributeSensor_amplitude(self._context)
        self.detector_auto_adjustment_status = RootLuSensor_controlInstanceAttributeDetector_auto_adjustment_status(self._context)
        self.offset_calib_mode = RootLuSensor_controlInstanceAttributeOffset_calib_mode(self._context)
        self.deflection_offset_calibration_status = RootLuSensor_controlInstanceAttributeDeflection_offset_calibration_status(self._context)
        self.offset_calib_i_gain_mode = RootLuSensor_controlInstanceAttributeOffset_calib_i_gain_mode(self._context)
        self.detector_adjustment_duration_limit = RootLuSensor_controlInstanceAttributeDetector_adjustment_duration_limit(self._context)
        self.detector_adjustment_tolerance = RootLuSensor_controlInstanceAttributeDetector_adjustment_tolerance(self._context)
        self.offset_calib_i_gain = RootLuSensor_controlInstanceAttributeOffset_calib_i_gain(self._context)


class RootLuSensor_controlInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sensor_control.instance'
        self.attribute = RootLuSensor_controlInstanceAttribute(self._context)
        self.trigger = RootLuSensor_controlInstanceTrigger(self._context)


class RootLuSensor_control(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sensor_control'
        self.instance = RootLuSensor_controlInstance(self._context)


class RootLuScanInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.trigger'

    def start_move_to_start_and_do_frame(self) -> None:
        return self._context.call('root.lu.scan.instance.trigger.start_move_to_start_and_do_frame')

    def user_abort(self) -> None:
        return self._context.call('root.lu.scan.instance.trigger.user_abort')

    def start_do_frame(self) -> None:
        return self._context.call('root.lu.scan.instance.trigger.start_do_frame')

    def offset_xyz(self) -> None:
        return self._context.call('root.lu.scan.instance.trigger.offset_xyz')

    def do_set_xy_sensor_data_acquisition(self) -> None:
        return self._context.call('root.lu.scan.instance.trigger.do_set_xy_sensor_data_acquisition')

    def start_move_to_start_and_do_frame_quick(self) -> None:
        return self._context.call('root.lu.scan.instance.trigger.start_move_to_start_and_do_frame_quick')

    def start_move_to_start(self) -> None:
        return self._context.call('root.lu.scan.instance.trigger.start_move_to_start')


class RootLuScanInstanceAttributeContour_data_channel(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.contour_data_channel'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.contour_data_channel.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.contour_data_channel.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.contour_data_channel.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.contour_data_channel.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.contour_data_channel.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.contour_data_channel.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.contour_data_channel.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.contour_data_channel.min', float(new_val))


class RootLuScanInstanceAttributeSlow_range(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.slow_range'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.slow_range.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.slow_range.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.slow_range.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.slow_range.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.slow_range.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.slow_range.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.slow_range.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.slow_range.min', float(new_val))


class RootLuScanInstanceAttributeLinearization_smoothing_factor(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.linearization_smoothing_factor'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.linearization_smoothing_factor.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.linearization_smoothing_factor.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.linearization_smoothing_factor.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.linearization_smoothing_factor.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.linearization_smoothing_factor.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.linearization_smoothing_factor.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.linearization_smoothing_factor.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.linearization_smoothing_factor.min', float(new_val))


class RootLuScanInstanceAttributeOverscan_points(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.overscan_points'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.overscan_points.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.overscan_points.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.overscan_points.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.overscan_points.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.overscan_points.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.overscan_points.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.overscan_points.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.overscan_points.min', float(new_val))


class RootLuScanInstanceAttributeSlow_points(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.slow_points'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.slow_points.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.slow_points.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.slow_points.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.slow_points.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.slow_points.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.slow_points.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.slow_points.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.slow_points.min', float(new_val))


class RootLuScanInstanceAttributeXy_move_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.xy_move_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.xy_move_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.xy_move_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.xy_move_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.xy_move_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.xy_move_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.xy_move_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.xy_move_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.xy_move_speed.min', float(new_val))


class RootLuScanInstanceAttributeSnd_scan_dynamic_amplitude_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.snd_scan_dynamic_amplitude_enabled'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_dynamic_amplitude_enabled.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_dynamic_amplitude_enabled.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.snd_scan_dynamic_amplitude_enabled.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_dynamic_amplitude_enabled.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_dynamic_amplitude_enabled.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_dynamic_amplitude_enabled.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_dynamic_amplitude_enabled.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_dynamic_amplitude_enabled.min', float(new_val))


class RootLuScanInstanceAttributeReadjust_lift_height(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.readjust_lift_height'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.readjust_lift_height.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.readjust_lift_height.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.readjust_lift_height.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.readjust_lift_height.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.readjust_lift_height.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.readjust_lift_height.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.readjust_lift_height.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.readjust_lift_height.min', float(new_val))


class RootLuScanInstanceAttributeSnd_scan_snd_lock_in_excitation_amplitude_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.snd_scan_snd_lock_in_excitation_amplitude_enabled'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_snd_lock_in_excitation_amplitude_enabled.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_snd_lock_in_excitation_amplitude_enabled.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.snd_scan_snd_lock_in_excitation_amplitude_enabled.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_snd_lock_in_excitation_amplitude_enabled.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_snd_lock_in_excitation_amplitude_enabled.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_snd_lock_in_excitation_amplitude_enabled.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_snd_lock_in_excitation_amplitude_enabled.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_snd_lock_in_excitation_amplitude_enabled.min', float(new_val))


class RootLuScanInstanceAttributeMove_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        controlled = 0
        lifted = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.move_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.scan.instance.attribute.move_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.scan.instance.attribute.move_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.scan.instance.attribute.move_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.scan.instance.attribute.move_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.scan.instance.attribute.move_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.scan.instance.attribute.move_mode.value_raw', new_val.value)


class RootLuScanInstanceAttributeX_rotation(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.x_rotation'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.x_rotation.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.x_rotation.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.x_rotation.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.x_rotation.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.x_rotation.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.x_rotation.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.x_rotation.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.x_rotation.min', float(new_val))


class RootLuScanInstanceAttributeX_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.x_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.x_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.x_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.x_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.x_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.x_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.x_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.x_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.x_offset.min', float(new_val))


class RootLuScanInstanceAttributeY_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.y_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.y_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.y_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.y_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.y_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.y_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.y_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.y_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.y_offset.min', float(new_val))


class RootLuScanInstanceAttributeSnd_scan_dynamic_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.snd_scan_dynamic_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_dynamic_amplitude.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_dynamic_amplitude.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.snd_scan_dynamic_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_dynamic_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_dynamic_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_dynamic_amplitude.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_dynamic_amplitude.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_dynamic_amplitude.min', float(new_val))


class RootLuScanInstanceAttributeLinearization_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.linearization_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.scan.instance.attribute.linearization_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.scan.instance.attribute.linearization_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.scan.instance.attribute.linearization_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.scan.instance.attribute.linearization_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.scan.instance.attribute.linearization_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.scan.instance.attribute.linearization_enable.value_raw', new_val.value)


class RootLuScanInstanceAttributeLine_z_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.line_z_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.line_z_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.line_z_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.line_z_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.line_z_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.line_z_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.line_z_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.line_z_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.line_z_offset.min', float(new_val))


class RootLuScanInstanceAttributeLine_scanning(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        standard = 0
        dual_scan = 1
        interlaced = 2
        snd_scan_only = 3

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.line_scanning'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.scan.instance.attribute.line_scanning.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.scan.instance.attribute.line_scanning.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.scan.instance.attribute.line_scanning.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.scan.instance.attribute.line_scanning.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.scan.instance.attribute.line_scanning.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.scan.instance.attribute.line_scanning.value_raw', new_val.value)


class RootLuScanInstanceAttributeY_rotation(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.y_rotation'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.y_rotation.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.y_rotation.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.y_rotation.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.y_rotation.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.y_rotation.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.y_rotation.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.y_rotation.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.y_rotation.min', float(new_val))


class RootLuScanInstanceAttributeZ_move_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.z_move_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.z_move_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.z_move_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.z_move_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.z_move_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.z_move_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.z_move_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.z_move_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.z_move_speed.min', float(new_val))


class RootLuScanInstanceAttributeSnd_scan_snd_lock_in_excitation_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.snd_scan_snd_lock_in_excitation_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_snd_lock_in_excitation_amplitude.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_snd_lock_in_excitation_amplitude.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.snd_scan_snd_lock_in_excitation_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_snd_lock_in_excitation_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_snd_lock_in_excitation_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_snd_lock_in_excitation_amplitude.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_snd_lock_in_excitation_amplitude.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_snd_lock_in_excitation_amplitude.min', float(new_val))


class RootLuScanInstanceAttributeSnd_scan_force_modulation_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.snd_scan_force_modulation_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_force_modulation_amplitude.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_force_modulation_amplitude.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.snd_scan_force_modulation_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_force_modulation_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_force_modulation_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_force_modulation_amplitude.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_force_modulation_amplitude.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_force_modulation_amplitude.min', float(new_val))


class RootLuScanInstanceAttributeZ_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.z_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.z_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.z_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.z_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.z_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.z_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.z_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.z_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.z_offset.min', float(new_val))


class RootLuScanInstanceAttributeFast_points(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.fast_points'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.fast_points.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.fast_points.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.fast_points.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.fast_points.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.fast_points.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.fast_points.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.fast_points.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.fast_points.min', float(new_val))


class RootLuScanInstanceAttributeZ_rotation(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.z_rotation'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.z_rotation.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.z_rotation.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.z_rotation.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.z_rotation.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.z_rotation.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.z_rotation.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.z_rotation.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.z_rotation.min', float(new_val))


class RootLuScanInstanceAttributeSnd_scan_force_modulation_amplitude_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.snd_scan_force_modulation_amplitude_enabled'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_force_modulation_amplitude_enabled.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_force_modulation_amplitude_enabled.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.snd_scan_force_modulation_amplitude_enabled.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_force_modulation_amplitude_enabled.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_force_modulation_amplitude_enabled.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_force_modulation_amplitude_enabled.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_force_modulation_amplitude_enabled.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_force_modulation_amplitude_enabled.min', float(new_val))


class RootLuScanInstanceAttributeSlow_axis_move_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        stepwise = 0
        serpentine = 1
        continuous = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.slow_axis_move_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.scan.instance.attribute.slow_axis_move_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.scan.instance.attribute.slow_axis_move_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.scan.instance.attribute.slow_axis_move_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.scan.instance.attribute.slow_axis_move_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.scan.instance.attribute.slow_axis_move_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.scan.instance.attribute.slow_axis_move_mode.value_raw', new_val.value)


class RootLuScanInstanceAttributeBackward_fast_points(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.backward_fast_points'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.backward_fast_points.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.backward_fast_points.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.backward_fast_points.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.backward_fast_points.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.backward_fast_points.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.backward_fast_points.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.backward_fast_points.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.backward_fast_points.min', float(new_val))


class RootLuScanInstanceAttributeSlow_increment(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.slow_increment'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.slow_increment.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.slow_increment.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.slow_increment.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.slow_increment.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.slow_increment.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.slow_increment.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.slow_increment.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.slow_increment.min', float(new_val))


class RootLuScanInstanceAttributeAuto_readjust_probe_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.auto_readjust_probe_enabled'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.auto_readjust_probe_enabled.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.auto_readjust_probe_enabled.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.auto_readjust_probe_enabled.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.auto_readjust_probe_enabled.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.auto_readjust_probe_enabled.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.auto_readjust_probe_enabled.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.auto_readjust_probe_enabled.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.auto_readjust_probe_enabled.min', float(new_val))


class RootLuScanInstanceAttributeContour_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.contour_enabled'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.contour_enabled.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.contour_enabled.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.contour_enabled.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.contour_enabled.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.contour_enabled.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.contour_enabled.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.contour_enabled.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.contour_enabled.min', float(new_val))


class RootLuScanInstanceAttributeTime_per_line(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.time_per_line'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.time_per_line.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.time_per_line.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.time_per_line.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.time_per_line.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.time_per_line.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.time_per_line.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.time_per_line.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.time_per_line.min', float(new_val))


class RootLuScanInstanceAttributeSnd_scan_enable_kpfm(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.snd_scan_enable_kpfm'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_enable_kpfm.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_enable_kpfm.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.snd_scan_enable_kpfm.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_enable_kpfm.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_enable_kpfm.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_enable_kpfm.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_enable_kpfm.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_enable_kpfm.min', float(new_val))


class RootLuScanInstanceAttributeFirst_line_repetition(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.first_line_repetition'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.first_line_repetition.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.first_line_repetition.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.first_line_repetition.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.first_line_repetition.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.first_line_repetition.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.first_line_repetition.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.first_line_repetition.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.first_line_repetition.min', float(new_val))


class RootLuScanInstanceAttributeGenerator(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        generic_frame = 2
        generic_line = 1
        linear_line = 0
        generic_frame_fast = 3

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.generator'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.scan.instance.attribute.generator.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.scan.instance.attribute.generator.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.scan.instance.attribute.generator.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.scan.instance.attribute.generator.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.scan.instance.attribute.generator.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.scan.instance.attribute.generator.value_raw', new_val.value)


class RootLuScanInstanceAttributeSnd_scan_enable_dark_mode(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.snd_scan_enable_dark_mode'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_enable_dark_mode.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_enable_dark_mode.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.snd_scan_enable_dark_mode.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_enable_dark_mode.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_enable_dark_mode.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_enable_dark_mode.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.snd_scan_enable_dark_mode.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.snd_scan_enable_dark_mode.min', float(new_val))


class RootLuScanInstanceAttributeScan_direction_slow_axis(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        upward = 1
        downward = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.scan_direction_slow_axis'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.scan.instance.attribute.scan_direction_slow_axis.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.scan.instance.attribute.scan_direction_slow_axis.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.scan.instance.attribute.scan_direction_slow_axis.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.scan.instance.attribute.scan_direction_slow_axis.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.scan.instance.attribute.scan_direction_slow_axis.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.scan.instance.attribute.scan_direction_slow_axis.value_raw', new_val.value)


class RootLuScanInstanceAttributeFast_range(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute.fast_range'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.fast_range.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.fast_range.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scan.instance.attribute.fast_range.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scan.instance.attribute.fast_range.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.fast_range.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.fast_range.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scan.instance.attribute.fast_range.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scan.instance.attribute.fast_range.min', float(new_val))


class RootLuScanInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance.attribute'
        self.fast_range = RootLuScanInstanceAttributeFast_range(self._context)
        self.scan_direction_slow_axis = RootLuScanInstanceAttributeScan_direction_slow_axis(self._context)
        self.snd_scan_enable_dark_mode = RootLuScanInstanceAttributeSnd_scan_enable_dark_mode(self._context)
        self.generator = RootLuScanInstanceAttributeGenerator(self._context)
        self.first_line_repetition = RootLuScanInstanceAttributeFirst_line_repetition(self._context)
        self.snd_scan_enable_kpfm = RootLuScanInstanceAttributeSnd_scan_enable_kpfm(self._context)
        self.time_per_line = RootLuScanInstanceAttributeTime_per_line(self._context)
        self.contour_enabled = RootLuScanInstanceAttributeContour_enabled(self._context)
        self.auto_readjust_probe_enabled = RootLuScanInstanceAttributeAuto_readjust_probe_enabled(self._context)
        self.slow_increment = RootLuScanInstanceAttributeSlow_increment(self._context)
        self.backward_fast_points = RootLuScanInstanceAttributeBackward_fast_points(self._context)
        self.slow_axis_move_mode = RootLuScanInstanceAttributeSlow_axis_move_mode(self._context)
        self.snd_scan_force_modulation_amplitude_enabled = RootLuScanInstanceAttributeSnd_scan_force_modulation_amplitude_enabled(self._context)
        self.z_rotation = RootLuScanInstanceAttributeZ_rotation(self._context)
        self.fast_points = RootLuScanInstanceAttributeFast_points(self._context)
        self.z_offset = RootLuScanInstanceAttributeZ_offset(self._context)
        self.snd_scan_force_modulation_amplitude = RootLuScanInstanceAttributeSnd_scan_force_modulation_amplitude(self._context)
        self.snd_scan_snd_lock_in_excitation_amplitude = RootLuScanInstanceAttributeSnd_scan_snd_lock_in_excitation_amplitude(self._context)
        self.z_move_speed = RootLuScanInstanceAttributeZ_move_speed(self._context)
        self.y_rotation = RootLuScanInstanceAttributeY_rotation(self._context)
        self.line_scanning = RootLuScanInstanceAttributeLine_scanning(self._context)
        self.line_z_offset = RootLuScanInstanceAttributeLine_z_offset(self._context)
        self.linearization_enable = RootLuScanInstanceAttributeLinearization_enable(self._context)
        self.snd_scan_dynamic_amplitude = RootLuScanInstanceAttributeSnd_scan_dynamic_amplitude(self._context)
        self.y_offset = RootLuScanInstanceAttributeY_offset(self._context)
        self.x_offset = RootLuScanInstanceAttributeX_offset(self._context)
        self.x_rotation = RootLuScanInstanceAttributeX_rotation(self._context)
        self.move_mode = RootLuScanInstanceAttributeMove_mode(self._context)
        self.snd_scan_snd_lock_in_excitation_amplitude_enabled = RootLuScanInstanceAttributeSnd_scan_snd_lock_in_excitation_amplitude_enabled(self._context)
        self.readjust_lift_height = RootLuScanInstanceAttributeReadjust_lift_height(self._context)
        self.snd_scan_dynamic_amplitude_enabled = RootLuScanInstanceAttributeSnd_scan_dynamic_amplitude_enabled(self._context)
        self.xy_move_speed = RootLuScanInstanceAttributeXy_move_speed(self._context)
        self.slow_points = RootLuScanInstanceAttributeSlow_points(self._context)
        self.overscan_points = RootLuScanInstanceAttributeOverscan_points(self._context)
        self.linearization_smoothing_factor = RootLuScanInstanceAttributeLinearization_smoothing_factor(self._context)
        self.slow_range = RootLuScanInstanceAttributeSlow_range(self._context)
        self.contour_data_channel = RootLuScanInstanceAttributeContour_data_channel(self._context)


class RootLuScanInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan.instance'
        self.attribute = RootLuScanInstanceAttribute(self._context)
        self.trigger = RootLuScanInstanceTrigger(self._context)


class RootLuScan(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scan'
        self.instance = RootLuScanInstance(self._context)


class RootLuPosition_controlInstanceBusy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.busy'

    @property
    def is_calibrating(self) -> bool:
        return bool(self._context.call('root.lu.position_control.instance.busy.is_calibrating'))

    @property
    def is_busy(self) -> bool:
        return bool(self._context.call('root.lu.position_control.instance.busy.is_busy'))

    @property
    def is_range_switching(self) -> bool:
        return bool(self._context.call('root.lu.position_control.instance.busy.is_range_switching'))

    @property
    def is_tip_moving(self) -> bool:
        return bool(self._context.call('root.lu.position_control.instance.busy.is_tip_moving'))


class RootLuPosition_controlInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.trigger'

    def start_calib_xy_sensor_zero_to_center_of_ramp(self) -> None:
        return self._context.call('root.lu.position_control.instance.trigger.start_calib_xy_sensor_zero_to_center_of_ramp')

    def start_move_to_target_fix_time_xy(self) -> None:
        return self._context.call('root.lu.position_control.instance.trigger.start_move_to_target_fix_time_xy')

    def calib_xy_sensor_zero_to_center_of_ramp(self) -> None:
        return self._context.call('root.lu.position_control.instance.trigger.calib_xy_sensor_zero_to_center_of_ramp')

    def start_move_to_target_fix_speed_xyz(self) -> None:
        return self._context.call('root.lu.position_control.instance.trigger.start_move_to_target_fix_speed_xyz')

    def move_to_target_fix_speed_xyz(self) -> None:
        return self._context.call('root.lu.position_control.instance.trigger.move_to_target_fix_speed_xyz')

    def switch_to_target_scan_axis_range_select(self) -> None:
        return self._context.call('root.lu.position_control.instance.trigger.switch_to_target_scan_axis_range_select')

    def start_switch_to_target_w_scan_axis_range_select(self) -> None:
        return self._context.call('root.lu.position_control.instance.trigger.start_switch_to_target_w_scan_axis_range_select')

    def disable_xy_closed_loop(self) -> None:
        return self._context.call('root.lu.position_control.instance.trigger.disable_xy_closed_loop')

    def move_to_target_fix_time_xyz(self) -> None:
        return self._context.call('root.lu.position_control.instance.trigger.move_to_target_fix_time_xyz')

    def start_move_to_target_fix_time_xyz(self) -> None:
        return self._context.call('root.lu.position_control.instance.trigger.start_move_to_target_fix_time_xyz')

    def move_to_target_fix_time_xy(self) -> None:
        return self._context.call('root.lu.position_control.instance.trigger.move_to_target_fix_time_xy')

    def start_switch_to_target_scan_axis_range_select(self) -> None:
        return self._context.call('root.lu.position_control.instance.trigger.start_switch_to_target_scan_axis_range_select')

    def enable_xy_closed_loop(self) -> None:
        return self._context.call('root.lu.position_control.instance.trigger.enable_xy_closed_loop')

    def start_move_to_target_fix_speed_xy(self) -> None:
        return self._context.call('root.lu.position_control.instance.trigger.start_move_to_target_fix_speed_xy')

    def move_to_target_fix_speed_xy(self) -> None:
        return self._context.call('root.lu.position_control.instance.trigger.move_to_target_fix_speed_xy')


class RootLuPosition_controlInstanceAttributeAxis_scale_xylv(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.axis_scale_xylv'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.axis_scale_xylv.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.axis_scale_xylv.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.axis_scale_xylv.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.axis_scale_xylv.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.axis_scale_xylv.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.axis_scale_xylv.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.axis_scale_xylv.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.axis_scale_xylv.min', float(new_val))


class RootLuPosition_controlInstanceAttributeCurrent_pos_y(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.current_pos_y'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.current_pos_y.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.current_pos_y.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.current_pos_y.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.current_pos_y.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.current_pos_y.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.current_pos_y.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.current_pos_y.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.current_pos_y.min', float(new_val))


class RootLuPosition_controlInstanceAttributeEnable_xy_closed_loop(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.enable_xy_closed_loop'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.enable_xy_closed_loop.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.enable_xy_closed_loop.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.enable_xy_closed_loop.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.enable_xy_closed_loop.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.enable_xy_closed_loop.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.enable_xy_closed_loop.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.enable_xy_closed_loop.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.enable_xy_closed_loop.min', float(new_val))


class RootLuPosition_controlInstanceAttributeCurrent_pos_z(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.current_pos_z'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.current_pos_z.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.current_pos_z.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.current_pos_z.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.current_pos_z.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.current_pos_z.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.current_pos_z.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.current_pos_z.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.current_pos_z.min', float(new_val))


class RootLuPosition_controlInstanceAttributeIs_xy_closed_loop_possible(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        not_possible_wrong_scan_axis_range = -2
        not_possible_no_sensor = -1
        not_possible = 0
        possible = 1
        not_possible_no_scan_head = -3

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.is_xy_closed_loop_possible'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.position_control.instance.attribute.is_xy_closed_loop_possible.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.position_control.instance.attribute.is_xy_closed_loop_possible.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.position_control.instance.attribute.is_xy_closed_loop_possible.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.position_control.instance.attribute.is_xy_closed_loop_possible.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.position_control.instance.attribute.is_xy_closed_loop_possible.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.position_control.instance.attribute.is_xy_closed_loop_possible.value_raw', new_val.value)


class RootLuPosition_controlInstanceAttributeLast_move_stop_event(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        out_of_bound_lower_limit = 5
        out_of_bound_max = 8
        out_of_bound_min = 9
        out_of_data = 7
        timer_expired = 3
        finish = 0
        user_abort = 4
        out_of_bound_upper_limit = 6
        setpoint_reached = 2
        position_reached = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.last_move_stop_event'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.position_control.instance.attribute.last_move_stop_event.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.position_control.instance.attribute.last_move_stop_event.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.position_control.instance.attribute.last_move_stop_event.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.position_control.instance.attribute.last_move_stop_event.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.position_control.instance.attribute.last_move_stop_event.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.position_control.instance.attribute.last_move_stop_event.value_raw', new_val.value)


class RootLuPosition_controlInstanceAttributeAxis_scale_zlv(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.axis_scale_zlv'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.axis_scale_zlv.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.axis_scale_zlv.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.axis_scale_zlv.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.axis_scale_zlv.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.axis_scale_zlv.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.axis_scale_zlv.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.axis_scale_zlv.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.axis_scale_zlv.min', float(new_val))


class RootLuPosition_controlInstanceAttributeRamp_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.ramp_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.ramp_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.ramp_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.ramp_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.ramp_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.ramp_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.ramp_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.ramp_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.ramp_time.min', float(new_val))


class RootLuPosition_controlInstanceAttributeScan_correction_y_rotation(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.scan_correction_y_rotation'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.scan_correction_y_rotation.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.scan_correction_y_rotation.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.scan_correction_y_rotation.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.scan_correction_y_rotation.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.scan_correction_y_rotation.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.scan_correction_y_rotation.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.scan_correction_y_rotation.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.scan_correction_y_rotation.min', float(new_val))


class RootLuPosition_controlInstanceAttributeCurrent_pos_w(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.current_pos_w'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.current_pos_w.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.current_pos_w.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.current_pos_w.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.current_pos_w.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.current_pos_w.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.current_pos_w.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.current_pos_w.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.current_pos_w.min', float(new_val))


class RootLuPosition_controlInstanceAttributeTarget_move_pos_w(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.target_move_pos_w'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.target_move_pos_w.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.target_move_pos_w.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.target_move_pos_w.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.target_move_pos_w.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.target_move_pos_w.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.target_move_pos_w.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.target_move_pos_w.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.target_move_pos_w.min', float(new_val))


class RootLuPosition_controlInstanceAttributeCurrent_pos_x(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.current_pos_x'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.current_pos_x.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.current_pos_x.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.current_pos_x.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.current_pos_x.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.current_pos_x.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.current_pos_x.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.current_pos_x.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.current_pos_x.min', float(new_val))


class RootLuPosition_controlInstanceAttributePid_controller_settings_x(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        p_gain = 0
        i_gain = 1
        d_gain = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.pid_controller_settings_x'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.position_control.instance.attribute.pid_controller_settings_x.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.position_control.instance.attribute.pid_controller_settings_x.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.position_control.instance.attribute.pid_controller_settings_x.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.position_control.instance.attribute.pid_controller_settings_x.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.position_control.instance.attribute.pid_controller_settings_x.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.position_control.instance.attribute.pid_controller_settings_x.value_raw', new_val.value)


class RootLuPosition_controlInstanceAttributeTarget_move_pos_x(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.target_move_pos_x'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.target_move_pos_x.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.target_move_pos_x.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.target_move_pos_x.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.target_move_pos_x.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.target_move_pos_x.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.target_move_pos_x.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.target_move_pos_x.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.target_move_pos_x.min', float(new_val))


class RootLuPosition_controlInstanceAttributeTarget_move_pos_y(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.target_move_pos_y'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.target_move_pos_y.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.target_move_pos_y.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.target_move_pos_y.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.target_move_pos_y.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.target_move_pos_y.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.target_move_pos_y.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.target_move_pos_y.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.target_move_pos_y.min', float(new_val))


class RootLuPosition_controlInstanceAttributeAxis_scale_xy(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.axis_scale_xy'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.axis_scale_xy.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.axis_scale_xy.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.axis_scale_xy.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.axis_scale_xy.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.axis_scale_xy.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.axis_scale_xy.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.axis_scale_xy.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.axis_scale_xy.min', float(new_val))


class RootLuPosition_controlInstanceAttributeAxis_scale_z(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.axis_scale_z'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.axis_scale_z.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.axis_scale_z.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.axis_scale_z.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.axis_scale_z.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.axis_scale_z.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.axis_scale_z.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.axis_scale_z.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.axis_scale_z.min', float(new_val))


class RootLuPosition_controlInstanceAttributeTarget_move_pos_z(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.target_move_pos_z'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.target_move_pos_z.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.target_move_pos_z.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.target_move_pos_z.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.target_move_pos_z.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.target_move_pos_z.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.target_move_pos_z.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.target_move_pos_z.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.target_move_pos_z.min', float(new_val))


class RootLuPosition_controlInstanceAttributeTarget_scan_axis_range_select(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        reduced_range = 2
        full_range = 1
        off = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.target_scan_axis_range_select'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.position_control.instance.attribute.target_scan_axis_range_select.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.position_control.instance.attribute.target_scan_axis_range_select.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.position_control.instance.attribute.target_scan_axis_range_select.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.position_control.instance.attribute.target_scan_axis_range_select.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.position_control.instance.attribute.target_scan_axis_range_select.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.position_control.instance.attribute.target_scan_axis_range_select.value_raw', new_val.value)


class RootLuPosition_controlInstanceAttributeCurrent_scan_axis_range_select(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        reduced_range = 2
        full_range = 1
        off = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.current_scan_axis_range_select'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.position_control.instance.attribute.current_scan_axis_range_select.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.position_control.instance.attribute.current_scan_axis_range_select.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.position_control.instance.attribute.current_scan_axis_range_select.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.position_control.instance.attribute.current_scan_axis_range_select.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.position_control.instance.attribute.current_scan_axis_range_select.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.position_control.instance.attribute.current_scan_axis_range_select.value_raw', new_val.value)


class RootLuPosition_controlInstanceAttributeTarget_moving_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.target_moving_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.target_moving_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.target_moving_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.target_moving_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.target_moving_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.target_moving_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.target_moving_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.target_moving_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.target_moving_time.min', float(new_val))


class RootLuPosition_controlInstanceAttributePid_controller_settings_y(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        p_gain = 0
        i_gain = 1
        d_gain = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.pid_controller_settings_y'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.position_control.instance.attribute.pid_controller_settings_y.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.position_control.instance.attribute.pid_controller_settings_y.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.position_control.instance.attribute.pid_controller_settings_y.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.position_control.instance.attribute.pid_controller_settings_y.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.position_control.instance.attribute.pid_controller_settings_y.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.position_control.instance.attribute.pid_controller_settings_y.value_raw', new_val.value)


class RootLuPosition_controlInstanceAttributeXy_closed_loop_speed_keep_pos(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.xy_closed_loop_speed_keep_pos'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.xy_closed_loop_speed_keep_pos.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.xy_closed_loop_speed_keep_pos.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.xy_closed_loop_speed_keep_pos.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.xy_closed_loop_speed_keep_pos.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.xy_closed_loop_speed_keep_pos.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.xy_closed_loop_speed_keep_pos.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.xy_closed_loop_speed_keep_pos.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.xy_closed_loop_speed_keep_pos.min', float(new_val))


class RootLuPosition_controlInstanceAttributeXy_closed_loop_speed_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        moving = 0
        keep_position = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.xy_closed_loop_speed_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.position_control.instance.attribute.xy_closed_loop_speed_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.position_control.instance.attribute.xy_closed_loop_speed_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.position_control.instance.attribute.xy_closed_loop_speed_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.position_control.instance.attribute.xy_closed_loop_speed_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.position_control.instance.attribute.xy_closed_loop_speed_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.position_control.instance.attribute.xy_closed_loop_speed_mode.value_raw', new_val.value)


class RootLuPosition_controlInstanceAttributeLast_scan_axis_range_select_switch_result(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        interlock_open_hv_cable = 3
        interlock_open_cx_cable = 2
        feature_not_supported = 4
        ok = 0
        interlock_open_user = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.last_scan_axis_range_select_switch_result'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.position_control.instance.attribute.last_scan_axis_range_select_switch_result.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.position_control.instance.attribute.last_scan_axis_range_select_switch_result.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.position_control.instance.attribute.last_scan_axis_range_select_switch_result.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.position_control.instance.attribute.last_scan_axis_range_select_switch_result.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.position_control.instance.attribute.last_scan_axis_range_select_switch_result.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.position_control.instance.attribute.last_scan_axis_range_select_switch_result.value_raw', new_val.value)


class RootLuPosition_controlInstanceAttributeScan_correction_x_rotation(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.scan_correction_x_rotation'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.scan_correction_x_rotation.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.scan_correction_x_rotation.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.scan_correction_x_rotation.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.scan_correction_x_rotation.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.scan_correction_x_rotation.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.scan_correction_x_rotation.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.scan_correction_x_rotation.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.scan_correction_x_rotation.min', float(new_val))


class RootLuPosition_controlInstanceAttributeXy_closed_loop_speed_moving(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.xy_closed_loop_speed_moving'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.xy_closed_loop_speed_moving.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.xy_closed_loop_speed_moving.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.xy_closed_loop_speed_moving.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.xy_closed_loop_speed_moving.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.xy_closed_loop_speed_moving.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.xy_closed_loop_speed_moving.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.xy_closed_loop_speed_moving.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.xy_closed_loop_speed_moving.min', float(new_val))


class RootLuPosition_controlInstanceAttributeTarget_moving_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.target_moving_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.target_moving_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.target_moving_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.target_moving_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.target_moving_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.target_moving_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.target_moving_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.target_moving_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.target_moving_speed.min', float(new_val))


class RootLuPosition_controlInstanceAttributeRamp_count(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute.ramp_count'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.ramp_count.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.ramp_count.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.position_control.instance.attribute.ramp_count.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.position_control.instance.attribute.ramp_count.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.ramp_count.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.ramp_count.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.position_control.instance.attribute.ramp_count.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.position_control.instance.attribute.ramp_count.min', float(new_val))


class RootLuPosition_controlInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance.attribute'
        self.ramp_count = RootLuPosition_controlInstanceAttributeRamp_count(self._context)
        self.target_moving_speed = RootLuPosition_controlInstanceAttributeTarget_moving_speed(self._context)
        self.xy_closed_loop_speed_moving = RootLuPosition_controlInstanceAttributeXy_closed_loop_speed_moving(self._context)
        self.scan_correction_x_rotation = RootLuPosition_controlInstanceAttributeScan_correction_x_rotation(self._context)
        self.last_scan_axis_range_select_switch_result = RootLuPosition_controlInstanceAttributeLast_scan_axis_range_select_switch_result(self._context)
        self.xy_closed_loop_speed_mode = RootLuPosition_controlInstanceAttributeXy_closed_loop_speed_mode(self._context)
        self.xy_closed_loop_speed_keep_pos = RootLuPosition_controlInstanceAttributeXy_closed_loop_speed_keep_pos(self._context)
        self.pid_controller_settings_y = RootLuPosition_controlInstanceAttributePid_controller_settings_y(self._context)
        self.target_moving_time = RootLuPosition_controlInstanceAttributeTarget_moving_time(self._context)
        self.current_scan_axis_range_select = RootLuPosition_controlInstanceAttributeCurrent_scan_axis_range_select(self._context)
        self.target_scan_axis_range_select = RootLuPosition_controlInstanceAttributeTarget_scan_axis_range_select(self._context)
        self.target_move_pos_z = RootLuPosition_controlInstanceAttributeTarget_move_pos_z(self._context)
        self.axis_scale_z = RootLuPosition_controlInstanceAttributeAxis_scale_z(self._context)
        self.axis_scale_xy = RootLuPosition_controlInstanceAttributeAxis_scale_xy(self._context)
        self.target_move_pos_y = RootLuPosition_controlInstanceAttributeTarget_move_pos_y(self._context)
        self.target_move_pos_x = RootLuPosition_controlInstanceAttributeTarget_move_pos_x(self._context)
        self.pid_controller_settings_x = RootLuPosition_controlInstanceAttributePid_controller_settings_x(self._context)
        self.current_pos_x = RootLuPosition_controlInstanceAttributeCurrent_pos_x(self._context)
        self.target_move_pos_w = RootLuPosition_controlInstanceAttributeTarget_move_pos_w(self._context)
        self.current_pos_w = RootLuPosition_controlInstanceAttributeCurrent_pos_w(self._context)
        self.scan_correction_y_rotation = RootLuPosition_controlInstanceAttributeScan_correction_y_rotation(self._context)
        self.ramp_time = RootLuPosition_controlInstanceAttributeRamp_time(self._context)
        self.axis_scale_zlv = RootLuPosition_controlInstanceAttributeAxis_scale_zlv(self._context)
        self.last_move_stop_event = RootLuPosition_controlInstanceAttributeLast_move_stop_event(self._context)
        self.is_xy_closed_loop_possible = RootLuPosition_controlInstanceAttributeIs_xy_closed_loop_possible(self._context)
        self.current_pos_z = RootLuPosition_controlInstanceAttributeCurrent_pos_z(self._context)
        self.enable_xy_closed_loop = RootLuPosition_controlInstanceAttributeEnable_xy_closed_loop(self._context)
        self.current_pos_y = RootLuPosition_controlInstanceAttributeCurrent_pos_y(self._context)
        self.axis_scale_xylv = RootLuPosition_controlInstanceAttributeAxis_scale_xylv(self._context)


class RootLuPosition_controlInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control.instance'
        self.attribute = RootLuPosition_controlInstanceAttribute(self._context)
        self.trigger = RootLuPosition_controlInstanceTrigger(self._context)
        self.busy = RootLuPosition_controlInstanceBusy(self._context)


class RootLuPosition_control(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.position_control'
        self.instance = RootLuPosition_controlInstance(self._context)


class RootLuRamp_generatorAlternate_zBusy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.alternate_z.busy'

    @property
    def is_moving(self) -> bool:
        return bool(self._context.call('root.lu.ramp_generator.alternate_z.busy.is_moving'))


class RootLuRamp_generatorAlternate_zTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.alternate_z.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.ramp_generator.alternate_z.trigger.stop')

    def prepare(self) -> None:
        return self._context.call('root.lu.ramp_generator.alternate_z.trigger.prepare')

    def abort(self) -> None:
        return self._context.call('root.lu.ramp_generator.alternate_z.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.ramp_generator.alternate_z.trigger.start')


class RootLuRamp_generatorAlternate_zAttributeMoving_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        fix_time = 0
        fix_speed = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.alternate_z.attribute.moving_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.alternate_z.attribute.moving_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.moving_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.alternate_z.attribute.moving_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.moving_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.alternate_z.attribute.moving_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.moving_mode.value_raw', new_val.value)


class RootLuRamp_generatorAlternate_zAttributeStatus(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        reached_lower_limit = 2
        is_moving = 0
        reached_upper_limit = 3
        stopped_by_external_event = 4
        reached_endposition = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.alternate_z.attribute.status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.alternate_z.attribute.status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.alternate_z.attribute.status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.alternate_z.attribute.status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.status.value_raw', new_val.value)


class RootLuRamp_generatorAlternate_zAttributeEnd_value_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        move_relative = 1
        move_to_absolute = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.alternate_z.attribute.end_value_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.alternate_z.attribute.end_value_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.end_value_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.alternate_z.attribute.end_value_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.end_value_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.alternate_z.attribute.end_value_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.end_value_mode.value_raw', new_val.value)


class RootLuRamp_generatorAlternate_zAttributeCurrent_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.alternate_z.attribute.current_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.current_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.current_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.alternate_z.attribute.current_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.current_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.current_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.current_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.current_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.current_value.min', float(new_val))


class RootLuRamp_generatorAlternate_zAttributeEnd_value_absolute(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.alternate_z.attribute.end_value_absolute'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.end_value_absolute.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.end_value_absolute.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.alternate_z.attribute.end_value_absolute.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.end_value_absolute.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.end_value_absolute.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.end_value_absolute.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.end_value_absolute.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.end_value_absolute.min', float(new_val))


class RootLuRamp_generatorAlternate_zAttributeUpper_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.alternate_z.attribute.upper_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.upper_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.upper_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.alternate_z.attribute.upper_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.upper_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.upper_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.upper_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.upper_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.upper_limit.min', float(new_val))


class RootLuRamp_generatorAlternate_zAttributeLower_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.alternate_z.attribute.lower_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.lower_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.lower_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.alternate_z.attribute.lower_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.lower_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.lower_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.lower_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.lower_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.lower_limit.min', float(new_val))


class RootLuRamp_generatorAlternate_zAttributeMoving_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.alternate_z.attribute.moving_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.moving_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.moving_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.alternate_z.attribute.moving_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.moving_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.moving_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.moving_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.moving_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.moving_time.min', float(new_val))


class RootLuRamp_generatorAlternate_zAttributeEnd_value_relative(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.alternate_z.attribute.end_value_relative'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.end_value_relative.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.end_value_relative.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.alternate_z.attribute.end_value_relative.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.end_value_relative.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.end_value_relative.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.end_value_relative.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.end_value_relative.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.end_value_relative.min', float(new_val))


class RootLuRamp_generatorAlternate_zAttributeMoving_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.alternate_z.attribute.moving_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.moving_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.moving_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.alternate_z.attribute.moving_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.moving_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.moving_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.moving_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.alternate_z.attribute.moving_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.alternate_z.attribute.moving_speed.min', float(new_val))


class RootLuRamp_generatorAlternate_zAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.alternate_z.attribute'
        self.moving_speed = RootLuRamp_generatorAlternate_zAttributeMoving_speed(self._context)
        self.end_value_relative = RootLuRamp_generatorAlternate_zAttributeEnd_value_relative(self._context)
        self.moving_time = RootLuRamp_generatorAlternate_zAttributeMoving_time(self._context)
        self.lower_limit = RootLuRamp_generatorAlternate_zAttributeLower_limit(self._context)
        self.upper_limit = RootLuRamp_generatorAlternate_zAttributeUpper_limit(self._context)
        self.end_value_absolute = RootLuRamp_generatorAlternate_zAttributeEnd_value_absolute(self._context)
        self.current_value = RootLuRamp_generatorAlternate_zAttributeCurrent_value(self._context)
        self.end_value_mode = RootLuRamp_generatorAlternate_zAttributeEnd_value_mode(self._context)
        self.status = RootLuRamp_generatorAlternate_zAttributeStatus(self._context)
        self.moving_mode = RootLuRamp_generatorAlternate_zAttributeMoving_mode(self._context)


class RootLuRamp_generatorAlternate_z(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.alternate_z'
        self.attribute = RootLuRamp_generatorAlternate_zAttribute(self._context)
        self.trigger = RootLuRamp_generatorAlternate_zTrigger(self._context)
        self.busy = RootLuRamp_generatorAlternate_zBusy(self._context)


class RootLuRamp_generatorPosition_wBusy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_w.busy'

    @property
    def is_moving(self) -> bool:
        return bool(self._context.call('root.lu.ramp_generator.position_w.busy.is_moving'))


class RootLuRamp_generatorPosition_wTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_w.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.ramp_generator.position_w.trigger.stop')

    def prepare(self) -> None:
        return self._context.call('root.lu.ramp_generator.position_w.trigger.prepare')

    def abort(self) -> None:
        return self._context.call('root.lu.ramp_generator.position_w.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.ramp_generator.position_w.trigger.start')


class RootLuRamp_generatorPosition_wAttributeMoving_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        fix_time = 0
        fix_speed = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_w.attribute.moving_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.position_w.attribute.moving_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.position_w.attribute.moving_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.position_w.attribute.moving_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.position_w.attribute.moving_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.position_w.attribute.moving_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.position_w.attribute.moving_mode.value_raw', new_val.value)


class RootLuRamp_generatorPosition_wAttributeStatus(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        reached_lower_limit = 2
        is_moving = 0
        reached_upper_limit = 3
        stopped_by_external_event = 4
        reached_endposition = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_w.attribute.status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.position_w.attribute.status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.position_w.attribute.status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.position_w.attribute.status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.position_w.attribute.status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.position_w.attribute.status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.position_w.attribute.status.value_raw', new_val.value)


class RootLuRamp_generatorPosition_wAttributeEnd_value_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        move_relative = 1
        move_to_absolute = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_w.attribute.end_value_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.position_w.attribute.end_value_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.position_w.attribute.end_value_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.position_w.attribute.end_value_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.position_w.attribute.end_value_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.position_w.attribute.end_value_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.position_w.attribute.end_value_mode.value_raw', new_val.value)


class RootLuRamp_generatorPosition_wAttributeCurrent_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_w.attribute.current_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.current_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.current_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_w.attribute.current_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_w.attribute.current_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.current_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.current_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.current_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.current_value.min', float(new_val))


class RootLuRamp_generatorPosition_wAttributeEnd_value_absolute(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_w.attribute.end_value_absolute'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.end_value_absolute.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.end_value_absolute.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_w.attribute.end_value_absolute.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_w.attribute.end_value_absolute.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.end_value_absolute.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.end_value_absolute.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.end_value_absolute.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.end_value_absolute.min', float(new_val))


class RootLuRamp_generatorPosition_wAttributeUpper_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_w.attribute.upper_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.upper_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.upper_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_w.attribute.upper_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_w.attribute.upper_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.upper_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.upper_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.upper_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.upper_limit.min', float(new_val))


class RootLuRamp_generatorPosition_wAttributeLower_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_w.attribute.lower_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.lower_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.lower_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_w.attribute.lower_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_w.attribute.lower_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.lower_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.lower_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.lower_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.lower_limit.min', float(new_val))


class RootLuRamp_generatorPosition_wAttributeMoving_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_w.attribute.moving_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.moving_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.moving_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_w.attribute.moving_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_w.attribute.moving_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.moving_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.moving_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.moving_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.moving_time.min', float(new_val))


class RootLuRamp_generatorPosition_wAttributeEnd_value_relative(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_w.attribute.end_value_relative'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.end_value_relative.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.end_value_relative.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_w.attribute.end_value_relative.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_w.attribute.end_value_relative.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.end_value_relative.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.end_value_relative.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.end_value_relative.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.end_value_relative.min', float(new_val))


class RootLuRamp_generatorPosition_wAttributeMoving_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_w.attribute.moving_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.moving_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.moving_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_w.attribute.moving_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_w.attribute.moving_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.moving_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.moving_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_w.attribute.moving_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_w.attribute.moving_speed.min', float(new_val))


class RootLuRamp_generatorPosition_wAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_w.attribute'
        self.moving_speed = RootLuRamp_generatorPosition_wAttributeMoving_speed(self._context)
        self.end_value_relative = RootLuRamp_generatorPosition_wAttributeEnd_value_relative(self._context)
        self.moving_time = RootLuRamp_generatorPosition_wAttributeMoving_time(self._context)
        self.lower_limit = RootLuRamp_generatorPosition_wAttributeLower_limit(self._context)
        self.upper_limit = RootLuRamp_generatorPosition_wAttributeUpper_limit(self._context)
        self.end_value_absolute = RootLuRamp_generatorPosition_wAttributeEnd_value_absolute(self._context)
        self.current_value = RootLuRamp_generatorPosition_wAttributeCurrent_value(self._context)
        self.end_value_mode = RootLuRamp_generatorPosition_wAttributeEnd_value_mode(self._context)
        self.status = RootLuRamp_generatorPosition_wAttributeStatus(self._context)
        self.moving_mode = RootLuRamp_generatorPosition_wAttributeMoving_mode(self._context)


class RootLuRamp_generatorPosition_w(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_w'
        self.attribute = RootLuRamp_generatorPosition_wAttribute(self._context)
        self.trigger = RootLuRamp_generatorPosition_wTrigger(self._context)
        self.busy = RootLuRamp_generatorPosition_wBusy(self._context)


class RootLuRamp_generatorCtrl_zBusy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.ctrl_z.busy'

    @property
    def is_moving(self) -> bool:
        return bool(self._context.call('root.lu.ramp_generator.ctrl_z.busy.is_moving'))


class RootLuRamp_generatorCtrl_zTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.ctrl_z.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.ramp_generator.ctrl_z.trigger.stop')

    def prepare(self) -> None:
        return self._context.call('root.lu.ramp_generator.ctrl_z.trigger.prepare')

    def abort(self) -> None:
        return self._context.call('root.lu.ramp_generator.ctrl_z.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.ramp_generator.ctrl_z.trigger.start')


class RootLuRamp_generatorCtrl_zAttributeMoving_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        fix_time = 0
        fix_speed = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.ctrl_z.attribute.moving_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.moving_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.moving_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.moving_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.moving_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.moving_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.moving_mode.value_raw', new_val.value)


class RootLuRamp_generatorCtrl_zAttributeStatus(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        reached_lower_limit = 2
        is_moving = 0
        reached_upper_limit = 3
        stopped_by_external_event = 4
        reached_endposition = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.ctrl_z.attribute.status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.status.value_raw', new_val.value)


class RootLuRamp_generatorCtrl_zAttributeEnd_value_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        move_relative = 1
        move_to_absolute = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.ctrl_z.attribute.end_value_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.end_value_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.end_value_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.end_value_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.end_value_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.end_value_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.end_value_mode.value_raw', new_val.value)


class RootLuRamp_generatorCtrl_zAttributeCurrent_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.ctrl_z.attribute.current_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.current_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.current_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.current_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.current_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.current_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.current_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.current_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.current_value.min', float(new_val))


class RootLuRamp_generatorCtrl_zAttributeEnd_value_absolute(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.ctrl_z.attribute.end_value_absolute'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.end_value_absolute.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.end_value_absolute.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.end_value_absolute.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.end_value_absolute.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.end_value_absolute.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.end_value_absolute.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.end_value_absolute.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.end_value_absolute.min', float(new_val))


class RootLuRamp_generatorCtrl_zAttributeUpper_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.ctrl_z.attribute.upper_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.upper_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.upper_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.upper_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.upper_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.upper_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.upper_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.upper_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.upper_limit.min', float(new_val))


class RootLuRamp_generatorCtrl_zAttributeLower_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.ctrl_z.attribute.lower_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.lower_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.lower_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.lower_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.lower_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.lower_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.lower_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.lower_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.lower_limit.min', float(new_val))


class RootLuRamp_generatorCtrl_zAttributeMoving_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.ctrl_z.attribute.moving_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.moving_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.moving_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.moving_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.moving_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.moving_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.moving_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.moving_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.moving_time.min', float(new_val))


class RootLuRamp_generatorCtrl_zAttributeEnd_value_relative(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.ctrl_z.attribute.end_value_relative'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.end_value_relative.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.end_value_relative.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.end_value_relative.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.end_value_relative.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.end_value_relative.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.end_value_relative.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.end_value_relative.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.end_value_relative.min', float(new_val))


class RootLuRamp_generatorCtrl_zAttributeMoving_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.ctrl_z.attribute.moving_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.moving_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.moving_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.moving_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.moving_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.moving_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.moving_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.ctrl_z.attribute.moving_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.ctrl_z.attribute.moving_speed.min', float(new_val))


class RootLuRamp_generatorCtrl_zAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.ctrl_z.attribute'
        self.moving_speed = RootLuRamp_generatorCtrl_zAttributeMoving_speed(self._context)
        self.end_value_relative = RootLuRamp_generatorCtrl_zAttributeEnd_value_relative(self._context)
        self.moving_time = RootLuRamp_generatorCtrl_zAttributeMoving_time(self._context)
        self.lower_limit = RootLuRamp_generatorCtrl_zAttributeLower_limit(self._context)
        self.upper_limit = RootLuRamp_generatorCtrl_zAttributeUpper_limit(self._context)
        self.end_value_absolute = RootLuRamp_generatorCtrl_zAttributeEnd_value_absolute(self._context)
        self.current_value = RootLuRamp_generatorCtrl_zAttributeCurrent_value(self._context)
        self.end_value_mode = RootLuRamp_generatorCtrl_zAttributeEnd_value_mode(self._context)
        self.status = RootLuRamp_generatorCtrl_zAttributeStatus(self._context)
        self.moving_mode = RootLuRamp_generatorCtrl_zAttributeMoving_mode(self._context)


class RootLuRamp_generatorCtrl_z(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.ctrl_z'
        self.attribute = RootLuRamp_generatorCtrl_zAttribute(self._context)
        self.trigger = RootLuRamp_generatorCtrl_zTrigger(self._context)
        self.busy = RootLuRamp_generatorCtrl_zBusy(self._context)


class RootLuRamp_generatorPosition_yBusy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_y.busy'

    @property
    def is_moving(self) -> bool:
        return bool(self._context.call('root.lu.ramp_generator.position_y.busy.is_moving'))


class RootLuRamp_generatorPosition_yTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_y.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.ramp_generator.position_y.trigger.stop')

    def prepare(self) -> None:
        return self._context.call('root.lu.ramp_generator.position_y.trigger.prepare')

    def abort(self) -> None:
        return self._context.call('root.lu.ramp_generator.position_y.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.ramp_generator.position_y.trigger.start')


class RootLuRamp_generatorPosition_yAttributeMoving_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        fix_time = 0
        fix_speed = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_y.attribute.moving_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.position_y.attribute.moving_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.position_y.attribute.moving_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.position_y.attribute.moving_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.position_y.attribute.moving_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.position_y.attribute.moving_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.position_y.attribute.moving_mode.value_raw', new_val.value)


class RootLuRamp_generatorPosition_yAttributeStatus(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        reached_lower_limit = 2
        is_moving = 0
        reached_upper_limit = 3
        stopped_by_external_event = 4
        reached_endposition = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_y.attribute.status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.position_y.attribute.status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.position_y.attribute.status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.position_y.attribute.status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.position_y.attribute.status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.position_y.attribute.status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.position_y.attribute.status.value_raw', new_val.value)


class RootLuRamp_generatorPosition_yAttributeEnd_value_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        move_relative = 1
        move_to_absolute = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_y.attribute.end_value_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.position_y.attribute.end_value_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.position_y.attribute.end_value_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.position_y.attribute.end_value_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.position_y.attribute.end_value_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.position_y.attribute.end_value_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.position_y.attribute.end_value_mode.value_raw', new_val.value)


class RootLuRamp_generatorPosition_yAttributeCurrent_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_y.attribute.current_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.current_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.current_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_y.attribute.current_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_y.attribute.current_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.current_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.current_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.current_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.current_value.min', float(new_val))


class RootLuRamp_generatorPosition_yAttributeEnd_value_absolute(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_y.attribute.end_value_absolute'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.end_value_absolute.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.end_value_absolute.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_y.attribute.end_value_absolute.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_y.attribute.end_value_absolute.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.end_value_absolute.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.end_value_absolute.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.end_value_absolute.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.end_value_absolute.min', float(new_val))


class RootLuRamp_generatorPosition_yAttributeUpper_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_y.attribute.upper_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.upper_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.upper_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_y.attribute.upper_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_y.attribute.upper_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.upper_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.upper_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.upper_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.upper_limit.min', float(new_val))


class RootLuRamp_generatorPosition_yAttributeLower_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_y.attribute.lower_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.lower_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.lower_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_y.attribute.lower_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_y.attribute.lower_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.lower_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.lower_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.lower_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.lower_limit.min', float(new_val))


class RootLuRamp_generatorPosition_yAttributeMoving_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_y.attribute.moving_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.moving_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.moving_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_y.attribute.moving_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_y.attribute.moving_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.moving_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.moving_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.moving_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.moving_time.min', float(new_val))


class RootLuRamp_generatorPosition_yAttributeEnd_value_relative(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_y.attribute.end_value_relative'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.end_value_relative.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.end_value_relative.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_y.attribute.end_value_relative.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_y.attribute.end_value_relative.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.end_value_relative.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.end_value_relative.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.end_value_relative.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.end_value_relative.min', float(new_val))


class RootLuRamp_generatorPosition_yAttributeMoving_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_y.attribute.moving_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.moving_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.moving_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_y.attribute.moving_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_y.attribute.moving_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.moving_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.moving_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_y.attribute.moving_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_y.attribute.moving_speed.min', float(new_val))


class RootLuRamp_generatorPosition_yAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_y.attribute'
        self.moving_speed = RootLuRamp_generatorPosition_yAttributeMoving_speed(self._context)
        self.end_value_relative = RootLuRamp_generatorPosition_yAttributeEnd_value_relative(self._context)
        self.moving_time = RootLuRamp_generatorPosition_yAttributeMoving_time(self._context)
        self.lower_limit = RootLuRamp_generatorPosition_yAttributeLower_limit(self._context)
        self.upper_limit = RootLuRamp_generatorPosition_yAttributeUpper_limit(self._context)
        self.end_value_absolute = RootLuRamp_generatorPosition_yAttributeEnd_value_absolute(self._context)
        self.current_value = RootLuRamp_generatorPosition_yAttributeCurrent_value(self._context)
        self.end_value_mode = RootLuRamp_generatorPosition_yAttributeEnd_value_mode(self._context)
        self.status = RootLuRamp_generatorPosition_yAttributeStatus(self._context)
        self.moving_mode = RootLuRamp_generatorPosition_yAttributeMoving_mode(self._context)


class RootLuRamp_generatorPosition_y(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_y'
        self.attribute = RootLuRamp_generatorPosition_yAttribute(self._context)
        self.trigger = RootLuRamp_generatorPosition_yTrigger(self._context)
        self.busy = RootLuRamp_generatorPosition_yBusy(self._context)


class RootLuRamp_generatorPosition_xBusy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_x.busy'

    @property
    def is_moving(self) -> bool:
        return bool(self._context.call('root.lu.ramp_generator.position_x.busy.is_moving'))


class RootLuRamp_generatorPosition_xTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_x.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.ramp_generator.position_x.trigger.stop')

    def prepare(self) -> None:
        return self._context.call('root.lu.ramp_generator.position_x.trigger.prepare')

    def abort(self) -> None:
        return self._context.call('root.lu.ramp_generator.position_x.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.ramp_generator.position_x.trigger.start')


class RootLuRamp_generatorPosition_xAttributeMoving_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        fix_time = 0
        fix_speed = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_x.attribute.moving_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.position_x.attribute.moving_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.position_x.attribute.moving_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.position_x.attribute.moving_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.position_x.attribute.moving_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.position_x.attribute.moving_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.position_x.attribute.moving_mode.value_raw', new_val.value)


class RootLuRamp_generatorPosition_xAttributeStatus(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        reached_lower_limit = 2
        is_moving = 0
        reached_upper_limit = 3
        stopped_by_external_event = 4
        reached_endposition = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_x.attribute.status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.position_x.attribute.status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.position_x.attribute.status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.position_x.attribute.status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.position_x.attribute.status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.position_x.attribute.status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.position_x.attribute.status.value_raw', new_val.value)


class RootLuRamp_generatorPosition_xAttributeEnd_value_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        move_relative = 1
        move_to_absolute = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_x.attribute.end_value_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.position_x.attribute.end_value_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.position_x.attribute.end_value_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.position_x.attribute.end_value_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.position_x.attribute.end_value_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.position_x.attribute.end_value_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.position_x.attribute.end_value_mode.value_raw', new_val.value)


class RootLuRamp_generatorPosition_xAttributeCurrent_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_x.attribute.current_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.current_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.current_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_x.attribute.current_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_x.attribute.current_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.current_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.current_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.current_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.current_value.min', float(new_val))


class RootLuRamp_generatorPosition_xAttributeEnd_value_absolute(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_x.attribute.end_value_absolute'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.end_value_absolute.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.end_value_absolute.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_x.attribute.end_value_absolute.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_x.attribute.end_value_absolute.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.end_value_absolute.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.end_value_absolute.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.end_value_absolute.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.end_value_absolute.min', float(new_val))


class RootLuRamp_generatorPosition_xAttributeUpper_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_x.attribute.upper_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.upper_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.upper_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_x.attribute.upper_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_x.attribute.upper_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.upper_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.upper_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.upper_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.upper_limit.min', float(new_val))


class RootLuRamp_generatorPosition_xAttributeLower_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_x.attribute.lower_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.lower_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.lower_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_x.attribute.lower_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_x.attribute.lower_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.lower_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.lower_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.lower_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.lower_limit.min', float(new_val))


class RootLuRamp_generatorPosition_xAttributeMoving_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_x.attribute.moving_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.moving_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.moving_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_x.attribute.moving_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_x.attribute.moving_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.moving_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.moving_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.moving_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.moving_time.min', float(new_val))


class RootLuRamp_generatorPosition_xAttributeEnd_value_relative(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_x.attribute.end_value_relative'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.end_value_relative.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.end_value_relative.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_x.attribute.end_value_relative.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_x.attribute.end_value_relative.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.end_value_relative.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.end_value_relative.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.end_value_relative.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.end_value_relative.min', float(new_val))


class RootLuRamp_generatorPosition_xAttributeMoving_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_x.attribute.moving_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.moving_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.moving_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.position_x.attribute.moving_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.position_x.attribute.moving_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.moving_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.moving_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.position_x.attribute.moving_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.position_x.attribute.moving_speed.min', float(new_val))


class RootLuRamp_generatorPosition_xAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_x.attribute'
        self.moving_speed = RootLuRamp_generatorPosition_xAttributeMoving_speed(self._context)
        self.end_value_relative = RootLuRamp_generatorPosition_xAttributeEnd_value_relative(self._context)
        self.moving_time = RootLuRamp_generatorPosition_xAttributeMoving_time(self._context)
        self.lower_limit = RootLuRamp_generatorPosition_xAttributeLower_limit(self._context)
        self.upper_limit = RootLuRamp_generatorPosition_xAttributeUpper_limit(self._context)
        self.end_value_absolute = RootLuRamp_generatorPosition_xAttributeEnd_value_absolute(self._context)
        self.current_value = RootLuRamp_generatorPosition_xAttributeCurrent_value(self._context)
        self.end_value_mode = RootLuRamp_generatorPosition_xAttributeEnd_value_mode(self._context)
        self.status = RootLuRamp_generatorPosition_xAttributeStatus(self._context)
        self.moving_mode = RootLuRamp_generatorPosition_xAttributeMoving_mode(self._context)


class RootLuRamp_generatorPosition_x(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.position_x'
        self.attribute = RootLuRamp_generatorPosition_xAttribute(self._context)
        self.trigger = RootLuRamp_generatorPosition_xTrigger(self._context)
        self.busy = RootLuRamp_generatorPosition_xBusy(self._context)


class RootLuRamp_generatorPlane_zBusy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.plane_z.busy'

    @property
    def is_moving(self) -> bool:
        return bool(self._context.call('root.lu.ramp_generator.plane_z.busy.is_moving'))


class RootLuRamp_generatorPlane_zTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.plane_z.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.ramp_generator.plane_z.trigger.stop')

    def prepare(self) -> None:
        return self._context.call('root.lu.ramp_generator.plane_z.trigger.prepare')

    def abort(self) -> None:
        return self._context.call('root.lu.ramp_generator.plane_z.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.ramp_generator.plane_z.trigger.start')


class RootLuRamp_generatorPlane_zAttributeMoving_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        fix_time = 0
        fix_speed = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.plane_z.attribute.moving_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.plane_z.attribute.moving_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.moving_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.plane_z.attribute.moving_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.moving_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.plane_z.attribute.moving_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.moving_mode.value_raw', new_val.value)


class RootLuRamp_generatorPlane_zAttributeStatus(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        reached_lower_limit = 2
        is_moving = 0
        reached_upper_limit = 3
        stopped_by_external_event = 4
        reached_endposition = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.plane_z.attribute.status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.plane_z.attribute.status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.plane_z.attribute.status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.plane_z.attribute.status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.status.value_raw', new_val.value)


class RootLuRamp_generatorPlane_zAttributeEnd_value_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        move_relative = 1
        move_to_absolute = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.plane_z.attribute.end_value_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.plane_z.attribute.end_value_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.end_value_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.plane_z.attribute.end_value_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.end_value_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.plane_z.attribute.end_value_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.end_value_mode.value_raw', new_val.value)


class RootLuRamp_generatorPlane_zAttributeCurrent_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.plane_z.attribute.current_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.current_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.current_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.plane_z.attribute.current_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.current_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.current_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.current_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.current_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.current_value.min', float(new_val))


class RootLuRamp_generatorPlane_zAttributeEnd_value_absolute(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.plane_z.attribute.end_value_absolute'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.end_value_absolute.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.end_value_absolute.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.plane_z.attribute.end_value_absolute.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.end_value_absolute.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.end_value_absolute.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.end_value_absolute.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.end_value_absolute.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.end_value_absolute.min', float(new_val))


class RootLuRamp_generatorPlane_zAttributeUpper_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.plane_z.attribute.upper_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.upper_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.upper_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.plane_z.attribute.upper_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.upper_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.upper_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.upper_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.upper_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.upper_limit.min', float(new_val))


class RootLuRamp_generatorPlane_zAttributeLower_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.plane_z.attribute.lower_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.lower_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.lower_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.plane_z.attribute.lower_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.lower_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.lower_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.lower_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.lower_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.lower_limit.min', float(new_val))


class RootLuRamp_generatorPlane_zAttributeMoving_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.plane_z.attribute.moving_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.moving_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.moving_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.plane_z.attribute.moving_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.moving_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.moving_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.moving_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.moving_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.moving_time.min', float(new_val))


class RootLuRamp_generatorPlane_zAttributeEnd_value_relative(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.plane_z.attribute.end_value_relative'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.end_value_relative.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.end_value_relative.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.plane_z.attribute.end_value_relative.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.end_value_relative.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.end_value_relative.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.end_value_relative.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.end_value_relative.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.end_value_relative.min', float(new_val))


class RootLuRamp_generatorPlane_zAttributeMoving_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.plane_z.attribute.moving_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.moving_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.moving_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.plane_z.attribute.moving_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.moving_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.moving_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.moving_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.plane_z.attribute.moving_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.plane_z.attribute.moving_speed.min', float(new_val))


class RootLuRamp_generatorPlane_zAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.plane_z.attribute'
        self.moving_speed = RootLuRamp_generatorPlane_zAttributeMoving_speed(self._context)
        self.end_value_relative = RootLuRamp_generatorPlane_zAttributeEnd_value_relative(self._context)
        self.moving_time = RootLuRamp_generatorPlane_zAttributeMoving_time(self._context)
        self.lower_limit = RootLuRamp_generatorPlane_zAttributeLower_limit(self._context)
        self.upper_limit = RootLuRamp_generatorPlane_zAttributeUpper_limit(self._context)
        self.end_value_absolute = RootLuRamp_generatorPlane_zAttributeEnd_value_absolute(self._context)
        self.current_value = RootLuRamp_generatorPlane_zAttributeCurrent_value(self._context)
        self.end_value_mode = RootLuRamp_generatorPlane_zAttributeEnd_value_mode(self._context)
        self.status = RootLuRamp_generatorPlane_zAttributeStatus(self._context)
        self.moving_mode = RootLuRamp_generatorPlane_zAttributeMoving_mode(self._context)


class RootLuRamp_generatorPlane_z(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.plane_z'
        self.attribute = RootLuRamp_generatorPlane_zAttribute(self._context)
        self.trigger = RootLuRamp_generatorPlane_zTrigger(self._context)
        self.busy = RootLuRamp_generatorPlane_zBusy(self._context)


class RootLuRamp_generatorApproachBusy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.approach.busy'

    @property
    def is_moving(self) -> bool:
        return bool(self._context.call('root.lu.ramp_generator.approach.busy.is_moving'))


class RootLuRamp_generatorApproachTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.approach.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.ramp_generator.approach.trigger.stop')

    def prepare(self) -> None:
        return self._context.call('root.lu.ramp_generator.approach.trigger.prepare')

    def abort(self) -> None:
        return self._context.call('root.lu.ramp_generator.approach.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.ramp_generator.approach.trigger.start')


class RootLuRamp_generatorApproachAttributeMoving_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        fix_time = 0
        fix_speed = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.approach.attribute.moving_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.approach.attribute.moving_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.approach.attribute.moving_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.approach.attribute.moving_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.approach.attribute.moving_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.approach.attribute.moving_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.approach.attribute.moving_mode.value_raw', new_val.value)


class RootLuRamp_generatorApproachAttributeStatus(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        reached_lower_limit = 2
        is_moving = 0
        reached_upper_limit = 3
        stopped_by_external_event = 4
        reached_endposition = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.approach.attribute.status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.approach.attribute.status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.approach.attribute.status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.approach.attribute.status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.approach.attribute.status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.approach.attribute.status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.approach.attribute.status.value_raw', new_val.value)


class RootLuRamp_generatorApproachAttributeEnd_value_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        move_relative = 1
        move_to_absolute = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.approach.attribute.end_value_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.approach.attribute.end_value_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.approach.attribute.end_value_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.approach.attribute.end_value_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.approach.attribute.end_value_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.approach.attribute.end_value_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.approach.attribute.end_value_mode.value_raw', new_val.value)


class RootLuRamp_generatorApproachAttributeCurrent_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.approach.attribute.current_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.current_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.current_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.approach.attribute.current_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.approach.attribute.current_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.current_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.current_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.current_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.current_value.min', float(new_val))


class RootLuRamp_generatorApproachAttributeEnd_value_absolute(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.approach.attribute.end_value_absolute'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.end_value_absolute.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.end_value_absolute.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.approach.attribute.end_value_absolute.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.approach.attribute.end_value_absolute.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.end_value_absolute.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.end_value_absolute.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.end_value_absolute.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.end_value_absolute.min', float(new_val))


class RootLuRamp_generatorApproachAttributeUpper_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.approach.attribute.upper_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.upper_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.upper_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.approach.attribute.upper_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.approach.attribute.upper_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.upper_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.upper_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.upper_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.upper_limit.min', float(new_val))


class RootLuRamp_generatorApproachAttributeLower_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.approach.attribute.lower_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.lower_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.lower_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.approach.attribute.lower_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.approach.attribute.lower_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.lower_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.lower_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.lower_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.lower_limit.min', float(new_val))


class RootLuRamp_generatorApproachAttributeMoving_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.approach.attribute.moving_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.moving_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.moving_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.approach.attribute.moving_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.approach.attribute.moving_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.moving_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.moving_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.moving_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.moving_time.min', float(new_val))


class RootLuRamp_generatorApproachAttributeEnd_value_relative(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.approach.attribute.end_value_relative'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.end_value_relative.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.end_value_relative.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.approach.attribute.end_value_relative.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.approach.attribute.end_value_relative.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.end_value_relative.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.end_value_relative.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.end_value_relative.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.end_value_relative.min', float(new_val))


class RootLuRamp_generatorApproachAttributeMoving_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.approach.attribute.moving_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.moving_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.moving_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.approach.attribute.moving_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.approach.attribute.moving_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.moving_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.moving_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.approach.attribute.moving_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.approach.attribute.moving_speed.min', float(new_val))


class RootLuRamp_generatorApproachAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.approach.attribute'
        self.moving_speed = RootLuRamp_generatorApproachAttributeMoving_speed(self._context)
        self.end_value_relative = RootLuRamp_generatorApproachAttributeEnd_value_relative(self._context)
        self.moving_time = RootLuRamp_generatorApproachAttributeMoving_time(self._context)
        self.lower_limit = RootLuRamp_generatorApproachAttributeLower_limit(self._context)
        self.upper_limit = RootLuRamp_generatorApproachAttributeUpper_limit(self._context)
        self.end_value_absolute = RootLuRamp_generatorApproachAttributeEnd_value_absolute(self._context)
        self.current_value = RootLuRamp_generatorApproachAttributeCurrent_value(self._context)
        self.end_value_mode = RootLuRamp_generatorApproachAttributeEnd_value_mode(self._context)
        self.status = RootLuRamp_generatorApproachAttributeStatus(self._context)
        self.moving_mode = RootLuRamp_generatorApproachAttributeMoving_mode(self._context)


class RootLuRamp_generatorApproach(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.approach'
        self.attribute = RootLuRamp_generatorApproachAttribute(self._context)
        self.trigger = RootLuRamp_generatorApproachTrigger(self._context)
        self.busy = RootLuRamp_generatorApproachBusy(self._context)


class RootLuRamp_generatorUser3Busy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user3.busy'

    @property
    def is_moving(self) -> bool:
        return bool(self._context.call('root.lu.ramp_generator.user3.busy.is_moving'))


class RootLuRamp_generatorUser3Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user3.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.ramp_generator.user3.trigger.stop')

    def prepare(self) -> None:
        return self._context.call('root.lu.ramp_generator.user3.trigger.prepare')

    def abort(self) -> None:
        return self._context.call('root.lu.ramp_generator.user3.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.ramp_generator.user3.trigger.start')


class RootLuRamp_generatorUser3AttributeMoving_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        fix_time = 0
        fix_speed = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user3.attribute.moving_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.user3.attribute.moving_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.user3.attribute.moving_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.user3.attribute.moving_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.user3.attribute.moving_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.user3.attribute.moving_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.user3.attribute.moving_mode.value_raw', new_val.value)


class RootLuRamp_generatorUser3AttributeStatus(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        reached_lower_limit = 2
        is_moving = 0
        reached_upper_limit = 3
        stopped_by_external_event = 4
        reached_endposition = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user3.attribute.status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.user3.attribute.status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.user3.attribute.status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.user3.attribute.status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.user3.attribute.status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.user3.attribute.status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.user3.attribute.status.value_raw', new_val.value)


class RootLuRamp_generatorUser3AttributeEnd_value_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        move_relative = 1
        move_to_absolute = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user3.attribute.end_value_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.user3.attribute.end_value_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.user3.attribute.end_value_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.user3.attribute.end_value_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.user3.attribute.end_value_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.user3.attribute.end_value_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.user3.attribute.end_value_mode.value_raw', new_val.value)


class RootLuRamp_generatorUser3AttributeCurrent_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user3.attribute.current_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.current_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.current_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user3.attribute.current_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user3.attribute.current_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.current_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.current_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.current_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.current_value.min', float(new_val))


class RootLuRamp_generatorUser3AttributeEnd_value_absolute(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user3.attribute.end_value_absolute'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.end_value_absolute.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.end_value_absolute.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user3.attribute.end_value_absolute.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user3.attribute.end_value_absolute.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.end_value_absolute.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.end_value_absolute.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.end_value_absolute.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.end_value_absolute.min', float(new_val))


class RootLuRamp_generatorUser3AttributeUpper_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user3.attribute.upper_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.upper_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.upper_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user3.attribute.upper_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user3.attribute.upper_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.upper_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.upper_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.upper_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.upper_limit.min', float(new_val))


class RootLuRamp_generatorUser3AttributeLower_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user3.attribute.lower_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.lower_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.lower_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user3.attribute.lower_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user3.attribute.lower_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.lower_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.lower_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.lower_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.lower_limit.min', float(new_val))


class RootLuRamp_generatorUser3AttributeMoving_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user3.attribute.moving_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.moving_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.moving_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user3.attribute.moving_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user3.attribute.moving_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.moving_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.moving_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.moving_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.moving_time.min', float(new_val))


class RootLuRamp_generatorUser3AttributeEnd_value_relative(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user3.attribute.end_value_relative'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.end_value_relative.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.end_value_relative.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user3.attribute.end_value_relative.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user3.attribute.end_value_relative.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.end_value_relative.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.end_value_relative.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.end_value_relative.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.end_value_relative.min', float(new_val))


class RootLuRamp_generatorUser3AttributeMoving_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user3.attribute.moving_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.moving_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.moving_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user3.attribute.moving_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user3.attribute.moving_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.moving_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.moving_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user3.attribute.moving_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user3.attribute.moving_speed.min', float(new_val))


class RootLuRamp_generatorUser3Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user3.attribute'
        self.moving_speed = RootLuRamp_generatorUser3AttributeMoving_speed(self._context)
        self.end_value_relative = RootLuRamp_generatorUser3AttributeEnd_value_relative(self._context)
        self.moving_time = RootLuRamp_generatorUser3AttributeMoving_time(self._context)
        self.lower_limit = RootLuRamp_generatorUser3AttributeLower_limit(self._context)
        self.upper_limit = RootLuRamp_generatorUser3AttributeUpper_limit(self._context)
        self.end_value_absolute = RootLuRamp_generatorUser3AttributeEnd_value_absolute(self._context)
        self.current_value = RootLuRamp_generatorUser3AttributeCurrent_value(self._context)
        self.end_value_mode = RootLuRamp_generatorUser3AttributeEnd_value_mode(self._context)
        self.status = RootLuRamp_generatorUser3AttributeStatus(self._context)
        self.moving_mode = RootLuRamp_generatorUser3AttributeMoving_mode(self._context)


class RootLuRamp_generatorUser3(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user3'
        self.attribute = RootLuRamp_generatorUser3Attribute(self._context)
        self.trigger = RootLuRamp_generatorUser3Trigger(self._context)
        self.busy = RootLuRamp_generatorUser3Busy(self._context)


class RootLuRamp_generatorUser1Busy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user1.busy'

    @property
    def is_moving(self) -> bool:
        return bool(self._context.call('root.lu.ramp_generator.user1.busy.is_moving'))


class RootLuRamp_generatorUser1Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user1.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.ramp_generator.user1.trigger.stop')

    def prepare(self) -> None:
        return self._context.call('root.lu.ramp_generator.user1.trigger.prepare')

    def abort(self) -> None:
        return self._context.call('root.lu.ramp_generator.user1.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.ramp_generator.user1.trigger.start')


class RootLuRamp_generatorUser1AttributeMoving_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        fix_time = 0
        fix_speed = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user1.attribute.moving_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.user1.attribute.moving_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.user1.attribute.moving_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.user1.attribute.moving_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.user1.attribute.moving_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.user1.attribute.moving_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.user1.attribute.moving_mode.value_raw', new_val.value)


class RootLuRamp_generatorUser1AttributeStatus(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        reached_lower_limit = 2
        is_moving = 0
        reached_upper_limit = 3
        stopped_by_external_event = 4
        reached_endposition = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user1.attribute.status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.user1.attribute.status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.user1.attribute.status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.user1.attribute.status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.user1.attribute.status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.user1.attribute.status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.user1.attribute.status.value_raw', new_val.value)


class RootLuRamp_generatorUser1AttributeEnd_value_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        move_relative = 1
        move_to_absolute = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user1.attribute.end_value_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.user1.attribute.end_value_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.user1.attribute.end_value_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.user1.attribute.end_value_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.user1.attribute.end_value_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.user1.attribute.end_value_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.user1.attribute.end_value_mode.value_raw', new_val.value)


class RootLuRamp_generatorUser1AttributeCurrent_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user1.attribute.current_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.current_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.current_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user1.attribute.current_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user1.attribute.current_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.current_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.current_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.current_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.current_value.min', float(new_val))


class RootLuRamp_generatorUser1AttributeEnd_value_absolute(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user1.attribute.end_value_absolute'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.end_value_absolute.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.end_value_absolute.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user1.attribute.end_value_absolute.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user1.attribute.end_value_absolute.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.end_value_absolute.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.end_value_absolute.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.end_value_absolute.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.end_value_absolute.min', float(new_val))


class RootLuRamp_generatorUser1AttributeUpper_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user1.attribute.upper_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.upper_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.upper_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user1.attribute.upper_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user1.attribute.upper_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.upper_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.upper_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.upper_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.upper_limit.min', float(new_val))


class RootLuRamp_generatorUser1AttributeLower_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user1.attribute.lower_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.lower_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.lower_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user1.attribute.lower_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user1.attribute.lower_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.lower_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.lower_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.lower_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.lower_limit.min', float(new_val))


class RootLuRamp_generatorUser1AttributeMoving_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user1.attribute.moving_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.moving_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.moving_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user1.attribute.moving_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user1.attribute.moving_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.moving_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.moving_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.moving_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.moving_time.min', float(new_val))


class RootLuRamp_generatorUser1AttributeEnd_value_relative(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user1.attribute.end_value_relative'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.end_value_relative.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.end_value_relative.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user1.attribute.end_value_relative.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user1.attribute.end_value_relative.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.end_value_relative.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.end_value_relative.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.end_value_relative.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.end_value_relative.min', float(new_val))


class RootLuRamp_generatorUser1AttributeMoving_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user1.attribute.moving_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.moving_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.moving_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user1.attribute.moving_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user1.attribute.moving_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.moving_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.moving_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user1.attribute.moving_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user1.attribute.moving_speed.min', float(new_val))


class RootLuRamp_generatorUser1Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user1.attribute'
        self.moving_speed = RootLuRamp_generatorUser1AttributeMoving_speed(self._context)
        self.end_value_relative = RootLuRamp_generatorUser1AttributeEnd_value_relative(self._context)
        self.moving_time = RootLuRamp_generatorUser1AttributeMoving_time(self._context)
        self.lower_limit = RootLuRamp_generatorUser1AttributeLower_limit(self._context)
        self.upper_limit = RootLuRamp_generatorUser1AttributeUpper_limit(self._context)
        self.end_value_absolute = RootLuRamp_generatorUser1AttributeEnd_value_absolute(self._context)
        self.current_value = RootLuRamp_generatorUser1AttributeCurrent_value(self._context)
        self.end_value_mode = RootLuRamp_generatorUser1AttributeEnd_value_mode(self._context)
        self.status = RootLuRamp_generatorUser1AttributeStatus(self._context)
        self.moving_mode = RootLuRamp_generatorUser1AttributeMoving_mode(self._context)


class RootLuRamp_generatorUser1(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user1'
        self.attribute = RootLuRamp_generatorUser1Attribute(self._context)
        self.trigger = RootLuRamp_generatorUser1Trigger(self._context)
        self.busy = RootLuRamp_generatorUser1Busy(self._context)


class RootLuRamp_generatorUser2Busy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user2.busy'

    @property
    def is_moving(self) -> bool:
        return bool(self._context.call('root.lu.ramp_generator.user2.busy.is_moving'))


class RootLuRamp_generatorUser2Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user2.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.ramp_generator.user2.trigger.stop')

    def prepare(self) -> None:
        return self._context.call('root.lu.ramp_generator.user2.trigger.prepare')

    def abort(self) -> None:
        return self._context.call('root.lu.ramp_generator.user2.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.ramp_generator.user2.trigger.start')


class RootLuRamp_generatorUser2AttributeMoving_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        fix_time = 0
        fix_speed = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user2.attribute.moving_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.user2.attribute.moving_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.user2.attribute.moving_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.user2.attribute.moving_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.user2.attribute.moving_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.user2.attribute.moving_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.user2.attribute.moving_mode.value_raw', new_val.value)


class RootLuRamp_generatorUser2AttributeStatus(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        reached_lower_limit = 2
        is_moving = 0
        reached_upper_limit = 3
        stopped_by_external_event = 4
        reached_endposition = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user2.attribute.status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.user2.attribute.status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.user2.attribute.status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.user2.attribute.status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.user2.attribute.status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.user2.attribute.status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.user2.attribute.status.value_raw', new_val.value)


class RootLuRamp_generatorUser2AttributeEnd_value_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        move_relative = 1
        move_to_absolute = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user2.attribute.end_value_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.user2.attribute.end_value_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.user2.attribute.end_value_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.user2.attribute.end_value_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.user2.attribute.end_value_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.user2.attribute.end_value_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.user2.attribute.end_value_mode.value_raw', new_val.value)


class RootLuRamp_generatorUser2AttributeCurrent_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user2.attribute.current_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.current_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.current_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user2.attribute.current_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user2.attribute.current_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.current_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.current_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.current_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.current_value.min', float(new_val))


class RootLuRamp_generatorUser2AttributeEnd_value_absolute(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user2.attribute.end_value_absolute'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.end_value_absolute.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.end_value_absolute.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user2.attribute.end_value_absolute.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user2.attribute.end_value_absolute.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.end_value_absolute.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.end_value_absolute.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.end_value_absolute.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.end_value_absolute.min', float(new_val))


class RootLuRamp_generatorUser2AttributeUpper_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user2.attribute.upper_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.upper_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.upper_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user2.attribute.upper_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user2.attribute.upper_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.upper_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.upper_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.upper_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.upper_limit.min', float(new_val))


class RootLuRamp_generatorUser2AttributeLower_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user2.attribute.lower_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.lower_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.lower_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user2.attribute.lower_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user2.attribute.lower_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.lower_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.lower_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.lower_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.lower_limit.min', float(new_val))


class RootLuRamp_generatorUser2AttributeMoving_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user2.attribute.moving_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.moving_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.moving_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user2.attribute.moving_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user2.attribute.moving_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.moving_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.moving_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.moving_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.moving_time.min', float(new_val))


class RootLuRamp_generatorUser2AttributeEnd_value_relative(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user2.attribute.end_value_relative'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.end_value_relative.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.end_value_relative.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user2.attribute.end_value_relative.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user2.attribute.end_value_relative.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.end_value_relative.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.end_value_relative.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.end_value_relative.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.end_value_relative.min', float(new_val))


class RootLuRamp_generatorUser2AttributeMoving_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user2.attribute.moving_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.moving_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.moving_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user2.attribute.moving_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user2.attribute.moving_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.moving_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.moving_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user2.attribute.moving_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user2.attribute.moving_speed.min', float(new_val))


class RootLuRamp_generatorUser2Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user2.attribute'
        self.moving_speed = RootLuRamp_generatorUser2AttributeMoving_speed(self._context)
        self.end_value_relative = RootLuRamp_generatorUser2AttributeEnd_value_relative(self._context)
        self.moving_time = RootLuRamp_generatorUser2AttributeMoving_time(self._context)
        self.lower_limit = RootLuRamp_generatorUser2AttributeLower_limit(self._context)
        self.upper_limit = RootLuRamp_generatorUser2AttributeUpper_limit(self._context)
        self.end_value_absolute = RootLuRamp_generatorUser2AttributeEnd_value_absolute(self._context)
        self.current_value = RootLuRamp_generatorUser2AttributeCurrent_value(self._context)
        self.end_value_mode = RootLuRamp_generatorUser2AttributeEnd_value_mode(self._context)
        self.status = RootLuRamp_generatorUser2AttributeStatus(self._context)
        self.moving_mode = RootLuRamp_generatorUser2AttributeMoving_mode(self._context)


class RootLuRamp_generatorUser2(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user2'
        self.attribute = RootLuRamp_generatorUser2Attribute(self._context)
        self.trigger = RootLuRamp_generatorUser2Trigger(self._context)
        self.busy = RootLuRamp_generatorUser2Busy(self._context)


class RootLuRamp_generatorTestBusy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.test.busy'

    @property
    def is_moving(self) -> bool:
        return bool(self._context.call('root.lu.ramp_generator.test.busy.is_moving'))


class RootLuRamp_generatorTestTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.test.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.ramp_generator.test.trigger.stop')

    def prepare(self) -> None:
        return self._context.call('root.lu.ramp_generator.test.trigger.prepare')

    def abort(self) -> None:
        return self._context.call('root.lu.ramp_generator.test.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.ramp_generator.test.trigger.start')


class RootLuRamp_generatorTestAttributeMoving_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        fix_time = 0
        fix_speed = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.test.attribute.moving_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.test.attribute.moving_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.test.attribute.moving_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.test.attribute.moving_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.test.attribute.moving_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.test.attribute.moving_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.test.attribute.moving_mode.value_raw', new_val.value)


class RootLuRamp_generatorTestAttributeStatus(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        reached_lower_limit = 2
        is_moving = 0
        reached_upper_limit = 3
        stopped_by_external_event = 4
        reached_endposition = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.test.attribute.status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.test.attribute.status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.test.attribute.status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.test.attribute.status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.test.attribute.status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.test.attribute.status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.test.attribute.status.value_raw', new_val.value)


class RootLuRamp_generatorTestAttributeEnd_value_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        move_relative = 1
        move_to_absolute = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.test.attribute.end_value_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.test.attribute.end_value_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.test.attribute.end_value_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.test.attribute.end_value_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.test.attribute.end_value_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.test.attribute.end_value_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.test.attribute.end_value_mode.value_raw', new_val.value)


class RootLuRamp_generatorTestAttributeCurrent_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.test.attribute.current_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.current_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.current_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.test.attribute.current_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.test.attribute.current_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.current_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.current_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.current_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.current_value.min', float(new_val))


class RootLuRamp_generatorTestAttributeEnd_value_absolute(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.test.attribute.end_value_absolute'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.end_value_absolute.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.end_value_absolute.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.test.attribute.end_value_absolute.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.test.attribute.end_value_absolute.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.end_value_absolute.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.end_value_absolute.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.end_value_absolute.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.end_value_absolute.min', float(new_val))


class RootLuRamp_generatorTestAttributeUpper_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.test.attribute.upper_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.upper_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.upper_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.test.attribute.upper_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.test.attribute.upper_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.upper_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.upper_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.upper_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.upper_limit.min', float(new_val))


class RootLuRamp_generatorTestAttributeLower_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.test.attribute.lower_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.lower_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.lower_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.test.attribute.lower_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.test.attribute.lower_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.lower_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.lower_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.lower_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.lower_limit.min', float(new_val))


class RootLuRamp_generatorTestAttributeMoving_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.test.attribute.moving_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.moving_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.moving_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.test.attribute.moving_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.test.attribute.moving_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.moving_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.moving_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.moving_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.moving_time.min', float(new_val))


class RootLuRamp_generatorTestAttributeEnd_value_relative(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.test.attribute.end_value_relative'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.end_value_relative.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.end_value_relative.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.test.attribute.end_value_relative.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.test.attribute.end_value_relative.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.end_value_relative.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.end_value_relative.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.end_value_relative.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.end_value_relative.min', float(new_val))


class RootLuRamp_generatorTestAttributeMoving_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.test.attribute.moving_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.moving_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.moving_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.test.attribute.moving_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.test.attribute.moving_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.moving_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.moving_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.test.attribute.moving_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.test.attribute.moving_speed.min', float(new_val))


class RootLuRamp_generatorTestAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.test.attribute'
        self.moving_speed = RootLuRamp_generatorTestAttributeMoving_speed(self._context)
        self.end_value_relative = RootLuRamp_generatorTestAttributeEnd_value_relative(self._context)
        self.moving_time = RootLuRamp_generatorTestAttributeMoving_time(self._context)
        self.lower_limit = RootLuRamp_generatorTestAttributeLower_limit(self._context)
        self.upper_limit = RootLuRamp_generatorTestAttributeUpper_limit(self._context)
        self.end_value_absolute = RootLuRamp_generatorTestAttributeEnd_value_absolute(self._context)
        self.current_value = RootLuRamp_generatorTestAttributeCurrent_value(self._context)
        self.end_value_mode = RootLuRamp_generatorTestAttributeEnd_value_mode(self._context)
        self.status = RootLuRamp_generatorTestAttributeStatus(self._context)
        self.moving_mode = RootLuRamp_generatorTestAttributeMoving_mode(self._context)


class RootLuRamp_generatorTest(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.test'
        self.attribute = RootLuRamp_generatorTestAttribute(self._context)
        self.trigger = RootLuRamp_generatorTestTrigger(self._context)
        self.busy = RootLuRamp_generatorTestBusy(self._context)


class RootLuRamp_generatorTip_voltageBusy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.tip_voltage.busy'

    @property
    def is_moving(self) -> bool:
        return bool(self._context.call('root.lu.ramp_generator.tip_voltage.busy.is_moving'))


class RootLuRamp_generatorTip_voltageTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.tip_voltage.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.ramp_generator.tip_voltage.trigger.stop')

    def prepare(self) -> None:
        return self._context.call('root.lu.ramp_generator.tip_voltage.trigger.prepare')

    def abort(self) -> None:
        return self._context.call('root.lu.ramp_generator.tip_voltage.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.ramp_generator.tip_voltage.trigger.start')


class RootLuRamp_generatorTip_voltageAttributeMoving_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        fix_time = 0
        fix_speed = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.tip_voltage.attribute.moving_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.moving_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.moving_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.moving_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.moving_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.moving_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.moving_mode.value_raw', new_val.value)


class RootLuRamp_generatorTip_voltageAttributeStatus(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        reached_lower_limit = 2
        is_moving = 0
        reached_upper_limit = 3
        stopped_by_external_event = 4
        reached_endposition = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.tip_voltage.attribute.status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.status.value_raw', new_val.value)


class RootLuRamp_generatorTip_voltageAttributeEnd_value_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        move_relative = 1
        move_to_absolute = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.tip_voltage.attribute.end_value_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.end_value_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.end_value_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.end_value_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.end_value_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.end_value_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.end_value_mode.value_raw', new_val.value)


class RootLuRamp_generatorTip_voltageAttributeCurrent_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.tip_voltage.attribute.current_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.current_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.current_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.current_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.current_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.current_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.current_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.current_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.current_value.min', float(new_val))


class RootLuRamp_generatorTip_voltageAttributeEnd_value_absolute(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.tip_voltage.attribute.end_value_absolute'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.end_value_absolute.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.end_value_absolute.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.end_value_absolute.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.end_value_absolute.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.end_value_absolute.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.end_value_absolute.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.end_value_absolute.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.end_value_absolute.min', float(new_val))


class RootLuRamp_generatorTip_voltageAttributeUpper_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.tip_voltage.attribute.upper_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.upper_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.upper_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.upper_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.upper_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.upper_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.upper_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.upper_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.upper_limit.min', float(new_val))


class RootLuRamp_generatorTip_voltageAttributeLower_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.tip_voltage.attribute.lower_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.lower_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.lower_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.lower_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.lower_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.lower_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.lower_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.lower_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.lower_limit.min', float(new_val))


class RootLuRamp_generatorTip_voltageAttributeMoving_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.tip_voltage.attribute.moving_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.moving_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.moving_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.moving_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.moving_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.moving_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.moving_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.moving_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.moving_time.min', float(new_val))


class RootLuRamp_generatorTip_voltageAttributeEnd_value_relative(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.tip_voltage.attribute.end_value_relative'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.end_value_relative.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.end_value_relative.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.end_value_relative.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.end_value_relative.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.end_value_relative.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.end_value_relative.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.end_value_relative.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.end_value_relative.min', float(new_val))


class RootLuRamp_generatorTip_voltageAttributeMoving_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.tip_voltage.attribute.moving_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.moving_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.moving_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.moving_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.moving_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.moving_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.moving_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.tip_voltage.attribute.moving_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.tip_voltage.attribute.moving_speed.min', float(new_val))


class RootLuRamp_generatorTip_voltageAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.tip_voltage.attribute'
        self.moving_speed = RootLuRamp_generatorTip_voltageAttributeMoving_speed(self._context)
        self.end_value_relative = RootLuRamp_generatorTip_voltageAttributeEnd_value_relative(self._context)
        self.moving_time = RootLuRamp_generatorTip_voltageAttributeMoving_time(self._context)
        self.lower_limit = RootLuRamp_generatorTip_voltageAttributeLower_limit(self._context)
        self.upper_limit = RootLuRamp_generatorTip_voltageAttributeUpper_limit(self._context)
        self.end_value_absolute = RootLuRamp_generatorTip_voltageAttributeEnd_value_absolute(self._context)
        self.current_value = RootLuRamp_generatorTip_voltageAttributeCurrent_value(self._context)
        self.end_value_mode = RootLuRamp_generatorTip_voltageAttributeEnd_value_mode(self._context)
        self.status = RootLuRamp_generatorTip_voltageAttributeStatus(self._context)
        self.moving_mode = RootLuRamp_generatorTip_voltageAttributeMoving_mode(self._context)


class RootLuRamp_generatorTip_voltage(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.tip_voltage'
        self.attribute = RootLuRamp_generatorTip_voltageAttribute(self._context)
        self.trigger = RootLuRamp_generatorTip_voltageTrigger(self._context)
        self.busy = RootLuRamp_generatorTip_voltageBusy(self._context)


class RootLuRamp_generatorVirtual0Busy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual0.busy'

    @property
    def is_moving(self) -> bool:
        return bool(self._context.call('root.lu.ramp_generator.virtual0.busy.is_moving'))


class RootLuRamp_generatorVirtual0Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual0.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.ramp_generator.virtual0.trigger.stop')

    def prepare(self) -> None:
        return self._context.call('root.lu.ramp_generator.virtual0.trigger.prepare')

    def abort(self) -> None:
        return self._context.call('root.lu.ramp_generator.virtual0.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.ramp_generator.virtual0.trigger.start')


class RootLuRamp_generatorVirtual0AttributeMoving_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        fix_time = 0
        fix_speed = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual0.attribute.moving_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.virtual0.attribute.moving_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.moving_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.virtual0.attribute.moving_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.moving_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.virtual0.attribute.moving_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.moving_mode.value_raw', new_val.value)


class RootLuRamp_generatorVirtual0AttributeStatus(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        reached_lower_limit = 2
        is_moving = 0
        reached_upper_limit = 3
        stopped_by_external_event = 4
        reached_endposition = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual0.attribute.status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.virtual0.attribute.status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.virtual0.attribute.status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.virtual0.attribute.status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.status.value_raw', new_val.value)


class RootLuRamp_generatorVirtual0AttributeEnd_value_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        move_relative = 1
        move_to_absolute = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual0.attribute.end_value_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.virtual0.attribute.end_value_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.end_value_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.virtual0.attribute.end_value_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.end_value_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.virtual0.attribute.end_value_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.end_value_mode.value_raw', new_val.value)


class RootLuRamp_generatorVirtual0AttributeCurrent_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual0.attribute.current_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.current_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.current_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual0.attribute.current_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.current_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.current_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.current_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.current_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.current_value.min', float(new_val))


class RootLuRamp_generatorVirtual0AttributeEnd_value_absolute(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual0.attribute.end_value_absolute'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.end_value_absolute.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.end_value_absolute.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual0.attribute.end_value_absolute.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.end_value_absolute.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.end_value_absolute.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.end_value_absolute.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.end_value_absolute.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.end_value_absolute.min', float(new_val))


class RootLuRamp_generatorVirtual0AttributeUpper_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual0.attribute.upper_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.upper_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.upper_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual0.attribute.upper_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.upper_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.upper_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.upper_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.upper_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.upper_limit.min', float(new_val))


class RootLuRamp_generatorVirtual0AttributeLower_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual0.attribute.lower_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.lower_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.lower_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual0.attribute.lower_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.lower_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.lower_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.lower_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.lower_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.lower_limit.min', float(new_val))


class RootLuRamp_generatorVirtual0AttributeMoving_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual0.attribute.moving_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.moving_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.moving_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual0.attribute.moving_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.moving_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.moving_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.moving_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.moving_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.moving_time.min', float(new_val))


class RootLuRamp_generatorVirtual0AttributeEnd_value_relative(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual0.attribute.end_value_relative'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.end_value_relative.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.end_value_relative.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual0.attribute.end_value_relative.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.end_value_relative.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.end_value_relative.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.end_value_relative.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.end_value_relative.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.end_value_relative.min', float(new_val))


class RootLuRamp_generatorVirtual0AttributeMoving_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual0.attribute.moving_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.moving_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.moving_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual0.attribute.moving_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.moving_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.moving_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.moving_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual0.attribute.moving_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual0.attribute.moving_speed.min', float(new_val))


class RootLuRamp_generatorVirtual0Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual0.attribute'
        self.moving_speed = RootLuRamp_generatorVirtual0AttributeMoving_speed(self._context)
        self.end_value_relative = RootLuRamp_generatorVirtual0AttributeEnd_value_relative(self._context)
        self.moving_time = RootLuRamp_generatorVirtual0AttributeMoving_time(self._context)
        self.lower_limit = RootLuRamp_generatorVirtual0AttributeLower_limit(self._context)
        self.upper_limit = RootLuRamp_generatorVirtual0AttributeUpper_limit(self._context)
        self.end_value_absolute = RootLuRamp_generatorVirtual0AttributeEnd_value_absolute(self._context)
        self.current_value = RootLuRamp_generatorVirtual0AttributeCurrent_value(self._context)
        self.end_value_mode = RootLuRamp_generatorVirtual0AttributeEnd_value_mode(self._context)
        self.status = RootLuRamp_generatorVirtual0AttributeStatus(self._context)
        self.moving_mode = RootLuRamp_generatorVirtual0AttributeMoving_mode(self._context)


class RootLuRamp_generatorVirtual0(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual0'
        self.attribute = RootLuRamp_generatorVirtual0Attribute(self._context)
        self.trigger = RootLuRamp_generatorVirtual0Trigger(self._context)
        self.busy = RootLuRamp_generatorVirtual0Busy(self._context)


class RootLuRamp_generatorVirtual2Busy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual2.busy'

    @property
    def is_moving(self) -> bool:
        return bool(self._context.call('root.lu.ramp_generator.virtual2.busy.is_moving'))


class RootLuRamp_generatorVirtual2Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual2.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.ramp_generator.virtual2.trigger.stop')

    def prepare(self) -> None:
        return self._context.call('root.lu.ramp_generator.virtual2.trigger.prepare')

    def abort(self) -> None:
        return self._context.call('root.lu.ramp_generator.virtual2.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.ramp_generator.virtual2.trigger.start')


class RootLuRamp_generatorVirtual2AttributeMoving_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        fix_time = 0
        fix_speed = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual2.attribute.moving_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.virtual2.attribute.moving_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.moving_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.virtual2.attribute.moving_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.moving_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.virtual2.attribute.moving_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.moving_mode.value_raw', new_val.value)


class RootLuRamp_generatorVirtual2AttributeStatus(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        reached_lower_limit = 2
        is_moving = 0
        reached_upper_limit = 3
        stopped_by_external_event = 4
        reached_endposition = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual2.attribute.status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.virtual2.attribute.status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.virtual2.attribute.status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.virtual2.attribute.status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.status.value_raw', new_val.value)


class RootLuRamp_generatorVirtual2AttributeEnd_value_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        move_relative = 1
        move_to_absolute = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual2.attribute.end_value_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.virtual2.attribute.end_value_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.end_value_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.virtual2.attribute.end_value_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.end_value_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.virtual2.attribute.end_value_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.end_value_mode.value_raw', new_val.value)


class RootLuRamp_generatorVirtual2AttributeCurrent_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual2.attribute.current_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.current_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.current_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual2.attribute.current_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.current_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.current_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.current_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.current_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.current_value.min', float(new_val))


class RootLuRamp_generatorVirtual2AttributeEnd_value_absolute(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual2.attribute.end_value_absolute'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.end_value_absolute.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.end_value_absolute.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual2.attribute.end_value_absolute.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.end_value_absolute.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.end_value_absolute.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.end_value_absolute.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.end_value_absolute.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.end_value_absolute.min', float(new_val))


class RootLuRamp_generatorVirtual2AttributeUpper_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual2.attribute.upper_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.upper_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.upper_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual2.attribute.upper_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.upper_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.upper_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.upper_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.upper_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.upper_limit.min', float(new_val))


class RootLuRamp_generatorVirtual2AttributeLower_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual2.attribute.lower_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.lower_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.lower_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual2.attribute.lower_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.lower_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.lower_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.lower_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.lower_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.lower_limit.min', float(new_val))


class RootLuRamp_generatorVirtual2AttributeMoving_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual2.attribute.moving_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.moving_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.moving_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual2.attribute.moving_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.moving_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.moving_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.moving_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.moving_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.moving_time.min', float(new_val))


class RootLuRamp_generatorVirtual2AttributeEnd_value_relative(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual2.attribute.end_value_relative'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.end_value_relative.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.end_value_relative.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual2.attribute.end_value_relative.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.end_value_relative.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.end_value_relative.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.end_value_relative.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.end_value_relative.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.end_value_relative.min', float(new_val))


class RootLuRamp_generatorVirtual2AttributeMoving_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual2.attribute.moving_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.moving_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.moving_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual2.attribute.moving_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.moving_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.moving_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.moving_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual2.attribute.moving_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual2.attribute.moving_speed.min', float(new_val))


class RootLuRamp_generatorVirtual2Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual2.attribute'
        self.moving_speed = RootLuRamp_generatorVirtual2AttributeMoving_speed(self._context)
        self.end_value_relative = RootLuRamp_generatorVirtual2AttributeEnd_value_relative(self._context)
        self.moving_time = RootLuRamp_generatorVirtual2AttributeMoving_time(self._context)
        self.lower_limit = RootLuRamp_generatorVirtual2AttributeLower_limit(self._context)
        self.upper_limit = RootLuRamp_generatorVirtual2AttributeUpper_limit(self._context)
        self.end_value_absolute = RootLuRamp_generatorVirtual2AttributeEnd_value_absolute(self._context)
        self.current_value = RootLuRamp_generatorVirtual2AttributeCurrent_value(self._context)
        self.end_value_mode = RootLuRamp_generatorVirtual2AttributeEnd_value_mode(self._context)
        self.status = RootLuRamp_generatorVirtual2AttributeStatus(self._context)
        self.moving_mode = RootLuRamp_generatorVirtual2AttributeMoving_mode(self._context)


class RootLuRamp_generatorVirtual2(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual2'
        self.attribute = RootLuRamp_generatorVirtual2Attribute(self._context)
        self.trigger = RootLuRamp_generatorVirtual2Trigger(self._context)
        self.busy = RootLuRamp_generatorVirtual2Busy(self._context)


class RootLuRamp_generatorVirtual1Busy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual1.busy'

    @property
    def is_moving(self) -> bool:
        return bool(self._context.call('root.lu.ramp_generator.virtual1.busy.is_moving'))


class RootLuRamp_generatorVirtual1Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual1.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.ramp_generator.virtual1.trigger.stop')

    def prepare(self) -> None:
        return self._context.call('root.lu.ramp_generator.virtual1.trigger.prepare')

    def abort(self) -> None:
        return self._context.call('root.lu.ramp_generator.virtual1.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.ramp_generator.virtual1.trigger.start')


class RootLuRamp_generatorVirtual1AttributeMoving_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        fix_time = 0
        fix_speed = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual1.attribute.moving_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.virtual1.attribute.moving_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.moving_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.virtual1.attribute.moving_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.moving_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.virtual1.attribute.moving_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.moving_mode.value_raw', new_val.value)


class RootLuRamp_generatorVirtual1AttributeStatus(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        reached_lower_limit = 2
        is_moving = 0
        reached_upper_limit = 3
        stopped_by_external_event = 4
        reached_endposition = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual1.attribute.status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.virtual1.attribute.status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.virtual1.attribute.status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.virtual1.attribute.status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.status.value_raw', new_val.value)


class RootLuRamp_generatorVirtual1AttributeEnd_value_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        move_relative = 1
        move_to_absolute = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual1.attribute.end_value_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.virtual1.attribute.end_value_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.end_value_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.virtual1.attribute.end_value_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.end_value_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.virtual1.attribute.end_value_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.end_value_mode.value_raw', new_val.value)


class RootLuRamp_generatorVirtual1AttributeCurrent_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual1.attribute.current_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.current_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.current_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual1.attribute.current_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.current_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.current_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.current_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.current_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.current_value.min', float(new_val))


class RootLuRamp_generatorVirtual1AttributeEnd_value_absolute(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual1.attribute.end_value_absolute'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.end_value_absolute.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.end_value_absolute.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual1.attribute.end_value_absolute.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.end_value_absolute.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.end_value_absolute.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.end_value_absolute.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.end_value_absolute.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.end_value_absolute.min', float(new_val))


class RootLuRamp_generatorVirtual1AttributeUpper_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual1.attribute.upper_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.upper_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.upper_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual1.attribute.upper_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.upper_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.upper_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.upper_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.upper_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.upper_limit.min', float(new_val))


class RootLuRamp_generatorVirtual1AttributeLower_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual1.attribute.lower_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.lower_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.lower_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual1.attribute.lower_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.lower_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.lower_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.lower_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.lower_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.lower_limit.min', float(new_val))


class RootLuRamp_generatorVirtual1AttributeMoving_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual1.attribute.moving_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.moving_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.moving_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual1.attribute.moving_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.moving_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.moving_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.moving_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.moving_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.moving_time.min', float(new_val))


class RootLuRamp_generatorVirtual1AttributeEnd_value_relative(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual1.attribute.end_value_relative'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.end_value_relative.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.end_value_relative.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual1.attribute.end_value_relative.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.end_value_relative.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.end_value_relative.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.end_value_relative.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.end_value_relative.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.end_value_relative.min', float(new_val))


class RootLuRamp_generatorVirtual1AttributeMoving_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual1.attribute.moving_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.moving_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.moving_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.virtual1.attribute.moving_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.moving_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.moving_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.moving_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.virtual1.attribute.moving_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.virtual1.attribute.moving_speed.min', float(new_val))


class RootLuRamp_generatorVirtual1Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual1.attribute'
        self.moving_speed = RootLuRamp_generatorVirtual1AttributeMoving_speed(self._context)
        self.end_value_relative = RootLuRamp_generatorVirtual1AttributeEnd_value_relative(self._context)
        self.moving_time = RootLuRamp_generatorVirtual1AttributeMoving_time(self._context)
        self.lower_limit = RootLuRamp_generatorVirtual1AttributeLower_limit(self._context)
        self.upper_limit = RootLuRamp_generatorVirtual1AttributeUpper_limit(self._context)
        self.end_value_absolute = RootLuRamp_generatorVirtual1AttributeEnd_value_absolute(self._context)
        self.current_value = RootLuRamp_generatorVirtual1AttributeCurrent_value(self._context)
        self.end_value_mode = RootLuRamp_generatorVirtual1AttributeEnd_value_mode(self._context)
        self.status = RootLuRamp_generatorVirtual1AttributeStatus(self._context)
        self.moving_mode = RootLuRamp_generatorVirtual1AttributeMoving_mode(self._context)


class RootLuRamp_generatorVirtual1(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.virtual1'
        self.attribute = RootLuRamp_generatorVirtual1Attribute(self._context)
        self.trigger = RootLuRamp_generatorVirtual1Trigger(self._context)
        self.busy = RootLuRamp_generatorVirtual1Busy(self._context)


class RootLuRamp_generatorUser4Busy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user4.busy'

    @property
    def is_moving(self) -> bool:
        return bool(self._context.call('root.lu.ramp_generator.user4.busy.is_moving'))


class RootLuRamp_generatorUser4Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user4.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.ramp_generator.user4.trigger.stop')

    def prepare(self) -> None:
        return self._context.call('root.lu.ramp_generator.user4.trigger.prepare')

    def abort(self) -> None:
        return self._context.call('root.lu.ramp_generator.user4.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.ramp_generator.user4.trigger.start')


class RootLuRamp_generatorUser4AttributeMoving_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        fix_time = 0
        fix_speed = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user4.attribute.moving_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.user4.attribute.moving_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.user4.attribute.moving_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.user4.attribute.moving_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.user4.attribute.moving_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.user4.attribute.moving_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.user4.attribute.moving_mode.value_raw', new_val.value)


class RootLuRamp_generatorUser4AttributeStatus(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        reached_lower_limit = 2
        is_moving = 0
        reached_upper_limit = 3
        stopped_by_external_event = 4
        reached_endposition = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user4.attribute.status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.user4.attribute.status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.user4.attribute.status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.user4.attribute.status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.user4.attribute.status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.user4.attribute.status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.user4.attribute.status.value_raw', new_val.value)


class RootLuRamp_generatorUser4AttributeEnd_value_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        move_relative = 1
        move_to_absolute = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user4.attribute.end_value_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ramp_generator.user4.attribute.end_value_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ramp_generator.user4.attribute.end_value_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ramp_generator.user4.attribute.end_value_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ramp_generator.user4.attribute.end_value_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ramp_generator.user4.attribute.end_value_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ramp_generator.user4.attribute.end_value_mode.value_raw', new_val.value)


class RootLuRamp_generatorUser4AttributeCurrent_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user4.attribute.current_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.current_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.current_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user4.attribute.current_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user4.attribute.current_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.current_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.current_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.current_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.current_value.min', float(new_val))


class RootLuRamp_generatorUser4AttributeEnd_value_absolute(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user4.attribute.end_value_absolute'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.end_value_absolute.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.end_value_absolute.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user4.attribute.end_value_absolute.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user4.attribute.end_value_absolute.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.end_value_absolute.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.end_value_absolute.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.end_value_absolute.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.end_value_absolute.min', float(new_val))


class RootLuRamp_generatorUser4AttributeUpper_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user4.attribute.upper_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.upper_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.upper_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user4.attribute.upper_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user4.attribute.upper_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.upper_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.upper_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.upper_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.upper_limit.min', float(new_val))


class RootLuRamp_generatorUser4AttributeLower_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user4.attribute.lower_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.lower_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.lower_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user4.attribute.lower_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user4.attribute.lower_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.lower_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.lower_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.lower_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.lower_limit.min', float(new_val))


class RootLuRamp_generatorUser4AttributeMoving_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user4.attribute.moving_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.moving_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.moving_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user4.attribute.moving_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user4.attribute.moving_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.moving_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.moving_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.moving_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.moving_time.min', float(new_val))


class RootLuRamp_generatorUser4AttributeEnd_value_relative(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user4.attribute.end_value_relative'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.end_value_relative.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.end_value_relative.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user4.attribute.end_value_relative.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user4.attribute.end_value_relative.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.end_value_relative.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.end_value_relative.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.end_value_relative.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.end_value_relative.min', float(new_val))


class RootLuRamp_generatorUser4AttributeMoving_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user4.attribute.moving_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.moving_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.moving_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ramp_generator.user4.attribute.moving_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ramp_generator.user4.attribute.moving_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.moving_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.moving_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ramp_generator.user4.attribute.moving_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ramp_generator.user4.attribute.moving_speed.min', float(new_val))


class RootLuRamp_generatorUser4Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user4.attribute'
        self.moving_speed = RootLuRamp_generatorUser4AttributeMoving_speed(self._context)
        self.end_value_relative = RootLuRamp_generatorUser4AttributeEnd_value_relative(self._context)
        self.moving_time = RootLuRamp_generatorUser4AttributeMoving_time(self._context)
        self.lower_limit = RootLuRamp_generatorUser4AttributeLower_limit(self._context)
        self.upper_limit = RootLuRamp_generatorUser4AttributeUpper_limit(self._context)
        self.end_value_absolute = RootLuRamp_generatorUser4AttributeEnd_value_absolute(self._context)
        self.current_value = RootLuRamp_generatorUser4AttributeCurrent_value(self._context)
        self.end_value_mode = RootLuRamp_generatorUser4AttributeEnd_value_mode(self._context)
        self.status = RootLuRamp_generatorUser4AttributeStatus(self._context)
        self.moving_mode = RootLuRamp_generatorUser4AttributeMoving_mode(self._context)


class RootLuRamp_generatorUser4(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator.user4'
        self.attribute = RootLuRamp_generatorUser4Attribute(self._context)
        self.trigger = RootLuRamp_generatorUser4Trigger(self._context)
        self.busy = RootLuRamp_generatorUser4Busy(self._context)


class RootLuRamp_generator(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ramp_generator'
        self.user4 = RootLuRamp_generatorUser4(self._context)
        self.virtual1 = RootLuRamp_generatorVirtual1(self._context)
        self.virtual2 = RootLuRamp_generatorVirtual2(self._context)
        self.virtual0 = RootLuRamp_generatorVirtual0(self._context)
        self.tip_voltage = RootLuRamp_generatorTip_voltage(self._context)
        self.test = RootLuRamp_generatorTest(self._context)
        self.user2 = RootLuRamp_generatorUser2(self._context)
        self.user1 = RootLuRamp_generatorUser1(self._context)
        self.user3 = RootLuRamp_generatorUser3(self._context)
        self.approach = RootLuRamp_generatorApproach(self._context)
        self.plane_z = RootLuRamp_generatorPlane_z(self._context)
        self.position_x = RootLuRamp_generatorPosition_x(self._context)
        self.position_y = RootLuRamp_generatorPosition_y(self._context)
        self.ctrl_z = RootLuRamp_generatorCtrl_z(self._context)
        self.position_w = RootLuRamp_generatorPosition_w(self._context)
        self.alternate_z = RootLuRamp_generatorAlternate_z(self._context)


class RootLuApproachInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.trigger'

    def start_pre_approach(self) -> None:
        return self._context.call('root.lu.approach.instance.trigger.start_pre_approach')

    def start_approach_steps(self) -> None:
        return self._context.call('root.lu.approach.instance.trigger.start_approach_steps')

    def start_approach_afm(self) -> None:
        return self._context.call('root.lu.approach.instance.trigger.start_approach_afm')

    def start_adjust_tip_pos(self) -> None:
        return self._context.call('root.lu.approach.instance.trigger.start_adjust_tip_pos')

    def start_approach_motor(self) -> None:
        return self._context.call('root.lu.approach.instance.trigger.start_approach_motor')

    def start_approach_fsa(self) -> None:
        return self._context.call('root.lu.approach.instance.trigger.start_approach_fsa')

    def withdraw_step(self) -> None:
        return self._context.call('root.lu.approach.instance.trigger.withdraw_step')

    def user_done(self) -> None:
        return self._context.call('root.lu.approach.instance.trigger.user_done')

    def user_abort(self) -> None:
        return self._context.call('root.lu.approach.instance.trigger.user_abort')


class RootLuApproachInstanceAttributeApproach_motor_status_external(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        dummy_0 = 0
        in_range = 1
        not_connected = 4
        error = 5
        min_in = 2
        max_out = 3

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.approach_motor_status_external'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.approach.instance.attribute.approach_motor_status_external.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.approach.instance.attribute.approach_motor_status_external.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.approach.instance.attribute.approach_motor_status_external.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.approach.instance.attribute.approach_motor_status_external.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.approach.instance.attribute.approach_motor_status_external.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.approach.instance.attribute.approach_motor_status_external.value_raw', new_val.value)


class RootLuApproachInstanceAttributeGentle_approach_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.gentle_approach_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.approach.instance.attribute.gentle_approach_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.approach.instance.attribute.gentle_approach_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.approach.instance.attribute.gentle_approach_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.approach.instance.attribute.gentle_approach_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.approach.instance.attribute.gentle_approach_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.approach.instance.attribute.gentle_approach_enable.value_raw', new_val.value)


class RootLuApproachInstanceAttributeRelease_tip(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.release_tip'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.release_tip.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.release_tip.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.approach.instance.attribute.release_tip.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.approach.instance.attribute.release_tip.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.release_tip.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.release_tip.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.release_tip.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.release_tip.min', float(new_val))


class RootLuApproachInstanceAttributeWithdraw_steps(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.withdraw_steps'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.withdraw_steps.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.withdraw_steps.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.approach.instance.attribute.withdraw_steps.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.approach.instance.attribute.withdraw_steps.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.withdraw_steps.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.withdraw_steps.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.withdraw_steps.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.withdraw_steps.min', float(new_val))


class RootLuApproachInstanceAttributeStep_by_step_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        tip_position_ignored = 2
        position_controlled = 0
        not_controlled = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.step_by_step_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.approach.instance.attribute.step_by_step_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.approach.instance.attribute.step_by_step_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.approach.instance.attribute.step_by_step_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_mode.value_raw', new_val.value)


class RootLuApproachInstanceAttributeStep_by_step_fine_step_size_percentage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.step_by_step_fine_step_size_percentage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.step_by_step_fine_step_size_percentage.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_fine_step_size_percentage.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.approach.instance.attribute.step_by_step_fine_step_size_percentage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_fine_step_size_percentage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.step_by_step_fine_step_size_percentage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_fine_step_size_percentage.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.step_by_step_fine_step_size_percentage.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_fine_step_size_percentage.min', float(new_val))


class RootLuApproachInstanceAttributeStep_period(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.step_period'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.step_period.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.step_period.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.approach.instance.attribute.step_period.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.approach.instance.attribute.step_period.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.step_period.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.step_period.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.step_period.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.step_period.min', float(new_val))


class RootLuApproachInstanceAttributeStep_by_step_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.step_by_step_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.step_by_step_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.approach.instance.attribute.step_by_step_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.step_by_step_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.step_by_step_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_time.min', float(new_val))


class RootLuApproachInstanceAttributeRetract_tip(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.retract_tip'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.retract_tip.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.retract_tip.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.approach.instance.attribute.retract_tip.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.approach.instance.attribute.retract_tip.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.retract_tip.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.retract_tip.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.retract_tip.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.retract_tip.min', float(new_val))


class RootLuApproachInstanceAttributeStepper_direction(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        forward = 0
        backward = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.stepper_direction'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.approach.instance.attribute.stepper_direction.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.approach.instance.attribute.stepper_direction.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.approach.instance.attribute.stepper_direction.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.approach.instance.attribute.stepper_direction.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.approach.instance.attribute.stepper_direction.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.approach.instance.attribute.stepper_direction.value_raw', new_val.value)


class RootLuApproachInstanceAttributeApproach_steps(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.approach_steps'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.approach_steps.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.approach_steps.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.approach.instance.attribute.approach_steps.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.approach.instance.attribute.approach_steps.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.approach_steps.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.approach_steps.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.approach_steps.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.approach_steps.min', float(new_val))


class RootLuApproachInstanceAttributeStep_by_step_slope(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.step_by_step_slope'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.step_by_step_slope.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_slope.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.approach.instance.attribute.step_by_step_slope.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_slope.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.step_by_step_slope.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_slope.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.step_by_step_slope.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_slope.min', float(new_val))


class RootLuApproachInstanceAttributeApproach_result(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        tip_pos_adjust_failed = 7
        park_position = 8
        approach_done = 1
        no_axis = 10
        user_abort = 5
        tip_pos_adjust_done = 6
        sensor_error = 3
        limit_switch_error = 4
        timeout = 9
        no_error = 0
        end_of_travel = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.approach_result'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.approach.instance.attribute.approach_result.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.approach.instance.attribute.approach_result.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.approach.instance.attribute.approach_result.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.approach.instance.attribute.approach_result.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.approach.instance.attribute.approach_result.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.approach.instance.attribute.approach_result.value_raw', new_val.value)


class RootLuApproachInstanceAttributeApproach_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.approach_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.approach_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.approach_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.approach.instance.attribute.approach_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.approach.instance.attribute.approach_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.approach_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.approach_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.approach_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.approach_speed.min', float(new_val))


class RootLuApproachInstanceAttributeWithdraw_step_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.withdraw_step_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.withdraw_step_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.withdraw_step_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.approach.instance.attribute.withdraw_step_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.approach.instance.attribute.withdraw_step_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.withdraw_step_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.withdraw_step_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.withdraw_step_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.withdraw_step_speed.min', float(new_val))


class RootLuApproachInstanceAttributeStep_by_step_coarse_step_size_percentage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.step_by_step_coarse_step_size_percentage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.step_by_step_coarse_step_size_percentage.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_coarse_step_size_percentage.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.approach.instance.attribute.step_by_step_coarse_step_size_percentage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_coarse_step_size_percentage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.step_by_step_coarse_step_size_percentage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_coarse_step_size_percentage.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.step_by_step_coarse_step_size_percentage.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.step_by_step_coarse_step_size_percentage.min', float(new_val))


class RootLuApproachInstanceAttributeEnable_pre_approach_xycl_calibration(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.enable_pre_approach_xycl_calibration'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.enable_pre_approach_xycl_calibration.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.enable_pre_approach_xycl_calibration.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.approach.instance.attribute.enable_pre_approach_xycl_calibration.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.approach.instance.attribute.enable_pre_approach_xycl_calibration.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.enable_pre_approach_xycl_calibration.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.enable_pre_approach_xycl_calibration.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.enable_pre_approach_xycl_calibration.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.enable_pre_approach_xycl_calibration.min', float(new_val))


class RootLuApproachInstanceAttributeAfm_approach_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        step_by_step = 1
        continuous = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.afm_approach_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.approach.instance.attribute.afm_approach_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.approach.instance.attribute.afm_approach_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.approach.instance.attribute.afm_approach_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.approach.instance.attribute.afm_approach_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.approach.instance.attribute.afm_approach_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.approach.instance.attribute.afm_approach_mode.value_raw', new_val.value)


class RootLuApproachInstanceAttributeApproach_pos_error(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.approach_pos_error'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.approach_pos_error.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.approach_pos_error.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.approach.instance.attribute.approach_pos_error.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.approach.instance.attribute.approach_pos_error.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.approach_pos_error.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.approach_pos_error.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.approach_pos_error.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.approach_pos_error.min', float(new_val))


class RootLuApproachInstanceAttributeWithdraw_step_distance(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.withdraw_step_distance'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.withdraw_step_distance.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.withdraw_step_distance.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.approach.instance.attribute.withdraw_step_distance.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.approach.instance.attribute.withdraw_step_distance.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.withdraw_step_distance.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.withdraw_step_distance.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.withdraw_step_distance.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.withdraw_step_distance.min', float(new_val))


class RootLuApproachInstanceAttributeMotor_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        external = 1
        internal = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.motor_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.approach.instance.attribute.motor_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.approach.instance.attribute.motor_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.approach.instance.attribute.motor_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.approach.instance.attribute.motor_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.approach.instance.attribute.motor_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.approach.instance.attribute.motor_source.value_raw', new_val.value)


class RootLuApproachInstanceAttributeCurrent_z_stage_pos(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.current_z_stage_pos'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.current_z_stage_pos.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.current_z_stage_pos.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.approach.instance.attribute.current_z_stage_pos.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.approach.instance.attribute.current_z_stage_pos.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.current_z_stage_pos.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.current_z_stage_pos.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.current_z_stage_pos.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.current_z_stage_pos.min', float(new_val))


class RootLuApproachInstanceAttributeApproach_pos(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute.approach_pos'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.approach_pos.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.approach_pos.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.approach.instance.attribute.approach_pos.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.approach.instance.attribute.approach_pos.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.approach_pos.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.approach_pos.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.approach.instance.attribute.approach_pos.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.approach.instance.attribute.approach_pos.min', float(new_val))


class RootLuApproachInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance.attribute'
        self.approach_pos = RootLuApproachInstanceAttributeApproach_pos(self._context)
        self.current_z_stage_pos = RootLuApproachInstanceAttributeCurrent_z_stage_pos(self._context)
        self.motor_source = RootLuApproachInstanceAttributeMotor_source(self._context)
        self.withdraw_step_distance = RootLuApproachInstanceAttributeWithdraw_step_distance(self._context)
        self.approach_pos_error = RootLuApproachInstanceAttributeApproach_pos_error(self._context)
        self.afm_approach_mode = RootLuApproachInstanceAttributeAfm_approach_mode(self._context)
        self.enable_pre_approach_xycl_calibration = RootLuApproachInstanceAttributeEnable_pre_approach_xycl_calibration(self._context)
        self.step_by_step_coarse_step_size_percentage = RootLuApproachInstanceAttributeStep_by_step_coarse_step_size_percentage(self._context)
        self.withdraw_step_speed = RootLuApproachInstanceAttributeWithdraw_step_speed(self._context)
        self.approach_speed = RootLuApproachInstanceAttributeApproach_speed(self._context)
        self.approach_result = RootLuApproachInstanceAttributeApproach_result(self._context)
        self.step_by_step_slope = RootLuApproachInstanceAttributeStep_by_step_slope(self._context)
        self.approach_steps = RootLuApproachInstanceAttributeApproach_steps(self._context)
        self.stepper_direction = RootLuApproachInstanceAttributeStepper_direction(self._context)
        self.retract_tip = RootLuApproachInstanceAttributeRetract_tip(self._context)
        self.step_by_step_time = RootLuApproachInstanceAttributeStep_by_step_time(self._context)
        self.step_period = RootLuApproachInstanceAttributeStep_period(self._context)
        self.step_by_step_fine_step_size_percentage = RootLuApproachInstanceAttributeStep_by_step_fine_step_size_percentage(self._context)
        self.step_by_step_mode = RootLuApproachInstanceAttributeStep_by_step_mode(self._context)
        self.withdraw_steps = RootLuApproachInstanceAttributeWithdraw_steps(self._context)
        self.release_tip = RootLuApproachInstanceAttributeRelease_tip(self._context)
        self.gentle_approach_enable = RootLuApproachInstanceAttributeGentle_approach_enable(self._context)
        self.approach_motor_status_external = RootLuApproachInstanceAttributeApproach_motor_status_external(self._context)


class RootLuApproachInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach.instance'
        self.attribute = RootLuApproachInstanceAttribute(self._context)
        self.trigger = RootLuApproachInstanceTrigger(self._context)


class RootLuApproach(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.approach'
        self.instance = RootLuApproachInstance(self._context)


class RootLuIsostageInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.isostage.instance.trigger'

    def setup_event_counter(self) -> None:
        return self._context.call('root.lu.isostage.instance.trigger.setup_event_counter')

    def test_connection(self) -> None:
        return self._context.call('root.lu.isostage.instance.trigger.test_connection')

    def update_settings(self) -> None:
        return self._context.call('root.lu.isostage.instance.trigger.update_settings')

    def clear_event_counter(self) -> None:
        return self._context.call('root.lu.isostage.instance.trigger.clear_event_counter')


class RootLuIsostageInstanceAttributeIsolation_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        off_or_defined_by_user_switch = 1
        active = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.isostage.instance.attribute.isolation_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.isostage.instance.attribute.isolation_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.isostage.instance.attribute.isolation_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.isostage.instance.attribute.isolation_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.isostage.instance.attribute.isolation_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.isostage.instance.attribute.isolation_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.isostage.instance.attribute.isolation_mode.value_raw', new_val.value)


class RootLuIsostageInstanceAttributeIs_connected(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.isostage.instance.attribute.is_connected'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.isostage.instance.attribute.is_connected.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.isostage.instance.attribute.is_connected.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.isostage.instance.attribute.is_connected.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.isostage.instance.attribute.is_connected.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.isostage.instance.attribute.is_connected.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.isostage.instance.attribute.is_connected.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.isostage.instance.attribute.is_connected.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.isostage.instance.attribute.is_connected.min', float(new_val))


class RootLuIsostageInstanceAttributeEvent_counter(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.isostage.instance.attribute.event_counter'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.isostage.instance.attribute.event_counter.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.isostage.instance.attribute.event_counter.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.isostage.instance.attribute.event_counter.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.isostage.instance.attribute.event_counter.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.isostage.instance.attribute.event_counter.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.isostage.instance.attribute.event_counter.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.isostage.instance.attribute.event_counter.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.isostage.instance.attribute.event_counter.min', float(new_val))


class RootLuIsostageInstanceAttributeOverload_sensitivity(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.isostage.instance.attribute.overload_sensitivity'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.isostage.instance.attribute.overload_sensitivity.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.isostage.instance.attribute.overload_sensitivity.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.isostage.instance.attribute.overload_sensitivity.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.isostage.instance.attribute.overload_sensitivity.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.isostage.instance.attribute.overload_sensitivity.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.isostage.instance.attribute.overload_sensitivity.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.isostage.instance.attribute.overload_sensitivity.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.isostage.instance.attribute.overload_sensitivity.min', float(new_val))


class RootLuIsostageInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.isostage.instance.attribute'
        self.overload_sensitivity = RootLuIsostageInstanceAttributeOverload_sensitivity(self._context)
        self.event_counter = RootLuIsostageInstanceAttributeEvent_counter(self._context)
        self.is_connected = RootLuIsostageInstanceAttributeIs_connected(self._context)
        self.isolation_mode = RootLuIsostageInstanceAttributeIsolation_mode(self._context)


class RootLuIsostageInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.isostage.instance'
        self.attribute = RootLuIsostageInstanceAttribute(self._context)
        self.trigger = RootLuIsostageInstanceTrigger(self._context)


class RootLuIsostage(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.isostage'
        self.instance = RootLuIsostageInstance(self._context)


class RootLuOrtInstanceBusy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance.busy'

    @property
    def is_averaging(self) -> bool:
        return bool(self._context.call('root.lu.ort.instance.busy.is_averaging'))


class RootLuOrtInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance.trigger'

    def apply_period_duration(self) -> None:
        return self._context.call('root.lu.ort.instance.trigger.apply_period_duration')

    def transfer_free_wave_data(self) -> None:
        return self._context.call('root.lu.ort.instance.trigger.transfer_free_wave_data')

    def update_free_wave(self) -> None:
        return self._context.call('root.lu.ort.instance.trigger.update_free_wave')

    def apply_samples_values(self) -> None:
        return self._context.call('root.lu.ort.instance.trigger.apply_samples_values')


class RootLuOrtInstanceAttributeDown_sample_factor(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance.attribute.down_sample_factor'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.down_sample_factor.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.down_sample_factor.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ort.instance.attribute.down_sample_factor.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ort.instance.attribute.down_sample_factor.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.down_sample_factor.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.down_sample_factor.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.down_sample_factor.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.down_sample_factor.min', float(new_val))


class RootLuOrtInstanceAttributeExcitation_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance.attribute.excitation_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.excitation_amplitude.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.excitation_amplitude.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ort.instance.attribute.excitation_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ort.instance.attribute.excitation_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.excitation_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.excitation_amplitude.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.excitation_amplitude.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.excitation_amplitude.min', float(new_val))


class RootLuOrtInstanceAttributeBaseline_window_end(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance.attribute.baseline_window_end'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.baseline_window_end.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.baseline_window_end.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ort.instance.attribute.baseline_window_end.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ort.instance.attribute.baseline_window_end.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.baseline_window_end.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.baseline_window_end.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.baseline_window_end.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.baseline_window_end.min', float(new_val))


class RootLuOrtInstanceAttributeBaseline(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance.attribute.baseline'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.baseline.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.baseline.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ort.instance.attribute.baseline.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ort.instance.attribute.baseline.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.baseline.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.baseline.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.baseline.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.baseline.min', float(new_val))


class RootLuOrtInstanceAttributeFeedback_amplitude_average_width(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance.attribute.feedback_amplitude_average_width'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.feedback_amplitude_average_width.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.feedback_amplitude_average_width.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ort.instance.attribute.feedback_amplitude_average_width.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ort.instance.attribute.feedback_amplitude_average_width.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.feedback_amplitude_average_width.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.feedback_amplitude_average_width.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.feedback_amplitude_average_width.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.feedback_amplitude_average_width.min', float(new_val))


class RootLuOrtInstanceAttributeAverage_periods(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance.attribute.average_periods'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.average_periods.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.average_periods.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ort.instance.attribute.average_periods.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ort.instance.attribute.average_periods.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.average_periods.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.average_periods.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.average_periods.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.average_periods.min', float(new_val))


class RootLuOrtInstanceAttributeBaseline_frequency(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance.attribute.baseline_frequency'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.baseline_frequency.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.baseline_frequency.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ort.instance.attribute.baseline_frequency.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ort.instance.attribute.baseline_frequency.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.baseline_frequency.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.baseline_frequency.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.baseline_frequency.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.baseline_frequency.min', float(new_val))


class RootLuOrtInstanceAttributeInput_select(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        hi_res_in_user1 = 3
        fast_in_user_hr_rate = 5
        fast_in_user = 2
        hi_res_in_deflection = 1
        fast_in_deflection_hr_rate = 4
        fast_in_deflection = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance.attribute.input_select'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ort.instance.attribute.input_select.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ort.instance.attribute.input_select.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ort.instance.attribute.input_select.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ort.instance.attribute.input_select.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ort.instance.attribute.input_select.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ort.instance.attribute.input_select.value_raw', new_val.value)


class RootLuOrtInstanceAttributeFree_wave_deflection_to_position_delay(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance.attribute.free_wave_deflection_to_position_delay'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.free_wave_deflection_to_position_delay.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.free_wave_deflection_to_position_delay.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ort.instance.attribute.free_wave_deflection_to_position_delay.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ort.instance.attribute.free_wave_deflection_to_position_delay.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.free_wave_deflection_to_position_delay.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.free_wave_deflection_to_position_delay.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.free_wave_deflection_to_position_delay.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.free_wave_deflection_to_position_delay.min', float(new_val))


class RootLuOrtInstanceAttributeBaseline_controller_state(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance.attribute.baseline_controller_state'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.ort.instance.attribute.baseline_controller_state.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.ort.instance.attribute.baseline_controller_state.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.ort.instance.attribute.baseline_controller_state.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.ort.instance.attribute.baseline_controller_state.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.ort.instance.attribute.baseline_controller_state.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.ort.instance.attribute.baseline_controller_state.value_raw', new_val.value)


class RootLuOrtInstanceAttributeFeedback_amplitude_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance.attribute.feedback_amplitude_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.feedback_amplitude_position.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.feedback_amplitude_position.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ort.instance.attribute.feedback_amplitude_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ort.instance.attribute.feedback_amplitude_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.feedback_amplitude_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.feedback_amplitude_position.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.feedback_amplitude_position.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.feedback_amplitude_position.min', float(new_val))


class RootLuOrtInstanceAttributeBaseline_window_begin(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance.attribute.baseline_window_begin'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.baseline_window_begin.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.baseline_window_begin.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ort.instance.attribute.baseline_window_begin.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ort.instance.attribute.baseline_window_begin.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.baseline_window_begin.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.baseline_window_begin.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.baseline_window_begin.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.baseline_window_begin.min', float(new_val))


class RootLuOrtInstanceAttributePeriod_duration(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance.attribute.period_duration'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.period_duration.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.period_duration.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ort.instance.attribute.period_duration.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ort.instance.attribute.period_duration.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.period_duration.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.period_duration.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.period_duration.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.period_duration.min', float(new_val))


class RootLuOrtInstanceAttributeAmplitude_reduction(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance.attribute.amplitude_reduction'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.amplitude_reduction.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.amplitude_reduction.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ort.instance.attribute.amplitude_reduction.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ort.instance.attribute.amplitude_reduction.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.amplitude_reduction.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.amplitude_reduction.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.amplitude_reduction.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.amplitude_reduction.min', float(new_val))


class RootLuOrtInstanceAttributeExcitation_to_deflection_delay(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance.attribute.excitation_to_deflection_delay'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.excitation_to_deflection_delay.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.excitation_to_deflection_delay.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.ort.instance.attribute.excitation_to_deflection_delay.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.ort.instance.attribute.excitation_to_deflection_delay.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.excitation_to_deflection_delay.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.excitation_to_deflection_delay.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.ort.instance.attribute.excitation_to_deflection_delay.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.ort.instance.attribute.excitation_to_deflection_delay.min', float(new_val))


class RootLuOrtInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance.attribute'
        self.excitation_to_deflection_delay = RootLuOrtInstanceAttributeExcitation_to_deflection_delay(self._context)
        self.amplitude_reduction = RootLuOrtInstanceAttributeAmplitude_reduction(self._context)
        self.period_duration = RootLuOrtInstanceAttributePeriod_duration(self._context)
        self.baseline_window_begin = RootLuOrtInstanceAttributeBaseline_window_begin(self._context)
        self.feedback_amplitude_position = RootLuOrtInstanceAttributeFeedback_amplitude_position(self._context)
        self.baseline_controller_state = RootLuOrtInstanceAttributeBaseline_controller_state(self._context)
        self.free_wave_deflection_to_position_delay = RootLuOrtInstanceAttributeFree_wave_deflection_to_position_delay(self._context)
        self.input_select = RootLuOrtInstanceAttributeInput_select(self._context)
        self.baseline_frequency = RootLuOrtInstanceAttributeBaseline_frequency(self._context)
        self.average_periods = RootLuOrtInstanceAttributeAverage_periods(self._context)
        self.feedback_amplitude_average_width = RootLuOrtInstanceAttributeFeedback_amplitude_average_width(self._context)
        self.baseline = RootLuOrtInstanceAttributeBaseline(self._context)
        self.baseline_window_end = RootLuOrtInstanceAttributeBaseline_window_end(self._context)
        self.excitation_amplitude = RootLuOrtInstanceAttributeExcitation_amplitude(self._context)
        self.down_sample_factor = RootLuOrtInstanceAttributeDown_sample_factor(self._context)


class RootLuOrtInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort.instance'
        self.attribute = RootLuOrtInstanceAttribute(self._context)
        self.trigger = RootLuOrtInstanceTrigger(self._context)
        self.busy = RootLuOrtInstanceBusy(self._context)


class RootLuOrt(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.ort'
        self.instance = RootLuOrtInstance(self._context)


class RootLuMemory_signal_genInstanceBusy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.busy'

    @property
    def is_busy(self) -> bool:
        return bool(self._context.call('root.lu.memory_signal_gen.instance.busy.is_busy'))


class RootLuMemory_signal_genInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.memory_signal_gen.instance.trigger.stop')

    def enable_preset_value(self) -> None:
        return self._context.call('root.lu.memory_signal_gen.instance.trigger.enable_preset_value')

    def start(self) -> None:
        return self._context.call('root.lu.memory_signal_gen.instance.trigger.start')

    def generate_noise_data(self) -> None:
        return self._context.call('root.lu.memory_signal_gen.instance.trigger.generate_noise_data')

    def abort(self) -> None:
        return self._context.call('root.lu.memory_signal_gen.instance.trigger.abort')

    def prepare(self) -> None:
        return self._context.call('root.lu.memory_signal_gen.instance.trigger.prepare')


class RootLuMemory_signal_genInstanceAttributeNoise_amplitude_binary_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.attribute.noise_amplitude_binary_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_binary_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_binary_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_binary_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_binary_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_binary_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_binary_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_binary_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_binary_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_binary_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_binary_vec.min', float(new_val))


class RootLuMemory_signal_genInstanceAttributeNoise_amplitude_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.attribute.noise_amplitude_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.noise_amplitude_vec.min', float(new_val))


class RootLuMemory_signal_genInstanceAttributeOffset_value_binary_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.attribute.offset_value_binary_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.memory_signal_gen.instance.attribute.offset_value_binary_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.offset_value_binary_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.memory_signal_gen.instance.attribute.offset_value_binary_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.offset_value_binary_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.memory_signal_gen.instance.attribute.offset_value_binary_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.memory_signal_gen.instance.attribute.offset_value_binary_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.offset_value_binary_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.offset_value_binary_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.offset_value_binary_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.offset_value_binary_vec.min', float(new_val))


class RootLuMemory_signal_genInstanceAttributeOutput_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.attribute.output_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.memory_signal_gen.instance.attribute.output_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.output_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.memory_signal_gen.instance.attribute.output_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.output_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.memory_signal_gen.instance.attribute.output_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.memory_signal_gen.instance.attribute.output_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.output_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.output_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.output_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.output_vec.min', float(new_val))


class RootLuMemory_signal_genInstanceAttributeOffset_value_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.attribute.offset_value_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.memory_signal_gen.instance.attribute.offset_value_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.offset_value_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.memory_signal_gen.instance.attribute.offset_value_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.offset_value_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.memory_signal_gen.instance.attribute.offset_value_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.memory_signal_gen.instance.attribute.offset_value_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.offset_value_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.offset_value_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.offset_value_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.offset_value_vec.min', float(new_val))


class RootLuMemory_signal_genInstanceAttributeEnd_reached(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.attribute.end_reached'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.end_reached.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.end_reached.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.memory_signal_gen.instance.attribute.end_reached.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.end_reached.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.end_reached.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.end_reached.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.end_reached.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.end_reached.min', float(new_val))


class RootLuMemory_signal_genInstanceAttributeLast_datapoint_value_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_vec.min', float(new_val))


class RootLuMemory_signal_genInstanceAttributeFirst_datapoint_value_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_vec.min', float(new_val))


class RootLuMemory_signal_genInstanceAttributeLast_datapoint_value_binary_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_binary_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_binary_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_binary_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_binary_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_binary_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_binary_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_binary_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_binary_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_binary_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_binary_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.last_datapoint_value_binary_vec.min', float(new_val))


class RootLuMemory_signal_genInstanceAttributeSweep_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.attribute.sweep_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.sweep_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.sweep_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.memory_signal_gen.instance.attribute.sweep_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.sweep_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.sweep_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.sweep_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.sweep_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.sweep_time.min', float(new_val))


class RootLuMemory_signal_genInstanceAttributeFirst_datapoint_value_binary_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_binary_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_binary_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_binary_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_binary_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_binary_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_binary_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_binary_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_binary_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_binary_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_binary_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.first_datapoint_value_binary_vec.min', float(new_val))


class RootLuMemory_signal_genInstanceAttributeData_group_id(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.attribute.data_group_id'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.data_group_id.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.data_group_id.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.memory_signal_gen.instance.attribute.data_group_id.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.data_group_id.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.data_group_id.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.data_group_id.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.data_group_id.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.data_group_id.min', float(new_val))


class RootLuMemory_signal_genInstanceAttributeUnder_run(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.attribute.under_run'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.under_run.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.under_run.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.memory_signal_gen.instance.attribute.under_run.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.under_run.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.under_run.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.under_run.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.under_run.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.under_run.min', float(new_val))


class RootLuMemory_signal_genInstanceAttributeOutput_binary_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.attribute.output_binary_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.memory_signal_gen.instance.attribute.output_binary_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.output_binary_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.memory_signal_gen.instance.attribute.output_binary_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.output_binary_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.memory_signal_gen.instance.attribute.output_binary_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.memory_signal_gen.instance.attribute.output_binary_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.output_binary_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.output_binary_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.output_binary_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.output_binary_vec.min', float(new_val))


class RootLuMemory_signal_genInstanceAttributeLinear_interpolation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.attribute.linear_interpolation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.memory_signal_gen.instance.attribute.linear_interpolation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.linear_interpolation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.memory_signal_gen.instance.attribute.linear_interpolation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.linear_interpolation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.memory_signal_gen.instance.attribute.linear_interpolation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.linear_interpolation.value_raw', new_val.value)


class RootLuMemory_signal_genInstanceAttributeCurrent_datapoint(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.attribute.current_datapoint'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.current_datapoint.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.current_datapoint.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.memory_signal_gen.instance.attribute.current_datapoint.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.current_datapoint.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.current_datapoint.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.current_datapoint.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.memory_signal_gen.instance.attribute.current_datapoint.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.current_datapoint.min', float(new_val))


class RootLuMemory_signal_genInstanceAttributeJoin(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.attribute.join'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.memory_signal_gen.instance.attribute.join.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.join.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.memory_signal_gen.instance.attribute.join.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.join.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.memory_signal_gen.instance.attribute.join.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.memory_signal_gen.instance.attribute.join.value_raw', new_val.value)


class RootLuMemory_signal_genInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance.attribute'
        self.join = RootLuMemory_signal_genInstanceAttributeJoin(self._context)
        self.current_datapoint = RootLuMemory_signal_genInstanceAttributeCurrent_datapoint(self._context)
        self.linear_interpolation = RootLuMemory_signal_genInstanceAttributeLinear_interpolation(self._context)
        self.output_binary_vec = RootLuMemory_signal_genInstanceAttributeOutput_binary_vec(self._context)
        self.under_run = RootLuMemory_signal_genInstanceAttributeUnder_run(self._context)
        self.data_group_id = RootLuMemory_signal_genInstanceAttributeData_group_id(self._context)
        self.first_datapoint_value_binary_vec = RootLuMemory_signal_genInstanceAttributeFirst_datapoint_value_binary_vec(self._context)
        self.sweep_time = RootLuMemory_signal_genInstanceAttributeSweep_time(self._context)
        self.last_datapoint_value_binary_vec = RootLuMemory_signal_genInstanceAttributeLast_datapoint_value_binary_vec(self._context)
        self.first_datapoint_value_vec = RootLuMemory_signal_genInstanceAttributeFirst_datapoint_value_vec(self._context)
        self.last_datapoint_value_vec = RootLuMemory_signal_genInstanceAttributeLast_datapoint_value_vec(self._context)
        self.end_reached = RootLuMemory_signal_genInstanceAttributeEnd_reached(self._context)
        self.offset_value_vec = RootLuMemory_signal_genInstanceAttributeOffset_value_vec(self._context)
        self.output_vec = RootLuMemory_signal_genInstanceAttributeOutput_vec(self._context)
        self.offset_value_binary_vec = RootLuMemory_signal_genInstanceAttributeOffset_value_binary_vec(self._context)
        self.noise_amplitude_vec = RootLuMemory_signal_genInstanceAttributeNoise_amplitude_vec(self._context)
        self.noise_amplitude_binary_vec = RootLuMemory_signal_genInstanceAttributeNoise_amplitude_binary_vec(self._context)


class RootLuMemory_signal_genInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen.instance'
        self.attribute = RootLuMemory_signal_genInstanceAttribute(self._context)
        self.trigger = RootLuMemory_signal_genInstanceTrigger(self._context)
        self.busy = RootLuMemory_signal_genInstanceBusy(self._context)


class RootLuMemory_signal_gen(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.memory_signal_gen'
        self.instance = RootLuMemory_signal_genInstance(self._context)


class RootLuTestInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.test.instance.trigger'

    def force_all_dac_to_max(self) -> None:
        return self._context.call('root.lu.test.instance.trigger.force_all_dac_to_max')

    def force_all_dac_to_zero(self) -> None:
        return self._context.call('root.lu.test.instance.trigger.force_all_dac_to_zero')

    def force_all_dac_to_min(self) -> None:
        return self._context.call('root.lu.test.instance.trigger.force_all_dac_to_min')

    def test(self) -> None:
        return self._context.call('root.lu.test.instance.trigger.test')


class RootLuTestInstanceAttributeTest(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.test.instance.attribute.test'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.test.instance.attribute.test.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.test.instance.attribute.test.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.test.instance.attribute.test.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.test.instance.attribute.test.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.test.instance.attribute.test.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.test.instance.attribute.test.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.test.instance.attribute.test.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.test.instance.attribute.test.min', float(new_val))


class RootLuTestInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.test.instance.attribute'
        self.test = RootLuTestInstanceAttributeTest(self._context)


class RootLuTestInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.test.instance'
        self.attribute = RootLuTestInstanceAttribute(self._context)
        self.trigger = RootLuTestInstanceTrigger(self._context)


class RootLuTest(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.test'
        self.instance = RootLuTestInstance(self._context)


class RootLuTimerDbg1Busy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.dbg1.busy'

    @property
    def is_busy(self) -> bool:
        return bool(self._context.call('root.lu.timer.dbg1.busy.is_busy'))


class RootLuTimerDbg1Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.dbg1.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.timer.dbg1.trigger.stop')

    def abort(self) -> None:
        return self._context.call('root.lu.timer.dbg1.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.timer.dbg1.trigger.start')


class RootLuTimerDbg1AttributeCounter_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.dbg1.attribute.counter_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.timer.dbg1.attribute.counter_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.timer.dbg1.attribute.counter_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.timer.dbg1.attribute.counter_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.timer.dbg1.attribute.counter_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.timer.dbg1.attribute.counter_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.timer.dbg1.attribute.counter_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.timer.dbg1.attribute.counter_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.timer.dbg1.attribute.counter_value.min', float(new_val))


class RootLuTimerDbg1AttributeCounter_max(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.dbg1.attribute.counter_max'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.timer.dbg1.attribute.counter_max.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.timer.dbg1.attribute.counter_max.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.timer.dbg1.attribute.counter_max.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.timer.dbg1.attribute.counter_max.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.timer.dbg1.attribute.counter_max.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.timer.dbg1.attribute.counter_max.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.timer.dbg1.attribute.counter_max.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.timer.dbg1.attribute.counter_max.min', float(new_val))


class RootLuTimerDbg1AttributeDelay_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.dbg1.attribute.delay_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.timer.dbg1.attribute.delay_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.timer.dbg1.attribute.delay_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.timer.dbg1.attribute.delay_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.timer.dbg1.attribute.delay_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.timer.dbg1.attribute.delay_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.timer.dbg1.attribute.delay_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.timer.dbg1.attribute.delay_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.timer.dbg1.attribute.delay_time.min', float(new_val))


class RootLuTimerDbg1AttributeCounter_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        digital_sync1 = 0
        digital_sync2 = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.dbg1.attribute.counter_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.timer.dbg1.attribute.counter_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.timer.dbg1.attribute.counter_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.timer.dbg1.attribute.counter_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.timer.dbg1.attribute.counter_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.timer.dbg1.attribute.counter_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.timer.dbg1.attribute.counter_input.value_raw', new_val.value)


class RootLuTimerDbg1AttributeCurrent_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.dbg1.attribute.current_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.timer.dbg1.attribute.current_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.timer.dbg1.attribute.current_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.timer.dbg1.attribute.current_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.timer.dbg1.attribute.current_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.timer.dbg1.attribute.current_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.timer.dbg1.attribute.current_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.timer.dbg1.attribute.current_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.timer.dbg1.attribute.current_time.min', float(new_val))


class RootLuTimerDbg1AttributeMode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        delay_timer = 0
        event_counter = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.dbg1.attribute.mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.timer.dbg1.attribute.mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.timer.dbg1.attribute.mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.timer.dbg1.attribute.mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.timer.dbg1.attribute.mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.timer.dbg1.attribute.mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.timer.dbg1.attribute.mode.value_raw', new_val.value)


class RootLuTimerDbg1Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.dbg1.attribute'
        self.mode = RootLuTimerDbg1AttributeMode(self._context)
        self.current_time = RootLuTimerDbg1AttributeCurrent_time(self._context)
        self.counter_input = RootLuTimerDbg1AttributeCounter_input(self._context)
        self.delay_time = RootLuTimerDbg1AttributeDelay_time(self._context)
        self.counter_max = RootLuTimerDbg1AttributeCounter_max(self._context)
        self.counter_value = RootLuTimerDbg1AttributeCounter_value(self._context)


class RootLuTimerDbg1(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.dbg1'
        self.attribute = RootLuTimerDbg1Attribute(self._context)
        self.trigger = RootLuTimerDbg1Trigger(self._context)
        self.busy = RootLuTimerDbg1Busy(self._context)


class RootLuTimerProc0Busy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.proc0.busy'

    @property
    def is_busy(self) -> bool:
        return bool(self._context.call('root.lu.timer.proc0.busy.is_busy'))


class RootLuTimerProc0Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.proc0.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.timer.proc0.trigger.stop')

    def abort(self) -> None:
        return self._context.call('root.lu.timer.proc0.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.timer.proc0.trigger.start')


class RootLuTimerProc0AttributeCounter_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.proc0.attribute.counter_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.timer.proc0.attribute.counter_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.timer.proc0.attribute.counter_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.timer.proc0.attribute.counter_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.timer.proc0.attribute.counter_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.timer.proc0.attribute.counter_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.timer.proc0.attribute.counter_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.timer.proc0.attribute.counter_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.timer.proc0.attribute.counter_value.min', float(new_val))


class RootLuTimerProc0AttributeCounter_max(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.proc0.attribute.counter_max'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.timer.proc0.attribute.counter_max.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.timer.proc0.attribute.counter_max.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.timer.proc0.attribute.counter_max.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.timer.proc0.attribute.counter_max.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.timer.proc0.attribute.counter_max.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.timer.proc0.attribute.counter_max.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.timer.proc0.attribute.counter_max.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.timer.proc0.attribute.counter_max.min', float(new_val))


class RootLuTimerProc0AttributeDelay_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.proc0.attribute.delay_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.timer.proc0.attribute.delay_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.timer.proc0.attribute.delay_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.timer.proc0.attribute.delay_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.timer.proc0.attribute.delay_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.timer.proc0.attribute.delay_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.timer.proc0.attribute.delay_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.timer.proc0.attribute.delay_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.timer.proc0.attribute.delay_time.min', float(new_val))


class RootLuTimerProc0AttributeCounter_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        digital_sync1 = 0
        digital_sync2 = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.proc0.attribute.counter_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.timer.proc0.attribute.counter_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.timer.proc0.attribute.counter_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.timer.proc0.attribute.counter_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.timer.proc0.attribute.counter_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.timer.proc0.attribute.counter_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.timer.proc0.attribute.counter_input.value_raw', new_val.value)


class RootLuTimerProc0AttributeCurrent_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.proc0.attribute.current_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.timer.proc0.attribute.current_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.timer.proc0.attribute.current_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.timer.proc0.attribute.current_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.timer.proc0.attribute.current_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.timer.proc0.attribute.current_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.timer.proc0.attribute.current_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.timer.proc0.attribute.current_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.timer.proc0.attribute.current_time.min', float(new_val))


class RootLuTimerProc0AttributeMode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        delay_timer = 0
        event_counter = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.proc0.attribute.mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.timer.proc0.attribute.mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.timer.proc0.attribute.mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.timer.proc0.attribute.mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.timer.proc0.attribute.mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.timer.proc0.attribute.mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.timer.proc0.attribute.mode.value_raw', new_val.value)


class RootLuTimerProc0Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.proc0.attribute'
        self.mode = RootLuTimerProc0AttributeMode(self._context)
        self.current_time = RootLuTimerProc0AttributeCurrent_time(self._context)
        self.counter_input = RootLuTimerProc0AttributeCounter_input(self._context)
        self.delay_time = RootLuTimerProc0AttributeDelay_time(self._context)
        self.counter_max = RootLuTimerProc0AttributeCounter_max(self._context)
        self.counter_value = RootLuTimerProc0AttributeCounter_value(self._context)


class RootLuTimerProc0(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer.proc0'
        self.attribute = RootLuTimerProc0Attribute(self._context)
        self.trigger = RootLuTimerProc0Trigger(self._context)
        self.busy = RootLuTimerProc0Busy(self._context)


class RootLuTimer(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.timer'
        self.proc0 = RootLuTimerProc0(self._context)
        self.dbg1 = RootLuTimerDbg1(self._context)


class RootLuDigi_user_ioInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.digi_user_io.instance.trigger'


class RootLuDigi_user_ioInstanceAttributeDigi_in2_level(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        low = 0
        high = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.digi_user_io.instance.attribute.digi_in2_level'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.digi_user_io.instance.attribute.digi_in2_level.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_in2_level.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.digi_user_io.instance.attribute.digi_in2_level.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_in2_level.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.digi_user_io.instance.attribute.digi_in2_level.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_in2_level.value_raw', new_val.value)


class RootLuDigi_user_ioInstanceAttributeDigi_out1_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        static_level = 0
        event_rising_and_falling_edge_pulse = 4
        event_rising_edge_pulse = 2
        event_falling_edge_pulse = 3
        event_level = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.digi_user_io.instance.attribute.digi_out1_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out1_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out1_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out1_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out1_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out1_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out1_mode.value_raw', new_val.value)


class RootLuDigi_user_ioInstanceAttributeDigi_out2_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.digi_user_io.instance.attribute.digi_out2_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out2_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out2_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out2_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out2_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out2_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out2_enable.value_raw', new_val.value)


class RootLuDigi_user_ioInstanceAttributeDigi_in1_level(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        low = 0
        high = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.digi_user_io.instance.attribute.digi_in1_level'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.digi_user_io.instance.attribute.digi_in1_level.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_in1_level.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.digi_user_io.instance.attribute.digi_in1_level.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_in1_level.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.digi_user_io.instance.attribute.digi_in1_level.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_in1_level.value_raw', new_val.value)


class RootLuDigi_user_ioInstanceAttributeDigi_out2_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        static_level = 0
        event_rising_and_falling_edge_pulse = 4
        event_rising_edge_pulse = 2
        event_falling_edge_pulse = 3
        event_level = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.digi_user_io.instance.attribute.digi_out2_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out2_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out2_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out2_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out2_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out2_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out2_mode.value_raw', new_val.value)


class RootLuDigi_user_ioInstanceAttributeDigi_out1_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.digi_user_io.instance.attribute.digi_out1_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out1_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out1_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out1_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out1_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out1_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out1_enable.value_raw', new_val.value)


class RootLuDigi_user_ioInstanceAttributeDigi_out1_level(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        low = 0
        high = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.digi_user_io.instance.attribute.digi_out1_level'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out1_level.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out1_level.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out1_level.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out1_level.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out1_level.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out1_level.value_raw', new_val.value)


class RootLuDigi_user_ioInstanceAttributeDigi_out1_event_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        data_sampling_done = 1
        timer_proc0_done = 11
        ramp_gen_maxz_done = 7
        z_ctrl_reached_min_z_true = 19
        mem_sig_gen_done = 12
        soft_event1_true = 25
        ramp_gen_user4_done = 14
        event_manager_done = 2
        ramp_gen_positionw_done = 16
        and_mask0_true = 28
        data_capture_done = 0
        z_ctrl_reached_error_limit_true = 18
        user_abort_event_true = 27
        comparator2_true = 30
        timer_dbg1_done = 15
        comparator1_true = 29
        static_value = 17
        ext_event1_true = 23
        z_ctrl_reached_max_z_true = 20
        soft_event0_true = 24
        ramp_gen_test_done = 13
        ramp_gen_ctrlz_done = 6
        ramp_gen_positiony_done = 4
        ramp_gen_tipvoltage_done = 9
        ramp_gen_approach_done = 10
        comparator3_true = 31
        ramp_gen_alternatez_done = 8
        ramp_gen_planez_done = 5
        ramp_gen_positionx_done = 3
        soft_event2_true = 26
        ext_event0_true = 22

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.digi_user_io.instance.attribute.digi_out1_event_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out1_event_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out1_event_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out1_event_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out1_event_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out1_event_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out1_event_source.value_raw', new_val.value)


class RootLuDigi_user_ioInstanceAttributeDigi_out2_pulse(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        t20_ms = 5
        t5_us = 1
        t5_ms = 4
        t0_5_us = 0
        t50_us = 2
        t500_us = 3

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.digi_user_io.instance.attribute.digi_out2_pulse'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out2_pulse.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out2_pulse.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out2_pulse.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out2_pulse.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out2_pulse.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out2_pulse.value_raw', new_val.value)


class RootLuDigi_user_ioInstanceAttributeDigi_out1_pulse(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        t20_ms = 5
        t5_us = 1
        t5_ms = 4
        t0_5_us = 0
        t50_us = 2
        t500_us = 3

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.digi_user_io.instance.attribute.digi_out1_pulse'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out1_pulse.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out1_pulse.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out1_pulse.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out1_pulse.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out1_pulse.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out1_pulse.value_raw', new_val.value)


class RootLuDigi_user_ioInstanceAttributeDigi_out2_event_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        data_sampling_done = 1
        timer_proc0_done = 11
        ramp_gen_maxz_done = 7
        z_ctrl_reached_min_z_true = 19
        mem_sig_gen_done = 12
        soft_event1_true = 25
        ramp_gen_user4_done = 14
        event_manager_done = 2
        ramp_gen_positionw_done = 16
        and_mask0_true = 28
        data_capture_done = 0
        z_ctrl_reached_error_limit_true = 18
        user_abort_event_true = 27
        comparator2_true = 30
        timer_dbg1_done = 15
        comparator1_true = 29
        static_value = 17
        ext_event1_true = 23
        z_ctrl_reached_max_z_true = 20
        soft_event0_true = 24
        ramp_gen_test_done = 13
        ramp_gen_ctrlz_done = 6
        ramp_gen_positiony_done = 4
        ramp_gen_tipvoltage_done = 9
        ramp_gen_approach_done = 10
        comparator3_true = 31
        ramp_gen_alternatez_done = 8
        ramp_gen_planez_done = 5
        ramp_gen_positionx_done = 3
        soft_event2_true = 26
        ext_event0_true = 22

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.digi_user_io.instance.attribute.digi_out2_event_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out2_event_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out2_event_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out2_event_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out2_event_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out2_event_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out2_event_source.value_raw', new_val.value)


class RootLuDigi_user_ioInstanceAttributeDigi_out2_level(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        low = 0
        high = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.digi_user_io.instance.attribute.digi_out2_level'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out2_level.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out2_level.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out2_level.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out2_level.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.digi_user_io.instance.attribute.digi_out2_level.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.digi_user_io.instance.attribute.digi_out2_level.value_raw', new_val.value)


class RootLuDigi_user_ioInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.digi_user_io.instance.attribute'
        self.digi_out2_level = RootLuDigi_user_ioInstanceAttributeDigi_out2_level(self._context)
        self.digi_out2_event_source = RootLuDigi_user_ioInstanceAttributeDigi_out2_event_source(self._context)
        self.digi_out1_pulse = RootLuDigi_user_ioInstanceAttributeDigi_out1_pulse(self._context)
        self.digi_out2_pulse = RootLuDigi_user_ioInstanceAttributeDigi_out2_pulse(self._context)
        self.digi_out1_event_source = RootLuDigi_user_ioInstanceAttributeDigi_out1_event_source(self._context)
        self.digi_out1_level = RootLuDigi_user_ioInstanceAttributeDigi_out1_level(self._context)
        self.digi_out1_enable = RootLuDigi_user_ioInstanceAttributeDigi_out1_enable(self._context)
        self.digi_out2_mode = RootLuDigi_user_ioInstanceAttributeDigi_out2_mode(self._context)
        self.digi_in1_level = RootLuDigi_user_ioInstanceAttributeDigi_in1_level(self._context)
        self.digi_out2_enable = RootLuDigi_user_ioInstanceAttributeDigi_out2_enable(self._context)
        self.digi_out1_mode = RootLuDigi_user_ioInstanceAttributeDigi_out1_mode(self._context)
        self.digi_in2_level = RootLuDigi_user_ioInstanceAttributeDigi_in2_level(self._context)


class RootLuDigi_user_ioInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.digi_user_io.instance'
        self.attribute = RootLuDigi_user_ioInstanceAttribute(self._context)
        self.trigger = RootLuDigi_user_ioInstanceTrigger(self._context)


class RootLuDigi_user_io(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.digi_user_io'
        self.instance = RootLuDigi_user_ioInstance(self._context)


class RootLuZ_controller_exInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.z_controller_ex.instance.trigger.stop')

    def start_simple(self) -> None:
        return self._context.call('root.lu.z_controller_ex.instance.trigger.start_simple')

    def apply_max_z_value(self) -> None:
        return self._context.call('root.lu.z_controller_ex.instance.trigger.apply_max_z_value')

    def start(self) -> None:
        return self._context.call('root.lu.z_controller_ex.instance.trigger.start')

    def abort(self) -> None:
        return self._context.call('root.lu.z_controller_ex.instance.trigger.abort')

    def wait_for_z_controller_adjust(self) -> None:
        return self._context.call('root.lu.z_controller_ex.instance.trigger.wait_for_z_controller_adjust')

    def init_phase_move(self) -> None:
        return self._context.call('root.lu.z_controller_ex.instance.trigger.init_phase_move')

    def update_base_line_pos(self) -> None:
        return self._context.call('root.lu.z_controller_ex.instance.trigger.update_base_line_pos')

    def validate_on_surface(self) -> None:
        return self._context.call('root.lu.z_controller_ex.instance.trigger.validate_on_surface')

    def reset_tip_guard_active(self) -> None:
        return self._context.call('root.lu.z_controller_ex.instance.trigger.reset_tip_guard_active')


class RootLuZ_controller_exInstanceAttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_output_value.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeInput_compare_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.input_compare_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.input_compare_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.input_compare_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.input_compare_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.input_compare_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.input_compare_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.input_compare_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.input_compare_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.input_compare_value.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeMax_z_value_change_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.max_z_value_change_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.max_z_value_change_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.max_z_value_change_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.max_z_value_change_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.max_z_value_change_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.max_z_value_change_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.max_z_value_change_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.max_z_value_change_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.max_z_value_change_speed.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeFeedback_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.feedback_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.feedback_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.feedback_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.feedback_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.feedback_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.z_controller_ex.instance.attribute.feedback_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.z_controller_ex.instance.attribute.feedback_polarity.value_raw', new_val.value)


class RootLuZ_controller_exInstanceAttributeClosed_loop_polarity(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.closed_loop_polarity'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.closed_loop_polarity.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.closed_loop_polarity.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.closed_loop_polarity.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.closed_loop_polarity.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.closed_loop_polarity.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.closed_loop_polarity.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.closed_loop_polarity.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.closed_loop_polarity.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeTip_guard_current_states(wrap.CmdTreeProp):

    class ValueMask(enum.IntEnum):
        all = 15
        deflection = 2
        user_channel = 8
        detector_sum = 1
        none = 0
        z_ctrl_in = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.tip_guard_current_states'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_current_states.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_current_states.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_current_states.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_current_states.enum', list(new_val))

    @property
    def value(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_current_states.value_raw'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_current_states.value_raw', int(new_val))


class RootLuZ_controller_exInstanceAttributeCurrent_limited_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.current_limited_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_limited_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_limited_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.current_limited_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_limited_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_limited_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_limited_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_limited_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_limited_value.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeCtrl_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 44
        analyzer1_amplitude = 8
        ramp_gen_max_z = 41
        ctrl_x_out = 48
        analyzer2_reference = 68
        analyzer2_ctrl_amplitude = 14
        comparator1_out = 59
        ort_excitation = 69
        ramp_gen_tip_voltage = 36
        memory_gen_out8 = 31
        fast_in_user = 66
        analyzer1_x = 53
        memory_gen_position_z = 28
        ctrl_w_out = 50
        analyzer1_y = 54
        analyzer2_amplitude = 12
        in_user1 = 3
        ramp_gen_user4 = 38
        memory_gen_out7 = 30
        ramp_gen_position_y = 34
        ramp_gen_position_x = 33
        ctrl_user1_out = 51
        in_tip_current = 7
        in_position_y = 21
        comparator2_in_filtered = 60
        analyzer2_x = 55
        memory_gen_position_y = 26
        memory_gen_position_x = 24
        ctrl_z_error = 43
        comparator1_in_filtered = 58
        ctrl_z_nominal = 46
        analyzer1_reference = 67
        analyzer1_phase = 9
        comparator2_out = 61
        analyzer2_phase = 13
        analyzer1_ctrl_delta_f = 11
        memory_gen_drive_y = 27
        ctrl_z_sum = 45
        ramp_gen_alternate_z = 37
        comparator3_in_filtered = 62
        ctrl_user2_out = 52
        analyzer2_ctrl_delta_f = 15
        analyzer2_y = 56
        in_detector_sum = 22
        fast_in2 = 65
        in_position_x = 20
        in_user4 = 6
        static = 17
        ramp_gen_ctrl_z = 40
        ramp_gen_test = 19
        memory_gen_drive_z = 29
        ramp_gen_position_w = 35
        comparator3_out = 63
        ramp_gen_plane_z = 39
        ramp_gen_approach = 32
        ort_baseline = 57
        ort_amplitude_reduction = 16
        analyzer1_ctrl_amplitude = 10
        ctrl_y_out = 49
        ctrl_z_in = 42
        in_position_z = 2
        fast_in_deflection = 64
        memory_gen_drive_x = 25
        in6 = 23
        ctrl_z_out = 47
        in_user3 = 5
        in_user2 = 4
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 18

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.ctrl_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.ctrl_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.ctrl_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.ctrl_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.ctrl_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.z_controller_ex.instance.attribute.ctrl_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.z_controller_ex.instance.attribute.ctrl_input.value_raw', new_val.value)


class RootLuZ_controller_exInstanceAttributeTip_guard_user_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.tip_guard_user_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_user_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_user_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_user_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_user_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_user_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_user_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_user_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_user_limit.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeBase_line_pos(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.base_line_pos'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.base_line_pos.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.base_line_pos.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.base_line_pos.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.base_line_pos.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.base_line_pos.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.base_line_pos.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.base_line_pos.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.base_line_pos.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeMemory_signal_gen_drive_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.memory_signal_gen_drive_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.memory_signal_gen_drive_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.memory_signal_gen_drive_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.memory_signal_gen_drive_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.memory_signal_gen_drive_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.z_controller_ex.instance.attribute.memory_signal_gen_drive_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.z_controller_ex.instance.attribute.memory_signal_gen_drive_enable.value_raw', new_val.value)


class RootLuZ_controller_exInstanceAttributeMin_z_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.min_z_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.min_z_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.min_z_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.min_z_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.min_z_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.min_z_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.min_z_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.min_z_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.min_z_value.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeOutput_compare_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.output_compare_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.output_compare_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.output_compare_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.output_compare_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.output_compare_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.output_compare_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.output_compare_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.output_compare_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.output_compare_value.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeCurrent_status_flags(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.current_status_flags'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_status_flags.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_status_flags.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.current_status_flags.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_status_flags.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_status_flags.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_status_flags.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_status_flags.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_status_flags.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeOutput_modulation_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.output_modulation_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.output_modulation_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.output_modulation_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.output_modulation_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.output_modulation_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.z_controller_ex.instance.attribute.output_modulation_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.z_controller_ex.instance.attribute.output_modulation_enable.value_raw', new_val.value)


class RootLuZ_controller_exInstanceAttributePhase_move_end_mode_vec(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        move_relative = 1
        move_to_absolute = 0
        pause = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.phase_move_end_mode_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_end_mode_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_end_mode_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_end_mode_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_end_mode_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.z_controller_ex.instance.attribute.phase_move_end_mode_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.z_controller_ex.instance.attribute.phase_move_end_mode_vec.set_vector_value', int(index), new_val)

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_end_mode_vec.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_end_mode_vec.enum', list(new_val))

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_end_mode_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_end_mode_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_end_mode_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_end_mode_vec.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeTip_guard_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.tip_guard_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_speed.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeTip_guard_user_compare_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        equal_or_higher_than = 0
        equal_or_lower_than = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.tip_guard_user_compare_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_user_compare_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_user_compare_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_user_compare_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_user_compare_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_user_compare_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_user_compare_mode.value_raw', new_val.value)


class RootLuZ_controller_exInstanceAttributePhase_move_stop_by_value_active_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.phase_move_stop_by_value_active_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_stop_by_value_active_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_stop_by_value_active_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_stop_by_value_active_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_stop_by_value_active_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.z_controller_ex.instance.attribute.phase_move_stop_by_value_active_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.z_controller_ex.instance.attribute.phase_move_stop_by_value_active_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_stop_by_value_active_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_stop_by_value_active_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_stop_by_value_active_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_stop_by_value_active_vec.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeDdc_filter_rate(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.ddc_filter_rate'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.ddc_filter_rate.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.ddc_filter_rate.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.ddc_filter_rate.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.ddc_filter_rate.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.ddc_filter_rate.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.ddc_filter_rate.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.ddc_filter_rate.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.ddc_filter_rate.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeMemory_signal_gen_position_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.memory_signal_gen_position_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.memory_signal_gen_position_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.memory_signal_gen_position_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.memory_signal_gen_position_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.memory_signal_gen_position_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.z_controller_ex.instance.attribute.memory_signal_gen_position_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.z_controller_ex.instance.attribute.memory_signal_gen_position_enable.value_raw', new_val.value)


class RootLuZ_controller_exInstanceAttributePhase_move_time_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.phase_move_time_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_time_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_time_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_time_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_time_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.z_controller_ex.instance.attribute.phase_move_time_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.z_controller_ex.instance.attribute.phase_move_time_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_time_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_time_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_time_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_time_vec.min', float(new_val))


class RootLuZ_controller_exInstanceAttributePhase_pause_time_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.phase_pause_time_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_pause_time_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_pause_time_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_pause_time_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_pause_time_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.z_controller_ex.instance.attribute.phase_pause_time_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.z_controller_ex.instance.attribute.phase_pause_time_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_pause_time_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_pause_time_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_pause_time_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_pause_time_vec.min', float(new_val))


class RootLuZ_controller_exInstanceAttributePhase_real_end_pos_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.phase_real_end_pos_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_real_end_pos_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_real_end_pos_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_real_end_pos_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_real_end_pos_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.z_controller_ex.instance.attribute.phase_real_end_pos_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.z_controller_ex.instance.attribute.phase_real_end_pos_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_real_end_pos_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_real_end_pos_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_real_end_pos_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_real_end_pos_vec.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeSet_point(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.set_point'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.set_point.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.set_point.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.set_point.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.set_point.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.set_point.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.set_point.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.set_point.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.set_point.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeSet_point_modulation_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.set_point_modulation_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.set_point_modulation_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.set_point_modulation_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.set_point_modulation_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.set_point_modulation_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.z_controller_ex.instance.attribute.set_point_modulation_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.z_controller_ex.instance.attribute.set_point_modulation_enable.value_raw', new_val.value)


class RootLuZ_controller_exInstanceAttributeCurrent_phase(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.current_phase'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_phase.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_phase.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.current_phase.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_phase.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_phase.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_phase.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_phase.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_phase.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeProportional_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.proportional_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.proportional_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.proportional_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.proportional_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.proportional_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.proportional_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.proportional_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.proportional_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.proportional_gain.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeTip_guard_deflection_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.tip_guard_deflection_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_deflection_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_deflection_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_deflection_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_deflection_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_deflection_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_deflection_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_deflection_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_deflection_limit.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeClosed_loop_i_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.closed_loop_i_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.closed_loop_i_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.closed_loop_i_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.closed_loop_i_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.closed_loop_i_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.closed_loop_i_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.closed_loop_i_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.closed_loop_i_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.closed_loop_i_gain.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeClosed_loop_p_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.closed_loop_p_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.closed_loop_p_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.closed_loop_p_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.closed_loop_p_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.closed_loop_p_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.closed_loop_p_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.closed_loop_p_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.closed_loop_p_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.closed_loop_p_gain.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeTip_guard_criteria_enable_mask(wrap.CmdTreeProp):

    class ValueMask(enum.IntEnum):
        all = 15
        deflection = 2
        user_channel = 8
        detector_sum = 1
        none = 0
        z_ctrl_in = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.tip_guard_criteria_enable_mask'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_criteria_enable_mask.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_criteria_enable_mask.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_criteria_enable_mask.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_criteria_enable_mask.enum', list(new_val))

    @property
    def value(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_criteria_enable_mask.value_raw'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_criteria_enable_mask.value_raw', int(new_val))


class RootLuZ_controller_exInstanceAttributeMax_z_current_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.max_z_current_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.max_z_current_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.max_z_current_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.max_z_current_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.max_z_current_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.max_z_current_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.max_z_current_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.max_z_current_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.max_z_current_value.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeMax_z_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.max_z_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.max_z_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.max_z_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.max_z_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.max_z_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.max_z_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.max_z_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.max_z_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.max_z_value.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeIntegral_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.integral_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.integral_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.integral_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.integral_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.integral_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.integral_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.integral_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.integral_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.integral_gain.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeDdc_filter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.ddc_filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.ddc_filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.ddc_filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.ddc_filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.ddc_filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.ddc_filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.ddc_filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.ddc_filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.ddc_filter_number.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeSet_point_modulation_scale_factor(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.set_point_modulation_scale_factor'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.set_point_modulation_scale_factor.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.set_point_modulation_scale_factor.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.set_point_modulation_scale_factor.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.set_point_modulation_scale_factor.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.set_point_modulation_scale_factor.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.set_point_modulation_scale_factor.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.set_point_modulation_scale_factor.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.set_point_modulation_scale_factor.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeZ_controller_adjust_timed_out(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.z_controller_adjust_timed_out'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.z_controller_adjust_timed_out.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.z_controller_adjust_timed_out.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.z_controller_adjust_timed_out.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.z_controller_adjust_timed_out.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.z_controller_adjust_timed_out.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.z_controller_adjust_timed_out.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.z_controller_adjust_timed_out.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.z_controller_adjust_timed_out.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeTip_guard_current_active_state(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.tip_guard_current_active_state'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_current_active_state.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_current_active_state.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_current_active_state.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_current_active_state.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_current_active_state.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_current_active_state.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_current_active_state.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_current_active_state.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeOutput_compare_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        equal_or_higher_than = 0
        equal_or_lower_than = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.output_compare_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.output_compare_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.output_compare_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.output_compare_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.output_compare_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.z_controller_ex.instance.attribute.output_compare_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.z_controller_ex.instance.attribute.output_compare_mode.value_raw', new_val.value)


class RootLuZ_controller_exInstanceAttributePhase_init_phase_count(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.phase_init_phase_count'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_init_phase_count.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_init_phase_count.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_init_phase_count.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_init_phase_count.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_init_phase_count.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_init_phase_count.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_init_phase_count.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_init_phase_count.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeTip_guard_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.tip_guard_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_enable.value_raw', new_val.value)


class RootLuZ_controller_exInstanceAttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.z_controller_ex.instance.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.z_controller_ex.instance.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.filter_coeff_vec.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeCurrent_input_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.current_input_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_input_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_input_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.current_input_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_input_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_input_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_input_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_input_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_input_value.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeTip_guard_last_active_states(wrap.CmdTreeProp):

    class ValueMask(enum.IntEnum):
        all = 15
        deflection = 2
        user_channel = 8
        detector_sum = 1
        none = 0
        z_ctrl_in = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.tip_guard_last_active_states'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_last_active_states.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_last_active_states.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_last_active_states.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_last_active_states.enum', list(new_val))

    @property
    def value(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_last_active_states.value_raw'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_last_active_states.value_raw', int(new_val))


class RootLuZ_controller_exInstanceAttributePhase_move_mode_vec(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        fix_time = 0
        fix_speed = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.phase_move_mode_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_mode_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_mode_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_mode_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_mode_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.z_controller_ex.instance.attribute.phase_move_mode_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.z_controller_ex.instance.attribute.phase_move_mode_vec.set_vector_value', int(index), new_val)

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_mode_vec.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_mode_vec.enum', list(new_val))

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_mode_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_mode_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_mode_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_mode_vec.min', float(new_val))


class RootLuZ_controller_exInstanceAttributePhase_move_speed_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.phase_move_speed_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_speed_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_speed_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_speed_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_speed_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.z_controller_ex.instance.attribute.phase_move_speed_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.z_controller_ex.instance.attribute.phase_move_speed_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_speed_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_speed_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_speed_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_speed_vec.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeCurrent_feedback_status(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        max_extended = 2
        in_range = 0
        max_retracted = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.current_feedback_status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.current_feedback_status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_feedback_status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.current_feedback_status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_feedback_status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.z_controller_ex.instance.attribute.current_feedback_status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_feedback_status.value_raw', new_val.value)


class RootLuZ_controller_exInstanceAttributeSensor_slope(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.sensor_slope'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.sensor_slope.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.sensor_slope.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.sensor_slope.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.sensor_slope.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.sensor_slope.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.sensor_slope.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.sensor_slope.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.sensor_slope.min', float(new_val))


class RootLuZ_controller_exInstanceAttributePhase_work_mode_vec(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        z_drive = 1
        z_closed_loop = 0
        z_feedback = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.phase_work_mode_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_work_mode_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_work_mode_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_work_mode_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_work_mode_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.z_controller_ex.instance.attribute.phase_work_mode_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.z_controller_ex.instance.attribute.phase_work_mode_vec.set_vector_value', int(index), new_val)

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_work_mode_vec.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_work_mode_vec.enum', list(new_val))

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_work_mode_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_work_mode_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_work_mode_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_work_mode_vec.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeCurrent_pid_command_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.current_pid_command_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_pid_command_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_pid_command_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.current_pid_command_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_pid_command_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_pid_command_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_pid_command_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_pid_command_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_pid_command_value.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeCurrent_sum_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.current_sum_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_sum_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_sum_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.current_sum_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_sum_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_sum_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_sum_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_sum_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_sum_value.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeTip_guard_user_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.tip_guard_user_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_user_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_user_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_user_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_user_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_user_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_user_input.value_raw', new_val.value)


class RootLuZ_controller_exInstanceAttributeClosed_loop_d_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.closed_loop_d_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.closed_loop_d_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.closed_loop_d_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.closed_loop_d_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.closed_loop_d_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.closed_loop_d_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.closed_loop_d_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.closed_loop_d_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.closed_loop_d_gain.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeDdc_filter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.ddc_filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.ddc_filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.ddc_filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.ddc_filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.ddc_filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.z_controller_ex.instance.attribute.ddc_filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.z_controller_ex.instance.attribute.ddc_filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.ddc_filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.ddc_filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.ddc_filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.ddc_filter_coeff_vec.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeInput_compare_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        equal_or_higher_than = 0
        equal_or_lower_than = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.input_compare_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.input_compare_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.input_compare_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.input_compare_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.input_compare_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.z_controller_ex.instance.attribute.input_compare_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.z_controller_ex.instance.attribute.input_compare_mode.value_raw', new_val.value)


class RootLuZ_controller_exInstanceAttributeCurrent_input_filtered_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.current_input_filtered_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_input_filtered_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_input_filtered_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.current_input_filtered_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_input_filtered_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_input_filtered_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_input_filtered_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_input_filtered_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_input_filtered_value.min', float(new_val))


class RootLuZ_controller_exInstanceAttributePhase_count(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.phase_count'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_count.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_count.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_count.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_count.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_count.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_count.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_count.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_count.min', float(new_val))


class RootLuZ_controller_exInstanceAttributePhase_move_value_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.phase_move_value_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_value_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_value_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_value_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_value_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.z_controller_ex.instance.attribute.phase_move_value_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.z_controller_ex.instance.attribute.phase_move_value_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_value_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_value_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.phase_move_value_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.phase_move_value_vec.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeDifferential_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.differential_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.differential_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.differential_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.differential_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.differential_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.differential_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.differential_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.differential_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.differential_gain.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeTip_guard_detector_sum_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.tip_guard_detector_sum_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_detector_sum_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_detector_sum_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_detector_sum_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_detector_sum_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_detector_sum_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_detector_sum_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.tip_guard_detector_sum_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.tip_guard_detector_sum_limit.min', float(new_val))


class RootLuZ_controller_exInstanceAttributeBase_work_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        z_drive = 1
        z_closed_loop = 0
        z_feedback = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.base_work_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.z_controller_ex.instance.attribute.base_work_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.z_controller_ex.instance.attribute.base_work_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.z_controller_ex.instance.attribute.base_work_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.z_controller_ex.instance.attribute.base_work_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.z_controller_ex.instance.attribute.base_work_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.z_controller_ex.instance.attribute.base_work_mode.value_raw', new_val.value)


class RootLuZ_controller_exInstanceAttributeCurrent_error_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute.current_error_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_error_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_error_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.z_controller_ex.instance.attribute.current_error_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_error_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_error_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_error_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.z_controller_ex.instance.attribute.current_error_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.z_controller_ex.instance.attribute.current_error_value.min', float(new_val))


class RootLuZ_controller_exInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance.attribute'
        self.current_error_value = RootLuZ_controller_exInstanceAttributeCurrent_error_value(self._context)
        self.base_work_mode = RootLuZ_controller_exInstanceAttributeBase_work_mode(self._context)
        self.tip_guard_detector_sum_limit = RootLuZ_controller_exInstanceAttributeTip_guard_detector_sum_limit(self._context)
        self.differential_gain = RootLuZ_controller_exInstanceAttributeDifferential_gain(self._context)
        self.phase_move_value_vec = RootLuZ_controller_exInstanceAttributePhase_move_value_vec(self._context)
        self.phase_count = RootLuZ_controller_exInstanceAttributePhase_count(self._context)
        self.current_input_filtered_value = RootLuZ_controller_exInstanceAttributeCurrent_input_filtered_value(self._context)
        self.input_compare_mode = RootLuZ_controller_exInstanceAttributeInput_compare_mode(self._context)
        self.ddc_filter_coeff_vec = RootLuZ_controller_exInstanceAttributeDdc_filter_coeff_vec(self._context)
        self.closed_loop_d_gain = RootLuZ_controller_exInstanceAttributeClosed_loop_d_gain(self._context)
        self.tip_guard_user_input = RootLuZ_controller_exInstanceAttributeTip_guard_user_input(self._context)
        self.current_sum_value = RootLuZ_controller_exInstanceAttributeCurrent_sum_value(self._context)
        self.current_pid_command_value = RootLuZ_controller_exInstanceAttributeCurrent_pid_command_value(self._context)
        self.phase_work_mode_vec = RootLuZ_controller_exInstanceAttributePhase_work_mode_vec(self._context)
        self.sensor_slope = RootLuZ_controller_exInstanceAttributeSensor_slope(self._context)
        self.current_feedback_status = RootLuZ_controller_exInstanceAttributeCurrent_feedback_status(self._context)
        self.phase_move_speed_vec = RootLuZ_controller_exInstanceAttributePhase_move_speed_vec(self._context)
        self.phase_move_mode_vec = RootLuZ_controller_exInstanceAttributePhase_move_mode_vec(self._context)
        self.tip_guard_last_active_states = RootLuZ_controller_exInstanceAttributeTip_guard_last_active_states(self._context)
        self.current_input_value = RootLuZ_controller_exInstanceAttributeCurrent_input_value(self._context)
        self.filter_coeff_vec = RootLuZ_controller_exInstanceAttributeFilter_coeff_vec(self._context)
        self.tip_guard_enable = RootLuZ_controller_exInstanceAttributeTip_guard_enable(self._context)
        self.phase_init_phase_count = RootLuZ_controller_exInstanceAttributePhase_init_phase_count(self._context)
        self.output_compare_mode = RootLuZ_controller_exInstanceAttributeOutput_compare_mode(self._context)
        self.tip_guard_current_active_state = RootLuZ_controller_exInstanceAttributeTip_guard_current_active_state(self._context)
        self.z_controller_adjust_timed_out = RootLuZ_controller_exInstanceAttributeZ_controller_adjust_timed_out(self._context)
        self.set_point_modulation_scale_factor = RootLuZ_controller_exInstanceAttributeSet_point_modulation_scale_factor(self._context)
        self.ddc_filter_number = RootLuZ_controller_exInstanceAttributeDdc_filter_number(self._context)
        self.integral_gain = RootLuZ_controller_exInstanceAttributeIntegral_gain(self._context)
        self.max_z_value = RootLuZ_controller_exInstanceAttributeMax_z_value(self._context)
        self.max_z_current_value = RootLuZ_controller_exInstanceAttributeMax_z_current_value(self._context)
        self.tip_guard_criteria_enable_mask = RootLuZ_controller_exInstanceAttributeTip_guard_criteria_enable_mask(self._context)
        self.closed_loop_p_gain = RootLuZ_controller_exInstanceAttributeClosed_loop_p_gain(self._context)
        self.closed_loop_i_gain = RootLuZ_controller_exInstanceAttributeClosed_loop_i_gain(self._context)
        self.tip_guard_deflection_limit = RootLuZ_controller_exInstanceAttributeTip_guard_deflection_limit(self._context)
        self.proportional_gain = RootLuZ_controller_exInstanceAttributeProportional_gain(self._context)
        self.current_phase = RootLuZ_controller_exInstanceAttributeCurrent_phase(self._context)
        self.set_point_modulation_enable = RootLuZ_controller_exInstanceAttributeSet_point_modulation_enable(self._context)
        self.set_point = RootLuZ_controller_exInstanceAttributeSet_point(self._context)
        self.phase_real_end_pos_vec = RootLuZ_controller_exInstanceAttributePhase_real_end_pos_vec(self._context)
        self.phase_pause_time_vec = RootLuZ_controller_exInstanceAttributePhase_pause_time_vec(self._context)
        self.phase_move_time_vec = RootLuZ_controller_exInstanceAttributePhase_move_time_vec(self._context)
        self.memory_signal_gen_position_enable = RootLuZ_controller_exInstanceAttributeMemory_signal_gen_position_enable(self._context)
        self.ddc_filter_rate = RootLuZ_controller_exInstanceAttributeDdc_filter_rate(self._context)
        self.phase_move_stop_by_value_active_vec = RootLuZ_controller_exInstanceAttributePhase_move_stop_by_value_active_vec(self._context)
        self.tip_guard_user_compare_mode = RootLuZ_controller_exInstanceAttributeTip_guard_user_compare_mode(self._context)
        self.tip_guard_speed = RootLuZ_controller_exInstanceAttributeTip_guard_speed(self._context)
        self.phase_move_end_mode_vec = RootLuZ_controller_exInstanceAttributePhase_move_end_mode_vec(self._context)
        self.output_modulation_enable = RootLuZ_controller_exInstanceAttributeOutput_modulation_enable(self._context)
        self.current_status_flags = RootLuZ_controller_exInstanceAttributeCurrent_status_flags(self._context)
        self.output_compare_value = RootLuZ_controller_exInstanceAttributeOutput_compare_value(self._context)
        self.min_z_value = RootLuZ_controller_exInstanceAttributeMin_z_value(self._context)
        self.memory_signal_gen_drive_enable = RootLuZ_controller_exInstanceAttributeMemory_signal_gen_drive_enable(self._context)
        self.base_line_pos = RootLuZ_controller_exInstanceAttributeBase_line_pos(self._context)
        self.tip_guard_user_limit = RootLuZ_controller_exInstanceAttributeTip_guard_user_limit(self._context)
        self.ctrl_input = RootLuZ_controller_exInstanceAttributeCtrl_input(self._context)
        self.current_limited_value = RootLuZ_controller_exInstanceAttributeCurrent_limited_value(self._context)
        self.tip_guard_current_states = RootLuZ_controller_exInstanceAttributeTip_guard_current_states(self._context)
        self.closed_loop_polarity = RootLuZ_controller_exInstanceAttributeClosed_loop_polarity(self._context)
        self.feedback_polarity = RootLuZ_controller_exInstanceAttributeFeedback_polarity(self._context)
        self.max_z_value_change_speed = RootLuZ_controller_exInstanceAttributeMax_z_value_change_speed(self._context)
        self.input_compare_value = RootLuZ_controller_exInstanceAttributeInput_compare_value(self._context)
        self.current_output_value = RootLuZ_controller_exInstanceAttributeCurrent_output_value(self._context)


class RootLuZ_controller_exInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex.instance'
        self.attribute = RootLuZ_controller_exInstanceAttribute(self._context)
        self.trigger = RootLuZ_controller_exInstanceTrigger(self._context)


class RootLuZ_controller_ex(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.z_controller_ex'
        self.instance = RootLuZ_controller_exInstance(self._context)


class RootLuHv_amplifierDual_actuationTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.dual_actuation.trigger'

    def start_switch_to_target_mode(self) -> None:
        return self._context.call('root.lu.hv_amplifier.dual_actuation.trigger.start_switch_to_target_mode')

    def enable_module(self) -> None:
        return self._context.call('root.lu.hv_amplifier.dual_actuation.trigger.enable_module')

    def depreciated_6(self) -> None:
        return self._context.call('root.lu.hv_amplifier.dual_actuation.trigger.depreciated_6')

    def enable_z_modulation(self) -> None:
        return self._context.call('root.lu.hv_amplifier.dual_actuation.trigger.enable_z_modulation')

    def switch_to_target_mode(self) -> None:
        return self._context.call('root.lu.hv_amplifier.dual_actuation.trigger.switch_to_target_mode')

    def disable_module(self) -> None:
        return self._context.call('root.lu.hv_amplifier.dual_actuation.trigger.disable_module')

    def enable_power(self) -> None:
        return self._context.call('root.lu.hv_amplifier.dual_actuation.trigger.enable_power')

    def disable_z_modulation(self) -> None:
        return self._context.call('root.lu.hv_amplifier.dual_actuation.trigger.disable_z_modulation')

    def disable_power(self) -> None:
        return self._context.call('root.lu.hv_amplifier.dual_actuation.trigger.disable_power')


class RootLuHv_amplifierDual_actuationAttributeOutput_discharge_delay(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.dual_actuation.attribute.output_discharge_delay'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.output_discharge_delay.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.output_discharge_delay.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.output_discharge_delay.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.output_discharge_delay.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.output_discharge_delay.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.output_discharge_delay.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.output_discharge_delay.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.output_discharge_delay.min', float(new_val))


class RootLuHv_amplifierDual_actuationAttributeHv_module_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.dual_actuation.attribute.hv_module_enabled'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.hv_module_enabled.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.hv_module_enabled.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.hv_module_enabled.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.hv_module_enabled.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.hv_module_enabled.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.hv_module_enabled.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.hv_module_enabled.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.hv_module_enabled.min', float(new_val))


class RootLuHv_amplifierDual_actuationAttributeTemperature(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.dual_actuation.attribute.temperature'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.temperature.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.temperature.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.temperature.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.temperature.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.temperature.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.temperature.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.temperature.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.temperature.min', float(new_val))


class RootLuHv_amplifierDual_actuationAttributeSelected_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        dvi = 2
        bnc = 1
        not_selectable = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.dual_actuation.attribute.selected_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.selected_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.selected_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.selected_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.selected_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.selected_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.selected_input.value_raw', new_val.value)


class RootLuHv_amplifierDual_actuationAttributeInterlock_open_hv_cable(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_hv_cable'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_hv_cable.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_hv_cable.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_hv_cable.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_hv_cable.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_hv_cable.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_hv_cable.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_hv_cable.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_hv_cable.min', float(new_val))


class RootLuHv_amplifierDual_actuationAttributeMode_current(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        off = 0
        hv = 1
        lv = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.dual_actuation.attribute.mode_current'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.mode_current.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.mode_current.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.mode_current.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.mode_current.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.mode_current.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.mode_current.value_raw', new_val.value)


class RootLuHv_amplifierDual_actuationAttributeLast_mode_switch_retval(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        mode_not_supported = 1
        ok = 0
        interlock_open = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.dual_actuation.attribute.last_mode_switch_retval'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.last_mode_switch_retval.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.last_mode_switch_retval.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.last_mode_switch_retval.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.last_mode_switch_retval.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.last_mode_switch_retval.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.last_mode_switch_retval.value_raw', new_val.value)


class RootLuHv_amplifierDual_actuationAttributePower_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.dual_actuation.attribute.power_enabled'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.power_enabled.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.power_enabled.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.power_enabled.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.power_enabled.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.power_enabled.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.power_enabled.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.power_enabled.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.power_enabled.min', float(new_val))


class RootLuHv_amplifierDual_actuationAttributeZ_modulation_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.dual_actuation.attribute.z_modulation_enabled'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.z_modulation_enabled.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.z_modulation_enabled.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.z_modulation_enabled.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.z_modulation_enabled.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.z_modulation_enabled.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.z_modulation_enabled.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.z_modulation_enabled.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.z_modulation_enabled.min', float(new_val))


class RootLuHv_amplifierDual_actuationAttributeInterlock_open_cx_cable(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_cx_cable'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_cx_cable.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_cx_cable.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_cx_cable.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_cx_cable.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_cx_cable.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_cx_cable.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_cx_cable.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_cx_cable.min', float(new_val))


class RootLuHv_amplifierDual_actuationAttributeInterlock_open_user(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_user'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_user.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_user.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_user.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_user.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_user.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_user.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_user.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.interlock_open_user.min', float(new_val))


class RootLuHv_amplifierDual_actuationAttributeMode_target(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        off = 0
        hv = 1
        lv = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.dual_actuation.attribute.mode_target'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.mode_target.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.mode_target.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.mode_target.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.mode_target.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.mode_target.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.mode_target.value_raw', new_val.value)


class RootLuHv_amplifierDual_actuationAttributeType(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        a201 = 2
        a202 = 5
        unknown = 1
        hv500 = 4
        not_connected = 0
        hv180 = 3

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.dual_actuation.attribute.type'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.type.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.type.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.type.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.type.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.hv_amplifier.dual_actuation.attribute.type.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.hv_amplifier.dual_actuation.attribute.type.value_raw', new_val.value)


class RootLuHv_amplifierDual_actuationAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.dual_actuation.attribute'
        self.type = RootLuHv_amplifierDual_actuationAttributeType(self._context)
        self.mode_target = RootLuHv_amplifierDual_actuationAttributeMode_target(self._context)
        self.interlock_open_user = RootLuHv_amplifierDual_actuationAttributeInterlock_open_user(self._context)
        self.interlock_open_cx_cable = RootLuHv_amplifierDual_actuationAttributeInterlock_open_cx_cable(self._context)
        self.z_modulation_enabled = RootLuHv_amplifierDual_actuationAttributeZ_modulation_enabled(self._context)
        self.power_enabled = RootLuHv_amplifierDual_actuationAttributePower_enabled(self._context)
        self.last_mode_switch_retval = RootLuHv_amplifierDual_actuationAttributeLast_mode_switch_retval(self._context)
        self.mode_current = RootLuHv_amplifierDual_actuationAttributeMode_current(self._context)
        self.interlock_open_hv_cable = RootLuHv_amplifierDual_actuationAttributeInterlock_open_hv_cable(self._context)
        self.selected_input = RootLuHv_amplifierDual_actuationAttributeSelected_input(self._context)
        self.temperature = RootLuHv_amplifierDual_actuationAttributeTemperature(self._context)
        self.hv_module_enabled = RootLuHv_amplifierDual_actuationAttributeHv_module_enabled(self._context)
        self.output_discharge_delay = RootLuHv_amplifierDual_actuationAttributeOutput_discharge_delay(self._context)


class RootLuHv_amplifierDual_actuation(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.dual_actuation'
        self.attribute = RootLuHv_amplifierDual_actuationAttribute(self._context)
        self.trigger = RootLuHv_amplifierDual_actuationTrigger(self._context)


class RootLuHv_amplifierScanheadTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.scanhead.trigger'

    def start_switch_to_target_mode(self) -> None:
        return self._context.call('root.lu.hv_amplifier.scanhead.trigger.start_switch_to_target_mode')

    def enable_module(self) -> None:
        return self._context.call('root.lu.hv_amplifier.scanhead.trigger.enable_module')

    def depreciated_6(self) -> None:
        return self._context.call('root.lu.hv_amplifier.scanhead.trigger.depreciated_6')

    def enable_z_modulation(self) -> None:
        return self._context.call('root.lu.hv_amplifier.scanhead.trigger.enable_z_modulation')

    def switch_to_target_mode(self) -> None:
        return self._context.call('root.lu.hv_amplifier.scanhead.trigger.switch_to_target_mode')

    def disable_module(self) -> None:
        return self._context.call('root.lu.hv_amplifier.scanhead.trigger.disable_module')

    def enable_power(self) -> None:
        return self._context.call('root.lu.hv_amplifier.scanhead.trigger.enable_power')

    def disable_z_modulation(self) -> None:
        return self._context.call('root.lu.hv_amplifier.scanhead.trigger.disable_z_modulation')

    def disable_power(self) -> None:
        return self._context.call('root.lu.hv_amplifier.scanhead.trigger.disable_power')


class RootLuHv_amplifierScanheadAttributeOutput_discharge_delay(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.scanhead.attribute.output_discharge_delay'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.output_discharge_delay.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.output_discharge_delay.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.hv_amplifier.scanhead.attribute.output_discharge_delay.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.output_discharge_delay.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.output_discharge_delay.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.output_discharge_delay.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.output_discharge_delay.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.output_discharge_delay.min', float(new_val))


class RootLuHv_amplifierScanheadAttributeHv_module_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.scanhead.attribute.hv_module_enabled'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.hv_module_enabled.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.hv_module_enabled.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.hv_amplifier.scanhead.attribute.hv_module_enabled.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.hv_module_enabled.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.hv_module_enabled.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.hv_module_enabled.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.hv_module_enabled.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.hv_module_enabled.min', float(new_val))


class RootLuHv_amplifierScanheadAttributeTemperature(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.scanhead.attribute.temperature'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.temperature.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.temperature.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.hv_amplifier.scanhead.attribute.temperature.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.temperature.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.temperature.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.temperature.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.temperature.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.temperature.min', float(new_val))


class RootLuHv_amplifierScanheadAttributeSelected_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        dvi = 2
        bnc = 1
        not_selectable = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.scanhead.attribute.selected_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.hv_amplifier.scanhead.attribute.selected_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.selected_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.hv_amplifier.scanhead.attribute.selected_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.selected_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.hv_amplifier.scanhead.attribute.selected_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.selected_input.value_raw', new_val.value)


class RootLuHv_amplifierScanheadAttributeInterlock_open_hv_cable(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.scanhead.attribute.interlock_open_hv_cable'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.interlock_open_hv_cable.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.interlock_open_hv_cable.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.hv_amplifier.scanhead.attribute.interlock_open_hv_cable.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.interlock_open_hv_cable.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.interlock_open_hv_cable.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.interlock_open_hv_cable.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.interlock_open_hv_cable.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.interlock_open_hv_cable.min', float(new_val))


class RootLuHv_amplifierScanheadAttributeMode_current(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        off = 0
        hv = 1
        lv = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.scanhead.attribute.mode_current'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.hv_amplifier.scanhead.attribute.mode_current.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.mode_current.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.hv_amplifier.scanhead.attribute.mode_current.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.mode_current.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.hv_amplifier.scanhead.attribute.mode_current.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.mode_current.value_raw', new_val.value)


class RootLuHv_amplifierScanheadAttributeLast_mode_switch_retval(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        mode_not_supported = 1
        ok = 0
        interlock_open = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.scanhead.attribute.last_mode_switch_retval'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.hv_amplifier.scanhead.attribute.last_mode_switch_retval.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.last_mode_switch_retval.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.hv_amplifier.scanhead.attribute.last_mode_switch_retval.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.last_mode_switch_retval.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.hv_amplifier.scanhead.attribute.last_mode_switch_retval.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.last_mode_switch_retval.value_raw', new_val.value)


class RootLuHv_amplifierScanheadAttributePower_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.scanhead.attribute.power_enabled'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.power_enabled.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.power_enabled.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.hv_amplifier.scanhead.attribute.power_enabled.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.power_enabled.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.power_enabled.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.power_enabled.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.power_enabled.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.power_enabled.min', float(new_val))


class RootLuHv_amplifierScanheadAttributeZ_modulation_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.scanhead.attribute.z_modulation_enabled'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.z_modulation_enabled.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.z_modulation_enabled.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.hv_amplifier.scanhead.attribute.z_modulation_enabled.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.z_modulation_enabled.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.z_modulation_enabled.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.z_modulation_enabled.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.z_modulation_enabled.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.z_modulation_enabled.min', float(new_val))


class RootLuHv_amplifierScanheadAttributeInterlock_open_cx_cable(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.scanhead.attribute.interlock_open_cx_cable'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.interlock_open_cx_cable.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.interlock_open_cx_cable.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.hv_amplifier.scanhead.attribute.interlock_open_cx_cable.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.interlock_open_cx_cable.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.interlock_open_cx_cable.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.interlock_open_cx_cable.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.interlock_open_cx_cable.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.interlock_open_cx_cable.min', float(new_val))


class RootLuHv_amplifierScanheadAttributeInterlock_open_user(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.scanhead.attribute.interlock_open_user'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.interlock_open_user.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.interlock_open_user.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.hv_amplifier.scanhead.attribute.interlock_open_user.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.interlock_open_user.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.interlock_open_user.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.interlock_open_user.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.hv_amplifier.scanhead.attribute.interlock_open_user.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.interlock_open_user.min', float(new_val))


class RootLuHv_amplifierScanheadAttributeMode_target(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        off = 0
        hv = 1
        lv = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.scanhead.attribute.mode_target'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.hv_amplifier.scanhead.attribute.mode_target.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.mode_target.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.hv_amplifier.scanhead.attribute.mode_target.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.mode_target.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.hv_amplifier.scanhead.attribute.mode_target.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.mode_target.value_raw', new_val.value)


class RootLuHv_amplifierScanheadAttributeType(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        a201 = 2
        a202 = 5
        unknown = 1
        hv500 = 4
        not_connected = 0
        hv180 = 3

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.scanhead.attribute.type'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.hv_amplifier.scanhead.attribute.type.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.type.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.hv_amplifier.scanhead.attribute.type.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.type.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.hv_amplifier.scanhead.attribute.type.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.hv_amplifier.scanhead.attribute.type.value_raw', new_val.value)


class RootLuHv_amplifierScanheadAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.scanhead.attribute'
        self.type = RootLuHv_amplifierScanheadAttributeType(self._context)
        self.mode_target = RootLuHv_amplifierScanheadAttributeMode_target(self._context)
        self.interlock_open_user = RootLuHv_amplifierScanheadAttributeInterlock_open_user(self._context)
        self.interlock_open_cx_cable = RootLuHv_amplifierScanheadAttributeInterlock_open_cx_cable(self._context)
        self.z_modulation_enabled = RootLuHv_amplifierScanheadAttributeZ_modulation_enabled(self._context)
        self.power_enabled = RootLuHv_amplifierScanheadAttributePower_enabled(self._context)
        self.last_mode_switch_retval = RootLuHv_amplifierScanheadAttributeLast_mode_switch_retval(self._context)
        self.mode_current = RootLuHv_amplifierScanheadAttributeMode_current(self._context)
        self.interlock_open_hv_cable = RootLuHv_amplifierScanheadAttributeInterlock_open_hv_cable(self._context)
        self.selected_input = RootLuHv_amplifierScanheadAttributeSelected_input(self._context)
        self.temperature = RootLuHv_amplifierScanheadAttributeTemperature(self._context)
        self.hv_module_enabled = RootLuHv_amplifierScanheadAttributeHv_module_enabled(self._context)
        self.output_discharge_delay = RootLuHv_amplifierScanheadAttributeOutput_discharge_delay(self._context)


class RootLuHv_amplifierScanhead(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier.scanhead'
        self.attribute = RootLuHv_amplifierScanheadAttribute(self._context)
        self.trigger = RootLuHv_amplifierScanheadTrigger(self._context)


class RootLuHv_amplifier(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.hv_amplifier'
        self.scanhead = RootLuHv_amplifierScanhead(self._context)
        self.dual_actuation = RootLuHv_amplifierDual_actuation(self._context)


class RootLuSystemInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.trigger'

    def exit_approach(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.exit_approach')

    def entry_uncal(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.entry_uncal')

    def offset_xyz(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.offset_xyz')

    def motor_reference_and_move_back(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.motor_reference_and_move_back')

    def entry_idle(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.entry_idle')

    def entry_approach(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.entry_approach')

    def force_motor_pos_update(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.force_motor_pos_update')

    def entry_litho(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.entry_litho')

    def exit_scan(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.exit_scan')

    def motor_step(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.motor_step')

    def exit_litho(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.exit_litho')

    def entry_spec(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.entry_spec')

    def motor_move(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.motor_move')

    def entry_scan(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.entry_scan')

    def start_system_startup(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.start_system_startup')

    def exit_spec(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.exit_spec')

    def motor_stop(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.motor_stop')

    def motor_set_pos_zero(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.motor_set_pos_zero')

    def exit_uncal(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.exit_uncal')

    def motor_reference(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.motor_reference')

    def level_scanhead(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.level_scanhead')

    def exit_idle(self) -> None:
        return self._context.call('root.lu.system.instance.trigger.exit_idle')


class RootLuSystemInstanceAttributeIdle_position_z_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        keep_last_z_pos = 2
        z_controller_active = 0
        absolute_z_pos = 3
        retract_tip = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute.idle_position_z_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system.instance.attribute.idle_position_z_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system.instance.attribute.idle_position_z_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system.instance.attribute.idle_position_z_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system.instance.attribute.idle_position_z_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system.instance.attribute.idle_position_z_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system.instance.attribute.idle_position_z_mode.value_raw', new_val.value)


class RootLuSystemInstanceAttributeMeasurement_environment(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        air = 0
        liquid = 1
        vacuum = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute.measurement_environment'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system.instance.attribute.measurement_environment.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system.instance.attribute.measurement_environment.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system.instance.attribute.measurement_environment.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system.instance.attribute.measurement_environment.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system.instance.attribute.measurement_environment.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system.instance.attribute.measurement_environment.value_raw', new_val.value)


class RootLuSystemInstanceAttributeMemory_block_available(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute.memory_block_available'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.memory_block_available.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.memory_block_available.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system.instance.attribute.memory_block_available.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system.instance.attribute.memory_block_available.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.memory_block_available.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.memory_block_available.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.memory_block_available.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.memory_block_available.min', float(new_val))


class RootLuSystemInstanceAttributeMotor_move_direction(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute.motor_move_direction'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system.instance.attribute.motor_move_direction.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system.instance.attribute.motor_move_direction.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system.instance.attribute.motor_move_direction.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system.instance.attribute.motor_move_direction.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system.instance.attribute.motor_move_direction.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system.instance.attribute.motor_move_direction.value_raw', new_val.value)


class RootLuSystemInstanceAttributeMotor_selection(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        motor_beam_deflection_x = 7
        motor_b = 2
        motor_a = 1
        motor_approach = 0
        motor_photodiode_lateral = 9
        motor_ptey = 6
        motor_focus = 4
        motor_ptex = 5
        motor_photodiode_normal = 10
        motor_beam_deflection_y = 8
        motor_c = 3
        motor_lens_gimbal = 11

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute.motor_selection'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system.instance.attribute.motor_selection.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system.instance.attribute.motor_selection.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system.instance.attribute.motor_selection.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system.instance.attribute.motor_selection.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system.instance.attribute.motor_selection.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system.instance.attribute.motor_selection.value_raw', new_val.value)


class RootLuSystemInstanceAttributeOp_mode_kpfm_enabled(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute.op_mode_kpfm_enabled'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system.instance.attribute.op_mode_kpfm_enabled.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system.instance.attribute.op_mode_kpfm_enabled.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system.instance.attribute.op_mode_kpfm_enabled.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system.instance.attribute.op_mode_kpfm_enabled.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system.instance.attribute.op_mode_kpfm_enabled.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system.instance.attribute.op_mode_kpfm_enabled.value_raw', new_val.value)


class RootLuSystemInstanceAttributeHv_position_w_output_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        dac_hi_res_position_w = 0
        dac_fast_fast3 = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute.hv_position_w_output_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system.instance.attribute.hv_position_w_output_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system.instance.attribute.hv_position_w_output_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system.instance.attribute.hv_position_w_output_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system.instance.attribute.hv_position_w_output_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system.instance.attribute.hv_position_w_output_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system.instance.attribute.hv_position_w_output_mode.value_raw', new_val.value)


class RootLuSystemInstanceAttributeMemory_available(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute.memory_available'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.memory_available.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.memory_available.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system.instance.attribute.memory_available.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system.instance.attribute.memory_available.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.memory_available.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.memory_available.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.memory_available.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.memory_available.min', float(new_val))


class RootLuSystemInstanceAttributeHi_res_ch5_input(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute.hi_res_ch5_input'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.hi_res_ch5_input.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.hi_res_ch5_input.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system.instance.attribute.hi_res_ch5_input.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system.instance.attribute.hi_res_ch5_input.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.hi_res_ch5_input.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.hi_res_ch5_input.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.hi_res_ch5_input.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.hi_res_ch5_input.min', float(new_val))


class RootLuSystemInstanceAttributeMotor_move_speed_factor(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute.motor_move_speed_factor'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.motor_move_speed_factor.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.motor_move_speed_factor.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system.instance.attribute.motor_move_speed_factor.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system.instance.attribute.motor_move_speed_factor.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.motor_move_speed_factor.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.motor_move_speed_factor.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.motor_move_speed_factor.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.motor_move_speed_factor.min', float(new_val))


class RootLuSystemInstanceAttributeIdle_position_xy_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        keep_last_xy_pos = 1
        image_center = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute.idle_position_xy_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system.instance.attribute.idle_position_xy_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system.instance.attribute.idle_position_xy_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system.instance.attribute.idle_position_xy_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system.instance.attribute.idle_position_xy_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system.instance.attribute.idle_position_xy_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system.instance.attribute.idle_position_xy_mode.value_raw', new_val.value)


class RootLuSystemInstanceAttributeIdle_position_z(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute.idle_position_z'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.idle_position_z.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.idle_position_z.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system.instance.attribute.idle_position_z.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system.instance.attribute.idle_position_z.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.idle_position_z.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.idle_position_z.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.idle_position_z.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.idle_position_z.min', float(new_val))


class RootLuSystemInstanceAttributeMotor_step_size(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute.motor_step_size'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.motor_step_size.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.motor_step_size.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system.instance.attribute.motor_step_size.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system.instance.attribute.motor_step_size.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.motor_step_size.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.motor_step_size.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.motor_step_size.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.motor_step_size.min', float(new_val))


class RootLuSystemInstanceAttributeIdle_external_z(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute.idle_external_z'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.idle_external_z.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.idle_external_z.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system.instance.attribute.idle_external_z.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system.instance.attribute.idle_external_z.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.idle_external_z.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.idle_external_z.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.idle_external_z.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.idle_external_z.min', float(new_val))


class RootLuSystemInstanceAttributeZ_axis_ctrl_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        position_control = 3
        undefined = 0
        position_sensing = 2
        position_drive = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute.z_axis_ctrl_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system.instance.attribute.z_axis_ctrl_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system.instance.attribute.z_axis_ctrl_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system.instance.attribute.z_axis_ctrl_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system.instance.attribute.z_axis_ctrl_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system.instance.attribute.z_axis_ctrl_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system.instance.attribute.z_axis_ctrl_mode.value_raw', new_val.value)


class RootLuSystemInstanceAttributeIdle_external_z_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        absolute_z_pos = 1
        retract_tip = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute.idle_external_z_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system.instance.attribute.idle_external_z_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system.instance.attribute.idle_external_z_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system.instance.attribute.idle_external_z_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system.instance.attribute.idle_external_z_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system.instance.attribute.idle_external_z_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system.instance.attribute.idle_external_z_mode.value_raw', new_val.value)


class RootLuSystemInstanceAttributeSystem_state(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        internal = 6
        approach = 2
        idle = 1
        scan = 3
        spec = 4
        litho = 5
        uncal = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute.system_state'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system.instance.attribute.system_state.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system.instance.attribute.system_state.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system.instance.attribute.system_state.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system.instance.attribute.system_state.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system.instance.attribute.system_state.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system.instance.attribute.system_state.value_raw', new_val.value)


class RootLuSystemInstanceAttributeHi_res_ch4_input(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute.hi_res_ch4_input'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.hi_res_ch4_input.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.hi_res_ch4_input.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system.instance.attribute.hi_res_ch4_input.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system.instance.attribute.hi_res_ch4_input.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.hi_res_ch4_input.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.hi_res_ch4_input.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system.instance.attribute.hi_res_ch4_input.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system.instance.attribute.hi_res_ch4_input.min', float(new_val))


class RootLuSystemInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance.attribute'
        self.hi_res_ch4_input = RootLuSystemInstanceAttributeHi_res_ch4_input(self._context)
        self.system_state = RootLuSystemInstanceAttributeSystem_state(self._context)
        self.idle_external_z_mode = RootLuSystemInstanceAttributeIdle_external_z_mode(self._context)
        self.z_axis_ctrl_mode = RootLuSystemInstanceAttributeZ_axis_ctrl_mode(self._context)
        self.idle_external_z = RootLuSystemInstanceAttributeIdle_external_z(self._context)
        self.motor_step_size = RootLuSystemInstanceAttributeMotor_step_size(self._context)
        self.idle_position_z = RootLuSystemInstanceAttributeIdle_position_z(self._context)
        self.idle_position_xy_mode = RootLuSystemInstanceAttributeIdle_position_xy_mode(self._context)
        self.motor_move_speed_factor = RootLuSystemInstanceAttributeMotor_move_speed_factor(self._context)
        self.hi_res_ch5_input = RootLuSystemInstanceAttributeHi_res_ch5_input(self._context)
        self.memory_available = RootLuSystemInstanceAttributeMemory_available(self._context)
        self.hv_position_w_output_mode = RootLuSystemInstanceAttributeHv_position_w_output_mode(self._context)
        self.op_mode_kpfm_enabled = RootLuSystemInstanceAttributeOp_mode_kpfm_enabled(self._context)
        self.motor_selection = RootLuSystemInstanceAttributeMotor_selection(self._context)
        self.motor_move_direction = RootLuSystemInstanceAttributeMotor_move_direction(self._context)
        self.memory_block_available = RootLuSystemInstanceAttributeMemory_block_available(self._context)
        self.measurement_environment = RootLuSystemInstanceAttributeMeasurement_environment(self._context)
        self.idle_position_z_mode = RootLuSystemInstanceAttributeIdle_position_z_mode(self._context)


class RootLuSystemInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system.instance'
        self.attribute = RootLuSystemInstanceAttribute(self._context)
        self.trigger = RootLuSystemInstanceTrigger(self._context)


class RootLuSystem(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system'
        self.instance = RootLuSystemInstance(self._context)


class RootLuAnalog_hi_res_inPosition_xTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_x.trigger'


class RootLuAnalog_hi_res_inPosition_xAttributeCross_coupling_axis_id(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        position_z = 2
        self = 4
        position_y = 1
        position_w = 3
        position_x = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_id'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_id.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_id.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_id.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_id.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_id.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_id.value_raw', new_val.value)


class RootLuAnalog_hi_res_inPosition_xAttributeInput_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_x.attribute.input_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.input_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.input_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.input_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.input_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.input_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.input_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.input_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.input_offset.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_xAttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_x.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_xAttributeInput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_x.attribute.input_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.input_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.input_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.input_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.input_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.input_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.input_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.input_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.input_gain.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_xAttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_x.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_inPosition_xAttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_x.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_xAttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_x.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_xAttributeCross_coupling_axis_z_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        input = 1
        output = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_z_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_z_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_z_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_z_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_z_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_z_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_z_source.value_raw', new_val.value)


class RootLuAnalog_hi_res_inPosition_xAttributeCross_coupling_axis_coefficient_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_coefficient_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_coefficient_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_coefficient_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_coefficient_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_coefficient_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_coefficient_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_coefficient_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_coefficient_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_coefficient_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_coefficient_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.cross_coupling_axis_coefficient_vec.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_xAttributeFilter_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        no_filter = 0
        low_pass_filter = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_x.attribute.filter_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.filter_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.filter_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.filter_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.filter_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.filter_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.filter_mode.value_raw', new_val.value)


class RootLuAnalog_hi_res_inPosition_xAttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_x.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.position_x.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.position_x.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_xAttributeCurrent_input_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_x.attribute.current_input_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.current_input_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.current_input_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.current_input_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.current_input_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.current_input_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.current_input_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_x.attribute.current_input_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_x.attribute.current_input_value.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_xAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_x.attribute'
        self.current_input_value = RootLuAnalog_hi_res_inPosition_xAttributeCurrent_input_value(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_inPosition_xAttributeFilter_coeff_vec(self._context)
        self.filter_mode = RootLuAnalog_hi_res_inPosition_xAttributeFilter_mode(self._context)
        self.cross_coupling_axis_coefficient_vec = RootLuAnalog_hi_res_inPosition_xAttributeCross_coupling_axis_coefficient_vec(self._context)
        self.cross_coupling_axis_z_source = RootLuAnalog_hi_res_inPosition_xAttributeCross_coupling_axis_z_source(self._context)
        self.calib_offset = RootLuAnalog_hi_res_inPosition_xAttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_inPosition_xAttributeFilter_number(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_inPosition_xAttributeCalib_polarity(self._context)
        self.input_gain = RootLuAnalog_hi_res_inPosition_xAttributeInput_gain(self._context)
        self.calib_gain = RootLuAnalog_hi_res_inPosition_xAttributeCalib_gain(self._context)
        self.input_offset = RootLuAnalog_hi_res_inPosition_xAttributeInput_offset(self._context)
        self.cross_coupling_axis_id = RootLuAnalog_hi_res_inPosition_xAttributeCross_coupling_axis_id(self._context)


class RootLuAnalog_hi_res_inPosition_x(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_x'
        self.attribute = RootLuAnalog_hi_res_inPosition_xAttribute(self._context)
        self.trigger = RootLuAnalog_hi_res_inPosition_xTrigger(self._context)


class RootLuAnalog_hi_res_inMain2Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.main2.trigger'


class RootLuAnalog_hi_res_inMain2AttributeCross_coupling_axis_id(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        position_z = 2
        self = 4
        position_y = 1
        position_w = 3
        position_x = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_id'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_id.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_id.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_id.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_id.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_id.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_id.value_raw', new_val.value)


class RootLuAnalog_hi_res_inMain2AttributeInput_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.main2.attribute.input_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.input_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.input_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.main2.attribute.input_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.input_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.input_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.input_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.input_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.input_offset.min', float(new_val))


class RootLuAnalog_hi_res_inMain2AttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.main2.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.main2.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_inMain2AttributeInput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.main2.attribute.input_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.input_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.input_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.main2.attribute.input_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.input_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.input_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.input_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.input_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.input_gain.min', float(new_val))


class RootLuAnalog_hi_res_inMain2AttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.main2.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.main2.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.main2.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.main2.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_inMain2AttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.main2.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.main2.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_inMain2AttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.main2.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.main2.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_inMain2AttributeCross_coupling_axis_z_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        input = 1
        output = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_z_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_z_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_z_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_z_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_z_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_z_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_z_source.value_raw', new_val.value)


class RootLuAnalog_hi_res_inMain2AttributeCross_coupling_axis_coefficient_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_coefficient_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_coefficient_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_coefficient_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_coefficient_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_coefficient_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_coefficient_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_coefficient_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_coefficient_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_coefficient_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_coefficient_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.cross_coupling_axis_coefficient_vec.min', float(new_val))


class RootLuAnalog_hi_res_inMain2AttributeFilter_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        no_filter = 0
        low_pass_filter = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.main2.attribute.filter_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.main2.attribute.filter_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.filter_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.main2.attribute.filter_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.filter_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.main2.attribute.filter_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.filter_mode.value_raw', new_val.value)


class RootLuAnalog_hi_res_inMain2AttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.main2.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.main2.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.main2.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.main2.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.main2.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_inMain2AttributeCurrent_input_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.main2.attribute.current_input_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.current_input_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.current_input_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.main2.attribute.current_input_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.current_input_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.current_input_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.current_input_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.main2.attribute.current_input_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.main2.attribute.current_input_value.min', float(new_val))


class RootLuAnalog_hi_res_inMain2Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.main2.attribute'
        self.current_input_value = RootLuAnalog_hi_res_inMain2AttributeCurrent_input_value(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_inMain2AttributeFilter_coeff_vec(self._context)
        self.filter_mode = RootLuAnalog_hi_res_inMain2AttributeFilter_mode(self._context)
        self.cross_coupling_axis_coefficient_vec = RootLuAnalog_hi_res_inMain2AttributeCross_coupling_axis_coefficient_vec(self._context)
        self.cross_coupling_axis_z_source = RootLuAnalog_hi_res_inMain2AttributeCross_coupling_axis_z_source(self._context)
        self.calib_offset = RootLuAnalog_hi_res_inMain2AttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_inMain2AttributeFilter_number(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_inMain2AttributeCalib_polarity(self._context)
        self.input_gain = RootLuAnalog_hi_res_inMain2AttributeInput_gain(self._context)
        self.calib_gain = RootLuAnalog_hi_res_inMain2AttributeCalib_gain(self._context)
        self.input_offset = RootLuAnalog_hi_res_inMain2AttributeInput_offset(self._context)
        self.cross_coupling_axis_id = RootLuAnalog_hi_res_inMain2AttributeCross_coupling_axis_id(self._context)


class RootLuAnalog_hi_res_inMain2(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.main2'
        self.attribute = RootLuAnalog_hi_res_inMain2Attribute(self._context)
        self.trigger = RootLuAnalog_hi_res_inMain2Trigger(self._context)


class RootLuAnalog_hi_res_inDetector_sumTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.detector_sum.trigger'


class RootLuAnalog_hi_res_inDetector_sumAttributeCross_coupling_axis_id(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        position_z = 2
        self = 4
        position_y = 1
        position_w = 3
        position_x = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_id'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_id.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_id.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_id.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_id.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_id.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_id.value_raw', new_val.value)


class RootLuAnalog_hi_res_inDetector_sumAttributeInput_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.detector_sum.attribute.input_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.input_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.input_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.input_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.input_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.input_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.input_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.input_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.input_offset.min', float(new_val))


class RootLuAnalog_hi_res_inDetector_sumAttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.detector_sum.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_inDetector_sumAttributeInput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.detector_sum.attribute.input_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.input_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.input_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.input_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.input_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.input_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.input_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.input_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.input_gain.min', float(new_val))


class RootLuAnalog_hi_res_inDetector_sumAttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.detector_sum.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_inDetector_sumAttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.detector_sum.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_inDetector_sumAttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.detector_sum.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_inDetector_sumAttributeCross_coupling_axis_z_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        input = 1
        output = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_z_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_z_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_z_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_z_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_z_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_z_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_z_source.value_raw', new_val.value)


class RootLuAnalog_hi_res_inDetector_sumAttributeCross_coupling_axis_coefficient_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_coefficient_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_coefficient_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_coefficient_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_coefficient_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_coefficient_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_coefficient_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_coefficient_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_coefficient_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_coefficient_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_coefficient_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.cross_coupling_axis_coefficient_vec.min', float(new_val))


class RootLuAnalog_hi_res_inDetector_sumAttributeFilter_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        no_filter = 0
        low_pass_filter = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.detector_sum.attribute.filter_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.filter_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.filter_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.filter_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.filter_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.filter_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.filter_mode.value_raw', new_val.value)


class RootLuAnalog_hi_res_inDetector_sumAttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.detector_sum.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.detector_sum.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.detector_sum.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_inDetector_sumAttributeCurrent_input_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.detector_sum.attribute.current_input_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.current_input_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.current_input_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.current_input_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.current_input_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.current_input_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.current_input_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.detector_sum.attribute.current_input_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.detector_sum.attribute.current_input_value.min', float(new_val))


class RootLuAnalog_hi_res_inDetector_sumAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.detector_sum.attribute'
        self.current_input_value = RootLuAnalog_hi_res_inDetector_sumAttributeCurrent_input_value(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_inDetector_sumAttributeFilter_coeff_vec(self._context)
        self.filter_mode = RootLuAnalog_hi_res_inDetector_sumAttributeFilter_mode(self._context)
        self.cross_coupling_axis_coefficient_vec = RootLuAnalog_hi_res_inDetector_sumAttributeCross_coupling_axis_coefficient_vec(self._context)
        self.cross_coupling_axis_z_source = RootLuAnalog_hi_res_inDetector_sumAttributeCross_coupling_axis_z_source(self._context)
        self.calib_offset = RootLuAnalog_hi_res_inDetector_sumAttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_inDetector_sumAttributeFilter_number(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_inDetector_sumAttributeCalib_polarity(self._context)
        self.input_gain = RootLuAnalog_hi_res_inDetector_sumAttributeInput_gain(self._context)
        self.calib_gain = RootLuAnalog_hi_res_inDetector_sumAttributeCalib_gain(self._context)
        self.input_offset = RootLuAnalog_hi_res_inDetector_sumAttributeInput_offset(self._context)
        self.cross_coupling_axis_id = RootLuAnalog_hi_res_inDetector_sumAttributeCross_coupling_axis_id(self._context)


class RootLuAnalog_hi_res_inDetector_sum(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.detector_sum'
        self.attribute = RootLuAnalog_hi_res_inDetector_sumAttribute(self._context)
        self.trigger = RootLuAnalog_hi_res_inDetector_sumTrigger(self._context)


class RootLuAnalog_hi_res_inPosition_yTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_y.trigger'


class RootLuAnalog_hi_res_inPosition_yAttributeCross_coupling_axis_id(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        position_z = 2
        self = 4
        position_y = 1
        position_w = 3
        position_x = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_id'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_id.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_id.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_id.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_id.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_id.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_id.value_raw', new_val.value)


class RootLuAnalog_hi_res_inPosition_yAttributeInput_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_y.attribute.input_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.input_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.input_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.input_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.input_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.input_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.input_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.input_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.input_offset.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_yAttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_y.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_yAttributeInput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_y.attribute.input_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.input_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.input_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.input_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.input_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.input_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.input_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.input_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.input_gain.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_yAttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_y.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_inPosition_yAttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_y.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_yAttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_y.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_yAttributeCross_coupling_axis_z_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        input = 1
        output = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_z_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_z_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_z_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_z_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_z_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_z_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_z_source.value_raw', new_val.value)


class RootLuAnalog_hi_res_inPosition_yAttributeCross_coupling_axis_coefficient_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_coefficient_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_coefficient_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_coefficient_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_coefficient_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_coefficient_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_coefficient_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_coefficient_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_coefficient_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_coefficient_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_coefficient_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.cross_coupling_axis_coefficient_vec.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_yAttributeFilter_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        no_filter = 0
        low_pass_filter = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_y.attribute.filter_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.filter_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.filter_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.filter_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.filter_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.filter_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.filter_mode.value_raw', new_val.value)


class RootLuAnalog_hi_res_inPosition_yAttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_y.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.position_y.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.position_y.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_yAttributeCurrent_input_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_y.attribute.current_input_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.current_input_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.current_input_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.current_input_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.current_input_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.current_input_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.current_input_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_y.attribute.current_input_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_y.attribute.current_input_value.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_yAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_y.attribute'
        self.current_input_value = RootLuAnalog_hi_res_inPosition_yAttributeCurrent_input_value(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_inPosition_yAttributeFilter_coeff_vec(self._context)
        self.filter_mode = RootLuAnalog_hi_res_inPosition_yAttributeFilter_mode(self._context)
        self.cross_coupling_axis_coefficient_vec = RootLuAnalog_hi_res_inPosition_yAttributeCross_coupling_axis_coefficient_vec(self._context)
        self.cross_coupling_axis_z_source = RootLuAnalog_hi_res_inPosition_yAttributeCross_coupling_axis_z_source(self._context)
        self.calib_offset = RootLuAnalog_hi_res_inPosition_yAttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_inPosition_yAttributeFilter_number(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_inPosition_yAttributeCalib_polarity(self._context)
        self.input_gain = RootLuAnalog_hi_res_inPosition_yAttributeInput_gain(self._context)
        self.calib_gain = RootLuAnalog_hi_res_inPosition_yAttributeCalib_gain(self._context)
        self.input_offset = RootLuAnalog_hi_res_inPosition_yAttributeInput_offset(self._context)
        self.cross_coupling_axis_id = RootLuAnalog_hi_res_inPosition_yAttributeCross_coupling_axis_id(self._context)


class RootLuAnalog_hi_res_inPosition_y(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_y'
        self.attribute = RootLuAnalog_hi_res_inPosition_yAttribute(self._context)
        self.trigger = RootLuAnalog_hi_res_inPosition_yTrigger(self._context)


class RootLuAnalog_hi_res_inDeflectionTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.deflection.trigger'


class RootLuAnalog_hi_res_inDeflectionAttributeCross_coupling_axis_id(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        position_z = 2
        self = 4
        position_y = 1
        position_w = 3
        position_x = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_id'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_id.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_id.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_id.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_id.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_id.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_id.value_raw', new_val.value)


class RootLuAnalog_hi_res_inDeflectionAttributeInput_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.deflection.attribute.input_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.input_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.input_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.input_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.input_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.input_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.input_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.input_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.input_offset.min', float(new_val))


class RootLuAnalog_hi_res_inDeflectionAttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.deflection.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_inDeflectionAttributeInput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.deflection.attribute.input_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.input_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.input_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.input_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.input_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.input_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.input_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.input_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.input_gain.min', float(new_val))


class RootLuAnalog_hi_res_inDeflectionAttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.deflection.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_inDeflectionAttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.deflection.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_inDeflectionAttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.deflection.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_inDeflectionAttributeCross_coupling_axis_z_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        input = 1
        output = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_z_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_z_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_z_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_z_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_z_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_z_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_z_source.value_raw', new_val.value)


class RootLuAnalog_hi_res_inDeflectionAttributeCross_coupling_axis_coefficient_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_coefficient_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_coefficient_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_coefficient_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_coefficient_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_coefficient_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_coefficient_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_coefficient_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_coefficient_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_coefficient_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_coefficient_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.cross_coupling_axis_coefficient_vec.min', float(new_val))


class RootLuAnalog_hi_res_inDeflectionAttributeFilter_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        no_filter = 0
        low_pass_filter = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.deflection.attribute.filter_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.filter_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.filter_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.filter_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.filter_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.filter_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.filter_mode.value_raw', new_val.value)


class RootLuAnalog_hi_res_inDeflectionAttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.deflection.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.deflection.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.deflection.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_inDeflectionAttributeCurrent_input_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.deflection.attribute.current_input_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.current_input_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.current_input_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.current_input_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.current_input_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.current_input_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.current_input_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.deflection.attribute.current_input_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.deflection.attribute.current_input_value.min', float(new_val))


class RootLuAnalog_hi_res_inDeflectionAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.deflection.attribute'
        self.current_input_value = RootLuAnalog_hi_res_inDeflectionAttributeCurrent_input_value(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_inDeflectionAttributeFilter_coeff_vec(self._context)
        self.filter_mode = RootLuAnalog_hi_res_inDeflectionAttributeFilter_mode(self._context)
        self.cross_coupling_axis_coefficient_vec = RootLuAnalog_hi_res_inDeflectionAttributeCross_coupling_axis_coefficient_vec(self._context)
        self.cross_coupling_axis_z_source = RootLuAnalog_hi_res_inDeflectionAttributeCross_coupling_axis_z_source(self._context)
        self.calib_offset = RootLuAnalog_hi_res_inDeflectionAttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_inDeflectionAttributeFilter_number(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_inDeflectionAttributeCalib_polarity(self._context)
        self.input_gain = RootLuAnalog_hi_res_inDeflectionAttributeInput_gain(self._context)
        self.calib_gain = RootLuAnalog_hi_res_inDeflectionAttributeCalib_gain(self._context)
        self.input_offset = RootLuAnalog_hi_res_inDeflectionAttributeInput_offset(self._context)
        self.cross_coupling_axis_id = RootLuAnalog_hi_res_inDeflectionAttributeCross_coupling_axis_id(self._context)


class RootLuAnalog_hi_res_inDeflection(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.deflection'
        self.attribute = RootLuAnalog_hi_res_inDeflectionAttribute(self._context)
        self.trigger = RootLuAnalog_hi_res_inDeflectionTrigger(self._context)


class RootLuAnalog_hi_res_inTip_currentTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.tip_current.trigger'


class RootLuAnalog_hi_res_inTip_currentAttributeCross_coupling_axis_id(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        position_z = 2
        self = 4
        position_y = 1
        position_w = 3
        position_x = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_id'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_id.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_id.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_id.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_id.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_id.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_id.value_raw', new_val.value)


class RootLuAnalog_hi_res_inTip_currentAttributeInput_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.tip_current.attribute.input_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.input_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.input_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.input_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.input_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.input_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.input_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.input_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.input_offset.min', float(new_val))


class RootLuAnalog_hi_res_inTip_currentAttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.tip_current.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_inTip_currentAttributeInput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.tip_current.attribute.input_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.input_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.input_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.input_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.input_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.input_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.input_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.input_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.input_gain.min', float(new_val))


class RootLuAnalog_hi_res_inTip_currentAttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.tip_current.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_inTip_currentAttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.tip_current.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_inTip_currentAttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.tip_current.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_inTip_currentAttributeCross_coupling_axis_z_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        input = 1
        output = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_z_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_z_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_z_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_z_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_z_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_z_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_z_source.value_raw', new_val.value)


class RootLuAnalog_hi_res_inTip_currentAttributeCross_coupling_axis_coefficient_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_coefficient_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_coefficient_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_coefficient_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_coefficient_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_coefficient_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_coefficient_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_coefficient_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_coefficient_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_coefficient_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_coefficient_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.cross_coupling_axis_coefficient_vec.min', float(new_val))


class RootLuAnalog_hi_res_inTip_currentAttributeFilter_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        no_filter = 0
        low_pass_filter = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.tip_current.attribute.filter_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.filter_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.filter_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.filter_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.filter_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.filter_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.filter_mode.value_raw', new_val.value)


class RootLuAnalog_hi_res_inTip_currentAttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.tip_current.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.tip_current.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.tip_current.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_inTip_currentAttributeCurrent_input_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.tip_current.attribute.current_input_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.current_input_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.current_input_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.current_input_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.current_input_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.current_input_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.current_input_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.tip_current.attribute.current_input_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.tip_current.attribute.current_input_value.min', float(new_val))


class RootLuAnalog_hi_res_inTip_currentAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.tip_current.attribute'
        self.current_input_value = RootLuAnalog_hi_res_inTip_currentAttributeCurrent_input_value(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_inTip_currentAttributeFilter_coeff_vec(self._context)
        self.filter_mode = RootLuAnalog_hi_res_inTip_currentAttributeFilter_mode(self._context)
        self.cross_coupling_axis_coefficient_vec = RootLuAnalog_hi_res_inTip_currentAttributeCross_coupling_axis_coefficient_vec(self._context)
        self.cross_coupling_axis_z_source = RootLuAnalog_hi_res_inTip_currentAttributeCross_coupling_axis_z_source(self._context)
        self.calib_offset = RootLuAnalog_hi_res_inTip_currentAttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_inTip_currentAttributeFilter_number(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_inTip_currentAttributeCalib_polarity(self._context)
        self.input_gain = RootLuAnalog_hi_res_inTip_currentAttributeInput_gain(self._context)
        self.calib_gain = RootLuAnalog_hi_res_inTip_currentAttributeCalib_gain(self._context)
        self.input_offset = RootLuAnalog_hi_res_inTip_currentAttributeInput_offset(self._context)
        self.cross_coupling_axis_id = RootLuAnalog_hi_res_inTip_currentAttributeCross_coupling_axis_id(self._context)


class RootLuAnalog_hi_res_inTip_current(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.tip_current'
        self.attribute = RootLuAnalog_hi_res_inTip_currentAttribute(self._context)
        self.trigger = RootLuAnalog_hi_res_inTip_currentTrigger(self._context)


class RootLuAnalog_hi_res_inIn6Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.in6.trigger'


class RootLuAnalog_hi_res_inIn6AttributeCross_coupling_axis_id(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        position_z = 2
        self = 4
        position_y = 1
        position_w = 3
        position_x = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_id'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_id.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_id.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_id.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_id.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_id.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_id.value_raw', new_val.value)


class RootLuAnalog_hi_res_inIn6AttributeInput_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.in6.attribute.input_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.input_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.input_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.in6.attribute.input_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.input_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.input_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.input_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.input_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.input_offset.min', float(new_val))


class RootLuAnalog_hi_res_inIn6AttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.in6.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.in6.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_inIn6AttributeInput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.in6.attribute.input_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.input_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.input_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.in6.attribute.input_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.input_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.input_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.input_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.input_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.input_gain.min', float(new_val))


class RootLuAnalog_hi_res_inIn6AttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.in6.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.in6.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.in6.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.in6.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_inIn6AttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.in6.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.in6.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_inIn6AttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.in6.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.in6.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_inIn6AttributeCross_coupling_axis_z_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        input = 1
        output = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_z_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_z_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_z_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_z_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_z_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_z_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_z_source.value_raw', new_val.value)


class RootLuAnalog_hi_res_inIn6AttributeCross_coupling_axis_coefficient_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_coefficient_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_coefficient_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_coefficient_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_coefficient_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_coefficient_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_coefficient_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_coefficient_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_coefficient_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_coefficient_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_coefficient_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.cross_coupling_axis_coefficient_vec.min', float(new_val))


class RootLuAnalog_hi_res_inIn6AttributeFilter_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        no_filter = 0
        low_pass_filter = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.in6.attribute.filter_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.in6.attribute.filter_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.filter_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.in6.attribute.filter_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.filter_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.in6.attribute.filter_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.filter_mode.value_raw', new_val.value)


class RootLuAnalog_hi_res_inIn6AttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.in6.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.in6.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.in6.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.in6.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.in6.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_inIn6AttributeCurrent_input_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.in6.attribute.current_input_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.current_input_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.current_input_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.in6.attribute.current_input_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.current_input_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.current_input_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.current_input_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.in6.attribute.current_input_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.in6.attribute.current_input_value.min', float(new_val))


class RootLuAnalog_hi_res_inIn6Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.in6.attribute'
        self.current_input_value = RootLuAnalog_hi_res_inIn6AttributeCurrent_input_value(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_inIn6AttributeFilter_coeff_vec(self._context)
        self.filter_mode = RootLuAnalog_hi_res_inIn6AttributeFilter_mode(self._context)
        self.cross_coupling_axis_coefficient_vec = RootLuAnalog_hi_res_inIn6AttributeCross_coupling_axis_coefficient_vec(self._context)
        self.cross_coupling_axis_z_source = RootLuAnalog_hi_res_inIn6AttributeCross_coupling_axis_z_source(self._context)
        self.calib_offset = RootLuAnalog_hi_res_inIn6AttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_inIn6AttributeFilter_number(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_inIn6AttributeCalib_polarity(self._context)
        self.input_gain = RootLuAnalog_hi_res_inIn6AttributeInput_gain(self._context)
        self.calib_gain = RootLuAnalog_hi_res_inIn6AttributeCalib_gain(self._context)
        self.input_offset = RootLuAnalog_hi_res_inIn6AttributeInput_offset(self._context)
        self.cross_coupling_axis_id = RootLuAnalog_hi_res_inIn6AttributeCross_coupling_axis_id(self._context)


class RootLuAnalog_hi_res_inIn6(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.in6'
        self.attribute = RootLuAnalog_hi_res_inIn6Attribute(self._context)
        self.trigger = RootLuAnalog_hi_res_inIn6Trigger(self._context)


class RootLuAnalog_hi_res_inUser3Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user3.trigger'


class RootLuAnalog_hi_res_inUser3AttributeCross_coupling_axis_id(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        position_z = 2
        self = 4
        position_y = 1
        position_w = 3
        position_x = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_id'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_id.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_id.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_id.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_id.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_id.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_id.value_raw', new_val.value)


class RootLuAnalog_hi_res_inUser3AttributeInput_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user3.attribute.input_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.input_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.input_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user3.attribute.input_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.input_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.input_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.input_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.input_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.input_offset.min', float(new_val))


class RootLuAnalog_hi_res_inUser3AttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user3.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user3.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_inUser3AttributeInput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user3.attribute.input_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.input_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.input_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user3.attribute.input_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.input_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.input_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.input_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.input_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.input_gain.min', float(new_val))


class RootLuAnalog_hi_res_inUser3AttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user3.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.user3.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user3.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.user3.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_inUser3AttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user3.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user3.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_inUser3AttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user3.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user3.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_inUser3AttributeCross_coupling_axis_z_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        input = 1
        output = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_z_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_z_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_z_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_z_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_z_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_z_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_z_source.value_raw', new_val.value)


class RootLuAnalog_hi_res_inUser3AttributeCross_coupling_axis_coefficient_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_coefficient_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_coefficient_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_coefficient_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_coefficient_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_coefficient_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_coefficient_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_coefficient_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_coefficient_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_coefficient_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_coefficient_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.cross_coupling_axis_coefficient_vec.min', float(new_val))


class RootLuAnalog_hi_res_inUser3AttributeFilter_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        no_filter = 0
        low_pass_filter = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user3.attribute.filter_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.user3.attribute.filter_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.filter_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user3.attribute.filter_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.filter_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.user3.attribute.filter_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.filter_mode.value_raw', new_val.value)


class RootLuAnalog_hi_res_inUser3AttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user3.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user3.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user3.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.user3.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.user3.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_inUser3AttributeCurrent_input_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user3.attribute.current_input_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.current_input_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.current_input_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user3.attribute.current_input_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.current_input_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.current_input_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.current_input_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user3.attribute.current_input_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user3.attribute.current_input_value.min', float(new_val))


class RootLuAnalog_hi_res_inUser3Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user3.attribute'
        self.current_input_value = RootLuAnalog_hi_res_inUser3AttributeCurrent_input_value(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_inUser3AttributeFilter_coeff_vec(self._context)
        self.filter_mode = RootLuAnalog_hi_res_inUser3AttributeFilter_mode(self._context)
        self.cross_coupling_axis_coefficient_vec = RootLuAnalog_hi_res_inUser3AttributeCross_coupling_axis_coefficient_vec(self._context)
        self.cross_coupling_axis_z_source = RootLuAnalog_hi_res_inUser3AttributeCross_coupling_axis_z_source(self._context)
        self.calib_offset = RootLuAnalog_hi_res_inUser3AttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_inUser3AttributeFilter_number(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_inUser3AttributeCalib_polarity(self._context)
        self.input_gain = RootLuAnalog_hi_res_inUser3AttributeInput_gain(self._context)
        self.calib_gain = RootLuAnalog_hi_res_inUser3AttributeCalib_gain(self._context)
        self.input_offset = RootLuAnalog_hi_res_inUser3AttributeInput_offset(self._context)
        self.cross_coupling_axis_id = RootLuAnalog_hi_res_inUser3AttributeCross_coupling_axis_id(self._context)


class RootLuAnalog_hi_res_inUser3(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user3'
        self.attribute = RootLuAnalog_hi_res_inUser3Attribute(self._context)
        self.trigger = RootLuAnalog_hi_res_inUser3Trigger(self._context)


class RootLuAnalog_hi_res_inUser1Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user1.trigger'


class RootLuAnalog_hi_res_inUser1AttributeCross_coupling_axis_id(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        position_z = 2
        self = 4
        position_y = 1
        position_w = 3
        position_x = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_id'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_id.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_id.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_id.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_id.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_id.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_id.value_raw', new_val.value)


class RootLuAnalog_hi_res_inUser1AttributeInput_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user1.attribute.input_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.input_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.input_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user1.attribute.input_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.input_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.input_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.input_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.input_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.input_offset.min', float(new_val))


class RootLuAnalog_hi_res_inUser1AttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user1.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user1.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_inUser1AttributeInput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user1.attribute.input_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.input_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.input_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user1.attribute.input_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.input_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.input_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.input_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.input_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.input_gain.min', float(new_val))


class RootLuAnalog_hi_res_inUser1AttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user1.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.user1.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user1.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.user1.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_inUser1AttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user1.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user1.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_inUser1AttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user1.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user1.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_inUser1AttributeCross_coupling_axis_z_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        input = 1
        output = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_z_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_z_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_z_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_z_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_z_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_z_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_z_source.value_raw', new_val.value)


class RootLuAnalog_hi_res_inUser1AttributeCross_coupling_axis_coefficient_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_coefficient_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_coefficient_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_coefficient_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_coefficient_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_coefficient_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_coefficient_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_coefficient_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_coefficient_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_coefficient_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_coefficient_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.cross_coupling_axis_coefficient_vec.min', float(new_val))


class RootLuAnalog_hi_res_inUser1AttributeFilter_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        no_filter = 0
        low_pass_filter = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user1.attribute.filter_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.user1.attribute.filter_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.filter_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user1.attribute.filter_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.filter_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.user1.attribute.filter_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.filter_mode.value_raw', new_val.value)


class RootLuAnalog_hi_res_inUser1AttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user1.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user1.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user1.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.user1.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.user1.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_inUser1AttributeCurrent_input_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user1.attribute.current_input_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.current_input_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.current_input_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user1.attribute.current_input_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.current_input_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.current_input_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.current_input_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user1.attribute.current_input_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user1.attribute.current_input_value.min', float(new_val))


class RootLuAnalog_hi_res_inUser1Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user1.attribute'
        self.current_input_value = RootLuAnalog_hi_res_inUser1AttributeCurrent_input_value(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_inUser1AttributeFilter_coeff_vec(self._context)
        self.filter_mode = RootLuAnalog_hi_res_inUser1AttributeFilter_mode(self._context)
        self.cross_coupling_axis_coefficient_vec = RootLuAnalog_hi_res_inUser1AttributeCross_coupling_axis_coefficient_vec(self._context)
        self.cross_coupling_axis_z_source = RootLuAnalog_hi_res_inUser1AttributeCross_coupling_axis_z_source(self._context)
        self.calib_offset = RootLuAnalog_hi_res_inUser1AttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_inUser1AttributeFilter_number(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_inUser1AttributeCalib_polarity(self._context)
        self.input_gain = RootLuAnalog_hi_res_inUser1AttributeInput_gain(self._context)
        self.calib_gain = RootLuAnalog_hi_res_inUser1AttributeCalib_gain(self._context)
        self.input_offset = RootLuAnalog_hi_res_inUser1AttributeInput_offset(self._context)
        self.cross_coupling_axis_id = RootLuAnalog_hi_res_inUser1AttributeCross_coupling_axis_id(self._context)


class RootLuAnalog_hi_res_inUser1(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user1'
        self.attribute = RootLuAnalog_hi_res_inUser1Attribute(self._context)
        self.trigger = RootLuAnalog_hi_res_inUser1Trigger(self._context)


class RootLuAnalog_hi_res_inPosition_zTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_z.trigger'


class RootLuAnalog_hi_res_inPosition_zAttributeCross_coupling_axis_id(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        position_z = 2
        self = 4
        position_y = 1
        position_w = 3
        position_x = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_id'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_id.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_id.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_id.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_id.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_id.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_id.value_raw', new_val.value)


class RootLuAnalog_hi_res_inPosition_zAttributeInput_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_z.attribute.input_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.input_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.input_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.input_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.input_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.input_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.input_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.input_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.input_offset.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_zAttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_z.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_zAttributeInput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_z.attribute.input_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.input_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.input_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.input_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.input_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.input_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.input_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.input_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.input_gain.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_zAttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_z.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_inPosition_zAttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_z.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_zAttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_z.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_zAttributeCross_coupling_axis_z_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        input = 1
        output = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_z_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_z_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_z_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_z_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_z_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_z_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_z_source.value_raw', new_val.value)


class RootLuAnalog_hi_res_inPosition_zAttributeCross_coupling_axis_coefficient_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_coefficient_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_coefficient_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_coefficient_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_coefficient_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_coefficient_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_coefficient_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_coefficient_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_coefficient_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_coefficient_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_coefficient_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.cross_coupling_axis_coefficient_vec.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_zAttributeFilter_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        no_filter = 0
        low_pass_filter = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_z.attribute.filter_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.filter_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.filter_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.filter_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.filter_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.filter_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.filter_mode.value_raw', new_val.value)


class RootLuAnalog_hi_res_inPosition_zAttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_z.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.position_z.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.position_z.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_zAttributeCurrent_input_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_z.attribute.current_input_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.current_input_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.current_input_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.current_input_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.current_input_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.current_input_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.current_input_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.position_z.attribute.current_input_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.position_z.attribute.current_input_value.min', float(new_val))


class RootLuAnalog_hi_res_inPosition_zAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_z.attribute'
        self.current_input_value = RootLuAnalog_hi_res_inPosition_zAttributeCurrent_input_value(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_inPosition_zAttributeFilter_coeff_vec(self._context)
        self.filter_mode = RootLuAnalog_hi_res_inPosition_zAttributeFilter_mode(self._context)
        self.cross_coupling_axis_coefficient_vec = RootLuAnalog_hi_res_inPosition_zAttributeCross_coupling_axis_coefficient_vec(self._context)
        self.cross_coupling_axis_z_source = RootLuAnalog_hi_res_inPosition_zAttributeCross_coupling_axis_z_source(self._context)
        self.calib_offset = RootLuAnalog_hi_res_inPosition_zAttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_inPosition_zAttributeFilter_number(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_inPosition_zAttributeCalib_polarity(self._context)
        self.input_gain = RootLuAnalog_hi_res_inPosition_zAttributeInput_gain(self._context)
        self.calib_gain = RootLuAnalog_hi_res_inPosition_zAttributeCalib_gain(self._context)
        self.input_offset = RootLuAnalog_hi_res_inPosition_zAttributeInput_offset(self._context)
        self.cross_coupling_axis_id = RootLuAnalog_hi_res_inPosition_zAttributeCross_coupling_axis_id(self._context)


class RootLuAnalog_hi_res_inPosition_z(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.position_z'
        self.attribute = RootLuAnalog_hi_res_inPosition_zAttribute(self._context)
        self.trigger = RootLuAnalog_hi_res_inPosition_zTrigger(self._context)


class RootLuAnalog_hi_res_inUser4Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user4.trigger'


class RootLuAnalog_hi_res_inUser4AttributeCross_coupling_axis_id(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        position_z = 2
        self = 4
        position_y = 1
        position_w = 3
        position_x = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_id'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_id.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_id.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_id.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_id.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_id.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_id.value_raw', new_val.value)


class RootLuAnalog_hi_res_inUser4AttributeInput_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user4.attribute.input_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.input_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.input_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user4.attribute.input_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.input_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.input_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.input_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.input_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.input_offset.min', float(new_val))


class RootLuAnalog_hi_res_inUser4AttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user4.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user4.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_inUser4AttributeInput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user4.attribute.input_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.input_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.input_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user4.attribute.input_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.input_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.input_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.input_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.input_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.input_gain.min', float(new_val))


class RootLuAnalog_hi_res_inUser4AttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user4.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.user4.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user4.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.user4.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_inUser4AttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user4.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user4.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_inUser4AttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user4.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user4.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_inUser4AttributeCross_coupling_axis_z_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        input = 1
        output = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_z_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_z_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_z_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_z_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_z_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_z_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_z_source.value_raw', new_val.value)


class RootLuAnalog_hi_res_inUser4AttributeCross_coupling_axis_coefficient_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_coefficient_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_coefficient_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_coefficient_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_coefficient_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_coefficient_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_coefficient_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_coefficient_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_coefficient_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_coefficient_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_coefficient_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.cross_coupling_axis_coefficient_vec.min', float(new_val))


class RootLuAnalog_hi_res_inUser4AttributeFilter_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        no_filter = 0
        low_pass_filter = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user4.attribute.filter_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.user4.attribute.filter_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.filter_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user4.attribute.filter_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.filter_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.user4.attribute.filter_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.filter_mode.value_raw', new_val.value)


class RootLuAnalog_hi_res_inUser4AttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user4.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user4.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user4.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.user4.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.user4.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_inUser4AttributeCurrent_input_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user4.attribute.current_input_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.current_input_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.current_input_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user4.attribute.current_input_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.current_input_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.current_input_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.current_input_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user4.attribute.current_input_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user4.attribute.current_input_value.min', float(new_val))


class RootLuAnalog_hi_res_inUser4Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user4.attribute'
        self.current_input_value = RootLuAnalog_hi_res_inUser4AttributeCurrent_input_value(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_inUser4AttributeFilter_coeff_vec(self._context)
        self.filter_mode = RootLuAnalog_hi_res_inUser4AttributeFilter_mode(self._context)
        self.cross_coupling_axis_coefficient_vec = RootLuAnalog_hi_res_inUser4AttributeCross_coupling_axis_coefficient_vec(self._context)
        self.cross_coupling_axis_z_source = RootLuAnalog_hi_res_inUser4AttributeCross_coupling_axis_z_source(self._context)
        self.calib_offset = RootLuAnalog_hi_res_inUser4AttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_inUser4AttributeFilter_number(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_inUser4AttributeCalib_polarity(self._context)
        self.input_gain = RootLuAnalog_hi_res_inUser4AttributeInput_gain(self._context)
        self.calib_gain = RootLuAnalog_hi_res_inUser4AttributeCalib_gain(self._context)
        self.input_offset = RootLuAnalog_hi_res_inUser4AttributeInput_offset(self._context)
        self.cross_coupling_axis_id = RootLuAnalog_hi_res_inUser4AttributeCross_coupling_axis_id(self._context)


class RootLuAnalog_hi_res_inUser4(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user4'
        self.attribute = RootLuAnalog_hi_res_inUser4Attribute(self._context)
        self.trigger = RootLuAnalog_hi_res_inUser4Trigger(self._context)


class RootLuAnalog_hi_res_inUser2Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user2.trigger'


class RootLuAnalog_hi_res_inUser2AttributeCross_coupling_axis_id(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        position_z = 2
        self = 4
        position_y = 1
        position_w = 3
        position_x = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_id'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_id.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_id.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_id.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_id.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_id.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_id.value_raw', new_val.value)


class RootLuAnalog_hi_res_inUser2AttributeInput_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user2.attribute.input_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.input_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.input_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user2.attribute.input_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.input_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.input_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.input_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.input_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.input_offset.min', float(new_val))


class RootLuAnalog_hi_res_inUser2AttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user2.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user2.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_inUser2AttributeInput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user2.attribute.input_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.input_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.input_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user2.attribute.input_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.input_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.input_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.input_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.input_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.input_gain.min', float(new_val))


class RootLuAnalog_hi_res_inUser2AttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user2.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.user2.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user2.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.user2.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_inUser2AttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user2.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user2.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_inUser2AttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user2.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user2.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_inUser2AttributeCross_coupling_axis_z_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        input = 1
        output = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_z_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_z_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_z_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_z_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_z_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_z_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_z_source.value_raw', new_val.value)


class RootLuAnalog_hi_res_inUser2AttributeCross_coupling_axis_coefficient_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_coefficient_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_coefficient_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_coefficient_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_coefficient_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_coefficient_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_coefficient_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_coefficient_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_coefficient_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_coefficient_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_coefficient_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.cross_coupling_axis_coefficient_vec.min', float(new_val))


class RootLuAnalog_hi_res_inUser2AttributeFilter_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        no_filter = 0
        low_pass_filter = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user2.attribute.filter_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.user2.attribute.filter_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.filter_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user2.attribute.filter_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.filter_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.user2.attribute.filter_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.filter_mode.value_raw', new_val.value)


class RootLuAnalog_hi_res_inUser2AttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user2.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user2.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.user2.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.user2.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.user2.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_inUser2AttributeCurrent_input_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user2.attribute.current_input_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.current_input_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.current_input_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.user2.attribute.current_input_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.current_input_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.current_input_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.current_input_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.user2.attribute.current_input_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.user2.attribute.current_input_value.min', float(new_val))


class RootLuAnalog_hi_res_inUser2Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user2.attribute'
        self.current_input_value = RootLuAnalog_hi_res_inUser2AttributeCurrent_input_value(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_inUser2AttributeFilter_coeff_vec(self._context)
        self.filter_mode = RootLuAnalog_hi_res_inUser2AttributeFilter_mode(self._context)
        self.cross_coupling_axis_coefficient_vec = RootLuAnalog_hi_res_inUser2AttributeCross_coupling_axis_coefficient_vec(self._context)
        self.cross_coupling_axis_z_source = RootLuAnalog_hi_res_inUser2AttributeCross_coupling_axis_z_source(self._context)
        self.calib_offset = RootLuAnalog_hi_res_inUser2AttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_inUser2AttributeFilter_number(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_inUser2AttributeCalib_polarity(self._context)
        self.input_gain = RootLuAnalog_hi_res_inUser2AttributeInput_gain(self._context)
        self.calib_gain = RootLuAnalog_hi_res_inUser2AttributeCalib_gain(self._context)
        self.input_offset = RootLuAnalog_hi_res_inUser2AttributeInput_offset(self._context)
        self.cross_coupling_axis_id = RootLuAnalog_hi_res_inUser2AttributeCross_coupling_axis_id(self._context)


class RootLuAnalog_hi_res_inUser2(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.user2'
        self.attribute = RootLuAnalog_hi_res_inUser2Attribute(self._context)
        self.trigger = RootLuAnalog_hi_res_inUser2Trigger(self._context)


class RootLuAnalog_hi_res_inLateralTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.lateral.trigger'


class RootLuAnalog_hi_res_inLateralAttributeCross_coupling_axis_id(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        position_z = 2
        self = 4
        position_y = 1
        position_w = 3
        position_x = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_id'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_id.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_id.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_id.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_id.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_id.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_id.value_raw', new_val.value)


class RootLuAnalog_hi_res_inLateralAttributeInput_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.lateral.attribute.input_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.input_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.input_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.input_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.input_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.input_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.input_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.input_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.input_offset.min', float(new_val))


class RootLuAnalog_hi_res_inLateralAttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.lateral.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_inLateralAttributeInput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.lateral.attribute.input_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.input_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.input_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.input_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.input_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.input_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.input_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.input_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.input_gain.min', float(new_val))


class RootLuAnalog_hi_res_inLateralAttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.lateral.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_inLateralAttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.lateral.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_inLateralAttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.lateral.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_inLateralAttributeCross_coupling_axis_z_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        input = 1
        output = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_z_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_z_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_z_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_z_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_z_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_z_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_z_source.value_raw', new_val.value)


class RootLuAnalog_hi_res_inLateralAttributeCross_coupling_axis_coefficient_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_coefficient_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_coefficient_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_coefficient_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_coefficient_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_coefficient_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_coefficient_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_coefficient_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_coefficient_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_coefficient_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_coefficient_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.cross_coupling_axis_coefficient_vec.min', float(new_val))


class RootLuAnalog_hi_res_inLateralAttributeFilter_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        no_filter = 0
        low_pass_filter = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.lateral.attribute.filter_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.filter_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.filter_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.filter_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.filter_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.filter_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.filter_mode.value_raw', new_val.value)


class RootLuAnalog_hi_res_inLateralAttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.lateral.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_in.lateral.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_in.lateral.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_inLateralAttributeCurrent_input_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.lateral.attribute.current_input_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.current_input_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.current_input_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.current_input_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.current_input_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.current_input_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.current_input_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_in.lateral.attribute.current_input_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_in.lateral.attribute.current_input_value.min', float(new_val))


class RootLuAnalog_hi_res_inLateralAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.lateral.attribute'
        self.current_input_value = RootLuAnalog_hi_res_inLateralAttributeCurrent_input_value(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_inLateralAttributeFilter_coeff_vec(self._context)
        self.filter_mode = RootLuAnalog_hi_res_inLateralAttributeFilter_mode(self._context)
        self.cross_coupling_axis_coefficient_vec = RootLuAnalog_hi_res_inLateralAttributeCross_coupling_axis_coefficient_vec(self._context)
        self.cross_coupling_axis_z_source = RootLuAnalog_hi_res_inLateralAttributeCross_coupling_axis_z_source(self._context)
        self.calib_offset = RootLuAnalog_hi_res_inLateralAttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_inLateralAttributeFilter_number(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_inLateralAttributeCalib_polarity(self._context)
        self.input_gain = RootLuAnalog_hi_res_inLateralAttributeInput_gain(self._context)
        self.calib_gain = RootLuAnalog_hi_res_inLateralAttributeCalib_gain(self._context)
        self.input_offset = RootLuAnalog_hi_res_inLateralAttributeInput_offset(self._context)
        self.cross_coupling_axis_id = RootLuAnalog_hi_res_inLateralAttributeCross_coupling_axis_id(self._context)


class RootLuAnalog_hi_res_inLateral(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in.lateral'
        self.attribute = RootLuAnalog_hi_res_inLateralAttribute(self._context)
        self.trigger = RootLuAnalog_hi_res_inLateralTrigger(self._context)


class RootLuAnalog_hi_res_in(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_in'
        self.lateral = RootLuAnalog_hi_res_inLateral(self._context)
        self.user2 = RootLuAnalog_hi_res_inUser2(self._context)
        self.user4 = RootLuAnalog_hi_res_inUser4(self._context)
        self.position_z = RootLuAnalog_hi_res_inPosition_z(self._context)
        self.user1 = RootLuAnalog_hi_res_inUser1(self._context)
        self.user3 = RootLuAnalog_hi_res_inUser3(self._context)
        self.in6 = RootLuAnalog_hi_res_inIn6(self._context)
        self.tip_current = RootLuAnalog_hi_res_inTip_current(self._context)
        self.deflection = RootLuAnalog_hi_res_inDeflection(self._context)
        self.position_y = RootLuAnalog_hi_res_inPosition_y(self._context)
        self.detector_sum = RootLuAnalog_hi_res_inDetector_sum(self._context)
        self.main2 = RootLuAnalog_hi_res_inMain2(self._context)
        self.position_x = RootLuAnalog_hi_res_inPosition_x(self._context)


class RootLuScanheadInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead.instance.trigger'

    def disable_pte_laser(self) -> None:
        return self._context.call('root.lu.scanhead.instance.trigger.disable_pte_laser')

    def enable_piezo_electric_excitation(self) -> None:
        return self._context.call('root.lu.scanhead.instance.trigger.enable_piezo_electric_excitation')

    def apply_addon_module_attributes(self) -> None:
        return self._context.call('root.lu.scanhead.instance.trigger.apply_addon_module_attributes')

    def read_and_push_addon_module_calibration(self) -> None:
        return self._context.call('root.lu.scanhead.instance.trigger.read_and_push_addon_module_calibration')

    def apply_tilt_mode(self) -> None:
        return self._context.call('root.lu.scanhead.instance.trigger.apply_tilt_mode')

    def enable_readout_laser(self) -> None:
        return self._context.call('root.lu.scanhead.instance.trigger.enable_readout_laser')

    def enable_pte_laser(self) -> None:
        return self._context.call('root.lu.scanhead.instance.trigger.enable_pte_laser')

    def enable_electro_thermal_excitation(self) -> None:
        return self._context.call('root.lu.scanhead.instance.trigger.enable_electro_thermal_excitation')

    def disable_electro_thermal_excitation(self) -> None:
        return self._context.call('root.lu.scanhead.instance.trigger.disable_electro_thermal_excitation')

    def disable_piezo_electric_excitation(self) -> None:
        return self._context.call('root.lu.scanhead.instance.trigger.disable_piezo_electric_excitation')

    def disable_readout_laser(self) -> None:
        return self._context.call('root.lu.scanhead.instance.trigger.disable_readout_laser')


class RootLuScanheadInstanceAttributeHas_z_sensor(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        no = 0
        yes = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead.instance.attribute.has_z_sensor'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.scanhead.instance.attribute.has_z_sensor.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.scanhead.instance.attribute.has_z_sensor.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.scanhead.instance.attribute.has_z_sensor.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.scanhead.instance.attribute.has_z_sensor.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.scanhead.instance.attribute.has_z_sensor.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.scanhead.instance.attribute.has_z_sensor.value_raw', new_val.value)


class RootLuScanheadInstanceAttributeTilt_angle_x(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead.instance.attribute.tilt_angle_x'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scanhead.instance.attribute.tilt_angle_x.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scanhead.instance.attribute.tilt_angle_x.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scanhead.instance.attribute.tilt_angle_x.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scanhead.instance.attribute.tilt_angle_x.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scanhead.instance.attribute.tilt_angle_x.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scanhead.instance.attribute.tilt_angle_x.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scanhead.instance.attribute.tilt_angle_x.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scanhead.instance.attribute.tilt_angle_x.min', float(new_val))


class RootLuScanheadInstanceAttributeAddon_module_mode_tip_access(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        both = 3
        external = 1
        internal = 2
        no_connection = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead.instance.attribute.addon_module_mode_tip_access'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.scanhead.instance.attribute.addon_module_mode_tip_access.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.scanhead.instance.attribute.addon_module_mode_tip_access.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.scanhead.instance.attribute.addon_module_mode_tip_access.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.scanhead.instance.attribute.addon_module_mode_tip_access.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.scanhead.instance.attribute.addon_module_mode_tip_access.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.scanhead.instance.attribute.addon_module_mode_tip_access.value_raw', new_val.value)


class RootLuScanheadInstanceAttributePte_laser_setpoint(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead.instance.attribute.pte_laser_setpoint'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scanhead.instance.attribute.pte_laser_setpoint.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scanhead.instance.attribute.pte_laser_setpoint.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scanhead.instance.attribute.pte_laser_setpoint.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scanhead.instance.attribute.pte_laser_setpoint.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scanhead.instance.attribute.pte_laser_setpoint.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scanhead.instance.attribute.pte_laser_setpoint.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scanhead.instance.attribute.pte_laser_setpoint.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scanhead.instance.attribute.pte_laser_setpoint.min', float(new_val))


class RootLuScanheadInstanceAttributeTilt_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        measured = 1
        override = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead.instance.attribute.tilt_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.scanhead.instance.attribute.tilt_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.scanhead.instance.attribute.tilt_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.scanhead.instance.attribute.tilt_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.scanhead.instance.attribute.tilt_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.scanhead.instance.attribute.tilt_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.scanhead.instance.attribute.tilt_mode.value_raw', new_val.value)


class RootLuScanheadInstanceAttributeAddon_module_mode_ssrm(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        invalid10 = 10
        tip_in_sample_bias = 5
        sample_in_tip_bias = 9
        nothing_connected = 0
        invalid02 = 2
        invalid14 = 14
        invalid08 = 8
        invalid03 = 3
        invalid01 = 1
        invalid04 = 4
        invalid13 = 13
        invalid11 = 11
        invalid07 = 7
        invalid06 = 6
        invalid12 = 12

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead.instance.attribute.addon_module_mode_ssrm'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.scanhead.instance.attribute.addon_module_mode_ssrm.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.scanhead.instance.attribute.addon_module_mode_ssrm.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.scanhead.instance.attribute.addon_module_mode_ssrm.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.scanhead.instance.attribute.addon_module_mode_ssrm.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.scanhead.instance.attribute.addon_module_mode_ssrm.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.scanhead.instance.attribute.addon_module_mode_ssrm.value_raw', new_val.value)


class RootLuScanheadInstanceAttributeHas_xy_sensor(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        no = 0
        yes = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead.instance.attribute.has_xy_sensor'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.scanhead.instance.attribute.has_xy_sensor.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.scanhead.instance.attribute.has_xy_sensor.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.scanhead.instance.attribute.has_xy_sensor.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.scanhead.instance.attribute.has_xy_sensor.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.scanhead.instance.attribute.has_xy_sensor.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.scanhead.instance.attribute.has_xy_sensor.value_raw', new_val.value)


class RootLuScanheadInstanceAttributeTilt_angle_y(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead.instance.attribute.tilt_angle_y'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scanhead.instance.attribute.tilt_angle_y.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scanhead.instance.attribute.tilt_angle_y.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scanhead.instance.attribute.tilt_angle_y.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scanhead.instance.attribute.tilt_angle_y.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scanhead.instance.attribute.tilt_angle_y.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scanhead.instance.attribute.tilt_angle_y.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scanhead.instance.attribute.tilt_angle_y.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scanhead.instance.attribute.tilt_angle_y.min', float(new_val))


class RootLuScanheadInstanceAttributeReadout_laser_power_monitor(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead.instance.attribute.readout_laser_power_monitor'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scanhead.instance.attribute.readout_laser_power_monitor.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scanhead.instance.attribute.readout_laser_power_monitor.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scanhead.instance.attribute.readout_laser_power_monitor.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scanhead.instance.attribute.readout_laser_power_monitor.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scanhead.instance.attribute.readout_laser_power_monitor.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scanhead.instance.attribute.readout_laser_power_monitor.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scanhead.instance.attribute.readout_laser_power_monitor.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scanhead.instance.attribute.readout_laser_power_monitor.min', float(new_val))


class RootLuScanheadInstanceAttributePte_laser_power_monitor(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead.instance.attribute.pte_laser_power_monitor'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scanhead.instance.attribute.pte_laser_power_monitor.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scanhead.instance.attribute.pte_laser_power_monitor.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scanhead.instance.attribute.pte_laser_power_monitor.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scanhead.instance.attribute.pte_laser_power_monitor.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scanhead.instance.attribute.pte_laser_power_monitor.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scanhead.instance.attribute.pte_laser_power_monitor.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scanhead.instance.attribute.pte_laser_power_monitor.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scanhead.instance.attribute.pte_laser_power_monitor.min', float(new_val))


class RootLuScanheadInstanceAttributeType(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        flex_afm = 14
        dummy7 = 7
        lens_afm = 15
        core_afm = 19
        dummy3 = 3
        dummy6 = 6
        unknown = 1
        semafm = 16
        dummy8 = 8
        cytomass = 20
        dummy4 = 4
        not_connected = 0
        afsem = 13
        p6_mount = 21
        p6 = 18
        nanite_afm = 12
        arac = 17
        dummy5 = 5
        e_stm = 2
        e_afm = 9
        dummy11 = 11
        dummy10 = 10

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead.instance.attribute.type'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.scanhead.instance.attribute.type.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.scanhead.instance.attribute.type.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.scanhead.instance.attribute.type.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.scanhead.instance.attribute.type.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.scanhead.instance.attribute.type.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.scanhead.instance.attribute.type.value_raw', new_val.value)


class RootLuScanheadInstanceAttributeFast_in2_channel(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        pte_monitor = 2
        addon_in = 1
        friction_channel = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead.instance.attribute.fast_in2_channel'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.scanhead.instance.attribute.fast_in2_channel.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.scanhead.instance.attribute.fast_in2_channel.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.scanhead.instance.attribute.fast_in2_channel.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.scanhead.instance.attribute.fast_in2_channel.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.scanhead.instance.attribute.fast_in2_channel.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.scanhead.instance.attribute.fast_in2_channel.value_raw', new_val.value)


class RootLuScanheadInstanceAttributeType_addon_module(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        tip_current = 2
        ssrm = 4
        not_connected = 1
        tip_access = 3
        unknown = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead.instance.attribute.type_addon_module'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.scanhead.instance.attribute.type_addon_module.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.scanhead.instance.attribute.type_addon_module.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.scanhead.instance.attribute.type_addon_module.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.scanhead.instance.attribute.type_addon_module.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.scanhead.instance.attribute.type_addon_module.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.scanhead.instance.attribute.type_addon_module.value_raw', new_val.value)


class RootLuScanheadInstanceAttributeReadout_laser_setpoint(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead.instance.attribute.readout_laser_setpoint'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.scanhead.instance.attribute.readout_laser_setpoint.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.scanhead.instance.attribute.readout_laser_setpoint.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.scanhead.instance.attribute.readout_laser_setpoint.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.scanhead.instance.attribute.readout_laser_setpoint.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.scanhead.instance.attribute.readout_laser_setpoint.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.scanhead.instance.attribute.readout_laser_setpoint.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.scanhead.instance.attribute.readout_laser_setpoint.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.scanhead.instance.attribute.readout_laser_setpoint.min', float(new_val))


class RootLuScanheadInstanceAttributeAddon_module_mode_tip_current(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        disabled = 0
        invalid3 = 4
        mega1 = 7
        invalid4 = 5
        invalid2 = 3
        invalid1 = 2
        mega100 = 1
        kilo10 = 6
        invalid5 = 8

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead.instance.attribute.addon_module_mode_tip_current'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.scanhead.instance.attribute.addon_module_mode_tip_current.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.scanhead.instance.attribute.addon_module_mode_tip_current.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.scanhead.instance.attribute.addon_module_mode_tip_current.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.scanhead.instance.attribute.addon_module_mode_tip_current.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.scanhead.instance.attribute.addon_module_mode_tip_current.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.scanhead.instance.attribute.addon_module_mode_tip_current.value_raw', new_val.value)


class RootLuScanheadInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead.instance.attribute'
        self.addon_module_mode_tip_current = RootLuScanheadInstanceAttributeAddon_module_mode_tip_current(self._context)
        self.readout_laser_setpoint = RootLuScanheadInstanceAttributeReadout_laser_setpoint(self._context)
        self.type_addon_module = RootLuScanheadInstanceAttributeType_addon_module(self._context)
        self.fast_in2_channel = RootLuScanheadInstanceAttributeFast_in2_channel(self._context)
        self.type = RootLuScanheadInstanceAttributeType(self._context)
        self.pte_laser_power_monitor = RootLuScanheadInstanceAttributePte_laser_power_monitor(self._context)
        self.readout_laser_power_monitor = RootLuScanheadInstanceAttributeReadout_laser_power_monitor(self._context)
        self.tilt_angle_y = RootLuScanheadInstanceAttributeTilt_angle_y(self._context)
        self.has_xy_sensor = RootLuScanheadInstanceAttributeHas_xy_sensor(self._context)
        self.addon_module_mode_ssrm = RootLuScanheadInstanceAttributeAddon_module_mode_ssrm(self._context)
        self.tilt_mode = RootLuScanheadInstanceAttributeTilt_mode(self._context)
        self.pte_laser_setpoint = RootLuScanheadInstanceAttributePte_laser_setpoint(self._context)
        self.addon_module_mode_tip_access = RootLuScanheadInstanceAttributeAddon_module_mode_tip_access(self._context)
        self.tilt_angle_x = RootLuScanheadInstanceAttributeTilt_angle_x(self._context)
        self.has_z_sensor = RootLuScanheadInstanceAttributeHas_z_sensor(self._context)


class RootLuScanheadInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead.instance'
        self.attribute = RootLuScanheadInstanceAttribute(self._context)
        self.trigger = RootLuScanheadInstanceTrigger(self._context)


class RootLuScanhead(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.scanhead'
        self.instance = RootLuScanheadInstance(self._context)


class RootLuSystem_infraInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.trigger'

    def detect_scan_head_lever_change(self) -> None:
        return self._context.call('root.lu.system_infra.instance.trigger.detect_scan_head_lever_change')

    def detect_laser_status_change(self) -> None:
        return self._context.call('root.lu.system_infra.instance.trigger.detect_laser_status_change')

    def switch_clock_source(self) -> None:
        return self._context.call('root.lu.system_infra.instance.trigger.switch_clock_source')

    def detect_scan_head_arrival_removal(self) -> None:
        return self._context.call('root.lu.system_infra.instance.trigger.detect_scan_head_arrival_removal')


class RootLuSystem_infraInstanceAttributeDeflection_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.deflection_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.deflection_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.deflection_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system_infra.instance.attribute.deflection_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system_infra.instance.attribute.deflection_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.deflection_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.deflection_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.deflection_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.deflection_offset.min', float(new_val))


class RootLuSystem_infraInstanceAttributeDepreciated_1(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.depreciated_1'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.depreciated_1.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.depreciated_1.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system_infra.instance.attribute.depreciated_1.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system_infra.instance.attribute.depreciated_1.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.depreciated_1.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.depreciated_1.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.depreciated_1.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.depreciated_1.min', float(new_val))


class RootLuSystem_infraInstanceAttributeDepreciated_0(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.depreciated_0'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.depreciated_0.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.depreciated_0.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system_infra.instance.attribute.depreciated_0.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system_infra.instance.attribute.depreciated_0.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.depreciated_0.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.depreciated_0.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.depreciated_0.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.depreciated_0.min', float(new_val))


class RootLuSystem_infraInstanceAttributeLaser_power_lock(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.laser_power_lock'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.laser_power_lock.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.laser_power_lock.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system_infra.instance.attribute.laser_power_lock.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system_infra.instance.attribute.laser_power_lock.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.laser_power_lock.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.laser_power_lock.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.laser_power_lock.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.laser_power_lock.min', float(new_val))


class RootLuSystem_infraInstanceAttributeTarget_clock_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        external = 1
        internal = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.target_clock_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.target_clock_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.target_clock_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system_infra.instance.attribute.target_clock_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system_infra.instance.attribute.target_clock_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system_infra.instance.attribute.target_clock_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system_infra.instance.attribute.target_clock_source.value_raw', new_val.value)


class RootLuSystem_infraInstanceAttributeLaser_power_absolute(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.laser_power_absolute'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.laser_power_absolute.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.laser_power_absolute.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system_infra.instance.attribute.laser_power_absolute.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system_infra.instance.attribute.laser_power_absolute.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.laser_power_absolute.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.laser_power_absolute.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.laser_power_absolute.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.laser_power_absolute.min', float(new_val))


class RootLuSystem_infraInstanceAttributeMain_in1_gain(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        gain4 = 1
        gain16 = 2
        gain1 = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.main_in1_gain'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.main_in1_gain.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.main_in1_gain.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system_infra.instance.attribute.main_in1_gain.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system_infra.instance.attribute.main_in1_gain.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system_infra.instance.attribute.main_in1_gain.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system_infra.instance.attribute.main_in1_gain.value_raw', new_val.value)


class RootLuSystem_infraInstanceAttributeEnable10_hz_update_sensor_status(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.enable10_hz_update_sensor_status'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.enable10_hz_update_sensor_status.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.enable10_hz_update_sensor_status.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system_infra.instance.attribute.enable10_hz_update_sensor_status.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system_infra.instance.attribute.enable10_hz_update_sensor_status.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.enable10_hz_update_sensor_status.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.enable10_hz_update_sensor_status.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.enable10_hz_update_sensor_status.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.enable10_hz_update_sensor_status.min', float(new_val))


class RootLuSystem_infraInstanceAttributeScan_head_type(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        flex_afm = 14
        dummy7 = 7
        lens_afm = 15
        core_afm = 19
        dummy3 = 3
        dummy6 = 6
        unknown = 1
        semafm = 16
        dummy8 = 8
        cytomass = 20
        dummy4 = 4
        not_connected = 0
        afsem = 13
        p6_mount = 21
        p6 = 18
        nanite_afm = 12
        arac = 17
        dummy5 = 5
        e_stm = 2
        e_afm = 9
        dummy11 = 11
        dummy10 = 10

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.scan_head_type'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.scan_head_type.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.scan_head_type.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system_infra.instance.attribute.scan_head_type.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system_infra.instance.attribute.scan_head_type.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system_infra.instance.attribute.scan_head_type.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system_infra.instance.attribute.scan_head_type.value_raw', new_val.value)


class RootLuSystem_infraInstanceAttributeMain_in2_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        lateral = 1
        user2 = 3
        test_ref = 7
        test_ana_gnd = 6
        deflection = 0
        user3 = 5
        tip_current = 4
        test_tip_voltage = 8
        user1 = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.main_in2_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.main_in2_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.main_in2_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system_infra.instance.attribute.main_in2_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system_infra.instance.attribute.main_in2_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system_infra.instance.attribute.main_in2_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system_infra.instance.attribute.main_in2_input.value_raw', new_val.value)


class RootLuSystem_infraInstanceAttributeInterface_box_type(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        i100_integrated = 4
        i100_afsem = 3
        not_connected = 1
        icxp6 = 8
        icxcytomass = 6
        icxflex = 7
        icxarac = 5
        i100 = 2
        unknown = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.interface_box_type'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.interface_box_type.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.interface_box_type.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system_infra.instance.attribute.interface_box_type.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system_infra.instance.attribute.interface_box_type.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system_infra.instance.attribute.interface_box_type.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system_infra.instance.attribute.interface_box_type.value_raw', new_val.value)


class RootLuSystem_infraInstanceAttributeSensor_light(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.sensor_light'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.sensor_light.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.sensor_light.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system_infra.instance.attribute.sensor_light.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system_infra.instance.attribute.sensor_light.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.sensor_light.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.sensor_light.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.sensor_light.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.sensor_light.min', float(new_val))


class RootLuSystem_infraInstanceAttributeMain_in1_coupling(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ac_coupling = 0
        dc_coupling = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.main_in1_coupling'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.main_in1_coupling.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.main_in1_coupling.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system_infra.instance.attribute.main_in1_coupling.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system_infra.instance.attribute.main_in1_coupling.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system_infra.instance.attribute.main_in1_coupling.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system_infra.instance.attribute.main_in1_coupling.value_raw', new_val.value)


class RootLuSystem_infraInstanceAttributeTip_current_or_in_user3_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        in_user3 = 1
        ana_gnd = 2
        tip_current = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.tip_current_or_in_user3_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.tip_current_or_in_user3_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.tip_current_or_in_user3_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system_infra.instance.attribute.tip_current_or_in_user3_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system_infra.instance.attribute.tip_current_or_in_user3_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system_infra.instance.attribute.tip_current_or_in_user3_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system_infra.instance.attribute.tip_current_or_in_user3_input.value_raw', new_val.value)


class RootLuSystem_infraInstanceAttributeAfm_sensor_status_normalized(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.afm_sensor_status_normalized'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.afm_sensor_status_normalized.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.afm_sensor_status_normalized.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system_infra.instance.attribute.afm_sensor_status_normalized.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system_infra.instance.attribute.afm_sensor_status_normalized.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.afm_sensor_status_normalized.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.afm_sensor_status_normalized.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.afm_sensor_status_normalized.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.afm_sensor_status_normalized.min', float(new_val))


class RootLuSystem_infraInstanceAttributeFast_out2_output_mask(wrap.CmdTreeProp):

    class ValueMask(enum.IntEnum):
        user_out_b = 16
        all = 31
        user_out1 = 8
        tip_voltage_or_user_out_a = 4
        monitor2 = 2
        none = 0
        monitor1 = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.fast_out2_output_mask'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.fast_out2_output_mask.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.fast_out2_output_mask.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system_infra.instance.attribute.fast_out2_output_mask.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system_infra.instance.attribute.fast_out2_output_mask.enum', list(new_val))

    @property
    def value(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.fast_out2_output_mask.value_raw'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.fast_out2_output_mask.value_raw', int(new_val))


class RootLuSystem_infraInstanceAttributeFriction_normalized(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.friction_normalized'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.friction_normalized.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.friction_normalized.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system_infra.instance.attribute.friction_normalized.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system_infra.instance.attribute.friction_normalized.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.friction_normalized.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.friction_normalized.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.friction_normalized.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.friction_normalized.min', float(new_val))


class RootLuSystem_infraInstanceAttributeLaser_power_current(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.laser_power_current'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.laser_power_current.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.laser_power_current.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system_infra.instance.attribute.laser_power_current.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system_infra.instance.attribute.laser_power_current.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.laser_power_current.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.laser_power_current.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.laser_power_current.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.laser_power_current.min', float(new_val))


class RootLuSystem_infraInstanceAttributeSensor_value_normalized(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.sensor_value_normalized'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.sensor_value_normalized.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.sensor_value_normalized.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system_infra.instance.attribute.sensor_value_normalized.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system_infra.instance.attribute.sensor_value_normalized.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.sensor_value_normalized.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.sensor_value_normalized.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.sensor_value_normalized.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.sensor_value_normalized.min', float(new_val))


class RootLuSystem_infraInstanceAttributeController_temperature(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.controller_temperature'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.controller_temperature.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.controller_temperature.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system_infra.instance.attribute.controller_temperature.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system_infra.instance.attribute.controller_temperature.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.controller_temperature.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.controller_temperature.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.controller_temperature.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.controller_temperature.min', float(new_val))


class RootLuSystem_infraInstanceAttributeDepreciated_2(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.depreciated_2'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.depreciated_2.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.depreciated_2.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system_infra.instance.attribute.depreciated_2.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system_infra.instance.attribute.depreciated_2.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.depreciated_2.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.depreciated_2.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.depreciated_2.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.depreciated_2.min', float(new_val))


class RootLuSystem_infraInstanceAttributeMain_in2_coupling(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ac_coupling = 0
        dc_coupling = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.main_in2_coupling'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.main_in2_coupling.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.main_in2_coupling.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system_infra.instance.attribute.main_in2_coupling.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system_infra.instance.attribute.main_in2_coupling.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system_infra.instance.attribute.main_in2_coupling.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system_infra.instance.attribute.main_in2_coupling.value_raw', new_val.value)


class RootLuSystem_infraInstanceAttributeAfm_sensor_status(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        low = 1
        high = 3
        fail = 4
        ok = 2
        undefined = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.afm_sensor_status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.afm_sensor_status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.afm_sensor_status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system_infra.instance.attribute.afm_sensor_status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system_infra.instance.attribute.afm_sensor_status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system_infra.instance.attribute.afm_sensor_status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system_infra.instance.attribute.afm_sensor_status.value_raw', new_val.value)


class RootLuSystem_infraInstanceAttributeApproach_motor_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        undefined = 0
        limit_switches = 1
        position_sensor = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.approach_motor_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.approach_motor_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.approach_motor_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system_infra.instance.attribute.approach_motor_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system_infra.instance.attribute.approach_motor_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system_infra.instance.attribute.approach_motor_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system_infra.instance.attribute.approach_motor_mode.value_raw', new_val.value)


class RootLuSystem_infraInstanceAttributeMain_in2_gain(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        gain4 = 1
        gain16 = 2
        gain1 = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.main_in2_gain'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.main_in2_gain.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.main_in2_gain.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system_infra.instance.attribute.main_in2_gain.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system_infra.instance.attribute.main_in2_gain.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system_infra.instance.attribute.main_in2_gain.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system_infra.instance.attribute.main_in2_gain.value_raw', new_val.value)


class RootLuSystem_infraInstanceAttributeAfm_sensor_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        undefined = 0
        laser_power = 2
        laser_drive = 1
        detector_intensity = 3

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.afm_sensor_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.afm_sensor_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.afm_sensor_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system_infra.instance.attribute.afm_sensor_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system_infra.instance.attribute.afm_sensor_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system_infra.instance.attribute.afm_sensor_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system_infra.instance.attribute.afm_sensor_mode.value_raw', new_val.value)


class RootLuSystem_infraInstanceAttributeApproach_motor_status_normalized(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.approach_motor_status_normalized'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.approach_motor_status_normalized.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.approach_motor_status_normalized.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system_infra.instance.attribute.approach_motor_status_normalized.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system_infra.instance.attribute.approach_motor_status_normalized.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.approach_motor_status_normalized.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.approach_motor_status_normalized.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.approach_motor_status_normalized.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.approach_motor_status_normalized.min', float(new_val))


class RootLuSystem_infraInstanceAttributeExtra_in1_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ana_gnd = 1
        in_user1 = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.extra_in1_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.extra_in1_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.extra_in1_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system_infra.instance.attribute.extra_in1_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system_infra.instance.attribute.extra_in1_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system_infra.instance.attribute.extra_in1_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system_infra.instance.attribute.extra_in1_input.value_raw', new_val.value)


class RootLuSystem_infraInstanceAttributeCurrent_clock_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        external = 1
        internal = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.current_clock_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.current_clock_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.current_clock_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system_infra.instance.attribute.current_clock_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system_infra.instance.attribute.current_clock_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system_infra.instance.attribute.current_clock_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system_infra.instance.attribute.current_clock_source.value_raw', new_val.value)


class RootLuSystem_infraInstanceAttributeControl_laser_power(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.control_laser_power'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.control_laser_power.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.control_laser_power.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system_infra.instance.attribute.control_laser_power.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system_infra.instance.attribute.control_laser_power.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.control_laser_power.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.control_laser_power.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.control_laser_power.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.control_laser_power.min', float(new_val))


class RootLuSystem_infraInstanceAttributeApproach_motor_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.approach_motor_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.approach_motor_position.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.approach_motor_position.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.system_infra.instance.attribute.approach_motor_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.system_infra.instance.attribute.approach_motor_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.approach_motor_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.approach_motor_position.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.system_infra.instance.attribute.approach_motor_position.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.system_infra.instance.attribute.approach_motor_position.min', float(new_val))


class RootLuSystem_infraInstanceAttributeController_type(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        cx_rev0 = 4
        c3000 = 2
        core_afm = 3
        cx_rev3 = 6
        c3000_i = 5
        unknown = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.controller_type'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.controller_type.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.controller_type.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system_infra.instance.attribute.controller_type.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system_infra.instance.attribute.controller_type.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system_infra.instance.attribute.controller_type.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system_infra.instance.attribute.controller_type.value_raw', new_val.value)


class RootLuSystem_infraInstanceAttributeApproach_motor_status(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        dummy_0 = 0
        in_range = 1
        not_connected = 4
        error = 5
        min_in = 2
        max_out = 3

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.approach_motor_status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.approach_motor_status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.approach_motor_status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system_infra.instance.attribute.approach_motor_status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system_infra.instance.attribute.approach_motor_status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system_infra.instance.attribute.approach_motor_status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system_infra.instance.attribute.approach_motor_status.value_raw', new_val.value)


class RootLuSystem_infraInstanceAttributeTip_signal_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        current_sense_input = 0
        external_feedthrough = 2
        voltage_output = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute.tip_signal_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.system_infra.instance.attribute.tip_signal_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.system_infra.instance.attribute.tip_signal_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.system_infra.instance.attribute.tip_signal_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.system_infra.instance.attribute.tip_signal_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.system_infra.instance.attribute.tip_signal_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.system_infra.instance.attribute.tip_signal_mode.value_raw', new_val.value)


class RootLuSystem_infraInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance.attribute'
        self.tip_signal_mode = RootLuSystem_infraInstanceAttributeTip_signal_mode(self._context)
        self.approach_motor_status = RootLuSystem_infraInstanceAttributeApproach_motor_status(self._context)
        self.controller_type = RootLuSystem_infraInstanceAttributeController_type(self._context)
        self.approach_motor_position = RootLuSystem_infraInstanceAttributeApproach_motor_position(self._context)
        self.control_laser_power = RootLuSystem_infraInstanceAttributeControl_laser_power(self._context)
        self.current_clock_source = RootLuSystem_infraInstanceAttributeCurrent_clock_source(self._context)
        self.extra_in1_input = RootLuSystem_infraInstanceAttributeExtra_in1_input(self._context)
        self.approach_motor_status_normalized = RootLuSystem_infraInstanceAttributeApproach_motor_status_normalized(self._context)
        self.afm_sensor_mode = RootLuSystem_infraInstanceAttributeAfm_sensor_mode(self._context)
        self.main_in2_gain = RootLuSystem_infraInstanceAttributeMain_in2_gain(self._context)
        self.approach_motor_mode = RootLuSystem_infraInstanceAttributeApproach_motor_mode(self._context)
        self.afm_sensor_status = RootLuSystem_infraInstanceAttributeAfm_sensor_status(self._context)
        self.main_in2_coupling = RootLuSystem_infraInstanceAttributeMain_in2_coupling(self._context)
        self.depreciated_2 = RootLuSystem_infraInstanceAttributeDepreciated_2(self._context)
        self.controller_temperature = RootLuSystem_infraInstanceAttributeController_temperature(self._context)
        self.sensor_value_normalized = RootLuSystem_infraInstanceAttributeSensor_value_normalized(self._context)
        self.laser_power_current = RootLuSystem_infraInstanceAttributeLaser_power_current(self._context)
        self.friction_normalized = RootLuSystem_infraInstanceAttributeFriction_normalized(self._context)
        self.fast_out2_output_mask = RootLuSystem_infraInstanceAttributeFast_out2_output_mask(self._context)
        self.afm_sensor_status_normalized = RootLuSystem_infraInstanceAttributeAfm_sensor_status_normalized(self._context)
        self.tip_current_or_in_user3_input = RootLuSystem_infraInstanceAttributeTip_current_or_in_user3_input(self._context)
        self.main_in1_coupling = RootLuSystem_infraInstanceAttributeMain_in1_coupling(self._context)
        self.sensor_light = RootLuSystem_infraInstanceAttributeSensor_light(self._context)
        self.interface_box_type = RootLuSystem_infraInstanceAttributeInterface_box_type(self._context)
        self.main_in2_input = RootLuSystem_infraInstanceAttributeMain_in2_input(self._context)
        self.scan_head_type = RootLuSystem_infraInstanceAttributeScan_head_type(self._context)
        self.enable10_hz_update_sensor_status = RootLuSystem_infraInstanceAttributeEnable10_hz_update_sensor_status(self._context)
        self.main_in1_gain = RootLuSystem_infraInstanceAttributeMain_in1_gain(self._context)
        self.laser_power_absolute = RootLuSystem_infraInstanceAttributeLaser_power_absolute(self._context)
        self.target_clock_source = RootLuSystem_infraInstanceAttributeTarget_clock_source(self._context)
        self.laser_power_lock = RootLuSystem_infraInstanceAttributeLaser_power_lock(self._context)
        self.depreciated_0 = RootLuSystem_infraInstanceAttributeDepreciated_0(self._context)
        self.depreciated_1 = RootLuSystem_infraInstanceAttributeDepreciated_1(self._context)
        self.deflection_offset = RootLuSystem_infraInstanceAttributeDeflection_offset(self._context)


class RootLuSystem_infraInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra.instance'
        self.attribute = RootLuSystem_infraInstanceAttribute(self._context)
        self.trigger = RootLuSystem_infraInstanceTrigger(self._context)


class RootLuSystem_infra(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.system_infra'
        self.instance = RootLuSystem_infraInstance(self._context)


class RootLuAnalog_fast_inCh2Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.ch2.trigger'


class RootLuAnalog_fast_inCh2AttributeCross_coupling_axis_id(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        position_z = 2
        self = 4
        position_y = 1
        position_w = 3
        position_x = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.ch2.attribute.cross_coupling_axis_id'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_in.ch2.attribute.cross_coupling_axis_id.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.cross_coupling_axis_id.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_in.ch2.attribute.cross_coupling_axis_id.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.cross_coupling_axis_id.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_in.ch2.attribute.cross_coupling_axis_id.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.cross_coupling_axis_id.value_raw', new_val.value)


class RootLuAnalog_fast_inCh2AttributeInput_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.ch2.attribute.input_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.ch2.attribute.input_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.input_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_in.ch2.attribute.input_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.input_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.ch2.attribute.input_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.input_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.ch2.attribute.input_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.input_offset.min', float(new_val))


class RootLuAnalog_fast_inCh2AttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.ch2.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.ch2.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_in.ch2.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.ch2.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.ch2.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_fast_inCh2AttributeCurrent_input_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.ch2.attribute.current_input_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.ch2.attribute.current_input_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.current_input_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_in.ch2.attribute.current_input_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.current_input_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.ch2.attribute.current_input_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.current_input_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.ch2.attribute.current_input_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.current_input_value.min', float(new_val))


class RootLuAnalog_fast_inCh2AttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.ch2.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_in.ch2.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_in.ch2.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_in.ch2.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_fast_inCh2AttributeInput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.ch2.attribute.input_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.ch2.attribute.input_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.input_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_in.ch2.attribute.input_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.input_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.ch2.attribute.input_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.input_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.ch2.attribute.input_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.input_gain.min', float(new_val))


class RootLuAnalog_fast_inCh2AttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.ch2.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.ch2.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_in.ch2.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.ch2.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.ch2.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_fast_inCh2AttributeCross_coupling_axis_coefficient_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.ch2.attribute.cross_coupling_axis_coefficient_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_in.ch2.attribute.cross_coupling_axis_coefficient_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.cross_coupling_axis_coefficient_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_fast_in.ch2.attribute.cross_coupling_axis_coefficient_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.cross_coupling_axis_coefficient_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_fast_in.ch2.attribute.cross_coupling_axis_coefficient_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_fast_in.ch2.attribute.cross_coupling_axis_coefficient_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.ch2.attribute.cross_coupling_axis_coefficient_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.cross_coupling_axis_coefficient_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.ch2.attribute.cross_coupling_axis_coefficient_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.ch2.attribute.cross_coupling_axis_coefficient_vec.min', float(new_val))


class RootLuAnalog_fast_inCh2Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.ch2.attribute'
        self.cross_coupling_axis_coefficient_vec = RootLuAnalog_fast_inCh2AttributeCross_coupling_axis_coefficient_vec(self._context)
        self.calib_offset = RootLuAnalog_fast_inCh2AttributeCalib_offset(self._context)
        self.input_gain = RootLuAnalog_fast_inCh2AttributeInput_gain(self._context)
        self.calib_polarity = RootLuAnalog_fast_inCh2AttributeCalib_polarity(self._context)
        self.current_input_value = RootLuAnalog_fast_inCh2AttributeCurrent_input_value(self._context)
        self.calib_gain = RootLuAnalog_fast_inCh2AttributeCalib_gain(self._context)
        self.input_offset = RootLuAnalog_fast_inCh2AttributeInput_offset(self._context)
        self.cross_coupling_axis_id = RootLuAnalog_fast_inCh2AttributeCross_coupling_axis_id(self._context)


class RootLuAnalog_fast_inCh2(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.ch2'
        self.attribute = RootLuAnalog_fast_inCh2Attribute(self._context)
        self.trigger = RootLuAnalog_fast_inCh2Trigger(self._context)


class RootLuAnalog_fast_inDeflectionTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.deflection.trigger'


class RootLuAnalog_fast_inDeflectionAttributeCross_coupling_axis_id(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        position_z = 2
        self = 4
        position_y = 1
        position_w = 3
        position_x = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.deflection.attribute.cross_coupling_axis_id'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_in.deflection.attribute.cross_coupling_axis_id.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.cross_coupling_axis_id.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_in.deflection.attribute.cross_coupling_axis_id.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.cross_coupling_axis_id.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_in.deflection.attribute.cross_coupling_axis_id.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.cross_coupling_axis_id.value_raw', new_val.value)


class RootLuAnalog_fast_inDeflectionAttributeInput_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.deflection.attribute.input_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.deflection.attribute.input_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.input_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_in.deflection.attribute.input_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.input_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.deflection.attribute.input_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.input_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.deflection.attribute.input_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.input_offset.min', float(new_val))


class RootLuAnalog_fast_inDeflectionAttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.deflection.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.deflection.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_in.deflection.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.deflection.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.deflection.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_fast_inDeflectionAttributeCurrent_input_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.deflection.attribute.current_input_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.deflection.attribute.current_input_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.current_input_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_in.deflection.attribute.current_input_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.current_input_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.deflection.attribute.current_input_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.current_input_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.deflection.attribute.current_input_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.current_input_value.min', float(new_val))


class RootLuAnalog_fast_inDeflectionAttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.deflection.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_in.deflection.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_in.deflection.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_in.deflection.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_fast_inDeflectionAttributeInput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.deflection.attribute.input_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.deflection.attribute.input_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.input_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_in.deflection.attribute.input_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.input_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.deflection.attribute.input_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.input_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.deflection.attribute.input_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.input_gain.min', float(new_val))


class RootLuAnalog_fast_inDeflectionAttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.deflection.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.deflection.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_in.deflection.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.deflection.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.deflection.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_fast_inDeflectionAttributeCross_coupling_axis_coefficient_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.deflection.attribute.cross_coupling_axis_coefficient_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_in.deflection.attribute.cross_coupling_axis_coefficient_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.cross_coupling_axis_coefficient_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_fast_in.deflection.attribute.cross_coupling_axis_coefficient_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.cross_coupling_axis_coefficient_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_fast_in.deflection.attribute.cross_coupling_axis_coefficient_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_fast_in.deflection.attribute.cross_coupling_axis_coefficient_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.deflection.attribute.cross_coupling_axis_coefficient_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.cross_coupling_axis_coefficient_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.deflection.attribute.cross_coupling_axis_coefficient_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.deflection.attribute.cross_coupling_axis_coefficient_vec.min', float(new_val))


class RootLuAnalog_fast_inDeflectionAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.deflection.attribute'
        self.cross_coupling_axis_coefficient_vec = RootLuAnalog_fast_inDeflectionAttributeCross_coupling_axis_coefficient_vec(self._context)
        self.calib_offset = RootLuAnalog_fast_inDeflectionAttributeCalib_offset(self._context)
        self.input_gain = RootLuAnalog_fast_inDeflectionAttributeInput_gain(self._context)
        self.calib_polarity = RootLuAnalog_fast_inDeflectionAttributeCalib_polarity(self._context)
        self.current_input_value = RootLuAnalog_fast_inDeflectionAttributeCurrent_input_value(self._context)
        self.calib_gain = RootLuAnalog_fast_inDeflectionAttributeCalib_gain(self._context)
        self.input_offset = RootLuAnalog_fast_inDeflectionAttributeInput_offset(self._context)
        self.cross_coupling_axis_id = RootLuAnalog_fast_inDeflectionAttributeCross_coupling_axis_id(self._context)


class RootLuAnalog_fast_inDeflection(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.deflection'
        self.attribute = RootLuAnalog_fast_inDeflectionAttribute(self._context)
        self.trigger = RootLuAnalog_fast_inDeflectionTrigger(self._context)


class RootLuAnalog_fast_inUserTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.user.trigger'


class RootLuAnalog_fast_inUserAttributeCross_coupling_axis_id(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        position_z = 2
        self = 4
        position_y = 1
        position_w = 3
        position_x = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.user.attribute.cross_coupling_axis_id'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_in.user.attribute.cross_coupling_axis_id.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_in.user.attribute.cross_coupling_axis_id.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_in.user.attribute.cross_coupling_axis_id.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_in.user.attribute.cross_coupling_axis_id.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_in.user.attribute.cross_coupling_axis_id.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_in.user.attribute.cross_coupling_axis_id.value_raw', new_val.value)


class RootLuAnalog_fast_inUserAttributeInput_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.user.attribute.input_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.user.attribute.input_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.user.attribute.input_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_in.user.attribute.input_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_in.user.attribute.input_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.user.attribute.input_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.user.attribute.input_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.user.attribute.input_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.user.attribute.input_offset.min', float(new_val))


class RootLuAnalog_fast_inUserAttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.user.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.user.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.user.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_in.user.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_in.user.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.user.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.user.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.user.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.user.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_fast_inUserAttributeCurrent_input_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.user.attribute.current_input_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.user.attribute.current_input_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.user.attribute.current_input_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_in.user.attribute.current_input_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_in.user.attribute.current_input_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.user.attribute.current_input_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.user.attribute.current_input_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.user.attribute.current_input_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.user.attribute.current_input_value.min', float(new_val))


class RootLuAnalog_fast_inUserAttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.user.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_in.user.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_in.user.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_in.user.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_in.user.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_in.user.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_in.user.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_fast_inUserAttributeInput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.user.attribute.input_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.user.attribute.input_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.user.attribute.input_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_in.user.attribute.input_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_in.user.attribute.input_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.user.attribute.input_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.user.attribute.input_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.user.attribute.input_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.user.attribute.input_gain.min', float(new_val))


class RootLuAnalog_fast_inUserAttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.user.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.user.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.user.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_in.user.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_in.user.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.user.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.user.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.user.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.user.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_fast_inUserAttributeCross_coupling_axis_coefficient_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.user.attribute.cross_coupling_axis_coefficient_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_in.user.attribute.cross_coupling_axis_coefficient_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_in.user.attribute.cross_coupling_axis_coefficient_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_fast_in.user.attribute.cross_coupling_axis_coefficient_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_fast_in.user.attribute.cross_coupling_axis_coefficient_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_fast_in.user.attribute.cross_coupling_axis_coefficient_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_fast_in.user.attribute.cross_coupling_axis_coefficient_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.user.attribute.cross_coupling_axis_coefficient_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.user.attribute.cross_coupling_axis_coefficient_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_in.user.attribute.cross_coupling_axis_coefficient_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_in.user.attribute.cross_coupling_axis_coefficient_vec.min', float(new_val))


class RootLuAnalog_fast_inUserAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.user.attribute'
        self.cross_coupling_axis_coefficient_vec = RootLuAnalog_fast_inUserAttributeCross_coupling_axis_coefficient_vec(self._context)
        self.calib_offset = RootLuAnalog_fast_inUserAttributeCalib_offset(self._context)
        self.input_gain = RootLuAnalog_fast_inUserAttributeInput_gain(self._context)
        self.calib_polarity = RootLuAnalog_fast_inUserAttributeCalib_polarity(self._context)
        self.current_input_value = RootLuAnalog_fast_inUserAttributeCurrent_input_value(self._context)
        self.calib_gain = RootLuAnalog_fast_inUserAttributeCalib_gain(self._context)
        self.input_offset = RootLuAnalog_fast_inUserAttributeInput_offset(self._context)
        self.cross_coupling_axis_id = RootLuAnalog_fast_inUserAttributeCross_coupling_axis_id(self._context)


class RootLuAnalog_fast_inUser(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in.user'
        self.attribute = RootLuAnalog_fast_inUserAttribute(self._context)
        self.trigger = RootLuAnalog_fast_inUserTrigger(self._context)


class RootLuAnalog_fast_in(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_in'
        self.user = RootLuAnalog_fast_inUser(self._context)
        self.deflection = RootLuAnalog_fast_inDeflection(self._context)
        self.ch2 = RootLuAnalog_fast_inCh2(self._context)


class RootLuSignal_analyzerInst2Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.trigger'

    def kpfm_phase_calibration(self) -> None:
        return self._context.call('root.lu.signal_analyzer.inst2.trigger.kpfm_phase_calibration')

    def switch_to_target_amplitude_ctrl_mode(self) -> None:
        return self._context.call('root.lu.signal_analyzer.inst2.trigger.switch_to_target_amplitude_ctrl_mode')

    def start_phase_zero_calibration(self) -> None:
        return self._context.call('root.lu.signal_analyzer.inst2.trigger.start_phase_zero_calibration')

    def switch_to_target_amplitude_ctrl_set_point(self) -> None:
        return self._context.call('root.lu.signal_analyzer.inst2.trigger.switch_to_target_amplitude_ctrl_set_point')

    def user_abort(self) -> None:
        return self._context.call('root.lu.signal_analyzer.inst2.trigger.user_abort')

    def start_kpfm_phase_calibration(self) -> None:
        return self._context.call('root.lu.signal_analyzer.inst2.trigger.start_kpfm_phase_calibration')

    def start_switch_to_target_amplitude_ctrl_mode(self) -> None:
        return self._context.call('root.lu.signal_analyzer.inst2.trigger.start_switch_to_target_amplitude_ctrl_mode')

    def start_switch_to_target_amplitude_ctrl_set_point(self) -> None:
        return self._context.call('root.lu.signal_analyzer.inst2.trigger.start_switch_to_target_amplitude_ctrl_set_point')


class RootLuSignal_analyzerInst2AttributeCurrent_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.current_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_amplitude.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_amplitude.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_amplitude.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_amplitude.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_amplitude.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeAmplitude_modulation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.amplitude_modulation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst2.attribute.amplitude_modulation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.amplitude_modulation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst2.attribute.amplitude_modulation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.amplitude_modulation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst2.attribute.amplitude_modulation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.amplitude_modulation.value_raw', new_val.value)


class RootLuSignal_analyzerInst2AttributeCurrent_ctrl_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.current_ctrl_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_ctrl_amplitude.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_ctrl_amplitude.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_ctrl_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_ctrl_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_ctrl_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_ctrl_amplitude.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_ctrl_amplitude.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_ctrl_amplitude.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeAmplitude_ctrl_i_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_i_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_i_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_i_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_i_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_i_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_i_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_i_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_i_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_i_gain.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeCurrent_reference_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.current_reference_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_reference_amplitude.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_reference_amplitude.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_reference_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_reference_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_reference_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_reference_amplitude.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_reference_amplitude.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_reference_amplitude.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeReference_frequency(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.reference_frequency'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_frequency.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_frequency.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_frequency.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_frequency.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_frequency.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_frequency.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_frequency.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_frequency.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeHarmonic_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1 = 0
        analyzer2 = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.harmonic_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst2.attribute.harmonic_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.harmonic_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst2.attribute.harmonic_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.harmonic_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst2.attribute.harmonic_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.harmonic_source.value_raw', new_val.value)


class RootLuSignal_analyzerInst2AttributeLock_in_calc_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.lock_in_calc_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.lock_in_calc_amplitude.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.lock_in_calc_amplitude.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.lock_in_calc_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.lock_in_calc_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.lock_in_calc_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.lock_in_calc_amplitude.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.lock_in_calc_amplitude.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.lock_in_calc_amplitude.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeCurrent_y_binary(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.current_y_binary'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_y_binary.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_y_binary.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_y_binary.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_y_binary.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_y_binary.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_y_binary.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_y_binary.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_y_binary.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeLock_in_calc_phase(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.lock_in_calc_phase'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.lock_in_calc_phase.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.lock_in_calc_phase.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.lock_in_calc_phase.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.lock_in_calc_phase.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.lock_in_calc_phase.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.lock_in_calc_phase.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.lock_in_calc_phase.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.lock_in_calc_phase.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeTarget_amplitude_ctrl_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        const_amplitude = 1
        const_drive = 0
        free_vibration = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.target_amplitude_ctrl_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst2.attribute.target_amplitude_ctrl_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.target_amplitude_ctrl_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst2.attribute.target_amplitude_ctrl_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.target_amplitude_ctrl_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst2.attribute.target_amplitude_ctrl_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.target_amplitude_ctrl_mode.value_raw', new_val.value)


class RootLuSignal_analyzerInst2AttributeReference_amplitude_factor(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.reference_amplitude_factor'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_amplitude_factor.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_amplitude_factor.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_amplitude_factor.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_amplitude_factor.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_amplitude_factor.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_amplitude_factor.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_amplitude_factor.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_amplitude_factor.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeDisplay_df_range(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.display_df_range'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.display_df_range.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.display_df_range.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.display_df_range.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.display_df_range.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.display_df_range.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.display_df_range.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.display_df_range.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.display_df_range.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeDemodulator_bw(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        bw_45_k_hz = 12
        bw_1500_hz = 7
        bw_750_hz = 6
        bw_45_hz = 2
        bw_500_k_hz = 15
        bw_360_hz = 5
        bw_23_k_hz = 11
        bw_90_hz = 3
        bw_230_k_hz = 14
        bw_180_hz = 4
        bw_6_k_hz = 9
        bw_3_k_hz = 8
        bw_100_k_hz = 13
        bw_23_hz = 1
        bw_12_k_hz = 10

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.demodulator_bw'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst2.attribute.demodulator_bw.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.demodulator_bw.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst2.attribute.demodulator_bw.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.demodulator_bw.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst2.attribute.demodulator_bw.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.demodulator_bw.value_raw', new_val.value)


class RootLuSignal_analyzerInst2AttributePhase_ctrl_p_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.phase_ctrl_p_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.phase_ctrl_p_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.phase_ctrl_p_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.phase_ctrl_p_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.phase_ctrl_p_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.phase_ctrl_p_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.phase_ctrl_p_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.phase_ctrl_p_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.phase_ctrl_p_gain.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeCurrent_ctrl_delta_f(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.current_ctrl_delta_f'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_ctrl_delta_f.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_ctrl_delta_f.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_ctrl_delta_f.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_ctrl_delta_f.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_ctrl_delta_f.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_ctrl_delta_f.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_ctrl_delta_f.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_ctrl_delta_f.min', float(new_val))


class RootLuSignal_analyzerInst2AttributePhase_ctrl_i_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.phase_ctrl_i_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.phase_ctrl_i_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.phase_ctrl_i_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.phase_ctrl_i_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.phase_ctrl_i_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.phase_ctrl_i_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.phase_ctrl_i_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.phase_ctrl_i_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.phase_ctrl_i_gain.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeCurrent_amplitude_ctrl_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        const_amplitude = 1
        const_drive = 0
        free_vibration = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.current_amplitude_ctrl_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_amplitude_ctrl_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_amplitude_ctrl_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_amplitude_ctrl_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_amplitude_ctrl_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_amplitude_ctrl_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_amplitude_ctrl_mode.value_raw', new_val.value)


class RootLuSignal_analyzerInst2AttributePhase_lock_range(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.phase_lock_range'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.phase_lock_range.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.phase_lock_range.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.phase_lock_range.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.phase_lock_range.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.phase_lock_range.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.phase_lock_range.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.phase_lock_range.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.phase_lock_range.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeTarget_amplitude_ctrl_set_point(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.target_amplitude_ctrl_set_point'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.target_amplitude_ctrl_set_point.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.target_amplitude_ctrl_set_point.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.target_amplitude_ctrl_set_point.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.target_amplitude_ctrl_set_point.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.target_amplitude_ctrl_set_point.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.target_amplitude_ctrl_set_point.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.target_amplitude_ctrl_set_point.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.target_amplitude_ctrl_set_point.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeOperating_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        kpfm = 2
        lock_in = 0
        pll = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.operating_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst2.attribute.operating_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.operating_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst2.attribute.operating_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.operating_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst2.attribute.operating_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.operating_mode.value_raw', new_val.value)


class RootLuSignal_analyzerInst2AttributeCurrent_phase(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.current_phase'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_phase.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_phase.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_phase.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_phase.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_phase.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_phase.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_phase.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_phase.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeCurrent_y(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.current_y'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_y.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_y.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_y.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_y.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_y.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_y.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_y.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_y.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeEnable_dc_block(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.enable_dc_block'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst2.attribute.enable_dc_block.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.enable_dc_block.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst2.attribute.enable_dc_block.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.enable_dc_block.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst2.attribute.enable_dc_block.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.enable_dc_block.value_raw', new_val.value)


class RootLuSignal_analyzerInst2AttributeAmplitude_ctrl_p_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_p_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_p_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_p_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_p_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_p_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_p_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_p_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_p_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_p_gain.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeReset_flag_pll_unlocked(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.reset_flag_pll_unlocked'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.reset_flag_pll_unlocked.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reset_flag_pll_unlocked.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.reset_flag_pll_unlocked.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reset_flag_pll_unlocked.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.reset_flag_pll_unlocked.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reset_flag_pll_unlocked.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.reset_flag_pll_unlocked.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reset_flag_pll_unlocked.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeCurrent_x(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.current_x'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_x.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_x.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_x.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_x.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_x.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_x.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_x.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_x.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeCurrent_x_binary(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.current_x_binary'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_x_binary.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_x_binary.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_x_binary.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_x_binary.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_x_binary.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_x_binary.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_x_binary.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_x_binary.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeDelay_comp(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.delay_comp'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.delay_comp.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.delay_comp.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.delay_comp.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.delay_comp.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.delay_comp.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.delay_comp.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.delay_comp.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.delay_comp.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 44
        analyzer1_amplitude = 15
        ramp_gen_max_z = 41
        ctrl_x_out = 47
        analyzer2_reference = 65
        analyzer2_ctrl_amplitude = 57
        comparator1_out = 68
        ort_excitation = 66
        ramp_gen_tip_voltage = 36
        memory_gen_out8 = 31
        fast_in_user = 2
        analyzer1_x = 54
        memory_gen_position_z = 28
        ctrl_w_out = 49
        analyzer1_y = 55
        analyzer2_amplitude = 59
        in_user1 = 4
        ramp_gen_user4 = 38
        memory_gen_out7 = 30
        ramp_gen_position_y = 34
        ramp_gen_position_x = 33
        ctrl_user1_out = 50
        in_tip_current = 8
        in_position_y = 13
        comparator2_in_filtered = 69
        analyzer2_x = 60
        memory_gen_position_y = 26
        memory_gen_position_x = 24
        ctrl_z_error = 43
        comparator1_in_filtered = 67
        ctrl_z_nominal = 46
        analyzer1_reference = 64
        analyzer1_phase = 53
        comparator2_out = 70
        analyzer2_phase = 58
        analyzer1_ctrl_delta_f = 16
        memory_gen_drive_y = 27
        ctrl_z_sum = 45
        ramp_gen_alternate_z = 37
        comparator3_in_filtered = 71
        ctrl_user2_out = 51
        analyzer2_ctrl_delta_f = 56
        analyzer2_y = 61
        in_detector_sum = 22
        fast_in2 = 1
        in_position_x = 12
        in_user4 = 7
        test_tip_voltage = 11
        test_ref = 10
        test_ana_gnd = 9
        static = 18
        ramp_gen_ctrl_z = 40
        ramp_gen_test = 20
        memory_gen_drive_z = 29
        ramp_gen_position_w = 35
        comparator3_out = 72
        ramp_gen_plane_z = 39
        ramp_gen_approach = 32
        ort_baseline = 62
        ort_amplitude_reduction = 63
        analyzer1_ctrl_amplitude = 52
        ctrl_y_out = 48
        ctrl_z_in = 42
        in_position_z = 14
        fast_in_deflection = 0
        memory_gen_drive_x = 25
        in6 = 23
        ctrl_z_out = 17
        in_user3 = 6
        in_user2 = 5
        in_lateral = 3
        in_deflection = 21
        gen_test_dynamic = 19

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst2.attribute.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst2.attribute.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst2.attribute.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.input.value_raw', new_val.value)


class RootLuSignal_analyzerInst2AttributePll_unlocked(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.pll_unlocked'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.pll_unlocked.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.pll_unlocked.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.pll_unlocked.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.pll_unlocked.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.pll_unlocked.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.pll_unlocked.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.pll_unlocked.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.pll_unlocked.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeCurrent_amplitude_ctrl_set_point(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.current_amplitude_ctrl_set_point'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_amplitude_ctrl_set_point.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_amplitude_ctrl_set_point.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_amplitude_ctrl_set_point.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_amplitude_ctrl_set_point.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_amplitude_ctrl_set_point.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_amplitude_ctrl_set_point.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_amplitude_ctrl_set_point.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_amplitude_ctrl_set_point.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeAmplitude_ctrl_set_point_calib_result(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        no_error = 0
        amplitude_calibration_error = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_set_point_calib_result'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_set_point_calib_result.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_set_point_calib_result.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_set_point_calib_result.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_set_point_calib_result.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_set_point_calib_result.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.amplitude_ctrl_set_point_calib_result.value_raw', new_val.value)


class RootLuSignal_analyzerInst2AttributeReference_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        own = 0
        harmonic3 = 3
        harmonic1 = 1
        harmonic2 = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.reference_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_source.value_raw', new_val.value)


class RootLuSignal_analyzerInst2AttributeCurrent_phase_binary(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.current_phase_binary'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_phase_binary.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_phase_binary.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_phase_binary.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_phase_binary.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_phase_binary.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_phase_binary.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_phase_binary.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_phase_binary.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeReference_phase(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.reference_phase'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_phase.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_phase.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_phase.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_phase.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_phase.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_phase.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_phase.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_phase.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeCurrent_amplitude_binary(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.current_amplitude_binary'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_amplitude_binary.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_amplitude_binary.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_amplitude_binary.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_amplitude_binary.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_amplitude_binary.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_amplitude_binary.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.current_amplitude_binary.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.current_amplitude_binary.min', float(new_val))


class RootLuSignal_analyzerInst2AttributeReference_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute.reference_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_amplitude.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_amplitude.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_amplitude.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst2.attribute.reference_amplitude.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst2.attribute.reference_amplitude.min', float(new_val))


class RootLuSignal_analyzerInst2Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2.attribute'
        self.reference_amplitude = RootLuSignal_analyzerInst2AttributeReference_amplitude(self._context)
        self.current_amplitude_binary = RootLuSignal_analyzerInst2AttributeCurrent_amplitude_binary(self._context)
        self.reference_phase = RootLuSignal_analyzerInst2AttributeReference_phase(self._context)
        self.current_phase_binary = RootLuSignal_analyzerInst2AttributeCurrent_phase_binary(self._context)
        self.reference_source = RootLuSignal_analyzerInst2AttributeReference_source(self._context)
        self.amplitude_ctrl_set_point_calib_result = RootLuSignal_analyzerInst2AttributeAmplitude_ctrl_set_point_calib_result(self._context)
        self.current_amplitude_ctrl_set_point = RootLuSignal_analyzerInst2AttributeCurrent_amplitude_ctrl_set_point(self._context)
        self.pll_unlocked = RootLuSignal_analyzerInst2AttributePll_unlocked(self._context)
        self.input = RootLuSignal_analyzerInst2AttributeInput(self._context)
        self.delay_comp = RootLuSignal_analyzerInst2AttributeDelay_comp(self._context)
        self.current_x_binary = RootLuSignal_analyzerInst2AttributeCurrent_x_binary(self._context)
        self.current_x = RootLuSignal_analyzerInst2AttributeCurrent_x(self._context)
        self.reset_flag_pll_unlocked = RootLuSignal_analyzerInst2AttributeReset_flag_pll_unlocked(self._context)
        self.amplitude_ctrl_p_gain = RootLuSignal_analyzerInst2AttributeAmplitude_ctrl_p_gain(self._context)
        self.enable_dc_block = RootLuSignal_analyzerInst2AttributeEnable_dc_block(self._context)
        self.current_y = RootLuSignal_analyzerInst2AttributeCurrent_y(self._context)
        self.current_phase = RootLuSignal_analyzerInst2AttributeCurrent_phase(self._context)
        self.operating_mode = RootLuSignal_analyzerInst2AttributeOperating_mode(self._context)
        self.target_amplitude_ctrl_set_point = RootLuSignal_analyzerInst2AttributeTarget_amplitude_ctrl_set_point(self._context)
        self.phase_lock_range = RootLuSignal_analyzerInst2AttributePhase_lock_range(self._context)
        self.current_amplitude_ctrl_mode = RootLuSignal_analyzerInst2AttributeCurrent_amplitude_ctrl_mode(self._context)
        self.phase_ctrl_i_gain = RootLuSignal_analyzerInst2AttributePhase_ctrl_i_gain(self._context)
        self.current_ctrl_delta_f = RootLuSignal_analyzerInst2AttributeCurrent_ctrl_delta_f(self._context)
        self.phase_ctrl_p_gain = RootLuSignal_analyzerInst2AttributePhase_ctrl_p_gain(self._context)
        self.demodulator_bw = RootLuSignal_analyzerInst2AttributeDemodulator_bw(self._context)
        self.display_df_range = RootLuSignal_analyzerInst2AttributeDisplay_df_range(self._context)
        self.reference_amplitude_factor = RootLuSignal_analyzerInst2AttributeReference_amplitude_factor(self._context)
        self.target_amplitude_ctrl_mode = RootLuSignal_analyzerInst2AttributeTarget_amplitude_ctrl_mode(self._context)
        self.lock_in_calc_phase = RootLuSignal_analyzerInst2AttributeLock_in_calc_phase(self._context)
        self.current_y_binary = RootLuSignal_analyzerInst2AttributeCurrent_y_binary(self._context)
        self.lock_in_calc_amplitude = RootLuSignal_analyzerInst2AttributeLock_in_calc_amplitude(self._context)
        self.harmonic_source = RootLuSignal_analyzerInst2AttributeHarmonic_source(self._context)
        self.reference_frequency = RootLuSignal_analyzerInst2AttributeReference_frequency(self._context)
        self.current_reference_amplitude = RootLuSignal_analyzerInst2AttributeCurrent_reference_amplitude(self._context)
        self.amplitude_ctrl_i_gain = RootLuSignal_analyzerInst2AttributeAmplitude_ctrl_i_gain(self._context)
        self.current_ctrl_amplitude = RootLuSignal_analyzerInst2AttributeCurrent_ctrl_amplitude(self._context)
        self.amplitude_modulation = RootLuSignal_analyzerInst2AttributeAmplitude_modulation(self._context)
        self.current_amplitude = RootLuSignal_analyzerInst2AttributeCurrent_amplitude(self._context)


class RootLuSignal_analyzerInst2(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst2'
        self.attribute = RootLuSignal_analyzerInst2Attribute(self._context)
        self.trigger = RootLuSignal_analyzerInst2Trigger(self._context)


class RootLuSignal_analyzerInst1Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.trigger'

    def kpfm_phase_calibration(self) -> None:
        return self._context.call('root.lu.signal_analyzer.inst1.trigger.kpfm_phase_calibration')

    def switch_to_target_amplitude_ctrl_mode(self) -> None:
        return self._context.call('root.lu.signal_analyzer.inst1.trigger.switch_to_target_amplitude_ctrl_mode')

    def start_phase_zero_calibration(self) -> None:
        return self._context.call('root.lu.signal_analyzer.inst1.trigger.start_phase_zero_calibration')

    def switch_to_target_amplitude_ctrl_set_point(self) -> None:
        return self._context.call('root.lu.signal_analyzer.inst1.trigger.switch_to_target_amplitude_ctrl_set_point')

    def user_abort(self) -> None:
        return self._context.call('root.lu.signal_analyzer.inst1.trigger.user_abort')

    def start_kpfm_phase_calibration(self) -> None:
        return self._context.call('root.lu.signal_analyzer.inst1.trigger.start_kpfm_phase_calibration')

    def start_switch_to_target_amplitude_ctrl_mode(self) -> None:
        return self._context.call('root.lu.signal_analyzer.inst1.trigger.start_switch_to_target_amplitude_ctrl_mode')

    def start_switch_to_target_amplitude_ctrl_set_point(self) -> None:
        return self._context.call('root.lu.signal_analyzer.inst1.trigger.start_switch_to_target_amplitude_ctrl_set_point')


class RootLuSignal_analyzerInst1AttributeCurrent_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.current_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_amplitude.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_amplitude.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_amplitude.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_amplitude.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_amplitude.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeAmplitude_modulation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.amplitude_modulation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst1.attribute.amplitude_modulation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.amplitude_modulation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst1.attribute.amplitude_modulation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.amplitude_modulation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst1.attribute.amplitude_modulation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.amplitude_modulation.value_raw', new_val.value)


class RootLuSignal_analyzerInst1AttributeCurrent_ctrl_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.current_ctrl_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_ctrl_amplitude.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_ctrl_amplitude.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_ctrl_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_ctrl_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_ctrl_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_ctrl_amplitude.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_ctrl_amplitude.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_ctrl_amplitude.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeAmplitude_ctrl_i_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_i_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_i_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_i_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_i_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_i_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_i_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_i_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_i_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_i_gain.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeCurrent_reference_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.current_reference_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_reference_amplitude.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_reference_amplitude.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_reference_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_reference_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_reference_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_reference_amplitude.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_reference_amplitude.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_reference_amplitude.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeReference_frequency(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.reference_frequency'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_frequency.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_frequency.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_frequency.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_frequency.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_frequency.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_frequency.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_frequency.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_frequency.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeHarmonic_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1 = 0
        analyzer2 = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.harmonic_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst1.attribute.harmonic_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.harmonic_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst1.attribute.harmonic_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.harmonic_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst1.attribute.harmonic_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.harmonic_source.value_raw', new_val.value)


class RootLuSignal_analyzerInst1AttributeLock_in_calc_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.lock_in_calc_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.lock_in_calc_amplitude.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.lock_in_calc_amplitude.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.lock_in_calc_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.lock_in_calc_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.lock_in_calc_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.lock_in_calc_amplitude.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.lock_in_calc_amplitude.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.lock_in_calc_amplitude.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeCurrent_y_binary(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.current_y_binary'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_y_binary.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_y_binary.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_y_binary.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_y_binary.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_y_binary.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_y_binary.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_y_binary.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_y_binary.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeLock_in_calc_phase(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.lock_in_calc_phase'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.lock_in_calc_phase.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.lock_in_calc_phase.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.lock_in_calc_phase.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.lock_in_calc_phase.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.lock_in_calc_phase.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.lock_in_calc_phase.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.lock_in_calc_phase.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.lock_in_calc_phase.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeTarget_amplitude_ctrl_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        const_amplitude = 1
        const_drive = 0
        free_vibration = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.target_amplitude_ctrl_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst1.attribute.target_amplitude_ctrl_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.target_amplitude_ctrl_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst1.attribute.target_amplitude_ctrl_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.target_amplitude_ctrl_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst1.attribute.target_amplitude_ctrl_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.target_amplitude_ctrl_mode.value_raw', new_val.value)


class RootLuSignal_analyzerInst1AttributeReference_amplitude_factor(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.reference_amplitude_factor'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_amplitude_factor.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_amplitude_factor.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_amplitude_factor.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_amplitude_factor.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_amplitude_factor.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_amplitude_factor.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_amplitude_factor.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_amplitude_factor.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeDisplay_df_range(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.display_df_range'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.display_df_range.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.display_df_range.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.display_df_range.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.display_df_range.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.display_df_range.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.display_df_range.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.display_df_range.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.display_df_range.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeDemodulator_bw(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        bw_45_k_hz = 12
        bw_1500_hz = 7
        bw_750_hz = 6
        bw_45_hz = 2
        bw_500_k_hz = 15
        bw_360_hz = 5
        bw_23_k_hz = 11
        bw_90_hz = 3
        bw_230_k_hz = 14
        bw_180_hz = 4
        bw_6_k_hz = 9
        bw_3_k_hz = 8
        bw_100_k_hz = 13
        bw_23_hz = 1
        bw_12_k_hz = 10

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.demodulator_bw'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst1.attribute.demodulator_bw.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.demodulator_bw.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst1.attribute.demodulator_bw.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.demodulator_bw.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst1.attribute.demodulator_bw.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.demodulator_bw.value_raw', new_val.value)


class RootLuSignal_analyzerInst1AttributePhase_ctrl_p_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.phase_ctrl_p_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.phase_ctrl_p_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.phase_ctrl_p_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.phase_ctrl_p_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.phase_ctrl_p_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.phase_ctrl_p_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.phase_ctrl_p_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.phase_ctrl_p_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.phase_ctrl_p_gain.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeCurrent_ctrl_delta_f(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.current_ctrl_delta_f'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_ctrl_delta_f.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_ctrl_delta_f.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_ctrl_delta_f.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_ctrl_delta_f.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_ctrl_delta_f.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_ctrl_delta_f.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_ctrl_delta_f.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_ctrl_delta_f.min', float(new_val))


class RootLuSignal_analyzerInst1AttributePhase_ctrl_i_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.phase_ctrl_i_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.phase_ctrl_i_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.phase_ctrl_i_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.phase_ctrl_i_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.phase_ctrl_i_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.phase_ctrl_i_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.phase_ctrl_i_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.phase_ctrl_i_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.phase_ctrl_i_gain.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeCurrent_amplitude_ctrl_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        const_amplitude = 1
        const_drive = 0
        free_vibration = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.current_amplitude_ctrl_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_amplitude_ctrl_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_amplitude_ctrl_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_amplitude_ctrl_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_amplitude_ctrl_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_amplitude_ctrl_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_amplitude_ctrl_mode.value_raw', new_val.value)


class RootLuSignal_analyzerInst1AttributePhase_lock_range(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.phase_lock_range'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.phase_lock_range.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.phase_lock_range.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.phase_lock_range.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.phase_lock_range.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.phase_lock_range.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.phase_lock_range.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.phase_lock_range.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.phase_lock_range.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeTarget_amplitude_ctrl_set_point(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.target_amplitude_ctrl_set_point'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.target_amplitude_ctrl_set_point.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.target_amplitude_ctrl_set_point.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.target_amplitude_ctrl_set_point.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.target_amplitude_ctrl_set_point.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.target_amplitude_ctrl_set_point.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.target_amplitude_ctrl_set_point.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.target_amplitude_ctrl_set_point.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.target_amplitude_ctrl_set_point.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeOperating_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        kpfm = 2
        lock_in = 0
        pll = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.operating_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst1.attribute.operating_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.operating_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst1.attribute.operating_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.operating_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst1.attribute.operating_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.operating_mode.value_raw', new_val.value)


class RootLuSignal_analyzerInst1AttributeCurrent_phase(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.current_phase'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_phase.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_phase.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_phase.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_phase.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_phase.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_phase.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_phase.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_phase.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeCurrent_y(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.current_y'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_y.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_y.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_y.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_y.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_y.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_y.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_y.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_y.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeEnable_dc_block(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.enable_dc_block'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst1.attribute.enable_dc_block.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.enable_dc_block.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst1.attribute.enable_dc_block.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.enable_dc_block.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst1.attribute.enable_dc_block.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.enable_dc_block.value_raw', new_val.value)


class RootLuSignal_analyzerInst1AttributeAmplitude_ctrl_p_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_p_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_p_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_p_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_p_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_p_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_p_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_p_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_p_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_p_gain.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeReset_flag_pll_unlocked(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.reset_flag_pll_unlocked'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.reset_flag_pll_unlocked.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reset_flag_pll_unlocked.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.reset_flag_pll_unlocked.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reset_flag_pll_unlocked.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.reset_flag_pll_unlocked.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reset_flag_pll_unlocked.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.reset_flag_pll_unlocked.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reset_flag_pll_unlocked.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeCurrent_x(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.current_x'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_x.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_x.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_x.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_x.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_x.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_x.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_x.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_x.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeCurrent_x_binary(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.current_x_binary'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_x_binary.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_x_binary.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_x_binary.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_x_binary.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_x_binary.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_x_binary.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_x_binary.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_x_binary.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeDelay_comp(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.delay_comp'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.delay_comp.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.delay_comp.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.delay_comp.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.delay_comp.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.delay_comp.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.delay_comp.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.delay_comp.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.delay_comp.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 44
        analyzer1_amplitude = 15
        ramp_gen_max_z = 41
        ctrl_x_out = 47
        analyzer2_reference = 65
        analyzer2_ctrl_amplitude = 57
        comparator1_out = 68
        ort_excitation = 66
        ramp_gen_tip_voltage = 36
        memory_gen_out8 = 31
        fast_in_user = 2
        analyzer1_x = 54
        memory_gen_position_z = 28
        ctrl_w_out = 49
        analyzer1_y = 55
        analyzer2_amplitude = 59
        in_user1 = 4
        ramp_gen_user4 = 38
        memory_gen_out7 = 30
        ramp_gen_position_y = 34
        ramp_gen_position_x = 33
        ctrl_user1_out = 50
        in_tip_current = 8
        in_position_y = 13
        comparator2_in_filtered = 69
        analyzer2_x = 60
        memory_gen_position_y = 26
        memory_gen_position_x = 24
        ctrl_z_error = 43
        comparator1_in_filtered = 67
        ctrl_z_nominal = 46
        analyzer1_reference = 64
        analyzer1_phase = 53
        comparator2_out = 70
        analyzer2_phase = 58
        analyzer1_ctrl_delta_f = 16
        memory_gen_drive_y = 27
        ctrl_z_sum = 45
        ramp_gen_alternate_z = 37
        comparator3_in_filtered = 71
        ctrl_user2_out = 51
        analyzer2_ctrl_delta_f = 56
        analyzer2_y = 61
        in_detector_sum = 22
        fast_in2 = 1
        in_position_x = 12
        in_user4 = 7
        test_tip_voltage = 11
        test_ref = 10
        test_ana_gnd = 9
        static = 18
        ramp_gen_ctrl_z = 40
        ramp_gen_test = 20
        memory_gen_drive_z = 29
        ramp_gen_position_w = 35
        comparator3_out = 72
        ramp_gen_plane_z = 39
        ramp_gen_approach = 32
        ort_baseline = 62
        ort_amplitude_reduction = 63
        analyzer1_ctrl_amplitude = 52
        ctrl_y_out = 48
        ctrl_z_in = 42
        in_position_z = 14
        fast_in_deflection = 0
        memory_gen_drive_x = 25
        in6 = 23
        ctrl_z_out = 17
        in_user3 = 6
        in_user2 = 5
        in_lateral = 3
        in_deflection = 21
        gen_test_dynamic = 19

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst1.attribute.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst1.attribute.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst1.attribute.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.input.value_raw', new_val.value)


class RootLuSignal_analyzerInst1AttributePll_unlocked(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.pll_unlocked'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.pll_unlocked.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.pll_unlocked.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.pll_unlocked.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.pll_unlocked.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.pll_unlocked.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.pll_unlocked.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.pll_unlocked.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.pll_unlocked.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeCurrent_amplitude_ctrl_set_point(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.current_amplitude_ctrl_set_point'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_amplitude_ctrl_set_point.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_amplitude_ctrl_set_point.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_amplitude_ctrl_set_point.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_amplitude_ctrl_set_point.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_amplitude_ctrl_set_point.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_amplitude_ctrl_set_point.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_amplitude_ctrl_set_point.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_amplitude_ctrl_set_point.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeAmplitude_ctrl_set_point_calib_result(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        no_error = 0
        amplitude_calibration_error = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_set_point_calib_result'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_set_point_calib_result.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_set_point_calib_result.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_set_point_calib_result.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_set_point_calib_result.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_set_point_calib_result.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.amplitude_ctrl_set_point_calib_result.value_raw', new_val.value)


class RootLuSignal_analyzerInst1AttributeReference_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        own = 0
        harmonic3 = 3
        harmonic1 = 1
        harmonic2 = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.reference_source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_source.value_raw', new_val.value)


class RootLuSignal_analyzerInst1AttributeCurrent_phase_binary(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.current_phase_binary'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_phase_binary.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_phase_binary.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_phase_binary.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_phase_binary.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_phase_binary.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_phase_binary.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_phase_binary.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_phase_binary.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeReference_phase(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.reference_phase'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_phase.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_phase.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_phase.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_phase.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_phase.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_phase.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_phase.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_phase.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeCurrent_amplitude_binary(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.current_amplitude_binary'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_amplitude_binary.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_amplitude_binary.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_amplitude_binary.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_amplitude_binary.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_amplitude_binary.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_amplitude_binary.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.current_amplitude_binary.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.current_amplitude_binary.min', float(new_val))


class RootLuSignal_analyzerInst1AttributeReference_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute.reference_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_amplitude.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_amplitude.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_amplitude.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.signal_analyzer.inst1.attribute.reference_amplitude.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.signal_analyzer.inst1.attribute.reference_amplitude.min', float(new_val))


class RootLuSignal_analyzerInst1Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1.attribute'
        self.reference_amplitude = RootLuSignal_analyzerInst1AttributeReference_amplitude(self._context)
        self.current_amplitude_binary = RootLuSignal_analyzerInst1AttributeCurrent_amplitude_binary(self._context)
        self.reference_phase = RootLuSignal_analyzerInst1AttributeReference_phase(self._context)
        self.current_phase_binary = RootLuSignal_analyzerInst1AttributeCurrent_phase_binary(self._context)
        self.reference_source = RootLuSignal_analyzerInst1AttributeReference_source(self._context)
        self.amplitude_ctrl_set_point_calib_result = RootLuSignal_analyzerInst1AttributeAmplitude_ctrl_set_point_calib_result(self._context)
        self.current_amplitude_ctrl_set_point = RootLuSignal_analyzerInst1AttributeCurrent_amplitude_ctrl_set_point(self._context)
        self.pll_unlocked = RootLuSignal_analyzerInst1AttributePll_unlocked(self._context)
        self.input = RootLuSignal_analyzerInst1AttributeInput(self._context)
        self.delay_comp = RootLuSignal_analyzerInst1AttributeDelay_comp(self._context)
        self.current_x_binary = RootLuSignal_analyzerInst1AttributeCurrent_x_binary(self._context)
        self.current_x = RootLuSignal_analyzerInst1AttributeCurrent_x(self._context)
        self.reset_flag_pll_unlocked = RootLuSignal_analyzerInst1AttributeReset_flag_pll_unlocked(self._context)
        self.amplitude_ctrl_p_gain = RootLuSignal_analyzerInst1AttributeAmplitude_ctrl_p_gain(self._context)
        self.enable_dc_block = RootLuSignal_analyzerInst1AttributeEnable_dc_block(self._context)
        self.current_y = RootLuSignal_analyzerInst1AttributeCurrent_y(self._context)
        self.current_phase = RootLuSignal_analyzerInst1AttributeCurrent_phase(self._context)
        self.operating_mode = RootLuSignal_analyzerInst1AttributeOperating_mode(self._context)
        self.target_amplitude_ctrl_set_point = RootLuSignal_analyzerInst1AttributeTarget_amplitude_ctrl_set_point(self._context)
        self.phase_lock_range = RootLuSignal_analyzerInst1AttributePhase_lock_range(self._context)
        self.current_amplitude_ctrl_mode = RootLuSignal_analyzerInst1AttributeCurrent_amplitude_ctrl_mode(self._context)
        self.phase_ctrl_i_gain = RootLuSignal_analyzerInst1AttributePhase_ctrl_i_gain(self._context)
        self.current_ctrl_delta_f = RootLuSignal_analyzerInst1AttributeCurrent_ctrl_delta_f(self._context)
        self.phase_ctrl_p_gain = RootLuSignal_analyzerInst1AttributePhase_ctrl_p_gain(self._context)
        self.demodulator_bw = RootLuSignal_analyzerInst1AttributeDemodulator_bw(self._context)
        self.display_df_range = RootLuSignal_analyzerInst1AttributeDisplay_df_range(self._context)
        self.reference_amplitude_factor = RootLuSignal_analyzerInst1AttributeReference_amplitude_factor(self._context)
        self.target_amplitude_ctrl_mode = RootLuSignal_analyzerInst1AttributeTarget_amplitude_ctrl_mode(self._context)
        self.lock_in_calc_phase = RootLuSignal_analyzerInst1AttributeLock_in_calc_phase(self._context)
        self.current_y_binary = RootLuSignal_analyzerInst1AttributeCurrent_y_binary(self._context)
        self.lock_in_calc_amplitude = RootLuSignal_analyzerInst1AttributeLock_in_calc_amplitude(self._context)
        self.harmonic_source = RootLuSignal_analyzerInst1AttributeHarmonic_source(self._context)
        self.reference_frequency = RootLuSignal_analyzerInst1AttributeReference_frequency(self._context)
        self.current_reference_amplitude = RootLuSignal_analyzerInst1AttributeCurrent_reference_amplitude(self._context)
        self.amplitude_ctrl_i_gain = RootLuSignal_analyzerInst1AttributeAmplitude_ctrl_i_gain(self._context)
        self.current_ctrl_amplitude = RootLuSignal_analyzerInst1AttributeCurrent_ctrl_amplitude(self._context)
        self.amplitude_modulation = RootLuSignal_analyzerInst1AttributeAmplitude_modulation(self._context)
        self.current_amplitude = RootLuSignal_analyzerInst1AttributeCurrent_amplitude(self._context)


class RootLuSignal_analyzerInst1(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer.inst1'
        self.attribute = RootLuSignal_analyzerInst1Attribute(self._context)
        self.trigger = RootLuSignal_analyzerInst1Trigger(self._context)


class RootLuSignal_analyzer(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.signal_analyzer'
        self.inst1 = RootLuSignal_analyzerInst1(self._context)
        self.inst2 = RootLuSignal_analyzerInst2(self._context)


class RootLuOscilloscopeInstanceBusy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.oscilloscope.instance.busy'

    @property
    def is_busy_line_capture(self) -> bool:
        return bool(self._context.call('root.lu.oscilloscope.instance.busy.is_busy_line_capture'))

    @property
    def is_busy(self) -> bool:
        return bool(self._context.call('root.lu.oscilloscope.instance.busy.is_busy'))


class RootLuOscilloscopeInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.oscilloscope.instance.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.oscilloscope.instance.trigger.stop')


class RootLuOscilloscopeInstanceAttributeDown_sample_factor(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.oscilloscope.instance.attribute.down_sample_factor'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.oscilloscope.instance.attribute.down_sample_factor.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.oscilloscope.instance.attribute.down_sample_factor.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.oscilloscope.instance.attribute.down_sample_factor.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.oscilloscope.instance.attribute.down_sample_factor.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.oscilloscope.instance.attribute.down_sample_factor.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.oscilloscope.instance.attribute.down_sample_factor.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.oscilloscope.instance.attribute.down_sample_factor.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.oscilloscope.instance.attribute.down_sample_factor.min', float(new_val))


class RootLuOscilloscopeInstanceAttributePeriod_duration(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.oscilloscope.instance.attribute.period_duration'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.oscilloscope.instance.attribute.period_duration.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.oscilloscope.instance.attribute.period_duration.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.oscilloscope.instance.attribute.period_duration.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.oscilloscope.instance.attribute.period_duration.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.oscilloscope.instance.attribute.period_duration.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.oscilloscope.instance.attribute.period_duration.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.oscilloscope.instance.attribute.period_duration.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.oscilloscope.instance.attribute.period_duration.min', float(new_val))


class RootLuOscilloscopeInstanceAttributeCapture_trigger_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        free_running = 0
        lu_scan = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.oscilloscope.instance.attribute.capture_trigger_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.oscilloscope.instance.attribute.capture_trigger_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.oscilloscope.instance.attribute.capture_trigger_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.oscilloscope.instance.attribute.capture_trigger_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.oscilloscope.instance.attribute.capture_trigger_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.oscilloscope.instance.attribute.capture_trigger_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.oscilloscope.instance.attribute.capture_trigger_mode.value_raw', new_val.value)


class RootLuOscilloscopeInstanceAttributeFree_wave_delay(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.oscilloscope.instance.attribute.free_wave_delay'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.oscilloscope.instance.attribute.free_wave_delay.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.oscilloscope.instance.attribute.free_wave_delay.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.oscilloscope.instance.attribute.free_wave_delay.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.oscilloscope.instance.attribute.free_wave_delay.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.oscilloscope.instance.attribute.free_wave_delay.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.oscilloscope.instance.attribute.free_wave_delay.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.oscilloscope.instance.attribute.free_wave_delay.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.oscilloscope.instance.attribute.free_wave_delay.min', float(new_val))


class RootLuOscilloscopeInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.oscilloscope.instance.attribute'
        self.free_wave_delay = RootLuOscilloscopeInstanceAttributeFree_wave_delay(self._context)
        self.capture_trigger_mode = RootLuOscilloscopeInstanceAttributeCapture_trigger_mode(self._context)
        self.period_duration = RootLuOscilloscopeInstanceAttributePeriod_duration(self._context)
        self.down_sample_factor = RootLuOscilloscopeInstanceAttributeDown_sample_factor(self._context)


class RootLuOscilloscopeInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.oscilloscope.instance'
        self.attribute = RootLuOscilloscopeInstanceAttribute(self._context)
        self.trigger = RootLuOscilloscopeInstanceTrigger(self._context)
        self.busy = RootLuOscilloscopeInstanceBusy(self._context)


class RootLuOscilloscope(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.oscilloscope'
        self.instance = RootLuOscilloscopeInstance(self._context)


class RootLuEvent_managerInstanceBusy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.event_manager.instance.busy'

    @property
    def is_busy(self) -> bool:
        return bool(self._context.call('root.lu.event_manager.instance.busy.is_busy'))


class RootLuEvent_managerInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.event_manager.instance.trigger'

    def stop(self) -> None:
        return self._context.call('root.lu.event_manager.instance.trigger.stop')

    def soft_event0_rising_edge(self) -> None:
        return self._context.call('root.lu.event_manager.instance.trigger.soft_event0_rising_edge')

    def soft_event0_falling_edge(self) -> None:
        return self._context.call('root.lu.event_manager.instance.trigger.soft_event0_falling_edge')

    def start(self) -> None:
        return self._context.call('root.lu.event_manager.instance.trigger.start')

    def soft_event1_rising_edge(self) -> None:
        return self._context.call('root.lu.event_manager.instance.trigger.soft_event1_rising_edge')

    def abort(self) -> None:
        return self._context.call('root.lu.event_manager.instance.trigger.abort')

    def soft_event2_falling_edge(self) -> None:
        return self._context.call('root.lu.event_manager.instance.trigger.soft_event2_falling_edge')

    def user_abort(self) -> None:
        return self._context.call('root.lu.event_manager.instance.trigger.user_abort')

    def soft_event2_rising_edge(self) -> None:
        return self._context.call('root.lu.event_manager.instance.trigger.soft_event2_rising_edge')

    def soft_event1_falling_edge(self) -> None:
        return self._context.call('root.lu.event_manager.instance.trigger.soft_event1_falling_edge')


class RootLuEvent_managerInstanceAttributeStop_event_mask(wrap.CmdTreeProp):

    class ValueMask(enum.IntEnum):
        data_sampling_done = 2
        z_ctrl_reached_min_z_true = 524288
        timer_proc0_done = 2048
        ramp_gen_maxz_done = 128
        soft_event1_true = 33554432
        mem_sig_gen_done = 4096
        unused_done = 4
        ramp_gen_user4_done = 16384
        soft_event0_true = 16777216
        ramp_gen_positionw_done = 65536
        and_mask0_true = 268435456
        data_capture_done = 1
        z_ctrl_reached_error_limit_true = 262144
        user_abort_event_true = 134217728
        comparator2_true = 1073741824
        timer_dbg1_done = 32768
        comparator1_true = 536870912
        soft_event2_true = 67108864
        all = 4294770687
        z_ctrl_reached_max_z_true = 1048576
        ext_event1_true = 8388608
        ramp_gen_test_done = 8192
        ramp_gen_ctrlz_done = 64
        ramp_gen_positiony_done = 16
        ramp_gen_tipvoltage_done = 512
        ramp_gen_approach_done = 1024
        comparator3_true = 2147483648
        ramp_gen_alternatez_done = 256
        ramp_gen_planez_done = 32
        ramp_gen_positionx_done = 8
        none = 0
        ext_event0_true = 4194304

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.event_manager.instance.attribute.stop_event_mask'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.event_manager.instance.attribute.stop_event_mask.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.event_manager.instance.attribute.stop_event_mask.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.event_manager.instance.attribute.stop_event_mask.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.event_manager.instance.attribute.stop_event_mask.enum', list(new_val))

    @property
    def value(self) -> int:
        return int(self._context.get('root.lu.event_manager.instance.attribute.stop_event_mask.value_raw'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.lu.event_manager.instance.attribute.stop_event_mask.value_raw', int(new_val))


class RootLuEvent_managerInstanceAttributeEvent_vector(wrap.CmdTreeProp):

    class ValueMask(enum.IntEnum):
        data_sampling_done = 2
        z_ctrl_reached_min_z_true = 524288
        timer_proc0_done = 2048
        ramp_gen_maxz_done = 128
        soft_event1_true = 33554432
        mem_sig_gen_done = 4096
        unused_done = 4
        ramp_gen_user4_done = 16384
        soft_event0_true = 16777216
        ramp_gen_positionw_done = 65536
        and_mask0_true = 268435456
        data_capture_done = 1
        z_ctrl_reached_error_limit_true = 262144
        user_abort_event_true = 134217728
        comparator2_true = 1073741824
        timer_dbg1_done = 32768
        comparator1_true = 536870912
        soft_event2_true = 67108864
        all = 4294770687
        z_ctrl_reached_max_z_true = 1048576
        ext_event1_true = 8388608
        ramp_gen_test_done = 8192
        ramp_gen_ctrlz_done = 64
        ramp_gen_positiony_done = 16
        ramp_gen_tipvoltage_done = 512
        ramp_gen_approach_done = 1024
        comparator3_true = 2147483648
        ramp_gen_alternatez_done = 256
        ramp_gen_planez_done = 32
        ramp_gen_positionx_done = 8
        none = 0
        ext_event0_true = 4194304

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.event_manager.instance.attribute.event_vector'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.event_manager.instance.attribute.event_vector.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.event_manager.instance.attribute.event_vector.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.event_manager.instance.attribute.event_vector.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.event_manager.instance.attribute.event_vector.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.event_manager.instance.attribute.event_vector.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.event_manager.instance.attribute.event_vector.set_vector_value', int(index), new_val)

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.event_manager.instance.attribute.event_vector.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.event_manager.instance.attribute.event_vector.enum', list(new_val))

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.event_manager.instance.attribute.event_vector.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.event_manager.instance.attribute.event_vector.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.event_manager.instance.attribute.event_vector.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.event_manager.instance.attribute.event_vector.min', float(new_val))


class RootLuEvent_managerInstanceAttributeStop_mask(wrap.CmdTreeProp):

    class ValueMask(enum.IntEnum):
        ramp_gen_positionx = 8
        ramp_gen_ctrlz = 64
        ramp_gen_alternatez = 256
        ramp_gen_approach = 1024
        ramp_gen_positionw = 65536
        all = 131071
        ramp_gen_planez = 32
        timer_proc0 = 2048
        timer_dbg1 = 32768
        ramp_gen_positiony = 16
        data_capture = 1
        data_sampling = 2
        ramp_gen_user4 = 16384
        mem_sig_gen = 4096
        ramp_gen_tipvoltage = 512
        ramp_gen_test = 8192
        unused = 4
        none = 0
        ramp_gen_maxz = 128

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.event_manager.instance.attribute.stop_mask'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.event_manager.instance.attribute.stop_mask.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.event_manager.instance.attribute.stop_mask.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.event_manager.instance.attribute.stop_mask.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.event_manager.instance.attribute.stop_mask.enum', list(new_val))

    @property
    def value(self) -> int:
        return int(self._context.get('root.lu.event_manager.instance.attribute.stop_mask.value_raw'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.lu.event_manager.instance.attribute.stop_mask.value_raw', int(new_val))


class RootLuEvent_managerInstanceAttributeAbort_event_mask(wrap.CmdTreeProp):

    class ValueMask(enum.IntEnum):
        data_sampling_done = 2
        z_ctrl_reached_min_z_true = 524288
        timer_proc0_done = 2048
        ramp_gen_maxz_done = 128
        soft_event1_true = 33554432
        mem_sig_gen_done = 4096
        unused_done = 4
        ramp_gen_user4_done = 16384
        soft_event0_true = 16777216
        ramp_gen_positionw_done = 65536
        and_mask0_true = 268435456
        data_capture_done = 1
        z_ctrl_reached_error_limit_true = 262144
        user_abort_event_true = 134217728
        comparator2_true = 1073741824
        timer_dbg1_done = 32768
        comparator1_true = 536870912
        soft_event2_true = 67108864
        all = 4294770687
        z_ctrl_reached_max_z_true = 1048576
        ext_event1_true = 8388608
        ramp_gen_test_done = 8192
        ramp_gen_ctrlz_done = 64
        ramp_gen_positiony_done = 16
        ramp_gen_tipvoltage_done = 512
        ramp_gen_approach_done = 1024
        comparator3_true = 2147483648
        ramp_gen_alternatez_done = 256
        ramp_gen_planez_done = 32
        ramp_gen_positionx_done = 8
        none = 0
        ext_event0_true = 4194304

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.event_manager.instance.attribute.abort_event_mask'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.event_manager.instance.attribute.abort_event_mask.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.event_manager.instance.attribute.abort_event_mask.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.event_manager.instance.attribute.abort_event_mask.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.event_manager.instance.attribute.abort_event_mask.enum', list(new_val))

    @property
    def value(self) -> int:
        return int(self._context.get('root.lu.event_manager.instance.attribute.abort_event_mask.value_raw'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.lu.event_manager.instance.attribute.abort_event_mask.value_raw', int(new_val))


class RootLuEvent_managerInstanceAttributeAnd_mask0(wrap.CmdTreeProp):

    class ValueMask(enum.IntEnum):
        data_sampling_done = 2
        z_ctrl_reached_min_z_true = 524288
        timer_proc0_done = 2048
        ramp_gen_maxz_done = 128
        soft_event1_true = 33554432
        mem_sig_gen_done = 4096
        unused_done = 4
        ramp_gen_user4_done = 16384
        soft_event0_true = 16777216
        ramp_gen_positionw_done = 65536
        and_mask0_true = 268435456
        data_capture_done = 1
        z_ctrl_reached_error_limit_true = 262144
        user_abort_event_true = 134217728
        comparator2_true = 1073741824
        timer_dbg1_done = 32768
        comparator1_true = 536870912
        soft_event2_true = 67108864
        all = 4294770687
        z_ctrl_reached_max_z_true = 1048576
        ext_event1_true = 8388608
        ramp_gen_test_done = 8192
        ramp_gen_ctrlz_done = 64
        ramp_gen_positiony_done = 16
        ramp_gen_tipvoltage_done = 512
        ramp_gen_approach_done = 1024
        comparator3_true = 2147483648
        ramp_gen_alternatez_done = 256
        ramp_gen_planez_done = 32
        ramp_gen_positionx_done = 8
        none = 0
        ext_event0_true = 4194304

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.event_manager.instance.attribute.and_mask0'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.event_manager.instance.attribute.and_mask0.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.event_manager.instance.attribute.and_mask0.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.event_manager.instance.attribute.and_mask0.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.event_manager.instance.attribute.and_mask0.enum', list(new_val))

    @property
    def value(self) -> int:
        return int(self._context.get('root.lu.event_manager.instance.attribute.and_mask0.value_raw'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.lu.event_manager.instance.attribute.and_mask0.value_raw', int(new_val))


class RootLuEvent_managerInstanceAttributeEvent_vector_snapshot(wrap.CmdTreeProp):

    class ValueMask(enum.IntEnum):
        data_sampling_done = 2
        z_ctrl_reached_min_z_true = 524288
        timer_proc0_done = 2048
        ramp_gen_maxz_done = 128
        soft_event1_true = 33554432
        mem_sig_gen_done = 4096
        unused_done = 4
        ramp_gen_user4_done = 16384
        soft_event0_true = 16777216
        ramp_gen_positionw_done = 65536
        and_mask0_true = 268435456
        data_capture_done = 1
        z_ctrl_reached_error_limit_true = 262144
        user_abort_event_true = 134217728
        comparator2_true = 1073741824
        timer_dbg1_done = 32768
        comparator1_true = 536870912
        soft_event2_true = 67108864
        all = 4294770687
        z_ctrl_reached_max_z_true = 1048576
        ext_event1_true = 8388608
        ramp_gen_test_done = 8192
        ramp_gen_ctrlz_done = 64
        ramp_gen_positiony_done = 16
        ramp_gen_tipvoltage_done = 512
        ramp_gen_approach_done = 1024
        comparator3_true = 2147483648
        ramp_gen_alternatez_done = 256
        ramp_gen_planez_done = 32
        ramp_gen_positionx_done = 8
        none = 0
        ext_event0_true = 4194304

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.event_manager.instance.attribute.event_vector_snapshot'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.event_manager.instance.attribute.event_vector_snapshot.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.event_manager.instance.attribute.event_vector_snapshot.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.event_manager.instance.attribute.event_vector_snapshot.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.event_manager.instance.attribute.event_vector_snapshot.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.event_manager.instance.attribute.event_vector_snapshot.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.event_manager.instance.attribute.event_vector_snapshot.set_vector_value', int(index), new_val)

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.event_manager.instance.attribute.event_vector_snapshot.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.event_manager.instance.attribute.event_vector_snapshot.enum', list(new_val))

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.event_manager.instance.attribute.event_vector_snapshot.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.event_manager.instance.attribute.event_vector_snapshot.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.event_manager.instance.attribute.event_vector_snapshot.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.event_manager.instance.attribute.event_vector_snapshot.min', float(new_val))


class RootLuEvent_managerInstanceAttributeStart_mask(wrap.CmdTreeProp):

    class ValueMask(enum.IntEnum):
        ramp_gen_positionx = 8
        ramp_gen_ctrlz = 64
        ramp_gen_alternatez = 256
        ramp_gen_approach = 1024
        ramp_gen_positionw = 65536
        all = 131071
        ramp_gen_planez = 32
        timer_proc0 = 2048
        timer_dbg1 = 32768
        ramp_gen_positiony = 16
        data_capture = 1
        data_sampling = 2
        ramp_gen_user4 = 16384
        mem_sig_gen = 4096
        ramp_gen_tipvoltage = 512
        ramp_gen_test = 8192
        unused = 4
        none = 0
        ramp_gen_maxz = 128

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.event_manager.instance.attribute.start_mask'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.event_manager.instance.attribute.start_mask.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.event_manager.instance.attribute.start_mask.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.event_manager.instance.attribute.start_mask.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.event_manager.instance.attribute.start_mask.enum', list(new_val))

    @property
    def value(self) -> int:
        return int(self._context.get('root.lu.event_manager.instance.attribute.start_mask.value_raw'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.lu.event_manager.instance.attribute.start_mask.value_raw', int(new_val))


class RootLuEvent_managerInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.event_manager.instance.attribute'
        self.start_mask = RootLuEvent_managerInstanceAttributeStart_mask(self._context)
        self.event_vector_snapshot = RootLuEvent_managerInstanceAttributeEvent_vector_snapshot(self._context)
        self.and_mask0 = RootLuEvent_managerInstanceAttributeAnd_mask0(self._context)
        self.abort_event_mask = RootLuEvent_managerInstanceAttributeAbort_event_mask(self._context)
        self.stop_mask = RootLuEvent_managerInstanceAttributeStop_mask(self._context)
        self.event_vector = RootLuEvent_managerInstanceAttributeEvent_vector(self._context)
        self.stop_event_mask = RootLuEvent_managerInstanceAttributeStop_event_mask(self._context)


class RootLuEvent_managerInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.event_manager.instance'
        self.attribute = RootLuEvent_managerInstanceAttribute(self._context)
        self.trigger = RootLuEvent_managerInstanceTrigger(self._context)
        self.busy = RootLuEvent_managerInstanceBusy(self._context)


class RootLuEvent_manager(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.event_manager'
        self.instance = RootLuEvent_managerInstance(self._context)


class RootLuThermal_tuningInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.thermal_tuning.instance.trigger'

    def user_abort(self) -> None:
        return self._context.call('root.lu.thermal_tuning.instance.trigger.user_abort')

    def start_block(self) -> None:
        return self._context.call('root.lu.thermal_tuning.instance.trigger.start_block')


class RootLuThermal_tuningInstanceAttributeBuffer_group_id(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.thermal_tuning.instance.attribute.buffer_group_id'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.thermal_tuning.instance.attribute.buffer_group_id.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.thermal_tuning.instance.attribute.buffer_group_id.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.thermal_tuning.instance.attribute.buffer_group_id.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.thermal_tuning.instance.attribute.buffer_group_id.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.thermal_tuning.instance.attribute.buffer_group_id.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.thermal_tuning.instance.attribute.buffer_group_id.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.thermal_tuning.instance.attribute.buffer_group_id.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.thermal_tuning.instance.attribute.buffer_group_id.min', float(new_val))


class RootLuThermal_tuningInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.thermal_tuning.instance.attribute'
        self.buffer_group_id = RootLuThermal_tuningInstanceAttributeBuffer_group_id(self._context)


class RootLuThermal_tuningInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.thermal_tuning.instance'
        self.attribute = RootLuThermal_tuningInstanceAttribute(self._context)
        self.trigger = RootLuThermal_tuningInstanceTrigger(self._context)


class RootLuThermal_tuning(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.thermal_tuning'
        self.instance = RootLuThermal_tuningInstance(self._context)


class RootLuComp_dcInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comp_dc.instance.trigger'

    def apply_new_configuration(self) -> None:
        return self._context.call('root.lu.comp_dc.instance.trigger.apply_new_configuration')

    def apply_new_nonlinear_configuration(self) -> None:
        return self._context.call('root.lu.comp_dc.instance.trigger.apply_new_nonlinear_configuration')

    def start_comp_dc_calibration(self) -> None:
        return self._context.call('root.lu.comp_dc.instance.trigger.start_comp_dc_calibration')

    def user_abort(self) -> None:
        return self._context.call('root.lu.comp_dc.instance.trigger.user_abort')

    def reset_calibration(self) -> None:
        return self._context.call('root.lu.comp_dc.instance.trigger.reset_calibration')

    def read_current_configuration(self) -> None:
        return self._context.call('root.lu.comp_dc.instance.trigger.read_current_configuration')


class RootLuComp_dcInstanceAttributeComp_dc_source_z(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        input = 1
        output = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comp_dc.instance.attribute.comp_dc_source_z'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_source_z.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_source_z.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_source_z.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_source_z.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_source_z.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_source_z.value_raw', new_val.value)


class RootLuComp_dcInstanceAttributeCoefficient_index(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comp_dc.instance.attribute.coefficient_index'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comp_dc.instance.attribute.coefficient_index.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comp_dc.instance.attribute.coefficient_index.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comp_dc.instance.attribute.coefficient_index.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comp_dc.instance.attribute.coefficient_index.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comp_dc.instance.attribute.coefficient_index.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comp_dc.instance.attribute.coefficient_index.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comp_dc.instance.attribute.coefficient_index.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comp_dc.instance.attribute.coefficient_index.min', float(new_val))


class RootLuComp_dcInstanceAttributeMove_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comp_dc.instance.attribute.move_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comp_dc.instance.attribute.move_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comp_dc.instance.attribute.move_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comp_dc.instance.attribute.move_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comp_dc.instance.attribute.move_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comp_dc.instance.attribute.move_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comp_dc.instance.attribute.move_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comp_dc.instance.attribute.move_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comp_dc.instance.attribute.move_time.min', float(new_val))


class RootLuComp_dcInstanceAttributeComp_dc_gain_y(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comp_dc.instance.attribute.comp_dc_gain_y'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_gain_y.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_gain_y.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_gain_y.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_gain_y.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_gain_y.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_gain_y.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_gain_y.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_gain_y.min', float(new_val))


class RootLuComp_dcInstanceAttributeComp_dc_gain_w(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comp_dc.instance.attribute.comp_dc_gain_w'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_gain_w.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_gain_w.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_gain_w.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_gain_w.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_gain_w.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_gain_w.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_gain_w.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_gain_w.min', float(new_val))


class RootLuComp_dcInstanceAttributeComp_dc_gain_x(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comp_dc.instance.attribute.comp_dc_gain_x'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_gain_x.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_gain_x.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_gain_x.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_gain_x.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_gain_x.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_gain_x.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_gain_x.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_gain_x.min', float(new_val))


class RootLuComp_dcInstanceAttributeComp_dc_gain_z(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comp_dc.instance.attribute.comp_dc_gain_z'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_gain_z.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_gain_z.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_gain_z.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_gain_z.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_gain_z.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_gain_z.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comp_dc.instance.attribute.comp_dc_gain_z.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comp_dc.instance.attribute.comp_dc_gain_z.min', float(new_val))


class RootLuComp_dcInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comp_dc.instance.attribute'
        self.comp_dc_gain_z = RootLuComp_dcInstanceAttributeComp_dc_gain_z(self._context)
        self.comp_dc_gain_x = RootLuComp_dcInstanceAttributeComp_dc_gain_x(self._context)
        self.comp_dc_gain_w = RootLuComp_dcInstanceAttributeComp_dc_gain_w(self._context)
        self.comp_dc_gain_y = RootLuComp_dcInstanceAttributeComp_dc_gain_y(self._context)
        self.move_time = RootLuComp_dcInstanceAttributeMove_time(self._context)
        self.coefficient_index = RootLuComp_dcInstanceAttributeCoefficient_index(self._context)
        self.comp_dc_source_z = RootLuComp_dcInstanceAttributeComp_dc_source_z(self._context)


class RootLuComp_dcInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comp_dc.instance'
        self.attribute = RootLuComp_dcInstanceAttribute(self._context)
        self.trigger = RootLuComp_dcInstanceTrigger(self._context)


class RootLuComp_dc(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comp_dc'
        self.instance = RootLuComp_dcInstance(self._context)


class RootLuPid_controllerPid_yTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.trigger'

    def clear_pid_accu(self) -> None:
        return self._context.call('root.lu.pid_controller.pid_y.trigger.clear_pid_accu')


class RootLuPid_controllerPid_yAttributeMax_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.max_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.max_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.max_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_y.attribute.max_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_y.attribute.max_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.max_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.max_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.max_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.max_value.min', float(new_val))


class RootLuPid_controllerPid_yAttributeReached_err_lim(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.reached_err_lim'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.reached_err_lim.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.reached_err_lim.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_y.attribute.reached_err_lim.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_y.attribute.reached_err_lim.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.reached_err_lim.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.reached_err_lim.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.reached_err_lim.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.reached_err_lim.min', float(new_val))


class RootLuPid_controllerPid_yAttributeCompare_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        equal_or_higher_than = 1
        equal_or_lower_than = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.compare_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_y.attribute.compare_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_y.attribute.compare_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_y.attribute.compare_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_y.attribute.compare_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_y.attribute.compare_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_y.attribute.compare_mode.value_raw', new_val.value)


class RootLuPid_controllerPid_yAttributeReached_max(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.reached_max'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.reached_max.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.reached_max.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_y.attribute.reached_max.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_y.attribute.reached_max.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.reached_max.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.reached_max.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.reached_max.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.reached_max.min', float(new_val))


class RootLuPid_controllerPid_yAttributeReached_min(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.reached_min'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.reached_min.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.reached_min.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_y.attribute.reached_min.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_y.attribute.reached_min.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.reached_min.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.reached_min.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.reached_min.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.reached_min.min', float(new_val))


class RootLuPid_controllerPid_yAttributePolarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        inverted = 1
        not_inverted = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_y.attribute.polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_y.attribute.polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_y.attribute.polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_y.attribute.polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_y.attribute.polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_y.attribute.polarity.value_raw', new_val.value)


class RootLuPid_controllerPid_yAttributeMedian_filter_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.median_filter_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_y.attribute.median_filter_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_y.attribute.median_filter_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_y.attribute.median_filter_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_y.attribute.median_filter_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_y.attribute.median_filter_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_y.attribute.median_filter_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_yAttributeSet_point_modulation_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.set_point_modulation_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_y.attribute.set_point_modulation_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_y.attribute.set_point_modulation_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_y.attribute.set_point_modulation_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_y.attribute.set_point_modulation_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_y.attribute.set_point_modulation_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_y.attribute.set_point_modulation_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_yAttributeSelect_output(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        pid_controller_out = 1
        set_point_in = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.select_output'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_y.attribute.select_output.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_y.attribute.select_output.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_y.attribute.select_output.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_y.attribute.select_output.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_y.attribute.select_output.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_y.attribute.select_output.value_raw', new_val.value)


class RootLuPid_controllerPid_yAttributeI_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.i_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.i_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.i_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_y.attribute.i_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_y.attribute.i_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.i_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.i_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.i_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.i_gain.min', float(new_val))


class RootLuPid_controllerPid_yAttributeSlope(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.slope'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.slope.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.slope.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_y.attribute.slope.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_y.attribute.slope.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.slope.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.slope.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.slope.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.slope.min', float(new_val))


class RootLuPid_controllerPid_yAttributeMemory_signal_gen_drive_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.memory_signal_gen_drive_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_y.attribute.memory_signal_gen_drive_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_y.attribute.memory_signal_gen_drive_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_y.attribute.memory_signal_gen_drive_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_y.attribute.memory_signal_gen_drive_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_y.attribute.memory_signal_gen_drive_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_y.attribute.memory_signal_gen_drive_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_yAttributeD_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.d_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.d_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.d_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_y.attribute.d_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_y.attribute.d_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.d_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.d_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.d_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.d_gain.min', float(new_val))


class RootLuPid_controllerPid_yAttributeStatic_set_point(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.static_set_point'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.static_set_point.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.static_set_point.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_y.attribute.static_set_point.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_y.attribute.static_set_point.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.static_set_point.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.static_set_point.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.static_set_point.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.static_set_point.min', float(new_val))


class RootLuPid_controllerPid_yAttributeFeedback_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        running = 1
        freeze = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.feedback_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_y.attribute.feedback_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_y.attribute.feedback_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_y.attribute.feedback_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_y.attribute.feedback_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_y.attribute.feedback_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_y.attribute.feedback_mode.value_raw', new_val.value)


class RootLuPid_controllerPid_yAttributeSet_point_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.set_point_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.set_point_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.set_point_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_y.attribute.set_point_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_y.attribute.set_point_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.set_point_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.set_point_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.set_point_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.set_point_gain.min', float(new_val))


class RootLuPid_controllerPid_yAttributeP_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.p_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.p_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.p_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_y.attribute.p_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_y.attribute.p_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.p_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.p_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.p_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.p_gain.min', float(new_val))


class RootLuPid_controllerPid_yAttributeInput_actual(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 44
        analyzer1_amplitude = 8
        ramp_gen_max_z = 41
        ctrl_x_out = 48
        analyzer2_reference = 68
        analyzer2_ctrl_amplitude = 14
        comparator1_out = 59
        ort_excitation = 69
        ramp_gen_tip_voltage = 36
        memory_gen_out8 = 31
        fast_in_user = 66
        analyzer1_x = 53
        memory_gen_position_z = 28
        ctrl_w_out = 50
        analyzer1_y = 54
        analyzer2_amplitude = 12
        in_user1 = 3
        ramp_gen_user4 = 38
        memory_gen_out7 = 30
        ramp_gen_position_y = 34
        ramp_gen_position_x = 33
        ctrl_user1_out = 51
        in_tip_current = 7
        in_position_y = 21
        comparator2_in_filtered = 60
        analyzer2_x = 55
        memory_gen_position_y = 26
        memory_gen_position_x = 24
        ctrl_z_error = 43
        comparator1_in_filtered = 58
        ctrl_z_nominal = 46
        analyzer1_reference = 67
        analyzer1_phase = 9
        comparator2_out = 61
        analyzer2_phase = 13
        analyzer1_ctrl_delta_f = 11
        memory_gen_drive_y = 27
        ctrl_z_sum = 45
        ramp_gen_alternate_z = 37
        comparator3_in_filtered = 62
        ctrl_user2_out = 52
        analyzer2_ctrl_delta_f = 15
        analyzer2_y = 56
        in_detector_sum = 22
        fast_in2 = 65
        in_position_x = 20
        in_user4 = 6
        static = 17
        ramp_gen_ctrl_z = 40
        ramp_gen_test = 19
        memory_gen_drive_z = 29
        ramp_gen_position_w = 35
        comparator3_out = 63
        ramp_gen_plane_z = 39
        ramp_gen_approach = 32
        ort_baseline = 57
        ort_amplitude_reduction = 16
        analyzer1_ctrl_amplitude = 10
        ctrl_y_out = 49
        ctrl_z_in = 42
        in_position_z = 2
        fast_in_deflection = 64
        memory_gen_drive_x = 25
        in6 = 23
        ctrl_z_out = 47
        in_user3 = 5
        in_user2 = 4
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 18

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.input_actual'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_y.attribute.input_actual.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_y.attribute.input_actual.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_y.attribute.input_actual.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_y.attribute.input_actual.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_y.attribute.input_actual.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_y.attribute.input_actual.value_raw', new_val.value)


class RootLuPid_controllerPid_yAttributeMemory_signal_gen_position_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.memory_signal_gen_position_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_y.attribute.memory_signal_gen_position_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_y.attribute.memory_signal_gen_position_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_y.attribute.memory_signal_gen_position_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_y.attribute.memory_signal_gen_position_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_y.attribute.memory_signal_gen_position_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_y.attribute.memory_signal_gen_position_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_yAttributeError_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.error_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.error_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.error_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_y.attribute.error_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_y.attribute.error_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.error_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.error_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.error_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.error_limit.min', float(new_val))


class RootLuPid_controllerPid_yAttributeMin_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.min_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.min_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.min_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_y.attribute.min_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_y.attribute.min_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.min_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.min_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.min_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.min_value.min', float(new_val))


class RootLuPid_controllerPid_yAttributeInput_set_point(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 44
        analyzer1_amplitude = 8
        ramp_gen_max_z = 41
        ctrl_x_out = 48
        analyzer2_reference = 68
        analyzer2_ctrl_amplitude = 14
        comparator1_out = 59
        ort_excitation = 69
        ramp_gen_tip_voltage = 36
        memory_gen_out8 = 31
        fast_in_user = 66
        analyzer1_x = 53
        memory_gen_position_z = 28
        ctrl_w_out = 50
        analyzer1_y = 54
        analyzer2_amplitude = 12
        in_user1 = 3
        ramp_gen_user4 = 38
        memory_gen_out7 = 30
        ramp_gen_position_y = 34
        ramp_gen_position_x = 33
        ctrl_user1_out = 51
        in_tip_current = 7
        in_position_y = 21
        comparator2_in_filtered = 60
        analyzer2_x = 55
        memory_gen_position_y = 26
        memory_gen_position_x = 24
        ctrl_z_error = 43
        comparator1_in_filtered = 58
        ctrl_z_nominal = 46
        analyzer1_reference = 67
        analyzer1_phase = 9
        comparator2_out = 61
        analyzer2_phase = 13
        analyzer1_ctrl_delta_f = 11
        memory_gen_drive_y = 27
        ctrl_z_sum = 45
        ramp_gen_alternate_z = 37
        comparator3_in_filtered = 62
        ctrl_user2_out = 52
        analyzer2_ctrl_delta_f = 15
        analyzer2_y = 56
        in_detector_sum = 22
        fast_in2 = 65
        in_position_x = 20
        in_user4 = 6
        static = 17
        ramp_gen_ctrl_z = 40
        ramp_gen_test = 19
        memory_gen_drive_z = 29
        ramp_gen_position_w = 35
        comparator3_out = 63
        ramp_gen_plane_z = 39
        ramp_gen_approach = 32
        ort_baseline = 57
        ort_amplitude_reduction = 16
        analyzer1_ctrl_amplitude = 10
        ctrl_y_out = 49
        ctrl_z_in = 42
        in_position_z = 2
        fast_in_deflection = 64
        memory_gen_drive_x = 25
        in6 = 23
        ctrl_z_out = 47
        in_user3 = 5
        in_user2 = 4
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 18

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.input_set_point'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_y.attribute.input_set_point.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_y.attribute.input_set_point.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_y.attribute.input_set_point.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_y.attribute.input_set_point.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_y.attribute.input_set_point.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_y.attribute.input_set_point.value_raw', new_val.value)


class RootLuPid_controllerPid_yAttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_y.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_y.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_y.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_y.attribute.current_output_value.min', float(new_val))


class RootLuPid_controllerPid_yAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y.attribute'
        self.current_output_value = RootLuPid_controllerPid_yAttributeCurrent_output_value(self._context)
        self.input_set_point = RootLuPid_controllerPid_yAttributeInput_set_point(self._context)
        self.min_value = RootLuPid_controllerPid_yAttributeMin_value(self._context)
        self.error_limit = RootLuPid_controllerPid_yAttributeError_limit(self._context)
        self.memory_signal_gen_position_enable = RootLuPid_controllerPid_yAttributeMemory_signal_gen_position_enable(self._context)
        self.input_actual = RootLuPid_controllerPid_yAttributeInput_actual(self._context)
        self.p_gain = RootLuPid_controllerPid_yAttributeP_gain(self._context)
        self.set_point_gain = RootLuPid_controllerPid_yAttributeSet_point_gain(self._context)
        self.feedback_mode = RootLuPid_controllerPid_yAttributeFeedback_mode(self._context)
        self.static_set_point = RootLuPid_controllerPid_yAttributeStatic_set_point(self._context)
        self.d_gain = RootLuPid_controllerPid_yAttributeD_gain(self._context)
        self.memory_signal_gen_drive_enable = RootLuPid_controllerPid_yAttributeMemory_signal_gen_drive_enable(self._context)
        self.slope = RootLuPid_controllerPid_yAttributeSlope(self._context)
        self.i_gain = RootLuPid_controllerPid_yAttributeI_gain(self._context)
        self.select_output = RootLuPid_controllerPid_yAttributeSelect_output(self._context)
        self.set_point_modulation_enable = RootLuPid_controllerPid_yAttributeSet_point_modulation_enable(self._context)
        self.median_filter_enable = RootLuPid_controllerPid_yAttributeMedian_filter_enable(self._context)
        self.polarity = RootLuPid_controllerPid_yAttributePolarity(self._context)
        self.reached_min = RootLuPid_controllerPid_yAttributeReached_min(self._context)
        self.reached_max = RootLuPid_controllerPid_yAttributeReached_max(self._context)
        self.compare_mode = RootLuPid_controllerPid_yAttributeCompare_mode(self._context)
        self.reached_err_lim = RootLuPid_controllerPid_yAttributeReached_err_lim(self._context)
        self.max_value = RootLuPid_controllerPid_yAttributeMax_value(self._context)


class RootLuPid_controllerPid_y(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_y'
        self.attribute = RootLuPid_controllerPid_yAttribute(self._context)
        self.trigger = RootLuPid_controllerPid_yTrigger(self._context)


class RootLuPid_controllerPid_xTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.trigger'

    def clear_pid_accu(self) -> None:
        return self._context.call('root.lu.pid_controller.pid_x.trigger.clear_pid_accu')


class RootLuPid_controllerPid_xAttributeMax_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.max_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.max_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.max_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_x.attribute.max_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_x.attribute.max_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.max_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.max_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.max_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.max_value.min', float(new_val))


class RootLuPid_controllerPid_xAttributeReached_err_lim(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.reached_err_lim'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.reached_err_lim.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.reached_err_lim.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_x.attribute.reached_err_lim.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_x.attribute.reached_err_lim.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.reached_err_lim.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.reached_err_lim.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.reached_err_lim.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.reached_err_lim.min', float(new_val))


class RootLuPid_controllerPid_xAttributeCompare_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        equal_or_higher_than = 1
        equal_or_lower_than = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.compare_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_x.attribute.compare_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_x.attribute.compare_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_x.attribute.compare_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_x.attribute.compare_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_x.attribute.compare_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_x.attribute.compare_mode.value_raw', new_val.value)


class RootLuPid_controllerPid_xAttributeReached_max(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.reached_max'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.reached_max.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.reached_max.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_x.attribute.reached_max.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_x.attribute.reached_max.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.reached_max.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.reached_max.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.reached_max.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.reached_max.min', float(new_val))


class RootLuPid_controllerPid_xAttributeReached_min(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.reached_min'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.reached_min.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.reached_min.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_x.attribute.reached_min.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_x.attribute.reached_min.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.reached_min.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.reached_min.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.reached_min.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.reached_min.min', float(new_val))


class RootLuPid_controllerPid_xAttributePolarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        inverted = 1
        not_inverted = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_x.attribute.polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_x.attribute.polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_x.attribute.polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_x.attribute.polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_x.attribute.polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_x.attribute.polarity.value_raw', new_val.value)


class RootLuPid_controllerPid_xAttributeMedian_filter_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.median_filter_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_x.attribute.median_filter_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_x.attribute.median_filter_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_x.attribute.median_filter_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_x.attribute.median_filter_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_x.attribute.median_filter_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_x.attribute.median_filter_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_xAttributeSet_point_modulation_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.set_point_modulation_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_x.attribute.set_point_modulation_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_x.attribute.set_point_modulation_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_x.attribute.set_point_modulation_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_x.attribute.set_point_modulation_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_x.attribute.set_point_modulation_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_x.attribute.set_point_modulation_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_xAttributeSelect_output(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        pid_controller_out = 1
        set_point_in = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.select_output'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_x.attribute.select_output.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_x.attribute.select_output.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_x.attribute.select_output.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_x.attribute.select_output.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_x.attribute.select_output.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_x.attribute.select_output.value_raw', new_val.value)


class RootLuPid_controllerPid_xAttributeI_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.i_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.i_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.i_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_x.attribute.i_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_x.attribute.i_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.i_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.i_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.i_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.i_gain.min', float(new_val))


class RootLuPid_controllerPid_xAttributeSlope(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.slope'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.slope.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.slope.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_x.attribute.slope.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_x.attribute.slope.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.slope.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.slope.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.slope.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.slope.min', float(new_val))


class RootLuPid_controllerPid_xAttributeMemory_signal_gen_drive_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.memory_signal_gen_drive_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_x.attribute.memory_signal_gen_drive_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_x.attribute.memory_signal_gen_drive_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_x.attribute.memory_signal_gen_drive_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_x.attribute.memory_signal_gen_drive_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_x.attribute.memory_signal_gen_drive_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_x.attribute.memory_signal_gen_drive_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_xAttributeD_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.d_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.d_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.d_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_x.attribute.d_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_x.attribute.d_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.d_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.d_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.d_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.d_gain.min', float(new_val))


class RootLuPid_controllerPid_xAttributeStatic_set_point(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.static_set_point'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.static_set_point.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.static_set_point.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_x.attribute.static_set_point.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_x.attribute.static_set_point.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.static_set_point.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.static_set_point.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.static_set_point.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.static_set_point.min', float(new_val))


class RootLuPid_controllerPid_xAttributeFeedback_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        running = 1
        freeze = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.feedback_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_x.attribute.feedback_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_x.attribute.feedback_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_x.attribute.feedback_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_x.attribute.feedback_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_x.attribute.feedback_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_x.attribute.feedback_mode.value_raw', new_val.value)


class RootLuPid_controllerPid_xAttributeSet_point_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.set_point_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.set_point_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.set_point_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_x.attribute.set_point_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_x.attribute.set_point_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.set_point_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.set_point_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.set_point_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.set_point_gain.min', float(new_val))


class RootLuPid_controllerPid_xAttributeP_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.p_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.p_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.p_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_x.attribute.p_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_x.attribute.p_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.p_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.p_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.p_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.p_gain.min', float(new_val))


class RootLuPid_controllerPid_xAttributeInput_actual(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 44
        analyzer1_amplitude = 8
        ramp_gen_max_z = 41
        ctrl_x_out = 48
        analyzer2_reference = 68
        analyzer2_ctrl_amplitude = 14
        comparator1_out = 59
        ort_excitation = 69
        ramp_gen_tip_voltage = 36
        memory_gen_out8 = 31
        fast_in_user = 66
        analyzer1_x = 53
        memory_gen_position_z = 28
        ctrl_w_out = 50
        analyzer1_y = 54
        analyzer2_amplitude = 12
        in_user1 = 3
        ramp_gen_user4 = 38
        memory_gen_out7 = 30
        ramp_gen_position_y = 34
        ramp_gen_position_x = 33
        ctrl_user1_out = 51
        in_tip_current = 7
        in_position_y = 21
        comparator2_in_filtered = 60
        analyzer2_x = 55
        memory_gen_position_y = 26
        memory_gen_position_x = 24
        ctrl_z_error = 43
        comparator1_in_filtered = 58
        ctrl_z_nominal = 46
        analyzer1_reference = 67
        analyzer1_phase = 9
        comparator2_out = 61
        analyzer2_phase = 13
        analyzer1_ctrl_delta_f = 11
        memory_gen_drive_y = 27
        ctrl_z_sum = 45
        ramp_gen_alternate_z = 37
        comparator3_in_filtered = 62
        ctrl_user2_out = 52
        analyzer2_ctrl_delta_f = 15
        analyzer2_y = 56
        in_detector_sum = 22
        fast_in2 = 65
        in_position_x = 20
        in_user4 = 6
        static = 17
        ramp_gen_ctrl_z = 40
        ramp_gen_test = 19
        memory_gen_drive_z = 29
        ramp_gen_position_w = 35
        comparator3_out = 63
        ramp_gen_plane_z = 39
        ramp_gen_approach = 32
        ort_baseline = 57
        ort_amplitude_reduction = 16
        analyzer1_ctrl_amplitude = 10
        ctrl_y_out = 49
        ctrl_z_in = 42
        in_position_z = 2
        fast_in_deflection = 64
        memory_gen_drive_x = 25
        in6 = 23
        ctrl_z_out = 47
        in_user3 = 5
        in_user2 = 4
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 18

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.input_actual'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_x.attribute.input_actual.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_x.attribute.input_actual.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_x.attribute.input_actual.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_x.attribute.input_actual.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_x.attribute.input_actual.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_x.attribute.input_actual.value_raw', new_val.value)


class RootLuPid_controllerPid_xAttributeMemory_signal_gen_position_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.memory_signal_gen_position_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_x.attribute.memory_signal_gen_position_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_x.attribute.memory_signal_gen_position_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_x.attribute.memory_signal_gen_position_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_x.attribute.memory_signal_gen_position_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_x.attribute.memory_signal_gen_position_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_x.attribute.memory_signal_gen_position_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_xAttributeError_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.error_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.error_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.error_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_x.attribute.error_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_x.attribute.error_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.error_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.error_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.error_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.error_limit.min', float(new_val))


class RootLuPid_controllerPid_xAttributeMin_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.min_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.min_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.min_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_x.attribute.min_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_x.attribute.min_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.min_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.min_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.min_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.min_value.min', float(new_val))


class RootLuPid_controllerPid_xAttributeInput_set_point(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 44
        analyzer1_amplitude = 8
        ramp_gen_max_z = 41
        ctrl_x_out = 48
        analyzer2_reference = 68
        analyzer2_ctrl_amplitude = 14
        comparator1_out = 59
        ort_excitation = 69
        ramp_gen_tip_voltage = 36
        memory_gen_out8 = 31
        fast_in_user = 66
        analyzer1_x = 53
        memory_gen_position_z = 28
        ctrl_w_out = 50
        analyzer1_y = 54
        analyzer2_amplitude = 12
        in_user1 = 3
        ramp_gen_user4 = 38
        memory_gen_out7 = 30
        ramp_gen_position_y = 34
        ramp_gen_position_x = 33
        ctrl_user1_out = 51
        in_tip_current = 7
        in_position_y = 21
        comparator2_in_filtered = 60
        analyzer2_x = 55
        memory_gen_position_y = 26
        memory_gen_position_x = 24
        ctrl_z_error = 43
        comparator1_in_filtered = 58
        ctrl_z_nominal = 46
        analyzer1_reference = 67
        analyzer1_phase = 9
        comparator2_out = 61
        analyzer2_phase = 13
        analyzer1_ctrl_delta_f = 11
        memory_gen_drive_y = 27
        ctrl_z_sum = 45
        ramp_gen_alternate_z = 37
        comparator3_in_filtered = 62
        ctrl_user2_out = 52
        analyzer2_ctrl_delta_f = 15
        analyzer2_y = 56
        in_detector_sum = 22
        fast_in2 = 65
        in_position_x = 20
        in_user4 = 6
        static = 17
        ramp_gen_ctrl_z = 40
        ramp_gen_test = 19
        memory_gen_drive_z = 29
        ramp_gen_position_w = 35
        comparator3_out = 63
        ramp_gen_plane_z = 39
        ramp_gen_approach = 32
        ort_baseline = 57
        ort_amplitude_reduction = 16
        analyzer1_ctrl_amplitude = 10
        ctrl_y_out = 49
        ctrl_z_in = 42
        in_position_z = 2
        fast_in_deflection = 64
        memory_gen_drive_x = 25
        in6 = 23
        ctrl_z_out = 47
        in_user3 = 5
        in_user2 = 4
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 18

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.input_set_point'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_x.attribute.input_set_point.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_x.attribute.input_set_point.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_x.attribute.input_set_point.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_x.attribute.input_set_point.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_x.attribute.input_set_point.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_x.attribute.input_set_point.value_raw', new_val.value)


class RootLuPid_controllerPid_xAttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_x.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_x.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_x.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_x.attribute.current_output_value.min', float(new_val))


class RootLuPid_controllerPid_xAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x.attribute'
        self.current_output_value = RootLuPid_controllerPid_xAttributeCurrent_output_value(self._context)
        self.input_set_point = RootLuPid_controllerPid_xAttributeInput_set_point(self._context)
        self.min_value = RootLuPid_controllerPid_xAttributeMin_value(self._context)
        self.error_limit = RootLuPid_controllerPid_xAttributeError_limit(self._context)
        self.memory_signal_gen_position_enable = RootLuPid_controllerPid_xAttributeMemory_signal_gen_position_enable(self._context)
        self.input_actual = RootLuPid_controllerPid_xAttributeInput_actual(self._context)
        self.p_gain = RootLuPid_controllerPid_xAttributeP_gain(self._context)
        self.set_point_gain = RootLuPid_controllerPid_xAttributeSet_point_gain(self._context)
        self.feedback_mode = RootLuPid_controllerPid_xAttributeFeedback_mode(self._context)
        self.static_set_point = RootLuPid_controllerPid_xAttributeStatic_set_point(self._context)
        self.d_gain = RootLuPid_controllerPid_xAttributeD_gain(self._context)
        self.memory_signal_gen_drive_enable = RootLuPid_controllerPid_xAttributeMemory_signal_gen_drive_enable(self._context)
        self.slope = RootLuPid_controllerPid_xAttributeSlope(self._context)
        self.i_gain = RootLuPid_controllerPid_xAttributeI_gain(self._context)
        self.select_output = RootLuPid_controllerPid_xAttributeSelect_output(self._context)
        self.set_point_modulation_enable = RootLuPid_controllerPid_xAttributeSet_point_modulation_enable(self._context)
        self.median_filter_enable = RootLuPid_controllerPid_xAttributeMedian_filter_enable(self._context)
        self.polarity = RootLuPid_controllerPid_xAttributePolarity(self._context)
        self.reached_min = RootLuPid_controllerPid_xAttributeReached_min(self._context)
        self.reached_max = RootLuPid_controllerPid_xAttributeReached_max(self._context)
        self.compare_mode = RootLuPid_controllerPid_xAttributeCompare_mode(self._context)
        self.reached_err_lim = RootLuPid_controllerPid_xAttributeReached_err_lim(self._context)
        self.max_value = RootLuPid_controllerPid_xAttributeMax_value(self._context)


class RootLuPid_controllerPid_x(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_x'
        self.attribute = RootLuPid_controllerPid_xAttribute(self._context)
        self.trigger = RootLuPid_controllerPid_xTrigger(self._context)


class RootLuPid_controllerPid_user2Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.trigger'

    def clear_pid_accu(self) -> None:
        return self._context.call('root.lu.pid_controller.pid_user2.trigger.clear_pid_accu')


class RootLuPid_controllerPid_user2AttributeMax_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.max_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.max_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.max_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user2.attribute.max_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.max_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.max_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.max_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.max_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.max_value.min', float(new_val))


class RootLuPid_controllerPid_user2AttributeReached_err_lim(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.reached_err_lim'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.reached_err_lim.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.reached_err_lim.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user2.attribute.reached_err_lim.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.reached_err_lim.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.reached_err_lim.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.reached_err_lim.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.reached_err_lim.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.reached_err_lim.min', float(new_val))


class RootLuPid_controllerPid_user2AttributeCompare_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        equal_or_higher_than = 1
        equal_or_lower_than = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.compare_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user2.attribute.compare_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.compare_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user2.attribute.compare_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.compare_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user2.attribute.compare_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.compare_mode.value_raw', new_val.value)


class RootLuPid_controllerPid_user2AttributeReached_max(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.reached_max'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.reached_max.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.reached_max.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user2.attribute.reached_max.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.reached_max.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.reached_max.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.reached_max.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.reached_max.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.reached_max.min', float(new_val))


class RootLuPid_controllerPid_user2AttributeReached_min(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.reached_min'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.reached_min.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.reached_min.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user2.attribute.reached_min.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.reached_min.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.reached_min.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.reached_min.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.reached_min.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.reached_min.min', float(new_val))


class RootLuPid_controllerPid_user2AttributePolarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        inverted = 1
        not_inverted = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user2.attribute.polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user2.attribute.polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user2.attribute.polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.polarity.value_raw', new_val.value)


class RootLuPid_controllerPid_user2AttributeMedian_filter_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.median_filter_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user2.attribute.median_filter_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.median_filter_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user2.attribute.median_filter_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.median_filter_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user2.attribute.median_filter_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.median_filter_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_user2AttributeSet_point_modulation_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.set_point_modulation_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user2.attribute.set_point_modulation_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.set_point_modulation_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user2.attribute.set_point_modulation_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.set_point_modulation_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user2.attribute.set_point_modulation_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.set_point_modulation_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_user2AttributeSelect_output(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        pid_controller_out = 1
        set_point_in = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.select_output'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user2.attribute.select_output.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.select_output.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user2.attribute.select_output.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.select_output.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user2.attribute.select_output.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.select_output.value_raw', new_val.value)


class RootLuPid_controllerPid_user2AttributeI_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.i_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.i_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.i_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user2.attribute.i_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.i_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.i_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.i_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.i_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.i_gain.min', float(new_val))


class RootLuPid_controllerPid_user2AttributeSlope(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.slope'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.slope.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.slope.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user2.attribute.slope.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.slope.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.slope.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.slope.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.slope.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.slope.min', float(new_val))


class RootLuPid_controllerPid_user2AttributeMemory_signal_gen_drive_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.memory_signal_gen_drive_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user2.attribute.memory_signal_gen_drive_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.memory_signal_gen_drive_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user2.attribute.memory_signal_gen_drive_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.memory_signal_gen_drive_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user2.attribute.memory_signal_gen_drive_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.memory_signal_gen_drive_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_user2AttributeD_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.d_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.d_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.d_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user2.attribute.d_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.d_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.d_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.d_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.d_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.d_gain.min', float(new_val))


class RootLuPid_controllerPid_user2AttributeStatic_set_point(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.static_set_point'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.static_set_point.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.static_set_point.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user2.attribute.static_set_point.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.static_set_point.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.static_set_point.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.static_set_point.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.static_set_point.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.static_set_point.min', float(new_val))


class RootLuPid_controllerPid_user2AttributeFeedback_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        running = 1
        freeze = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.feedback_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user2.attribute.feedback_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.feedback_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user2.attribute.feedback_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.feedback_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user2.attribute.feedback_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.feedback_mode.value_raw', new_val.value)


class RootLuPid_controllerPid_user2AttributeSet_point_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.set_point_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.set_point_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.set_point_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user2.attribute.set_point_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.set_point_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.set_point_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.set_point_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.set_point_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.set_point_gain.min', float(new_val))


class RootLuPid_controllerPid_user2AttributeP_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.p_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.p_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.p_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user2.attribute.p_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.p_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.p_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.p_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.p_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.p_gain.min', float(new_val))


class RootLuPid_controllerPid_user2AttributeInput_actual(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 44
        analyzer1_amplitude = 8
        ramp_gen_max_z = 41
        ctrl_x_out = 48
        analyzer2_reference = 68
        analyzer2_ctrl_amplitude = 14
        comparator1_out = 59
        ort_excitation = 69
        ramp_gen_tip_voltage = 36
        memory_gen_out8 = 31
        fast_in_user = 66
        analyzer1_x = 53
        memory_gen_position_z = 28
        ctrl_w_out = 50
        analyzer1_y = 54
        analyzer2_amplitude = 12
        in_user1 = 3
        ramp_gen_user4 = 38
        memory_gen_out7 = 30
        ramp_gen_position_y = 34
        ramp_gen_position_x = 33
        ctrl_user1_out = 51
        in_tip_current = 7
        in_position_y = 21
        comparator2_in_filtered = 60
        analyzer2_x = 55
        memory_gen_position_y = 26
        memory_gen_position_x = 24
        ctrl_z_error = 43
        comparator1_in_filtered = 58
        ctrl_z_nominal = 46
        analyzer1_reference = 67
        analyzer1_phase = 9
        comparator2_out = 61
        analyzer2_phase = 13
        analyzer1_ctrl_delta_f = 11
        memory_gen_drive_y = 27
        ctrl_z_sum = 45
        ramp_gen_alternate_z = 37
        comparator3_in_filtered = 62
        ctrl_user2_out = 52
        analyzer2_ctrl_delta_f = 15
        analyzer2_y = 56
        in_detector_sum = 22
        fast_in2 = 65
        in_position_x = 20
        in_user4 = 6
        static = 17
        ramp_gen_ctrl_z = 40
        ramp_gen_test = 19
        memory_gen_drive_z = 29
        ramp_gen_position_w = 35
        comparator3_out = 63
        ramp_gen_plane_z = 39
        ramp_gen_approach = 32
        ort_baseline = 57
        ort_amplitude_reduction = 16
        analyzer1_ctrl_amplitude = 10
        ctrl_y_out = 49
        ctrl_z_in = 42
        in_position_z = 2
        fast_in_deflection = 64
        memory_gen_drive_x = 25
        in6 = 23
        ctrl_z_out = 47
        in_user3 = 5
        in_user2 = 4
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 18

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.input_actual'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user2.attribute.input_actual.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.input_actual.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user2.attribute.input_actual.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.input_actual.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user2.attribute.input_actual.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.input_actual.value_raw', new_val.value)


class RootLuPid_controllerPid_user2AttributeMemory_signal_gen_position_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.memory_signal_gen_position_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user2.attribute.memory_signal_gen_position_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.memory_signal_gen_position_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user2.attribute.memory_signal_gen_position_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.memory_signal_gen_position_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user2.attribute.memory_signal_gen_position_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.memory_signal_gen_position_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_user2AttributeError_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.error_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.error_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.error_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user2.attribute.error_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.error_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.error_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.error_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.error_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.error_limit.min', float(new_val))


class RootLuPid_controllerPid_user2AttributeMin_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.min_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.min_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.min_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user2.attribute.min_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.min_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.min_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.min_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.min_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.min_value.min', float(new_val))


class RootLuPid_controllerPid_user2AttributeInput_set_point(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 44
        analyzer1_amplitude = 8
        ramp_gen_max_z = 41
        ctrl_x_out = 48
        analyzer2_reference = 68
        analyzer2_ctrl_amplitude = 14
        comparator1_out = 59
        ort_excitation = 69
        ramp_gen_tip_voltage = 36
        memory_gen_out8 = 31
        fast_in_user = 66
        analyzer1_x = 53
        memory_gen_position_z = 28
        ctrl_w_out = 50
        analyzer1_y = 54
        analyzer2_amplitude = 12
        in_user1 = 3
        ramp_gen_user4 = 38
        memory_gen_out7 = 30
        ramp_gen_position_y = 34
        ramp_gen_position_x = 33
        ctrl_user1_out = 51
        in_tip_current = 7
        in_position_y = 21
        comparator2_in_filtered = 60
        analyzer2_x = 55
        memory_gen_position_y = 26
        memory_gen_position_x = 24
        ctrl_z_error = 43
        comparator1_in_filtered = 58
        ctrl_z_nominal = 46
        analyzer1_reference = 67
        analyzer1_phase = 9
        comparator2_out = 61
        analyzer2_phase = 13
        analyzer1_ctrl_delta_f = 11
        memory_gen_drive_y = 27
        ctrl_z_sum = 45
        ramp_gen_alternate_z = 37
        comparator3_in_filtered = 62
        ctrl_user2_out = 52
        analyzer2_ctrl_delta_f = 15
        analyzer2_y = 56
        in_detector_sum = 22
        fast_in2 = 65
        in_position_x = 20
        in_user4 = 6
        static = 17
        ramp_gen_ctrl_z = 40
        ramp_gen_test = 19
        memory_gen_drive_z = 29
        ramp_gen_position_w = 35
        comparator3_out = 63
        ramp_gen_plane_z = 39
        ramp_gen_approach = 32
        ort_baseline = 57
        ort_amplitude_reduction = 16
        analyzer1_ctrl_amplitude = 10
        ctrl_y_out = 49
        ctrl_z_in = 42
        in_position_z = 2
        fast_in_deflection = 64
        memory_gen_drive_x = 25
        in6 = 23
        ctrl_z_out = 47
        in_user3 = 5
        in_user2 = 4
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 18

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.input_set_point'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user2.attribute.input_set_point.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.input_set_point.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user2.attribute.input_set_point.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.input_set_point.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user2.attribute.input_set_point.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.input_set_point.value_raw', new_val.value)


class RootLuPid_controllerPid_user2AttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user2.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user2.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user2.attribute.current_output_value.min', float(new_val))


class RootLuPid_controllerPid_user2Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2.attribute'
        self.current_output_value = RootLuPid_controllerPid_user2AttributeCurrent_output_value(self._context)
        self.input_set_point = RootLuPid_controllerPid_user2AttributeInput_set_point(self._context)
        self.min_value = RootLuPid_controllerPid_user2AttributeMin_value(self._context)
        self.error_limit = RootLuPid_controllerPid_user2AttributeError_limit(self._context)
        self.memory_signal_gen_position_enable = RootLuPid_controllerPid_user2AttributeMemory_signal_gen_position_enable(self._context)
        self.input_actual = RootLuPid_controllerPid_user2AttributeInput_actual(self._context)
        self.p_gain = RootLuPid_controllerPid_user2AttributeP_gain(self._context)
        self.set_point_gain = RootLuPid_controllerPid_user2AttributeSet_point_gain(self._context)
        self.feedback_mode = RootLuPid_controllerPid_user2AttributeFeedback_mode(self._context)
        self.static_set_point = RootLuPid_controllerPid_user2AttributeStatic_set_point(self._context)
        self.d_gain = RootLuPid_controllerPid_user2AttributeD_gain(self._context)
        self.memory_signal_gen_drive_enable = RootLuPid_controllerPid_user2AttributeMemory_signal_gen_drive_enable(self._context)
        self.slope = RootLuPid_controllerPid_user2AttributeSlope(self._context)
        self.i_gain = RootLuPid_controllerPid_user2AttributeI_gain(self._context)
        self.select_output = RootLuPid_controllerPid_user2AttributeSelect_output(self._context)
        self.set_point_modulation_enable = RootLuPid_controllerPid_user2AttributeSet_point_modulation_enable(self._context)
        self.median_filter_enable = RootLuPid_controllerPid_user2AttributeMedian_filter_enable(self._context)
        self.polarity = RootLuPid_controllerPid_user2AttributePolarity(self._context)
        self.reached_min = RootLuPid_controllerPid_user2AttributeReached_min(self._context)
        self.reached_max = RootLuPid_controllerPid_user2AttributeReached_max(self._context)
        self.compare_mode = RootLuPid_controllerPid_user2AttributeCompare_mode(self._context)
        self.reached_err_lim = RootLuPid_controllerPid_user2AttributeReached_err_lim(self._context)
        self.max_value = RootLuPid_controllerPid_user2AttributeMax_value(self._context)


class RootLuPid_controllerPid_user2(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user2'
        self.attribute = RootLuPid_controllerPid_user2Attribute(self._context)
        self.trigger = RootLuPid_controllerPid_user2Trigger(self._context)


class RootLuPid_controllerPid_wTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.trigger'

    def clear_pid_accu(self) -> None:
        return self._context.call('root.lu.pid_controller.pid_w.trigger.clear_pid_accu')


class RootLuPid_controllerPid_wAttributeMax_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.max_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.max_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.max_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_w.attribute.max_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_w.attribute.max_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.max_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.max_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.max_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.max_value.min', float(new_val))


class RootLuPid_controllerPid_wAttributeReached_err_lim(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.reached_err_lim'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.reached_err_lim.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.reached_err_lim.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_w.attribute.reached_err_lim.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_w.attribute.reached_err_lim.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.reached_err_lim.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.reached_err_lim.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.reached_err_lim.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.reached_err_lim.min', float(new_val))


class RootLuPid_controllerPid_wAttributeCompare_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        equal_or_higher_than = 1
        equal_or_lower_than = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.compare_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_w.attribute.compare_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_w.attribute.compare_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_w.attribute.compare_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_w.attribute.compare_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_w.attribute.compare_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_w.attribute.compare_mode.value_raw', new_val.value)


class RootLuPid_controllerPid_wAttributeReached_max(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.reached_max'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.reached_max.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.reached_max.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_w.attribute.reached_max.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_w.attribute.reached_max.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.reached_max.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.reached_max.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.reached_max.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.reached_max.min', float(new_val))


class RootLuPid_controllerPid_wAttributeReached_min(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.reached_min'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.reached_min.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.reached_min.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_w.attribute.reached_min.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_w.attribute.reached_min.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.reached_min.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.reached_min.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.reached_min.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.reached_min.min', float(new_val))


class RootLuPid_controllerPid_wAttributePolarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        inverted = 1
        not_inverted = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_w.attribute.polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_w.attribute.polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_w.attribute.polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_w.attribute.polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_w.attribute.polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_w.attribute.polarity.value_raw', new_val.value)


class RootLuPid_controllerPid_wAttributeMedian_filter_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.median_filter_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_w.attribute.median_filter_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_w.attribute.median_filter_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_w.attribute.median_filter_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_w.attribute.median_filter_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_w.attribute.median_filter_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_w.attribute.median_filter_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_wAttributeSet_point_modulation_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.set_point_modulation_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_w.attribute.set_point_modulation_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_w.attribute.set_point_modulation_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_w.attribute.set_point_modulation_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_w.attribute.set_point_modulation_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_w.attribute.set_point_modulation_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_w.attribute.set_point_modulation_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_wAttributeSelect_output(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        pid_controller_out = 1
        set_point_in = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.select_output'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_w.attribute.select_output.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_w.attribute.select_output.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_w.attribute.select_output.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_w.attribute.select_output.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_w.attribute.select_output.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_w.attribute.select_output.value_raw', new_val.value)


class RootLuPid_controllerPid_wAttributeI_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.i_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.i_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.i_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_w.attribute.i_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_w.attribute.i_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.i_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.i_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.i_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.i_gain.min', float(new_val))


class RootLuPid_controllerPid_wAttributeSlope(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.slope'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.slope.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.slope.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_w.attribute.slope.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_w.attribute.slope.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.slope.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.slope.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.slope.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.slope.min', float(new_val))


class RootLuPid_controllerPid_wAttributeMemory_signal_gen_drive_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.memory_signal_gen_drive_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_w.attribute.memory_signal_gen_drive_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_w.attribute.memory_signal_gen_drive_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_w.attribute.memory_signal_gen_drive_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_w.attribute.memory_signal_gen_drive_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_w.attribute.memory_signal_gen_drive_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_w.attribute.memory_signal_gen_drive_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_wAttributeD_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.d_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.d_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.d_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_w.attribute.d_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_w.attribute.d_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.d_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.d_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.d_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.d_gain.min', float(new_val))


class RootLuPid_controllerPid_wAttributeStatic_set_point(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.static_set_point'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.static_set_point.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.static_set_point.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_w.attribute.static_set_point.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_w.attribute.static_set_point.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.static_set_point.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.static_set_point.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.static_set_point.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.static_set_point.min', float(new_val))


class RootLuPid_controllerPid_wAttributeFeedback_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        running = 1
        freeze = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.feedback_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_w.attribute.feedback_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_w.attribute.feedback_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_w.attribute.feedback_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_w.attribute.feedback_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_w.attribute.feedback_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_w.attribute.feedback_mode.value_raw', new_val.value)


class RootLuPid_controllerPid_wAttributeSet_point_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.set_point_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.set_point_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.set_point_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_w.attribute.set_point_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_w.attribute.set_point_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.set_point_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.set_point_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.set_point_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.set_point_gain.min', float(new_val))


class RootLuPid_controllerPid_wAttributeP_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.p_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.p_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.p_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_w.attribute.p_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_w.attribute.p_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.p_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.p_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.p_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.p_gain.min', float(new_val))


class RootLuPid_controllerPid_wAttributeInput_actual(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 44
        analyzer1_amplitude = 8
        ramp_gen_max_z = 41
        ctrl_x_out = 48
        analyzer2_reference = 68
        analyzer2_ctrl_amplitude = 14
        comparator1_out = 59
        ort_excitation = 69
        ramp_gen_tip_voltage = 36
        memory_gen_out8 = 31
        fast_in_user = 66
        analyzer1_x = 53
        memory_gen_position_z = 28
        ctrl_w_out = 50
        analyzer1_y = 54
        analyzer2_amplitude = 12
        in_user1 = 3
        ramp_gen_user4 = 38
        memory_gen_out7 = 30
        ramp_gen_position_y = 34
        ramp_gen_position_x = 33
        ctrl_user1_out = 51
        in_tip_current = 7
        in_position_y = 21
        comparator2_in_filtered = 60
        analyzer2_x = 55
        memory_gen_position_y = 26
        memory_gen_position_x = 24
        ctrl_z_error = 43
        comparator1_in_filtered = 58
        ctrl_z_nominal = 46
        analyzer1_reference = 67
        analyzer1_phase = 9
        comparator2_out = 61
        analyzer2_phase = 13
        analyzer1_ctrl_delta_f = 11
        memory_gen_drive_y = 27
        ctrl_z_sum = 45
        ramp_gen_alternate_z = 37
        comparator3_in_filtered = 62
        ctrl_user2_out = 52
        analyzer2_ctrl_delta_f = 15
        analyzer2_y = 56
        in_detector_sum = 22
        fast_in2 = 65
        in_position_x = 20
        in_user4 = 6
        static = 17
        ramp_gen_ctrl_z = 40
        ramp_gen_test = 19
        memory_gen_drive_z = 29
        ramp_gen_position_w = 35
        comparator3_out = 63
        ramp_gen_plane_z = 39
        ramp_gen_approach = 32
        ort_baseline = 57
        ort_amplitude_reduction = 16
        analyzer1_ctrl_amplitude = 10
        ctrl_y_out = 49
        ctrl_z_in = 42
        in_position_z = 2
        fast_in_deflection = 64
        memory_gen_drive_x = 25
        in6 = 23
        ctrl_z_out = 47
        in_user3 = 5
        in_user2 = 4
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 18

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.input_actual'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_w.attribute.input_actual.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_w.attribute.input_actual.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_w.attribute.input_actual.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_w.attribute.input_actual.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_w.attribute.input_actual.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_w.attribute.input_actual.value_raw', new_val.value)


class RootLuPid_controllerPid_wAttributeMemory_signal_gen_position_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.memory_signal_gen_position_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_w.attribute.memory_signal_gen_position_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_w.attribute.memory_signal_gen_position_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_w.attribute.memory_signal_gen_position_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_w.attribute.memory_signal_gen_position_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_w.attribute.memory_signal_gen_position_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_w.attribute.memory_signal_gen_position_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_wAttributeError_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.error_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.error_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.error_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_w.attribute.error_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_w.attribute.error_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.error_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.error_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.error_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.error_limit.min', float(new_val))


class RootLuPid_controllerPid_wAttributeMin_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.min_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.min_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.min_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_w.attribute.min_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_w.attribute.min_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.min_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.min_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.min_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.min_value.min', float(new_val))


class RootLuPid_controllerPid_wAttributeInput_set_point(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 44
        analyzer1_amplitude = 8
        ramp_gen_max_z = 41
        ctrl_x_out = 48
        analyzer2_reference = 68
        analyzer2_ctrl_amplitude = 14
        comparator1_out = 59
        ort_excitation = 69
        ramp_gen_tip_voltage = 36
        memory_gen_out8 = 31
        fast_in_user = 66
        analyzer1_x = 53
        memory_gen_position_z = 28
        ctrl_w_out = 50
        analyzer1_y = 54
        analyzer2_amplitude = 12
        in_user1 = 3
        ramp_gen_user4 = 38
        memory_gen_out7 = 30
        ramp_gen_position_y = 34
        ramp_gen_position_x = 33
        ctrl_user1_out = 51
        in_tip_current = 7
        in_position_y = 21
        comparator2_in_filtered = 60
        analyzer2_x = 55
        memory_gen_position_y = 26
        memory_gen_position_x = 24
        ctrl_z_error = 43
        comparator1_in_filtered = 58
        ctrl_z_nominal = 46
        analyzer1_reference = 67
        analyzer1_phase = 9
        comparator2_out = 61
        analyzer2_phase = 13
        analyzer1_ctrl_delta_f = 11
        memory_gen_drive_y = 27
        ctrl_z_sum = 45
        ramp_gen_alternate_z = 37
        comparator3_in_filtered = 62
        ctrl_user2_out = 52
        analyzer2_ctrl_delta_f = 15
        analyzer2_y = 56
        in_detector_sum = 22
        fast_in2 = 65
        in_position_x = 20
        in_user4 = 6
        static = 17
        ramp_gen_ctrl_z = 40
        ramp_gen_test = 19
        memory_gen_drive_z = 29
        ramp_gen_position_w = 35
        comparator3_out = 63
        ramp_gen_plane_z = 39
        ramp_gen_approach = 32
        ort_baseline = 57
        ort_amplitude_reduction = 16
        analyzer1_ctrl_amplitude = 10
        ctrl_y_out = 49
        ctrl_z_in = 42
        in_position_z = 2
        fast_in_deflection = 64
        memory_gen_drive_x = 25
        in6 = 23
        ctrl_z_out = 47
        in_user3 = 5
        in_user2 = 4
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 18

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.input_set_point'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_w.attribute.input_set_point.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_w.attribute.input_set_point.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_w.attribute.input_set_point.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_w.attribute.input_set_point.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_w.attribute.input_set_point.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_w.attribute.input_set_point.value_raw', new_val.value)


class RootLuPid_controllerPid_wAttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_w.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_w.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_w.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_w.attribute.current_output_value.min', float(new_val))


class RootLuPid_controllerPid_wAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w.attribute'
        self.current_output_value = RootLuPid_controllerPid_wAttributeCurrent_output_value(self._context)
        self.input_set_point = RootLuPid_controllerPid_wAttributeInput_set_point(self._context)
        self.min_value = RootLuPid_controllerPid_wAttributeMin_value(self._context)
        self.error_limit = RootLuPid_controllerPid_wAttributeError_limit(self._context)
        self.memory_signal_gen_position_enable = RootLuPid_controllerPid_wAttributeMemory_signal_gen_position_enable(self._context)
        self.input_actual = RootLuPid_controllerPid_wAttributeInput_actual(self._context)
        self.p_gain = RootLuPid_controllerPid_wAttributeP_gain(self._context)
        self.set_point_gain = RootLuPid_controllerPid_wAttributeSet_point_gain(self._context)
        self.feedback_mode = RootLuPid_controllerPid_wAttributeFeedback_mode(self._context)
        self.static_set_point = RootLuPid_controllerPid_wAttributeStatic_set_point(self._context)
        self.d_gain = RootLuPid_controllerPid_wAttributeD_gain(self._context)
        self.memory_signal_gen_drive_enable = RootLuPid_controllerPid_wAttributeMemory_signal_gen_drive_enable(self._context)
        self.slope = RootLuPid_controllerPid_wAttributeSlope(self._context)
        self.i_gain = RootLuPid_controllerPid_wAttributeI_gain(self._context)
        self.select_output = RootLuPid_controllerPid_wAttributeSelect_output(self._context)
        self.set_point_modulation_enable = RootLuPid_controllerPid_wAttributeSet_point_modulation_enable(self._context)
        self.median_filter_enable = RootLuPid_controllerPid_wAttributeMedian_filter_enable(self._context)
        self.polarity = RootLuPid_controllerPid_wAttributePolarity(self._context)
        self.reached_min = RootLuPid_controllerPid_wAttributeReached_min(self._context)
        self.reached_max = RootLuPid_controllerPid_wAttributeReached_max(self._context)
        self.compare_mode = RootLuPid_controllerPid_wAttributeCompare_mode(self._context)
        self.reached_err_lim = RootLuPid_controllerPid_wAttributeReached_err_lim(self._context)
        self.max_value = RootLuPid_controllerPid_wAttributeMax_value(self._context)


class RootLuPid_controllerPid_w(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_w'
        self.attribute = RootLuPid_controllerPid_wAttribute(self._context)
        self.trigger = RootLuPid_controllerPid_wTrigger(self._context)


class RootLuPid_controllerPid_user1Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.trigger'

    def clear_pid_accu(self) -> None:
        return self._context.call('root.lu.pid_controller.pid_user1.trigger.clear_pid_accu')


class RootLuPid_controllerPid_user1AttributeMax_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.max_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.max_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.max_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user1.attribute.max_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.max_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.max_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.max_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.max_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.max_value.min', float(new_val))


class RootLuPid_controllerPid_user1AttributeReached_err_lim(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.reached_err_lim'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.reached_err_lim.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.reached_err_lim.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user1.attribute.reached_err_lim.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.reached_err_lim.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.reached_err_lim.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.reached_err_lim.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.reached_err_lim.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.reached_err_lim.min', float(new_val))


class RootLuPid_controllerPid_user1AttributeCompare_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        equal_or_higher_than = 1
        equal_or_lower_than = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.compare_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user1.attribute.compare_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.compare_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user1.attribute.compare_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.compare_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user1.attribute.compare_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.compare_mode.value_raw', new_val.value)


class RootLuPid_controllerPid_user1AttributeReached_max(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.reached_max'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.reached_max.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.reached_max.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user1.attribute.reached_max.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.reached_max.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.reached_max.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.reached_max.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.reached_max.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.reached_max.min', float(new_val))


class RootLuPid_controllerPid_user1AttributeReached_min(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.reached_min'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.reached_min.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.reached_min.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user1.attribute.reached_min.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.reached_min.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.reached_min.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.reached_min.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.reached_min.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.reached_min.min', float(new_val))


class RootLuPid_controllerPid_user1AttributePolarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        inverted = 1
        not_inverted = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user1.attribute.polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user1.attribute.polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user1.attribute.polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.polarity.value_raw', new_val.value)


class RootLuPid_controllerPid_user1AttributeMedian_filter_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.median_filter_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user1.attribute.median_filter_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.median_filter_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user1.attribute.median_filter_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.median_filter_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user1.attribute.median_filter_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.median_filter_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_user1AttributeSet_point_modulation_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.set_point_modulation_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user1.attribute.set_point_modulation_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.set_point_modulation_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user1.attribute.set_point_modulation_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.set_point_modulation_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user1.attribute.set_point_modulation_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.set_point_modulation_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_user1AttributeSelect_output(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        pid_controller_out = 1
        set_point_in = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.select_output'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user1.attribute.select_output.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.select_output.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user1.attribute.select_output.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.select_output.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user1.attribute.select_output.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.select_output.value_raw', new_val.value)


class RootLuPid_controllerPid_user1AttributeI_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.i_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.i_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.i_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user1.attribute.i_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.i_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.i_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.i_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.i_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.i_gain.min', float(new_val))


class RootLuPid_controllerPid_user1AttributeSlope(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.slope'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.slope.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.slope.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user1.attribute.slope.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.slope.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.slope.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.slope.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.slope.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.slope.min', float(new_val))


class RootLuPid_controllerPid_user1AttributeMemory_signal_gen_drive_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.memory_signal_gen_drive_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user1.attribute.memory_signal_gen_drive_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.memory_signal_gen_drive_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user1.attribute.memory_signal_gen_drive_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.memory_signal_gen_drive_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user1.attribute.memory_signal_gen_drive_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.memory_signal_gen_drive_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_user1AttributeD_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.d_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.d_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.d_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user1.attribute.d_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.d_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.d_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.d_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.d_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.d_gain.min', float(new_val))


class RootLuPid_controllerPid_user1AttributeStatic_set_point(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.static_set_point'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.static_set_point.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.static_set_point.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user1.attribute.static_set_point.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.static_set_point.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.static_set_point.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.static_set_point.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.static_set_point.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.static_set_point.min', float(new_val))


class RootLuPid_controllerPid_user1AttributeFeedback_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        running = 1
        freeze = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.feedback_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user1.attribute.feedback_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.feedback_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user1.attribute.feedback_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.feedback_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user1.attribute.feedback_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.feedback_mode.value_raw', new_val.value)


class RootLuPid_controllerPid_user1AttributeSet_point_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.set_point_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.set_point_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.set_point_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user1.attribute.set_point_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.set_point_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.set_point_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.set_point_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.set_point_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.set_point_gain.min', float(new_val))


class RootLuPid_controllerPid_user1AttributeP_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.p_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.p_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.p_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user1.attribute.p_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.p_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.p_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.p_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.p_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.p_gain.min', float(new_val))


class RootLuPid_controllerPid_user1AttributeInput_actual(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 44
        analyzer1_amplitude = 8
        ramp_gen_max_z = 41
        ctrl_x_out = 48
        analyzer2_reference = 68
        analyzer2_ctrl_amplitude = 14
        comparator1_out = 59
        ort_excitation = 69
        ramp_gen_tip_voltage = 36
        memory_gen_out8 = 31
        fast_in_user = 66
        analyzer1_x = 53
        memory_gen_position_z = 28
        ctrl_w_out = 50
        analyzer1_y = 54
        analyzer2_amplitude = 12
        in_user1 = 3
        ramp_gen_user4 = 38
        memory_gen_out7 = 30
        ramp_gen_position_y = 34
        ramp_gen_position_x = 33
        ctrl_user1_out = 51
        in_tip_current = 7
        in_position_y = 21
        comparator2_in_filtered = 60
        analyzer2_x = 55
        memory_gen_position_y = 26
        memory_gen_position_x = 24
        ctrl_z_error = 43
        comparator1_in_filtered = 58
        ctrl_z_nominal = 46
        analyzer1_reference = 67
        analyzer1_phase = 9
        comparator2_out = 61
        analyzer2_phase = 13
        analyzer1_ctrl_delta_f = 11
        memory_gen_drive_y = 27
        ctrl_z_sum = 45
        ramp_gen_alternate_z = 37
        comparator3_in_filtered = 62
        ctrl_user2_out = 52
        analyzer2_ctrl_delta_f = 15
        analyzer2_y = 56
        in_detector_sum = 22
        fast_in2 = 65
        in_position_x = 20
        in_user4 = 6
        static = 17
        ramp_gen_ctrl_z = 40
        ramp_gen_test = 19
        memory_gen_drive_z = 29
        ramp_gen_position_w = 35
        comparator3_out = 63
        ramp_gen_plane_z = 39
        ramp_gen_approach = 32
        ort_baseline = 57
        ort_amplitude_reduction = 16
        analyzer1_ctrl_amplitude = 10
        ctrl_y_out = 49
        ctrl_z_in = 42
        in_position_z = 2
        fast_in_deflection = 64
        memory_gen_drive_x = 25
        in6 = 23
        ctrl_z_out = 47
        in_user3 = 5
        in_user2 = 4
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 18

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.input_actual'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user1.attribute.input_actual.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.input_actual.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user1.attribute.input_actual.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.input_actual.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user1.attribute.input_actual.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.input_actual.value_raw', new_val.value)


class RootLuPid_controllerPid_user1AttributeMemory_signal_gen_position_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.memory_signal_gen_position_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user1.attribute.memory_signal_gen_position_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.memory_signal_gen_position_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user1.attribute.memory_signal_gen_position_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.memory_signal_gen_position_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user1.attribute.memory_signal_gen_position_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.memory_signal_gen_position_enable.value_raw', new_val.value)


class RootLuPid_controllerPid_user1AttributeError_limit(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.error_limit'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.error_limit.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.error_limit.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user1.attribute.error_limit.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.error_limit.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.error_limit.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.error_limit.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.error_limit.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.error_limit.min', float(new_val))


class RootLuPid_controllerPid_user1AttributeMin_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.min_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.min_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.min_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user1.attribute.min_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.min_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.min_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.min_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.min_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.min_value.min', float(new_val))


class RootLuPid_controllerPid_user1AttributeInput_set_point(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 44
        analyzer1_amplitude = 8
        ramp_gen_max_z = 41
        ctrl_x_out = 48
        analyzer2_reference = 68
        analyzer2_ctrl_amplitude = 14
        comparator1_out = 59
        ort_excitation = 69
        ramp_gen_tip_voltage = 36
        memory_gen_out8 = 31
        fast_in_user = 66
        analyzer1_x = 53
        memory_gen_position_z = 28
        ctrl_w_out = 50
        analyzer1_y = 54
        analyzer2_amplitude = 12
        in_user1 = 3
        ramp_gen_user4 = 38
        memory_gen_out7 = 30
        ramp_gen_position_y = 34
        ramp_gen_position_x = 33
        ctrl_user1_out = 51
        in_tip_current = 7
        in_position_y = 21
        comparator2_in_filtered = 60
        analyzer2_x = 55
        memory_gen_position_y = 26
        memory_gen_position_x = 24
        ctrl_z_error = 43
        comparator1_in_filtered = 58
        ctrl_z_nominal = 46
        analyzer1_reference = 67
        analyzer1_phase = 9
        comparator2_out = 61
        analyzer2_phase = 13
        analyzer1_ctrl_delta_f = 11
        memory_gen_drive_y = 27
        ctrl_z_sum = 45
        ramp_gen_alternate_z = 37
        comparator3_in_filtered = 62
        ctrl_user2_out = 52
        analyzer2_ctrl_delta_f = 15
        analyzer2_y = 56
        in_detector_sum = 22
        fast_in2 = 65
        in_position_x = 20
        in_user4 = 6
        static = 17
        ramp_gen_ctrl_z = 40
        ramp_gen_test = 19
        memory_gen_drive_z = 29
        ramp_gen_position_w = 35
        comparator3_out = 63
        ramp_gen_plane_z = 39
        ramp_gen_approach = 32
        ort_baseline = 57
        ort_amplitude_reduction = 16
        analyzer1_ctrl_amplitude = 10
        ctrl_y_out = 49
        ctrl_z_in = 42
        in_position_z = 2
        fast_in_deflection = 64
        memory_gen_drive_x = 25
        in6 = 23
        ctrl_z_out = 47
        in_user3 = 5
        in_user2 = 4
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 18

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.input_set_point'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.pid_controller.pid_user1.attribute.input_set_point.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.input_set_point.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.pid_controller.pid_user1.attribute.input_set_point.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.input_set_point.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.pid_controller.pid_user1.attribute.input_set_point.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.input_set_point.value_raw', new_val.value)


class RootLuPid_controllerPid_user1AttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.pid_controller.pid_user1.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.pid_controller.pid_user1.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.pid_controller.pid_user1.attribute.current_output_value.min', float(new_val))


class RootLuPid_controllerPid_user1Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1.attribute'
        self.current_output_value = RootLuPid_controllerPid_user1AttributeCurrent_output_value(self._context)
        self.input_set_point = RootLuPid_controllerPid_user1AttributeInput_set_point(self._context)
        self.min_value = RootLuPid_controllerPid_user1AttributeMin_value(self._context)
        self.error_limit = RootLuPid_controllerPid_user1AttributeError_limit(self._context)
        self.memory_signal_gen_position_enable = RootLuPid_controllerPid_user1AttributeMemory_signal_gen_position_enable(self._context)
        self.input_actual = RootLuPid_controllerPid_user1AttributeInput_actual(self._context)
        self.p_gain = RootLuPid_controllerPid_user1AttributeP_gain(self._context)
        self.set_point_gain = RootLuPid_controllerPid_user1AttributeSet_point_gain(self._context)
        self.feedback_mode = RootLuPid_controllerPid_user1AttributeFeedback_mode(self._context)
        self.static_set_point = RootLuPid_controllerPid_user1AttributeStatic_set_point(self._context)
        self.d_gain = RootLuPid_controllerPid_user1AttributeD_gain(self._context)
        self.memory_signal_gen_drive_enable = RootLuPid_controllerPid_user1AttributeMemory_signal_gen_drive_enable(self._context)
        self.slope = RootLuPid_controllerPid_user1AttributeSlope(self._context)
        self.i_gain = RootLuPid_controllerPid_user1AttributeI_gain(self._context)
        self.select_output = RootLuPid_controllerPid_user1AttributeSelect_output(self._context)
        self.set_point_modulation_enable = RootLuPid_controllerPid_user1AttributeSet_point_modulation_enable(self._context)
        self.median_filter_enable = RootLuPid_controllerPid_user1AttributeMedian_filter_enable(self._context)
        self.polarity = RootLuPid_controllerPid_user1AttributePolarity(self._context)
        self.reached_min = RootLuPid_controllerPid_user1AttributeReached_min(self._context)
        self.reached_max = RootLuPid_controllerPid_user1AttributeReached_max(self._context)
        self.compare_mode = RootLuPid_controllerPid_user1AttributeCompare_mode(self._context)
        self.reached_err_lim = RootLuPid_controllerPid_user1AttributeReached_err_lim(self._context)
        self.max_value = RootLuPid_controllerPid_user1AttributeMax_value(self._context)


class RootLuPid_controllerPid_user1(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller.pid_user1'
        self.attribute = RootLuPid_controllerPid_user1Attribute(self._context)
        self.trigger = RootLuPid_controllerPid_user1Trigger(self._context)


class RootLuPid_controller(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.pid_controller'
        self.pid_user1 = RootLuPid_controllerPid_user1(self._context)
        self.pid_w = RootLuPid_controllerPid_w(self._context)
        self.pid_user2 = RootLuPid_controllerPid_user2(self._context)
        self.pid_x = RootLuPid_controllerPid_x(self._context)
        self.pid_y = RootLuPid_controllerPid_y(self._context)


class RootLuAuto_alignmentInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.auto_alignment.instance.trigger'

    def start_search_algorithm(self) -> None:
        return self._context.call('root.lu.auto_alignment.instance.trigger.start_search_algorithm')

    def start_optimization(self) -> None:
        return self._context.call('root.lu.auto_alignment.instance.trigger.start_optimization')

    def user_abort(self) -> None:
        return self._context.call('root.lu.auto_alignment.instance.trigger.user_abort')

    def start_move_to_optical_center(self) -> None:
        return self._context.call('root.lu.auto_alignment.instance.trigger.start_move_to_optical_center')

    def adjust_optics_to_environment(self) -> None:
        return self._context.call('root.lu.auto_alignment.instance.trigger.adjust_optics_to_environment')

    def start_align(self) -> None:
        return self._context.call('root.lu.auto_alignment.instance.trigger.start_align')


class RootLuAuto_alignmentInstanceAttributeReadout_optical_center_x(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.auto_alignment.instance.attribute.readout_optical_center_x'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.readout_optical_center_x.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.readout_optical_center_x.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.auto_alignment.instance.attribute.readout_optical_center_x.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.auto_alignment.instance.attribute.readout_optical_center_x.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.readout_optical_center_x.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.readout_optical_center_x.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.readout_optical_center_x.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.readout_optical_center_x.min', float(new_val))


class RootLuAuto_alignmentInstanceAttributeReadout_optical_center_y(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.auto_alignment.instance.attribute.readout_optical_center_y'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.readout_optical_center_y.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.readout_optical_center_y.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.auto_alignment.instance.attribute.readout_optical_center_y.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.auto_alignment.instance.attribute.readout_optical_center_y.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.readout_optical_center_y.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.readout_optical_center_y.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.readout_optical_center_y.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.readout_optical_center_y.min', float(new_val))


class RootLuAuto_alignmentInstanceAttributeCurrent_optic_component(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        readout = 1
        all = 0
        detector = 5
        pte = 2
        beam_shifter = 4
        focus = 3

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.auto_alignment.instance.attribute.current_optic_component'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.auto_alignment.instance.attribute.current_optic_component.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.auto_alignment.instance.attribute.current_optic_component.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.auto_alignment.instance.attribute.current_optic_component.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.auto_alignment.instance.attribute.current_optic_component.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.auto_alignment.instance.attribute.current_optic_component.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.auto_alignment.instance.attribute.current_optic_component.value_raw', new_val.value)


class RootLuAuto_alignmentInstanceAttributeLaser_position_shift_x(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.auto_alignment.instance.attribute.laser_position_shift_x'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.laser_position_shift_x.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.laser_position_shift_x.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.auto_alignment.instance.attribute.laser_position_shift_x.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.auto_alignment.instance.attribute.laser_position_shift_x.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.laser_position_shift_x.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.laser_position_shift_x.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.laser_position_shift_x.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.laser_position_shift_x.min', float(new_val))


class RootLuAuto_alignmentInstanceAttributePte_optical_center_x(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.auto_alignment.instance.attribute.pte_optical_center_x'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.pte_optical_center_x.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.pte_optical_center_x.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.auto_alignment.instance.attribute.pte_optical_center_x.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.auto_alignment.instance.attribute.pte_optical_center_x.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.pte_optical_center_x.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.pte_optical_center_x.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.pte_optical_center_x.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.pte_optical_center_x.min', float(new_val))


class RootLuAuto_alignmentInstanceAttributeSearch_algorithm(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        in_place = 0
        cantilever_between_two_reflecting_edges = 4
        rhombus_spiral = 2
        bottom_to_top_stepped = 3
        minimalistic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.auto_alignment.instance.attribute.search_algorithm'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.auto_alignment.instance.attribute.search_algorithm.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.auto_alignment.instance.attribute.search_algorithm.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.auto_alignment.instance.attribute.search_algorithm.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.auto_alignment.instance.attribute.search_algorithm.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.auto_alignment.instance.attribute.search_algorithm.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.auto_alignment.instance.attribute.search_algorithm.value_raw', new_val.value)


class RootLuAuto_alignmentInstanceAttributePte_optical_center_y(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.auto_alignment.instance.attribute.pte_optical_center_y'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.pte_optical_center_y.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.pte_optical_center_y.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.auto_alignment.instance.attribute.pte_optical_center_y.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.auto_alignment.instance.attribute.pte_optical_center_y.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.pte_optical_center_y.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.pte_optical_center_y.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.pte_optical_center_y.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.pte_optical_center_y.min', float(new_val))


class RootLuAuto_alignmentInstanceAttributeAlign_state(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        failed = 2
        aligned_successfully = 3
        running = 1
        idle = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.auto_alignment.instance.attribute.align_state'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.auto_alignment.instance.attribute.align_state.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.auto_alignment.instance.attribute.align_state.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.auto_alignment.instance.attribute.align_state.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.auto_alignment.instance.attribute.align_state.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.auto_alignment.instance.attribute.align_state.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.auto_alignment.instance.attribute.align_state.value_raw', new_val.value)


class RootLuAuto_alignmentInstanceAttributeComponent_state(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        idle_positioned = 1
        idle_optimized = 7
        idle_not_positioned = 0
        searching = 3
        optimizing = 6

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.auto_alignment.instance.attribute.component_state'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.auto_alignment.instance.attribute.component_state.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.auto_alignment.instance.attribute.component_state.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.auto_alignment.instance.attribute.component_state.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.auto_alignment.instance.attribute.component_state.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.auto_alignment.instance.attribute.component_state.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.auto_alignment.instance.attribute.component_state.value_raw', new_val.value)


class RootLuAuto_alignmentInstanceAttributeFocus_default_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.auto_alignment.instance.attribute.focus_default_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.focus_default_position.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.focus_default_position.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.auto_alignment.instance.attribute.focus_default_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.auto_alignment.instance.attribute.focus_default_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.focus_default_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.focus_default_position.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.focus_default_position.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.focus_default_position.min', float(new_val))


class RootLuAuto_alignmentInstanceAttributeBeam_shifter_default_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.auto_alignment.instance.attribute.beam_shifter_default_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.beam_shifter_default_position.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.beam_shifter_default_position.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.auto_alignment.instance.attribute.beam_shifter_default_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.auto_alignment.instance.attribute.beam_shifter_default_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.beam_shifter_default_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.beam_shifter_default_position.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.beam_shifter_default_position.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.beam_shifter_default_position.min', float(new_val))


class RootLuAuto_alignmentInstanceAttributeLaser_position_shift_y(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.auto_alignment.instance.attribute.laser_position_shift_y'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.laser_position_shift_y.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.laser_position_shift_y.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.auto_alignment.instance.attribute.laser_position_shift_y.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.auto_alignment.instance.attribute.laser_position_shift_y.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.laser_position_shift_y.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.laser_position_shift_y.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.auto_alignment.instance.attribute.laser_position_shift_y.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.auto_alignment.instance.attribute.laser_position_shift_y.min', float(new_val))


class RootLuAuto_alignmentInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.auto_alignment.instance.attribute'
        self.laser_position_shift_y = RootLuAuto_alignmentInstanceAttributeLaser_position_shift_y(self._context)
        self.beam_shifter_default_position = RootLuAuto_alignmentInstanceAttributeBeam_shifter_default_position(self._context)
        self.focus_default_position = RootLuAuto_alignmentInstanceAttributeFocus_default_position(self._context)
        self.component_state = RootLuAuto_alignmentInstanceAttributeComponent_state(self._context)
        self.align_state = RootLuAuto_alignmentInstanceAttributeAlign_state(self._context)
        self.pte_optical_center_y = RootLuAuto_alignmentInstanceAttributePte_optical_center_y(self._context)
        self.search_algorithm = RootLuAuto_alignmentInstanceAttributeSearch_algorithm(self._context)
        self.pte_optical_center_x = RootLuAuto_alignmentInstanceAttributePte_optical_center_x(self._context)
        self.laser_position_shift_x = RootLuAuto_alignmentInstanceAttributeLaser_position_shift_x(self._context)
        self.current_optic_component = RootLuAuto_alignmentInstanceAttributeCurrent_optic_component(self._context)
        self.readout_optical_center_y = RootLuAuto_alignmentInstanceAttributeReadout_optical_center_y(self._context)
        self.readout_optical_center_x = RootLuAuto_alignmentInstanceAttributeReadout_optical_center_x(self._context)


class RootLuAuto_alignmentInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.auto_alignment.instance'
        self.attribute = RootLuAuto_alignmentInstanceAttribute(self._context)
        self.trigger = RootLuAuto_alignmentInstanceTrigger(self._context)


class RootLuAuto_alignment(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.auto_alignment'
        self.instance = RootLuAuto_alignmentInstance(self._context)


class RootLuData_acquisitionInstanceBusy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.busy'

    @property
    def is_capturing(self) -> bool:
        return bool(self._context.call('root.lu.data_acquisition.instance.busy.is_capturing'))

    @property
    def is_sampling(self) -> bool:
        return bool(self._context.call('root.lu.data_acquisition.instance.busy.is_sampling'))


class RootLuData_acquisitionInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.trigger'

    def background_sampler_start(self) -> None:
        return self._context.call('root.lu.data_acquisition.instance.trigger.background_sampler_start')

    def capture_prepare(self) -> None:
        return self._context.call('root.lu.data_acquisition.instance.trigger.capture_prepare')

    def sampler_set_start_time(self) -> None:
        return self._context.call('root.lu.data_acquisition.instance.trigger.sampler_set_start_time')

    def capture_set_start_time(self) -> None:
        return self._context.call('root.lu.data_acquisition.instance.trigger.capture_set_start_time')

    def background_capture_start(self) -> None:
        return self._context.call('root.lu.data_acquisition.instance.trigger.background_capture_start')

    def background_sampler_stop(self) -> None:
        return self._context.call('root.lu.data_acquisition.instance.trigger.background_sampler_stop')

    def abort_all(self) -> None:
        return self._context.call('root.lu.data_acquisition.instance.trigger.abort_all')

    def sampler_start(self) -> None:
        return self._context.call('root.lu.data_acquisition.instance.trigger.sampler_start')

    def sampler_trim_data_storage(self) -> None:
        return self._context.call('root.lu.data_acquisition.instance.trigger.sampler_trim_data_storage')

    def capture_start(self) -> None:
        return self._context.call('root.lu.data_acquisition.instance.trigger.capture_start')

    def capture_trim_data_storage(self) -> None:
        return self._context.call('root.lu.data_acquisition.instance.trigger.capture_trim_data_storage')

    def sampler_prepare(self) -> None:
        return self._context.call('root.lu.data_acquisition.instance.trigger.sampler_prepare')


class RootLuData_acquisitionInstanceAttributeCapture_hi_res_ch2_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_hi_res_ch2_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch2_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch2_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch2_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch2_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch2_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch2_input.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeCapture_fast_group_id(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_fast_group_id'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_group_id.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_group_id.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_group_id.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_group_id.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_group_id.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_group_id.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_group_id.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_group_id.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeCapture_hi_res_channel_mask(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_hi_res_channel_mask'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_channel_mask.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_channel_mask.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_channel_mask.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_channel_mask.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_channel_mask.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_channel_mask.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_channel_mask.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_channel_mask.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeNumber_of_sampler_sets(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.number_of_sampler_sets'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.number_of_sampler_sets.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.number_of_sampler_sets.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.number_of_sampler_sets.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.number_of_sampler_sets.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.number_of_sampler_sets.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.number_of_sampler_sets.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.number_of_sampler_sets.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.number_of_sampler_sets.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeCapture_hi_res_ch5_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_hi_res_ch5_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch5_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch5_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch5_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch5_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch5_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch5_input.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeNumber_of_capture_sets(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.number_of_capture_sets'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.number_of_capture_sets.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.number_of_capture_sets.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.number_of_capture_sets.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.number_of_capture_sets.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.number_of_capture_sets.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.number_of_capture_sets.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.number_of_capture_sets.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.number_of_capture_sets.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeCapture_hi_res_ch3_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_hi_res_ch3_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch3_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch3_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch3_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch3_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch3_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch3_input.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeSampler_auto_set_filter_mode(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_auto_set_filter_mode'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_auto_set_filter_mode.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_auto_set_filter_mode.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_auto_set_filter_mode.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_auto_set_filter_mode.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_auto_set_filter_mode.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_auto_set_filter_mode.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_auto_set_filter_mode.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_auto_set_filter_mode.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeSampler_filter_cutoff(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_filter_cutoff'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_filter_cutoff.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_filter_cutoff.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_filter_cutoff.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_filter_cutoff.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_filter_cutoff.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_filter_cutoff.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_filter_cutoff.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_filter_cutoff.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeSampler_filter_size(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_filter_size'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_filter_size.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_filter_size.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_filter_size.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_filter_size.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_filter_size.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_filter_size.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_filter_size.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_filter_size.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeActive_capture_set(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.active_capture_set'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.active_capture_set.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.active_capture_set.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.active_capture_set.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.active_capture_set.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.active_capture_set.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.active_capture_set.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.active_capture_set.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.active_capture_set.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeSampler_hi_res_ch1_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch1_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch1_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch1_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch1_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch1_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch1_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch1_input.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeCapture_hi_res_ch0_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_hi_res_ch0_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch0_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch0_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch0_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch0_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch0_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch0_input.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeSampler_hi_res_ch7_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch7_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch7_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch7_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch7_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch7_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch7_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch7_input.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeCapture_hi_res_datapoints(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_hi_res_datapoints'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_datapoints.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_datapoints.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_datapoints.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_datapoints.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_datapoints.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_datapoints.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_datapoints.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_datapoints.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeSampler_hi_res_ch5_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch5_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch5_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch5_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch5_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch5_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch5_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch5_input.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeSampler_hi_res_ch2_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch2_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch2_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch2_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch2_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch2_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch2_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch2_input.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeCapture_hi_res_ch_input_vec(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_hi_res_ch_input_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch_input_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch_input_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch_input_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch_input_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch_input_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch_input_vec.set_vector_value', int(index), new_val)

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch_input_vec.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch_input_vec.enum', list(new_val))

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch_input_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch_input_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch_input_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch_input_vec.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeCapture_fast_sampling_rate(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_fast_sampling_rate'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_sampling_rate.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_sampling_rate.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_sampling_rate.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_sampling_rate.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_sampling_rate.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_sampling_rate.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_sampling_rate.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_sampling_rate.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeCapture_hi_res_ch7_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_hi_res_ch7_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch7_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch7_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch7_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch7_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch7_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch7_input.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeSampler_group_id(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_group_id'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_group_id.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_group_id.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_group_id.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_group_id.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_group_id.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_group_id.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_group_id.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_group_id.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeSampler_hi_res_ch6_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch6_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch6_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch6_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch6_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch6_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch6_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch6_input.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeCapture_hi_res_ch4_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_hi_res_ch4_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch4_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch4_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch4_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch4_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch4_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch4_input.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeSampler_hi_res_ch4_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch4_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch4_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch4_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch4_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch4_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch4_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch4_input.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeSampler_hi_res_ch_input_vec(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch_input_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch_input_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch_input_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch_input_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch_input_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch_input_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch_input_vec.set_vector_value', int(index), new_val)

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch_input_vec.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch_input_vec.enum', list(new_val))

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch_input_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch_input_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch_input_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch_input_vec.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeCapture_fast_ch_input_vec(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 3
        in2 = 1
        ctrl_z_out = 6
        ctrl_w_out = 7
        analyzer2_reference = 4
        ort_excitation = 5
        in_user = 2
        in_deflection = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_fast_ch_input_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_ch_input_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_ch_input_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_ch_input_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_ch_input_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.data_acquisition.instance.attribute.capture_fast_ch_input_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.data_acquisition.instance.attribute.capture_fast_ch_input_vec.set_vector_value', int(index), new_val)

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_ch_input_vec.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_ch_input_vec.enum', list(new_val))

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_ch_input_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_ch_input_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_ch_input_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_ch_input_vec.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeSampler_hi_res_ch3_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch3_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch3_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch3_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch3_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch3_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch3_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch3_input.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeCapture_fast_datapoints(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_fast_datapoints'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_datapoints.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_datapoints.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_datapoints.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_datapoints.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_datapoints.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_datapoints.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_datapoints.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_datapoints.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeSampler_trigger_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        internal_continuous_timer = 2
        external_trigger = 1
        internal_timer = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_trigger_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_trigger_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_trigger_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_trigger_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_trigger_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_trigger_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_trigger_mode.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeSampler_data_rate(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_data_rate'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_data_rate.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_data_rate.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_data_rate.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_data_rate.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_data_rate.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_data_rate.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_data_rate.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_data_rate.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeCapture_hi_res_group_id(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_hi_res_group_id'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_group_id.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_group_id.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_group_id.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_group_id.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_group_id.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_group_id.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_group_id.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_group_id.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeCapture_fast_ch1_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 3
        in2 = 1
        ctrl_z_out = 6
        ctrl_w_out = 7
        analyzer2_reference = 4
        ort_excitation = 5
        in_user = 2
        in_deflection = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_fast_ch1_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_ch1_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_ch1_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_ch1_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_ch1_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_ch1_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_ch1_input.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeSampler_filter_type(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        window_hamming = 1
        window_rectangular = 0
        window_nuttall = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_filter_type'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_filter_type.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_filter_type.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_filter_type.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_filter_type.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_filter_type.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_filter_type.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeActive_sampler_set(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.active_sampler_set'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.active_sampler_set.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.active_sampler_set.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.active_sampler_set.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.active_sampler_set.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.active_sampler_set.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.active_sampler_set.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.active_sampler_set.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.active_sampler_set.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeCapture_fast_ch0_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 3
        in2 = 1
        ctrl_z_out = 6
        ctrl_w_out = 7
        analyzer2_reference = 4
        ort_excitation = 5
        in_user = 2
        in_deflection = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_fast_ch0_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_ch0_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_ch0_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_ch0_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_ch0_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_ch0_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_ch0_input.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeSampler_datapoints(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_datapoints'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_datapoints.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_datapoints.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_datapoints.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_datapoints.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_datapoints.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_datapoints.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_datapoints.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_datapoints.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeCapture_fast_channel_mask(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_fast_channel_mask'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_channel_mask.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_channel_mask.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_channel_mask.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_channel_mask.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_channel_mask.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_channel_mask.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.capture_fast_channel_mask.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_fast_channel_mask.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeSampler_channel_mask(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_channel_mask'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_channel_mask.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_channel_mask.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_channel_mask.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_channel_mask.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_channel_mask.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_channel_mask.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_channel_mask.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_channel_mask.min', float(new_val))


class RootLuData_acquisitionInstanceAttributeSampler_hi_res_ch0_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch0_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch0_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch0_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch0_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch0_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch0_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_hi_res_ch0_input.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeCapture_hi_res_ch1_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_hi_res_ch1_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch1_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch1_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch1_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch1_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch1_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch1_input.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeSampler_filter_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        low_pass_200_hz = 2
        low_pass_500_hz = 3
        low_pass_2_k_hz = 5
        low_pass_100_k_hz = 10
        low_pass_10_k_hz = 7
        low_pass_5_k_hz = 6
        filter_userdefined = 0
        low_pass_1_k_hz = 4
        low_pass_100_hz = 1
        low_pass_50_k_hz = 9
        low_pass_50_hz = 15
        low_pass_20_hz = 14
        low_pass_20_k_hz = 8
        low_pass_10_hz = 13
        low_pass_5_hz = 12

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.sampler_filter_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_filter_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_filter_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_filter_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_filter_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.sampler_filter_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.sampler_filter_mode.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttributeCapture_hi_res_ch6_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute.capture_hi_res_ch6_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch6_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch6_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch6_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch6_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch6_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.data_acquisition.instance.attribute.capture_hi_res_ch6_input.value_raw', new_val.value)


class RootLuData_acquisitionInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance.attribute'
        self.capture_hi_res_ch6_input = RootLuData_acquisitionInstanceAttributeCapture_hi_res_ch6_input(self._context)
        self.sampler_filter_mode = RootLuData_acquisitionInstanceAttributeSampler_filter_mode(self._context)
        self.capture_hi_res_ch1_input = RootLuData_acquisitionInstanceAttributeCapture_hi_res_ch1_input(self._context)
        self.sampler_hi_res_ch0_input = RootLuData_acquisitionInstanceAttributeSampler_hi_res_ch0_input(self._context)
        self.sampler_channel_mask = RootLuData_acquisitionInstanceAttributeSampler_channel_mask(self._context)
        self.capture_fast_channel_mask = RootLuData_acquisitionInstanceAttributeCapture_fast_channel_mask(self._context)
        self.sampler_datapoints = RootLuData_acquisitionInstanceAttributeSampler_datapoints(self._context)
        self.capture_fast_ch0_input = RootLuData_acquisitionInstanceAttributeCapture_fast_ch0_input(self._context)
        self.active_sampler_set = RootLuData_acquisitionInstanceAttributeActive_sampler_set(self._context)
        self.sampler_filter_type = RootLuData_acquisitionInstanceAttributeSampler_filter_type(self._context)
        self.capture_fast_ch1_input = RootLuData_acquisitionInstanceAttributeCapture_fast_ch1_input(self._context)
        self.capture_hi_res_group_id = RootLuData_acquisitionInstanceAttributeCapture_hi_res_group_id(self._context)
        self.sampler_data_rate = RootLuData_acquisitionInstanceAttributeSampler_data_rate(self._context)
        self.sampler_trigger_mode = RootLuData_acquisitionInstanceAttributeSampler_trigger_mode(self._context)
        self.capture_fast_datapoints = RootLuData_acquisitionInstanceAttributeCapture_fast_datapoints(self._context)
        self.sampler_hi_res_ch3_input = RootLuData_acquisitionInstanceAttributeSampler_hi_res_ch3_input(self._context)
        self.capture_fast_ch_input_vec = RootLuData_acquisitionInstanceAttributeCapture_fast_ch_input_vec(self._context)
        self.sampler_hi_res_ch_input_vec = RootLuData_acquisitionInstanceAttributeSampler_hi_res_ch_input_vec(self._context)
        self.sampler_hi_res_ch4_input = RootLuData_acquisitionInstanceAttributeSampler_hi_res_ch4_input(self._context)
        self.capture_hi_res_ch4_input = RootLuData_acquisitionInstanceAttributeCapture_hi_res_ch4_input(self._context)
        self.sampler_hi_res_ch6_input = RootLuData_acquisitionInstanceAttributeSampler_hi_res_ch6_input(self._context)
        self.sampler_group_id = RootLuData_acquisitionInstanceAttributeSampler_group_id(self._context)
        self.capture_hi_res_ch7_input = RootLuData_acquisitionInstanceAttributeCapture_hi_res_ch7_input(self._context)
        self.capture_fast_sampling_rate = RootLuData_acquisitionInstanceAttributeCapture_fast_sampling_rate(self._context)
        self.capture_hi_res_ch_input_vec = RootLuData_acquisitionInstanceAttributeCapture_hi_res_ch_input_vec(self._context)
        self.sampler_hi_res_ch2_input = RootLuData_acquisitionInstanceAttributeSampler_hi_res_ch2_input(self._context)
        self.sampler_hi_res_ch5_input = RootLuData_acquisitionInstanceAttributeSampler_hi_res_ch5_input(self._context)
        self.capture_hi_res_datapoints = RootLuData_acquisitionInstanceAttributeCapture_hi_res_datapoints(self._context)
        self.sampler_hi_res_ch7_input = RootLuData_acquisitionInstanceAttributeSampler_hi_res_ch7_input(self._context)
        self.capture_hi_res_ch0_input = RootLuData_acquisitionInstanceAttributeCapture_hi_res_ch0_input(self._context)
        self.sampler_hi_res_ch1_input = RootLuData_acquisitionInstanceAttributeSampler_hi_res_ch1_input(self._context)
        self.active_capture_set = RootLuData_acquisitionInstanceAttributeActive_capture_set(self._context)
        self.sampler_filter_size = RootLuData_acquisitionInstanceAttributeSampler_filter_size(self._context)
        self.sampler_filter_cutoff = RootLuData_acquisitionInstanceAttributeSampler_filter_cutoff(self._context)
        self.sampler_auto_set_filter_mode = RootLuData_acquisitionInstanceAttributeSampler_auto_set_filter_mode(self._context)
        self.capture_hi_res_ch3_input = RootLuData_acquisitionInstanceAttributeCapture_hi_res_ch3_input(self._context)
        self.number_of_capture_sets = RootLuData_acquisitionInstanceAttributeNumber_of_capture_sets(self._context)
        self.capture_hi_res_ch5_input = RootLuData_acquisitionInstanceAttributeCapture_hi_res_ch5_input(self._context)
        self.number_of_sampler_sets = RootLuData_acquisitionInstanceAttributeNumber_of_sampler_sets(self._context)
        self.capture_hi_res_channel_mask = RootLuData_acquisitionInstanceAttributeCapture_hi_res_channel_mask(self._context)
        self.capture_fast_group_id = RootLuData_acquisitionInstanceAttributeCapture_fast_group_id(self._context)
        self.capture_hi_res_ch2_input = RootLuData_acquisitionInstanceAttributeCapture_hi_res_ch2_input(self._context)


class RootLuData_acquisitionInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition.instance'
        self.attribute = RootLuData_acquisitionInstanceAttribute(self._context)
        self.trigger = RootLuData_acquisitionInstanceTrigger(self._context)
        self.busy = RootLuData_acquisitionInstanceBusy(self._context)


class RootLuData_acquisition(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.data_acquisition'
        self.instance = RootLuData_acquisitionInstance(self._context)


class RootLuLithoInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.litho.instance.trigger'

    def move_to_abs_xy_pos(self) -> None:
        return self._context.call('root.lu.litho.instance.trigger.move_to_abs_xy_pos')

    def first_cmd_item(self) -> None:
        return self._context.call('root.lu.litho.instance.trigger.first_cmd_item')

    def user_abort(self) -> None:
        return self._context.call('root.lu.litho.instance.trigger.user_abort')

    def move_to_z(self) -> None:
        return self._context.call('root.lu.litho.instance.trigger.move_to_z')

    def end_sequence(self) -> None:
        return self._context.call('root.lu.litho.instance.trigger.end_sequence')

    def next_cmd_item(self) -> None:
        return self._context.call('root.lu.litho.instance.trigger.next_cmd_item')

    def start_sequence(self) -> None:
        return self._context.call('root.lu.litho.instance.trigger.start_sequence')

    def make_pause(self) -> None:
        return self._context.call('root.lu.litho.instance.trigger.make_pause')


class RootLuLithoInstanceAttributeMove_z_pos(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.litho.instance.attribute.move_z_pos'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.move_z_pos.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.move_z_pos.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.litho.instance.attribute.move_z_pos.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.litho.instance.attribute.move_z_pos.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.move_z_pos.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.move_z_pos.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.move_z_pos.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.move_z_pos.min', float(new_val))


class RootLuLithoInstanceAttributeAbsolute_x_pos(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.litho.instance.attribute.absolute_x_pos'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.absolute_x_pos.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.absolute_x_pos.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.litho.instance.attribute.absolute_x_pos.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.litho.instance.attribute.absolute_x_pos.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.absolute_x_pos.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.absolute_x_pos.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.absolute_x_pos.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.absolute_x_pos.min', float(new_val))


class RootLuLithoInstanceAttributeZ_move_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.litho.instance.attribute.z_move_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.z_move_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.z_move_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.litho.instance.attribute.z_move_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.litho.instance.attribute.z_move_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.z_move_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.z_move_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.z_move_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.z_move_speed.min', float(new_val))


class RootLuLithoInstanceAttributePause_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.litho.instance.attribute.pause_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.pause_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.pause_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.litho.instance.attribute.pause_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.litho.instance.attribute.pause_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.pause_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.pause_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.pause_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.pause_time.min', float(new_val))


class RootLuLithoInstanceAttributeAbsolute_y_pos(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.litho.instance.attribute.absolute_y_pos'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.absolute_y_pos.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.absolute_y_pos.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.litho.instance.attribute.absolute_y_pos.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.litho.instance.attribute.absolute_y_pos.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.absolute_y_pos.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.absolute_y_pos.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.absolute_y_pos.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.absolute_y_pos.min', float(new_val))


class RootLuLithoInstanceAttributeMod_rel_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.litho.instance.attribute.mod_rel_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.mod_rel_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.mod_rel_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.litho.instance.attribute.mod_rel_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.litho.instance.attribute.mod_rel_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.mod_rel_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.mod_rel_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.mod_rel_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.mod_rel_value.min', float(new_val))


class RootLuLithoInstanceAttributeXy_move_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.litho.instance.attribute.xy_move_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.xy_move_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.xy_move_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.litho.instance.attribute.xy_move_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.litho.instance.attribute.xy_move_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.xy_move_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.xy_move_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.litho.instance.attribute.xy_move_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.litho.instance.attribute.xy_move_speed.min', float(new_val))


class RootLuLithoInstanceAttributeOp_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        stm = 1
        user = 0
        static_afm = 2
        z_modulation = 4
        dynamic_afm = 3

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.litho.instance.attribute.op_mode'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.litho.instance.attribute.op_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.litho.instance.attribute.op_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.litho.instance.attribute.op_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.litho.instance.attribute.op_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.litho.instance.attribute.op_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.litho.instance.attribute.op_mode.value_raw', new_val.value)


class RootLuLithoInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.litho.instance.attribute'
        self.op_mode = RootLuLithoInstanceAttributeOp_mode(self._context)
        self.xy_move_speed = RootLuLithoInstanceAttributeXy_move_speed(self._context)
        self.mod_rel_value = RootLuLithoInstanceAttributeMod_rel_value(self._context)
        self.absolute_y_pos = RootLuLithoInstanceAttributeAbsolute_y_pos(self._context)
        self.pause_time = RootLuLithoInstanceAttributePause_time(self._context)
        self.z_move_speed = RootLuLithoInstanceAttributeZ_move_speed(self._context)
        self.absolute_x_pos = RootLuLithoInstanceAttributeAbsolute_x_pos(self._context)
        self.move_z_pos = RootLuLithoInstanceAttributeMove_z_pos(self._context)


class RootLuLithoInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.litho.instance'
        self.attribute = RootLuLithoInstanceAttribute(self._context)
        self.trigger = RootLuLithoInstanceTrigger(self._context)


class RootLuLitho(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.litho'
        self.instance = RootLuLithoInstance(self._context)


class RootLuCantilever_propertiesInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.cantilever_properties.instance.trigger'


class RootLuCantilever_propertiesInstanceAttributeAlign_strategy(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        search_for_reflecting_edges = 1
        standard = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.cantilever_properties.instance.attribute.align_strategy'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.cantilever_properties.instance.attribute.align_strategy.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.cantilever_properties.instance.attribute.align_strategy.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.cantilever_properties.instance.attribute.align_strategy.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.cantilever_properties.instance.attribute.align_strategy.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.cantilever_properties.instance.attribute.align_strategy.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.cantilever_properties.instance.attribute.align_strategy.value_raw', new_val.value)


class RootLuCantilever_propertiesInstanceAttributeDeflection_sensitivity(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.cantilever_properties.instance.attribute.deflection_sensitivity'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.deflection_sensitivity.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.deflection_sensitivity.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.cantilever_properties.instance.attribute.deflection_sensitivity.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.cantilever_properties.instance.attribute.deflection_sensitivity.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.deflection_sensitivity.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.deflection_sensitivity.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.deflection_sensitivity.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.deflection_sensitivity.min', float(new_val))


class RootLuCantilever_propertiesInstanceAttributeResonance_frequency(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.cantilever_properties.instance.attribute.resonance_frequency'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.resonance_frequency.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.resonance_frequency.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.cantilever_properties.instance.attribute.resonance_frequency.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.cantilever_properties.instance.attribute.resonance_frequency.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.resonance_frequency.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.resonance_frequency.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.resonance_frequency.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.resonance_frequency.min', float(new_val))


class RootLuCantilever_propertiesInstanceAttributeShape(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        rectangular = 0
        triangular = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.cantilever_properties.instance.attribute.shape'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.cantilever_properties.instance.attribute.shape.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.cantilever_properties.instance.attribute.shape.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.cantilever_properties.instance.attribute.shape.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.cantilever_properties.instance.attribute.shape.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.cantilever_properties.instance.attribute.shape.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.cantilever_properties.instance.attribute.shape.value_raw', new_val.value)


class RootLuCantilever_propertiesInstanceAttributeTip_half_angle(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.cantilever_properties.instance.attribute.tip_half_angle'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.tip_half_angle.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.tip_half_angle.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.cantilever_properties.instance.attribute.tip_half_angle.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.cantilever_properties.instance.attribute.tip_half_angle.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.tip_half_angle.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.tip_half_angle.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.tip_half_angle.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.tip_half_angle.min', float(new_val))


class RootLuCantilever_propertiesInstanceAttributeQ_factor(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.cantilever_properties.instance.attribute.q_factor'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.q_factor.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.q_factor.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.cantilever_properties.instance.attribute.q_factor.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.cantilever_properties.instance.attribute.q_factor.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.q_factor.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.q_factor.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.q_factor.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.q_factor.min', float(new_val))


class RootLuCantilever_propertiesInstanceAttributeTip_radius(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.cantilever_properties.instance.attribute.tip_radius'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.tip_radius.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.tip_radius.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.cantilever_properties.instance.attribute.tip_radius.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.cantilever_properties.instance.attribute.tip_radius.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.tip_radius.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.tip_radius.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.tip_radius.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.tip_radius.min', float(new_val))


class RootLuCantilever_propertiesInstanceAttributeLength(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.cantilever_properties.instance.attribute.length'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.length.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.length.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.cantilever_properties.instance.attribute.length.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.cantilever_properties.instance.attribute.length.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.length.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.length.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.length.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.length.min', float(new_val))


class RootLuCantilever_propertiesInstanceAttributeWidth(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.cantilever_properties.instance.attribute.width'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.width.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.width.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.cantilever_properties.instance.attribute.width.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.cantilever_properties.instance.attribute.width.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.width.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.width.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.width.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.width.min', float(new_val))


class RootLuCantilever_propertiesInstanceAttributeSpring_constant(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.cantilever_properties.instance.attribute.spring_constant'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.spring_constant.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.spring_constant.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.cantilever_properties.instance.attribute.spring_constant.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.cantilever_properties.instance.attribute.spring_constant.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.spring_constant.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.spring_constant.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.cantilever_properties.instance.attribute.spring_constant.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.cantilever_properties.instance.attribute.spring_constant.min', float(new_val))


class RootLuCantilever_propertiesInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.cantilever_properties.instance.attribute'
        self.spring_constant = RootLuCantilever_propertiesInstanceAttributeSpring_constant(self._context)
        self.width = RootLuCantilever_propertiesInstanceAttributeWidth(self._context)
        self.length = RootLuCantilever_propertiesInstanceAttributeLength(self._context)
        self.tip_radius = RootLuCantilever_propertiesInstanceAttributeTip_radius(self._context)
        self.q_factor = RootLuCantilever_propertiesInstanceAttributeQ_factor(self._context)
        self.tip_half_angle = RootLuCantilever_propertiesInstanceAttributeTip_half_angle(self._context)
        self.shape = RootLuCantilever_propertiesInstanceAttributeShape(self._context)
        self.resonance_frequency = RootLuCantilever_propertiesInstanceAttributeResonance_frequency(self._context)
        self.deflection_sensitivity = RootLuCantilever_propertiesInstanceAttributeDeflection_sensitivity(self._context)
        self.align_strategy = RootLuCantilever_propertiesInstanceAttributeAlign_strategy(self._context)


class RootLuCantilever_propertiesInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.cantilever_properties.instance'
        self.attribute = RootLuCantilever_propertiesInstanceAttribute(self._context)
        self.trigger = RootLuCantilever_propertiesInstanceTrigger(self._context)


class RootLuCantilever_properties(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.cantilever_properties'
        self.instance = RootLuCantilever_propertiesInstance(self._context)


class RootLuAnalog_hi_res_outPosition_xTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.trigger'


class RootLuAnalog_hi_res_outPosition_xAttributeGlitch_corr_binary_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.attribute.glitch_corr_binary_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.glitch_corr_binary_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.glitch_corr_binary_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.glitch_corr_binary_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.glitch_corr_binary_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.position_x.attribute.glitch_corr_binary_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.position_x.attribute.glitch_corr_binary_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.glitch_corr_binary_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.glitch_corr_binary_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.glitch_corr_binary_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.glitch_corr_binary_vec.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_xAttributeCalib_sig_source_dir(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        from_input_to_output = 1
        from_output_to_input = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.attribute.calib_sig_source_dir'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_sig_source_dir.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_sig_source_dir.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_sig_source_dir.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_sig_source_dir.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_sig_source_dir.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_sig_source_dir.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_xAttributeOutput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.attribute.output_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.output_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.output_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.output_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.output_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.output_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.output_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.output_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.output_gain.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_xAttributeModulation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 2
        disabled = 1
        enabled = 0
        analyzer2_reference = 0
        ort_excitation = 3
        hi_res_signal = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.attribute.modulation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.modulation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.modulation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.modulation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.modulation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.modulation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.modulation.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_xAttributeModulation_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.attribute.modulation_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.modulation_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.modulation_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.modulation_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.modulation_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.modulation_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.modulation_input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_xAttributeGlitch_corr_enabled(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.attribute.glitch_corr_enabled'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.glitch_corr_enabled.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.glitch_corr_enabled.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.glitch_corr_enabled.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.glitch_corr_enabled.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.glitch_corr_enabled.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.glitch_corr_enabled.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_xAttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_xAttributeSlew_rate(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.attribute.slew_rate'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.slew_rate.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.slew_rate.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.slew_rate.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.slew_rate.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.slew_rate.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.slew_rate.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.slew_rate.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.slew_rate.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_xAttributeStatic_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.attribute.static_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.static_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.static_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.static_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.static_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.static_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.static_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.static_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.static_value.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_xAttributeCalib_lo_word_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.attribute.calib_lo_word_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_lo_word_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_lo_word_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_lo_word_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_lo_word_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_lo_word_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_lo_word_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_lo_word_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_lo_word_gain.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_xAttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.position_x.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.position_x.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_xAttributeInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.attribute.input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_xAttributeCalib_lo_word_delay(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.attribute.calib_lo_word_delay'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_lo_word_delay.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_lo_word_delay.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_lo_word_delay.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_lo_word_delay.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_lo_word_delay.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_lo_word_delay.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_lo_word_delay.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_lo_word_delay.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_xAttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_xAttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_xAttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_xAttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_x.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_x.attribute.current_output_value.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_xAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x.attribute'
        self.current_output_value = RootLuAnalog_hi_res_outPosition_xAttributeCurrent_output_value(self._context)
        self.calib_offset = RootLuAnalog_hi_res_outPosition_xAttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_outPosition_xAttributeFilter_number(self._context)
        self.calib_gain = RootLuAnalog_hi_res_outPosition_xAttributeCalib_gain(self._context)
        self.calib_lo_word_delay = RootLuAnalog_hi_res_outPosition_xAttributeCalib_lo_word_delay(self._context)
        self.input = RootLuAnalog_hi_res_outPosition_xAttributeInput(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_outPosition_xAttributeFilter_coeff_vec(self._context)
        self.calib_lo_word_gain = RootLuAnalog_hi_res_outPosition_xAttributeCalib_lo_word_gain(self._context)
        self.static_value = RootLuAnalog_hi_res_outPosition_xAttributeStatic_value(self._context)
        self.slew_rate = RootLuAnalog_hi_res_outPosition_xAttributeSlew_rate(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_outPosition_xAttributeCalib_polarity(self._context)
        self.glitch_corr_enabled = RootLuAnalog_hi_res_outPosition_xAttributeGlitch_corr_enabled(self._context)
        self.modulation_input = RootLuAnalog_hi_res_outPosition_xAttributeModulation_input(self._context)
        self.modulation = RootLuAnalog_hi_res_outPosition_xAttributeModulation(self._context)
        self.output_gain = RootLuAnalog_hi_res_outPosition_xAttributeOutput_gain(self._context)
        self.calib_sig_source_dir = RootLuAnalog_hi_res_outPosition_xAttributeCalib_sig_source_dir(self._context)
        self.glitch_corr_binary_vec = RootLuAnalog_hi_res_outPosition_xAttributeGlitch_corr_binary_vec(self._context)


class RootLuAnalog_hi_res_outPosition_x(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_x'
        self.attribute = RootLuAnalog_hi_res_outPosition_xAttribute(self._context)
        self.trigger = RootLuAnalog_hi_res_outPosition_xTrigger(self._context)


class RootLuAnalog_hi_res_outPosition_wTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.trigger'


class RootLuAnalog_hi_res_outPosition_wAttributeGlitch_corr_binary_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.attribute.glitch_corr_binary_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.glitch_corr_binary_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.glitch_corr_binary_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.glitch_corr_binary_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.glitch_corr_binary_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.position_w.attribute.glitch_corr_binary_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.position_w.attribute.glitch_corr_binary_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.glitch_corr_binary_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.glitch_corr_binary_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.glitch_corr_binary_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.glitch_corr_binary_vec.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_wAttributeCalib_sig_source_dir(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        from_input_to_output = 1
        from_output_to_input = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.attribute.calib_sig_source_dir'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_sig_source_dir.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_sig_source_dir.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_sig_source_dir.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_sig_source_dir.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_sig_source_dir.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_sig_source_dir.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_wAttributeOutput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.attribute.output_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.output_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.output_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.output_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.output_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.output_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.output_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.output_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.output_gain.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_wAttributeModulation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 2
        disabled = 1
        enabled = 0
        analyzer2_reference = 0
        ort_excitation = 3
        hi_res_signal = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.attribute.modulation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.modulation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.modulation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.modulation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.modulation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.modulation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.modulation.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_wAttributeModulation_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.attribute.modulation_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.modulation_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.modulation_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.modulation_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.modulation_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.modulation_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.modulation_input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_wAttributeGlitch_corr_enabled(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.attribute.glitch_corr_enabled'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.glitch_corr_enabled.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.glitch_corr_enabled.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.glitch_corr_enabled.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.glitch_corr_enabled.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.glitch_corr_enabled.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.glitch_corr_enabled.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_wAttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_wAttributeSlew_rate(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.attribute.slew_rate'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.slew_rate.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.slew_rate.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.slew_rate.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.slew_rate.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.slew_rate.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.slew_rate.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.slew_rate.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.slew_rate.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_wAttributeStatic_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.attribute.static_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.static_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.static_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.static_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.static_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.static_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.static_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.static_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.static_value.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_wAttributeCalib_lo_word_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.attribute.calib_lo_word_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_lo_word_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_lo_word_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_lo_word_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_lo_word_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_lo_word_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_lo_word_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_lo_word_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_lo_word_gain.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_wAttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.position_w.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.position_w.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_wAttributeInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.attribute.input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_wAttributeCalib_lo_word_delay(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.attribute.calib_lo_word_delay'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_lo_word_delay.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_lo_word_delay.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_lo_word_delay.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_lo_word_delay.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_lo_word_delay.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_lo_word_delay.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_lo_word_delay.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_lo_word_delay.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_wAttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_wAttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_wAttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_wAttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_w.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_w.attribute.current_output_value.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_wAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w.attribute'
        self.current_output_value = RootLuAnalog_hi_res_outPosition_wAttributeCurrent_output_value(self._context)
        self.calib_offset = RootLuAnalog_hi_res_outPosition_wAttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_outPosition_wAttributeFilter_number(self._context)
        self.calib_gain = RootLuAnalog_hi_res_outPosition_wAttributeCalib_gain(self._context)
        self.calib_lo_word_delay = RootLuAnalog_hi_res_outPosition_wAttributeCalib_lo_word_delay(self._context)
        self.input = RootLuAnalog_hi_res_outPosition_wAttributeInput(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_outPosition_wAttributeFilter_coeff_vec(self._context)
        self.calib_lo_word_gain = RootLuAnalog_hi_res_outPosition_wAttributeCalib_lo_word_gain(self._context)
        self.static_value = RootLuAnalog_hi_res_outPosition_wAttributeStatic_value(self._context)
        self.slew_rate = RootLuAnalog_hi_res_outPosition_wAttributeSlew_rate(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_outPosition_wAttributeCalib_polarity(self._context)
        self.glitch_corr_enabled = RootLuAnalog_hi_res_outPosition_wAttributeGlitch_corr_enabled(self._context)
        self.modulation_input = RootLuAnalog_hi_res_outPosition_wAttributeModulation_input(self._context)
        self.modulation = RootLuAnalog_hi_res_outPosition_wAttributeModulation(self._context)
        self.output_gain = RootLuAnalog_hi_res_outPosition_wAttributeOutput_gain(self._context)
        self.calib_sig_source_dir = RootLuAnalog_hi_res_outPosition_wAttributeCalib_sig_source_dir(self._context)
        self.glitch_corr_binary_vec = RootLuAnalog_hi_res_outPosition_wAttributeGlitch_corr_binary_vec(self._context)


class RootLuAnalog_hi_res_outPosition_w(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_w'
        self.attribute = RootLuAnalog_hi_res_outPosition_wAttribute(self._context)
        self.trigger = RootLuAnalog_hi_res_outPosition_wTrigger(self._context)


class RootLuAnalog_hi_res_outOut8Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.trigger'


class RootLuAnalog_hi_res_outOut8AttributeGlitch_corr_binary_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.attribute.glitch_corr_binary_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out8.attribute.glitch_corr_binary_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.glitch_corr_binary_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.out8.attribute.glitch_corr_binary_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.glitch_corr_binary_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.out8.attribute.glitch_corr_binary_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.out8.attribute.glitch_corr_binary_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.glitch_corr_binary_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.glitch_corr_binary_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.glitch_corr_binary_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.glitch_corr_binary_vec.min', float(new_val))


class RootLuAnalog_hi_res_outOut8AttributeCalib_sig_source_dir(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        from_input_to_output = 1
        from_output_to_input = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.attribute.calib_sig_source_dir'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_sig_source_dir.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_sig_source_dir.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_sig_source_dir.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_sig_source_dir.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_sig_source_dir.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_sig_source_dir.value_raw', new_val.value)


class RootLuAnalog_hi_res_outOut8AttributeOutput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.attribute.output_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.output_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.output_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out8.attribute.output_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.output_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.output_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.output_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.output_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.output_gain.min', float(new_val))


class RootLuAnalog_hi_res_outOut8AttributeModulation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 2
        disabled = 1
        enabled = 0
        analyzer2_reference = 0
        ort_excitation = 3
        hi_res_signal = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.attribute.modulation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.out8.attribute.modulation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.modulation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.out8.attribute.modulation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.modulation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.out8.attribute.modulation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.modulation.value_raw', new_val.value)


class RootLuAnalog_hi_res_outOut8AttributeModulation_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.attribute.modulation_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.out8.attribute.modulation_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.modulation_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.out8.attribute.modulation_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.modulation_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.out8.attribute.modulation_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.modulation_input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outOut8AttributeGlitch_corr_enabled(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.attribute.glitch_corr_enabled'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.out8.attribute.glitch_corr_enabled.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.glitch_corr_enabled.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.out8.attribute.glitch_corr_enabled.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.glitch_corr_enabled.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.out8.attribute.glitch_corr_enabled.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.glitch_corr_enabled.value_raw', new_val.value)


class RootLuAnalog_hi_res_outOut8AttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_outOut8AttributeSlew_rate(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.attribute.slew_rate'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.slew_rate.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.slew_rate.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out8.attribute.slew_rate.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.slew_rate.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.slew_rate.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.slew_rate.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.slew_rate.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.slew_rate.min', float(new_val))


class RootLuAnalog_hi_res_outOut8AttributeStatic_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.attribute.static_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.static_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.static_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out8.attribute.static_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.static_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.static_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.static_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.static_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.static_value.min', float(new_val))


class RootLuAnalog_hi_res_outOut8AttributeCalib_lo_word_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.attribute.calib_lo_word_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_lo_word_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_lo_word_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_lo_word_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_lo_word_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_lo_word_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_lo_word_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_lo_word_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_lo_word_gain.min', float(new_val))


class RootLuAnalog_hi_res_outOut8AttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out8.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.out8.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.out8.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.out8.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_outOut8AttributeInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.attribute.input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.out8.attribute.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.out8.attribute.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.out8.attribute.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outOut8AttributeCalib_lo_word_delay(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.attribute.calib_lo_word_delay'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_lo_word_delay.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_lo_word_delay.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_lo_word_delay.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_lo_word_delay.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_lo_word_delay.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_lo_word_delay.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_lo_word_delay.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_lo_word_delay.min', float(new_val))


class RootLuAnalog_hi_res_outOut8AttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_outOut8AttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out8.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_outOut8AttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_outOut8AttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out8.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out8.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out8.attribute.current_output_value.min', float(new_val))


class RootLuAnalog_hi_res_outOut8Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8.attribute'
        self.current_output_value = RootLuAnalog_hi_res_outOut8AttributeCurrent_output_value(self._context)
        self.calib_offset = RootLuAnalog_hi_res_outOut8AttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_outOut8AttributeFilter_number(self._context)
        self.calib_gain = RootLuAnalog_hi_res_outOut8AttributeCalib_gain(self._context)
        self.calib_lo_word_delay = RootLuAnalog_hi_res_outOut8AttributeCalib_lo_word_delay(self._context)
        self.input = RootLuAnalog_hi_res_outOut8AttributeInput(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_outOut8AttributeFilter_coeff_vec(self._context)
        self.calib_lo_word_gain = RootLuAnalog_hi_res_outOut8AttributeCalib_lo_word_gain(self._context)
        self.static_value = RootLuAnalog_hi_res_outOut8AttributeStatic_value(self._context)
        self.slew_rate = RootLuAnalog_hi_res_outOut8AttributeSlew_rate(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_outOut8AttributeCalib_polarity(self._context)
        self.glitch_corr_enabled = RootLuAnalog_hi_res_outOut8AttributeGlitch_corr_enabled(self._context)
        self.modulation_input = RootLuAnalog_hi_res_outOut8AttributeModulation_input(self._context)
        self.modulation = RootLuAnalog_hi_res_outOut8AttributeModulation(self._context)
        self.output_gain = RootLuAnalog_hi_res_outOut8AttributeOutput_gain(self._context)
        self.calib_sig_source_dir = RootLuAnalog_hi_res_outOut8AttributeCalib_sig_source_dir(self._context)
        self.glitch_corr_binary_vec = RootLuAnalog_hi_res_outOut8AttributeGlitch_corr_binary_vec(self._context)


class RootLuAnalog_hi_res_outOut8(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out8'
        self.attribute = RootLuAnalog_hi_res_outOut8Attribute(self._context)
        self.trigger = RootLuAnalog_hi_res_outOut8Trigger(self._context)


class RootLuAnalog_hi_res_outPosition_yTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.trigger'


class RootLuAnalog_hi_res_outPosition_yAttributeGlitch_corr_binary_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.attribute.glitch_corr_binary_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.glitch_corr_binary_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.glitch_corr_binary_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.glitch_corr_binary_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.glitch_corr_binary_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.position_y.attribute.glitch_corr_binary_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.position_y.attribute.glitch_corr_binary_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.glitch_corr_binary_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.glitch_corr_binary_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.glitch_corr_binary_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.glitch_corr_binary_vec.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_yAttributeCalib_sig_source_dir(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        from_input_to_output = 1
        from_output_to_input = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.attribute.calib_sig_source_dir'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_sig_source_dir.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_sig_source_dir.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_sig_source_dir.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_sig_source_dir.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_sig_source_dir.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_sig_source_dir.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_yAttributeOutput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.attribute.output_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.output_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.output_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.output_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.output_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.output_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.output_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.output_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.output_gain.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_yAttributeModulation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 2
        disabled = 1
        enabled = 0
        analyzer2_reference = 0
        ort_excitation = 3
        hi_res_signal = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.attribute.modulation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.modulation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.modulation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.modulation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.modulation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.modulation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.modulation.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_yAttributeModulation_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.attribute.modulation_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.modulation_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.modulation_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.modulation_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.modulation_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.modulation_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.modulation_input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_yAttributeGlitch_corr_enabled(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.attribute.glitch_corr_enabled'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.glitch_corr_enabled.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.glitch_corr_enabled.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.glitch_corr_enabled.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.glitch_corr_enabled.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.glitch_corr_enabled.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.glitch_corr_enabled.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_yAttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_yAttributeSlew_rate(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.attribute.slew_rate'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.slew_rate.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.slew_rate.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.slew_rate.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.slew_rate.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.slew_rate.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.slew_rate.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.slew_rate.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.slew_rate.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_yAttributeStatic_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.attribute.static_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.static_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.static_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.static_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.static_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.static_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.static_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.static_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.static_value.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_yAttributeCalib_lo_word_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.attribute.calib_lo_word_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_lo_word_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_lo_word_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_lo_word_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_lo_word_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_lo_word_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_lo_word_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_lo_word_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_lo_word_gain.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_yAttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.position_y.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.position_y.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_yAttributeInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.attribute.input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_yAttributeCalib_lo_word_delay(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.attribute.calib_lo_word_delay'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_lo_word_delay.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_lo_word_delay.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_lo_word_delay.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_lo_word_delay.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_lo_word_delay.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_lo_word_delay.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_lo_word_delay.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_lo_word_delay.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_yAttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_yAttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_yAttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_yAttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_y.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_y.attribute.current_output_value.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_yAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y.attribute'
        self.current_output_value = RootLuAnalog_hi_res_outPosition_yAttributeCurrent_output_value(self._context)
        self.calib_offset = RootLuAnalog_hi_res_outPosition_yAttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_outPosition_yAttributeFilter_number(self._context)
        self.calib_gain = RootLuAnalog_hi_res_outPosition_yAttributeCalib_gain(self._context)
        self.calib_lo_word_delay = RootLuAnalog_hi_res_outPosition_yAttributeCalib_lo_word_delay(self._context)
        self.input = RootLuAnalog_hi_res_outPosition_yAttributeInput(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_outPosition_yAttributeFilter_coeff_vec(self._context)
        self.calib_lo_word_gain = RootLuAnalog_hi_res_outPosition_yAttributeCalib_lo_word_gain(self._context)
        self.static_value = RootLuAnalog_hi_res_outPosition_yAttributeStatic_value(self._context)
        self.slew_rate = RootLuAnalog_hi_res_outPosition_yAttributeSlew_rate(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_outPosition_yAttributeCalib_polarity(self._context)
        self.glitch_corr_enabled = RootLuAnalog_hi_res_outPosition_yAttributeGlitch_corr_enabled(self._context)
        self.modulation_input = RootLuAnalog_hi_res_outPosition_yAttributeModulation_input(self._context)
        self.modulation = RootLuAnalog_hi_res_outPosition_yAttributeModulation(self._context)
        self.output_gain = RootLuAnalog_hi_res_outPosition_yAttributeOutput_gain(self._context)
        self.calib_sig_source_dir = RootLuAnalog_hi_res_outPosition_yAttributeCalib_sig_source_dir(self._context)
        self.glitch_corr_binary_vec = RootLuAnalog_hi_res_outPosition_yAttributeGlitch_corr_binary_vec(self._context)


class RootLuAnalog_hi_res_outPosition_y(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_y'
        self.attribute = RootLuAnalog_hi_res_outPosition_yAttribute(self._context)
        self.trigger = RootLuAnalog_hi_res_outPosition_yTrigger(self._context)


class RootLuAnalog_hi_res_outPosition_zTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.trigger'


class RootLuAnalog_hi_res_outPosition_zAttributeGlitch_corr_binary_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.attribute.glitch_corr_binary_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.glitch_corr_binary_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.glitch_corr_binary_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.glitch_corr_binary_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.glitch_corr_binary_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.position_z.attribute.glitch_corr_binary_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.position_z.attribute.glitch_corr_binary_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.glitch_corr_binary_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.glitch_corr_binary_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.glitch_corr_binary_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.glitch_corr_binary_vec.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_zAttributeCalib_sig_source_dir(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        from_input_to_output = 1
        from_output_to_input = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.attribute.calib_sig_source_dir'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_sig_source_dir.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_sig_source_dir.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_sig_source_dir.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_sig_source_dir.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_sig_source_dir.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_sig_source_dir.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_zAttributeOutput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.attribute.output_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.output_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.output_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.output_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.output_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.output_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.output_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.output_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.output_gain.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_zAttributeModulation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 2
        disabled = 1
        enabled = 0
        analyzer2_reference = 0
        ort_excitation = 3
        hi_res_signal = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.attribute.modulation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.modulation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.modulation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.modulation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.modulation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.modulation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.modulation.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_zAttributeModulation_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.attribute.modulation_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.modulation_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.modulation_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.modulation_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.modulation_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.modulation_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.modulation_input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_zAttributeGlitch_corr_enabled(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.attribute.glitch_corr_enabled'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.glitch_corr_enabled.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.glitch_corr_enabled.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.glitch_corr_enabled.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.glitch_corr_enabled.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.glitch_corr_enabled.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.glitch_corr_enabled.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_zAttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_zAttributeSlew_rate(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.attribute.slew_rate'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.slew_rate.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.slew_rate.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.slew_rate.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.slew_rate.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.slew_rate.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.slew_rate.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.slew_rate.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.slew_rate.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_zAttributeStatic_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.attribute.static_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.static_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.static_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.static_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.static_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.static_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.static_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.static_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.static_value.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_zAttributeCalib_lo_word_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.attribute.calib_lo_word_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_lo_word_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_lo_word_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_lo_word_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_lo_word_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_lo_word_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_lo_word_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_lo_word_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_lo_word_gain.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_zAttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.position_z.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.position_z.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_zAttributeInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.attribute.input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outPosition_zAttributeCalib_lo_word_delay(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.attribute.calib_lo_word_delay'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_lo_word_delay.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_lo_word_delay.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_lo_word_delay.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_lo_word_delay.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_lo_word_delay.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_lo_word_delay.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_lo_word_delay.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_lo_word_delay.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_zAttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_zAttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_zAttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_zAttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.position_z.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.position_z.attribute.current_output_value.min', float(new_val))


class RootLuAnalog_hi_res_outPosition_zAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z.attribute'
        self.current_output_value = RootLuAnalog_hi_res_outPosition_zAttributeCurrent_output_value(self._context)
        self.calib_offset = RootLuAnalog_hi_res_outPosition_zAttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_outPosition_zAttributeFilter_number(self._context)
        self.calib_gain = RootLuAnalog_hi_res_outPosition_zAttributeCalib_gain(self._context)
        self.calib_lo_word_delay = RootLuAnalog_hi_res_outPosition_zAttributeCalib_lo_word_delay(self._context)
        self.input = RootLuAnalog_hi_res_outPosition_zAttributeInput(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_outPosition_zAttributeFilter_coeff_vec(self._context)
        self.calib_lo_word_gain = RootLuAnalog_hi_res_outPosition_zAttributeCalib_lo_word_gain(self._context)
        self.static_value = RootLuAnalog_hi_res_outPosition_zAttributeStatic_value(self._context)
        self.slew_rate = RootLuAnalog_hi_res_outPosition_zAttributeSlew_rate(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_outPosition_zAttributeCalib_polarity(self._context)
        self.glitch_corr_enabled = RootLuAnalog_hi_res_outPosition_zAttributeGlitch_corr_enabled(self._context)
        self.modulation_input = RootLuAnalog_hi_res_outPosition_zAttributeModulation_input(self._context)
        self.modulation = RootLuAnalog_hi_res_outPosition_zAttributeModulation(self._context)
        self.output_gain = RootLuAnalog_hi_res_outPosition_zAttributeOutput_gain(self._context)
        self.calib_sig_source_dir = RootLuAnalog_hi_res_outPosition_zAttributeCalib_sig_source_dir(self._context)
        self.glitch_corr_binary_vec = RootLuAnalog_hi_res_outPosition_zAttributeGlitch_corr_binary_vec(self._context)


class RootLuAnalog_hi_res_outPosition_z(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.position_z'
        self.attribute = RootLuAnalog_hi_res_outPosition_zAttribute(self._context)
        self.trigger = RootLuAnalog_hi_res_outPosition_zTrigger(self._context)


class RootLuAnalog_hi_res_outUser4Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.trigger'


class RootLuAnalog_hi_res_outUser4AttributeGlitch_corr_binary_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.attribute.glitch_corr_binary_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user4.attribute.glitch_corr_binary_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.glitch_corr_binary_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user4.attribute.glitch_corr_binary_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.glitch_corr_binary_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.user4.attribute.glitch_corr_binary_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.user4.attribute.glitch_corr_binary_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.glitch_corr_binary_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.glitch_corr_binary_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.glitch_corr_binary_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.glitch_corr_binary_vec.min', float(new_val))


class RootLuAnalog_hi_res_outUser4AttributeCalib_sig_source_dir(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        from_input_to_output = 1
        from_output_to_input = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.attribute.calib_sig_source_dir'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_sig_source_dir.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_sig_source_dir.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_sig_source_dir.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_sig_source_dir.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_sig_source_dir.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_sig_source_dir.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser4AttributeOutput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.attribute.output_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.output_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.output_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user4.attribute.output_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.output_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.output_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.output_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.output_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.output_gain.min', float(new_val))


class RootLuAnalog_hi_res_outUser4AttributeModulation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 2
        disabled = 1
        enabled = 0
        analyzer2_reference = 0
        ort_excitation = 3
        hi_res_signal = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.attribute.modulation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user4.attribute.modulation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.modulation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user4.attribute.modulation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.modulation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user4.attribute.modulation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.modulation.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser4AttributeModulation_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.attribute.modulation_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user4.attribute.modulation_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.modulation_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user4.attribute.modulation_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.modulation_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user4.attribute.modulation_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.modulation_input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser4AttributeGlitch_corr_enabled(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.attribute.glitch_corr_enabled'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user4.attribute.glitch_corr_enabled.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.glitch_corr_enabled.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user4.attribute.glitch_corr_enabled.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.glitch_corr_enabled.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user4.attribute.glitch_corr_enabled.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.glitch_corr_enabled.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser4AttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser4AttributeSlew_rate(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.attribute.slew_rate'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.slew_rate.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.slew_rate.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user4.attribute.slew_rate.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.slew_rate.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.slew_rate.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.slew_rate.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.slew_rate.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.slew_rate.min', float(new_val))


class RootLuAnalog_hi_res_outUser4AttributeStatic_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.attribute.static_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.static_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.static_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user4.attribute.static_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.static_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.static_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.static_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.static_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.static_value.min', float(new_val))


class RootLuAnalog_hi_res_outUser4AttributeCalib_lo_word_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.attribute.calib_lo_word_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_lo_word_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_lo_word_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_lo_word_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_lo_word_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_lo_word_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_lo_word_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_lo_word_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_lo_word_gain.min', float(new_val))


class RootLuAnalog_hi_res_outUser4AttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user4.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user4.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.user4.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.user4.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_outUser4AttributeInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.attribute.input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user4.attribute.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user4.attribute.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user4.attribute.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser4AttributeCalib_lo_word_delay(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.attribute.calib_lo_word_delay'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_lo_word_delay.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_lo_word_delay.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_lo_word_delay.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_lo_word_delay.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_lo_word_delay.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_lo_word_delay.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_lo_word_delay.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_lo_word_delay.min', float(new_val))


class RootLuAnalog_hi_res_outUser4AttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_outUser4AttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user4.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_outUser4AttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_outUser4AttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user4.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user4.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user4.attribute.current_output_value.min', float(new_val))


class RootLuAnalog_hi_res_outUser4Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4.attribute'
        self.current_output_value = RootLuAnalog_hi_res_outUser4AttributeCurrent_output_value(self._context)
        self.calib_offset = RootLuAnalog_hi_res_outUser4AttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_outUser4AttributeFilter_number(self._context)
        self.calib_gain = RootLuAnalog_hi_res_outUser4AttributeCalib_gain(self._context)
        self.calib_lo_word_delay = RootLuAnalog_hi_res_outUser4AttributeCalib_lo_word_delay(self._context)
        self.input = RootLuAnalog_hi_res_outUser4AttributeInput(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_outUser4AttributeFilter_coeff_vec(self._context)
        self.calib_lo_word_gain = RootLuAnalog_hi_res_outUser4AttributeCalib_lo_word_gain(self._context)
        self.static_value = RootLuAnalog_hi_res_outUser4AttributeStatic_value(self._context)
        self.slew_rate = RootLuAnalog_hi_res_outUser4AttributeSlew_rate(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_outUser4AttributeCalib_polarity(self._context)
        self.glitch_corr_enabled = RootLuAnalog_hi_res_outUser4AttributeGlitch_corr_enabled(self._context)
        self.modulation_input = RootLuAnalog_hi_res_outUser4AttributeModulation_input(self._context)
        self.modulation = RootLuAnalog_hi_res_outUser4AttributeModulation(self._context)
        self.output_gain = RootLuAnalog_hi_res_outUser4AttributeOutput_gain(self._context)
        self.calib_sig_source_dir = RootLuAnalog_hi_res_outUser4AttributeCalib_sig_source_dir(self._context)
        self.glitch_corr_binary_vec = RootLuAnalog_hi_res_outUser4AttributeGlitch_corr_binary_vec(self._context)


class RootLuAnalog_hi_res_outUser4(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user4'
        self.attribute = RootLuAnalog_hi_res_outUser4Attribute(self._context)
        self.trigger = RootLuAnalog_hi_res_outUser4Trigger(self._context)


class RootLuAnalog_hi_res_outApproachTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.trigger'


class RootLuAnalog_hi_res_outApproachAttributeGlitch_corr_binary_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.attribute.glitch_corr_binary_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.approach.attribute.glitch_corr_binary_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.glitch_corr_binary_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.approach.attribute.glitch_corr_binary_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.glitch_corr_binary_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.approach.attribute.glitch_corr_binary_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.approach.attribute.glitch_corr_binary_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.glitch_corr_binary_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.glitch_corr_binary_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.glitch_corr_binary_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.glitch_corr_binary_vec.min', float(new_val))


class RootLuAnalog_hi_res_outApproachAttributeCalib_sig_source_dir(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        from_input_to_output = 1
        from_output_to_input = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.attribute.calib_sig_source_dir'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_sig_source_dir.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_sig_source_dir.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_sig_source_dir.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_sig_source_dir.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_sig_source_dir.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_sig_source_dir.value_raw', new_val.value)


class RootLuAnalog_hi_res_outApproachAttributeOutput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.attribute.output_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.output_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.output_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.approach.attribute.output_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.output_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.output_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.output_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.output_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.output_gain.min', float(new_val))


class RootLuAnalog_hi_res_outApproachAttributeModulation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 2
        disabled = 1
        enabled = 0
        analyzer2_reference = 0
        ort_excitation = 3
        hi_res_signal = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.attribute.modulation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.approach.attribute.modulation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.modulation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.approach.attribute.modulation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.modulation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.approach.attribute.modulation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.modulation.value_raw', new_val.value)


class RootLuAnalog_hi_res_outApproachAttributeModulation_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.attribute.modulation_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.approach.attribute.modulation_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.modulation_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.approach.attribute.modulation_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.modulation_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.approach.attribute.modulation_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.modulation_input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outApproachAttributeGlitch_corr_enabled(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.attribute.glitch_corr_enabled'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.approach.attribute.glitch_corr_enabled.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.glitch_corr_enabled.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.approach.attribute.glitch_corr_enabled.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.glitch_corr_enabled.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.approach.attribute.glitch_corr_enabled.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.glitch_corr_enabled.value_raw', new_val.value)


class RootLuAnalog_hi_res_outApproachAttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_outApproachAttributeSlew_rate(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.attribute.slew_rate'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.slew_rate.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.slew_rate.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.approach.attribute.slew_rate.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.slew_rate.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.slew_rate.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.slew_rate.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.slew_rate.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.slew_rate.min', float(new_val))


class RootLuAnalog_hi_res_outApproachAttributeStatic_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.attribute.static_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.static_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.static_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.approach.attribute.static_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.static_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.static_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.static_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.static_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.static_value.min', float(new_val))


class RootLuAnalog_hi_res_outApproachAttributeCalib_lo_word_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.attribute.calib_lo_word_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_lo_word_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_lo_word_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_lo_word_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_lo_word_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_lo_word_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_lo_word_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_lo_word_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_lo_word_gain.min', float(new_val))


class RootLuAnalog_hi_res_outApproachAttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.approach.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.approach.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.approach.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.approach.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_outApproachAttributeInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.attribute.input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.approach.attribute.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.approach.attribute.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.approach.attribute.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outApproachAttributeCalib_lo_word_delay(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.attribute.calib_lo_word_delay'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_lo_word_delay.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_lo_word_delay.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_lo_word_delay.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_lo_word_delay.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_lo_word_delay.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_lo_word_delay.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_lo_word_delay.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_lo_word_delay.min', float(new_val))


class RootLuAnalog_hi_res_outApproachAttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_outApproachAttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.approach.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_outApproachAttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_outApproachAttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.approach.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.approach.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.approach.attribute.current_output_value.min', float(new_val))


class RootLuAnalog_hi_res_outApproachAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach.attribute'
        self.current_output_value = RootLuAnalog_hi_res_outApproachAttributeCurrent_output_value(self._context)
        self.calib_offset = RootLuAnalog_hi_res_outApproachAttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_outApproachAttributeFilter_number(self._context)
        self.calib_gain = RootLuAnalog_hi_res_outApproachAttributeCalib_gain(self._context)
        self.calib_lo_word_delay = RootLuAnalog_hi_res_outApproachAttributeCalib_lo_word_delay(self._context)
        self.input = RootLuAnalog_hi_res_outApproachAttributeInput(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_outApproachAttributeFilter_coeff_vec(self._context)
        self.calib_lo_word_gain = RootLuAnalog_hi_res_outApproachAttributeCalib_lo_word_gain(self._context)
        self.static_value = RootLuAnalog_hi_res_outApproachAttributeStatic_value(self._context)
        self.slew_rate = RootLuAnalog_hi_res_outApproachAttributeSlew_rate(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_outApproachAttributeCalib_polarity(self._context)
        self.glitch_corr_enabled = RootLuAnalog_hi_res_outApproachAttributeGlitch_corr_enabled(self._context)
        self.modulation_input = RootLuAnalog_hi_res_outApproachAttributeModulation_input(self._context)
        self.modulation = RootLuAnalog_hi_res_outApproachAttributeModulation(self._context)
        self.output_gain = RootLuAnalog_hi_res_outApproachAttributeOutput_gain(self._context)
        self.calib_sig_source_dir = RootLuAnalog_hi_res_outApproachAttributeCalib_sig_source_dir(self._context)
        self.glitch_corr_binary_vec = RootLuAnalog_hi_res_outApproachAttributeGlitch_corr_binary_vec(self._context)


class RootLuAnalog_hi_res_outApproach(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.approach'
        self.attribute = RootLuAnalog_hi_res_outApproachAttribute(self._context)
        self.trigger = RootLuAnalog_hi_res_outApproachTrigger(self._context)


class RootLuAnalog_hi_res_outUser3Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.trigger'


class RootLuAnalog_hi_res_outUser3AttributeGlitch_corr_binary_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.attribute.glitch_corr_binary_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user3.attribute.glitch_corr_binary_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.glitch_corr_binary_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user3.attribute.glitch_corr_binary_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.glitch_corr_binary_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.user3.attribute.glitch_corr_binary_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.user3.attribute.glitch_corr_binary_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.glitch_corr_binary_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.glitch_corr_binary_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.glitch_corr_binary_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.glitch_corr_binary_vec.min', float(new_val))


class RootLuAnalog_hi_res_outUser3AttributeCalib_sig_source_dir(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        from_input_to_output = 1
        from_output_to_input = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.attribute.calib_sig_source_dir'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_sig_source_dir.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_sig_source_dir.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_sig_source_dir.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_sig_source_dir.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_sig_source_dir.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_sig_source_dir.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser3AttributeOutput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.attribute.output_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.output_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.output_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user3.attribute.output_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.output_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.output_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.output_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.output_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.output_gain.min', float(new_val))


class RootLuAnalog_hi_res_outUser3AttributeModulation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 2
        disabled = 1
        enabled = 0
        analyzer2_reference = 0
        ort_excitation = 3
        hi_res_signal = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.attribute.modulation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user3.attribute.modulation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.modulation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user3.attribute.modulation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.modulation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user3.attribute.modulation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.modulation.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser3AttributeModulation_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.attribute.modulation_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user3.attribute.modulation_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.modulation_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user3.attribute.modulation_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.modulation_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user3.attribute.modulation_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.modulation_input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser3AttributeGlitch_corr_enabled(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.attribute.glitch_corr_enabled'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user3.attribute.glitch_corr_enabled.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.glitch_corr_enabled.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user3.attribute.glitch_corr_enabled.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.glitch_corr_enabled.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user3.attribute.glitch_corr_enabled.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.glitch_corr_enabled.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser3AttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser3AttributeSlew_rate(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.attribute.slew_rate'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.slew_rate.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.slew_rate.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user3.attribute.slew_rate.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.slew_rate.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.slew_rate.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.slew_rate.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.slew_rate.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.slew_rate.min', float(new_val))


class RootLuAnalog_hi_res_outUser3AttributeStatic_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.attribute.static_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.static_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.static_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user3.attribute.static_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.static_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.static_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.static_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.static_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.static_value.min', float(new_val))


class RootLuAnalog_hi_res_outUser3AttributeCalib_lo_word_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.attribute.calib_lo_word_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_lo_word_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_lo_word_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_lo_word_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_lo_word_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_lo_word_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_lo_word_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_lo_word_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_lo_word_gain.min', float(new_val))


class RootLuAnalog_hi_res_outUser3AttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user3.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user3.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.user3.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.user3.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_outUser3AttributeInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.attribute.input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user3.attribute.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user3.attribute.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user3.attribute.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser3AttributeCalib_lo_word_delay(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.attribute.calib_lo_word_delay'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_lo_word_delay.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_lo_word_delay.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_lo_word_delay.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_lo_word_delay.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_lo_word_delay.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_lo_word_delay.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_lo_word_delay.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_lo_word_delay.min', float(new_val))


class RootLuAnalog_hi_res_outUser3AttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_outUser3AttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user3.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_outUser3AttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_outUser3AttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user3.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user3.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user3.attribute.current_output_value.min', float(new_val))


class RootLuAnalog_hi_res_outUser3Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3.attribute'
        self.current_output_value = RootLuAnalog_hi_res_outUser3AttributeCurrent_output_value(self._context)
        self.calib_offset = RootLuAnalog_hi_res_outUser3AttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_outUser3AttributeFilter_number(self._context)
        self.calib_gain = RootLuAnalog_hi_res_outUser3AttributeCalib_gain(self._context)
        self.calib_lo_word_delay = RootLuAnalog_hi_res_outUser3AttributeCalib_lo_word_delay(self._context)
        self.input = RootLuAnalog_hi_res_outUser3AttributeInput(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_outUser3AttributeFilter_coeff_vec(self._context)
        self.calib_lo_word_gain = RootLuAnalog_hi_res_outUser3AttributeCalib_lo_word_gain(self._context)
        self.static_value = RootLuAnalog_hi_res_outUser3AttributeStatic_value(self._context)
        self.slew_rate = RootLuAnalog_hi_res_outUser3AttributeSlew_rate(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_outUser3AttributeCalib_polarity(self._context)
        self.glitch_corr_enabled = RootLuAnalog_hi_res_outUser3AttributeGlitch_corr_enabled(self._context)
        self.modulation_input = RootLuAnalog_hi_res_outUser3AttributeModulation_input(self._context)
        self.modulation = RootLuAnalog_hi_res_outUser3AttributeModulation(self._context)
        self.output_gain = RootLuAnalog_hi_res_outUser3AttributeOutput_gain(self._context)
        self.calib_sig_source_dir = RootLuAnalog_hi_res_outUser3AttributeCalib_sig_source_dir(self._context)
        self.glitch_corr_binary_vec = RootLuAnalog_hi_res_outUser3AttributeGlitch_corr_binary_vec(self._context)


class RootLuAnalog_hi_res_outUser3(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user3'
        self.attribute = RootLuAnalog_hi_res_outUser3Attribute(self._context)
        self.trigger = RootLuAnalog_hi_res_outUser3Trigger(self._context)


class RootLuAnalog_hi_res_outUser2Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.trigger'


class RootLuAnalog_hi_res_outUser2AttributeGlitch_corr_binary_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.attribute.glitch_corr_binary_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user2.attribute.glitch_corr_binary_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.glitch_corr_binary_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user2.attribute.glitch_corr_binary_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.glitch_corr_binary_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.user2.attribute.glitch_corr_binary_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.user2.attribute.glitch_corr_binary_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.glitch_corr_binary_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.glitch_corr_binary_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.glitch_corr_binary_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.glitch_corr_binary_vec.min', float(new_val))


class RootLuAnalog_hi_res_outUser2AttributeCalib_sig_source_dir(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        from_input_to_output = 1
        from_output_to_input = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.attribute.calib_sig_source_dir'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_sig_source_dir.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_sig_source_dir.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_sig_source_dir.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_sig_source_dir.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_sig_source_dir.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_sig_source_dir.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser2AttributeOutput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.attribute.output_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.output_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.output_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user2.attribute.output_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.output_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.output_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.output_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.output_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.output_gain.min', float(new_val))


class RootLuAnalog_hi_res_outUser2AttributeModulation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 2
        disabled = 1
        enabled = 0
        analyzer2_reference = 0
        ort_excitation = 3
        hi_res_signal = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.attribute.modulation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user2.attribute.modulation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.modulation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user2.attribute.modulation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.modulation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user2.attribute.modulation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.modulation.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser2AttributeModulation_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.attribute.modulation_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user2.attribute.modulation_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.modulation_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user2.attribute.modulation_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.modulation_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user2.attribute.modulation_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.modulation_input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser2AttributeGlitch_corr_enabled(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.attribute.glitch_corr_enabled'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user2.attribute.glitch_corr_enabled.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.glitch_corr_enabled.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user2.attribute.glitch_corr_enabled.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.glitch_corr_enabled.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user2.attribute.glitch_corr_enabled.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.glitch_corr_enabled.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser2AttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser2AttributeSlew_rate(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.attribute.slew_rate'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.slew_rate.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.slew_rate.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user2.attribute.slew_rate.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.slew_rate.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.slew_rate.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.slew_rate.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.slew_rate.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.slew_rate.min', float(new_val))


class RootLuAnalog_hi_res_outUser2AttributeStatic_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.attribute.static_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.static_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.static_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user2.attribute.static_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.static_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.static_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.static_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.static_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.static_value.min', float(new_val))


class RootLuAnalog_hi_res_outUser2AttributeCalib_lo_word_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.attribute.calib_lo_word_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_lo_word_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_lo_word_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_lo_word_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_lo_word_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_lo_word_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_lo_word_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_lo_word_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_lo_word_gain.min', float(new_val))


class RootLuAnalog_hi_res_outUser2AttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user2.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user2.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.user2.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.user2.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_outUser2AttributeInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.attribute.input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user2.attribute.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user2.attribute.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user2.attribute.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser2AttributeCalib_lo_word_delay(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.attribute.calib_lo_word_delay'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_lo_word_delay.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_lo_word_delay.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_lo_word_delay.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_lo_word_delay.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_lo_word_delay.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_lo_word_delay.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_lo_word_delay.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_lo_word_delay.min', float(new_val))


class RootLuAnalog_hi_res_outUser2AttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_outUser2AttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user2.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_outUser2AttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_outUser2AttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user2.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user2.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user2.attribute.current_output_value.min', float(new_val))


class RootLuAnalog_hi_res_outUser2Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2.attribute'
        self.current_output_value = RootLuAnalog_hi_res_outUser2AttributeCurrent_output_value(self._context)
        self.calib_offset = RootLuAnalog_hi_res_outUser2AttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_outUser2AttributeFilter_number(self._context)
        self.calib_gain = RootLuAnalog_hi_res_outUser2AttributeCalib_gain(self._context)
        self.calib_lo_word_delay = RootLuAnalog_hi_res_outUser2AttributeCalib_lo_word_delay(self._context)
        self.input = RootLuAnalog_hi_res_outUser2AttributeInput(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_outUser2AttributeFilter_coeff_vec(self._context)
        self.calib_lo_word_gain = RootLuAnalog_hi_res_outUser2AttributeCalib_lo_word_gain(self._context)
        self.static_value = RootLuAnalog_hi_res_outUser2AttributeStatic_value(self._context)
        self.slew_rate = RootLuAnalog_hi_res_outUser2AttributeSlew_rate(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_outUser2AttributeCalib_polarity(self._context)
        self.glitch_corr_enabled = RootLuAnalog_hi_res_outUser2AttributeGlitch_corr_enabled(self._context)
        self.modulation_input = RootLuAnalog_hi_res_outUser2AttributeModulation_input(self._context)
        self.modulation = RootLuAnalog_hi_res_outUser2AttributeModulation(self._context)
        self.output_gain = RootLuAnalog_hi_res_outUser2AttributeOutput_gain(self._context)
        self.calib_sig_source_dir = RootLuAnalog_hi_res_outUser2AttributeCalib_sig_source_dir(self._context)
        self.glitch_corr_binary_vec = RootLuAnalog_hi_res_outUser2AttributeGlitch_corr_binary_vec(self._context)


class RootLuAnalog_hi_res_outUser2(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user2'
        self.attribute = RootLuAnalog_hi_res_outUser2Attribute(self._context)
        self.trigger = RootLuAnalog_hi_res_outUser2Trigger(self._context)


class RootLuAnalog_hi_res_outUser1Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.trigger'


class RootLuAnalog_hi_res_outUser1AttributeGlitch_corr_binary_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.attribute.glitch_corr_binary_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user1.attribute.glitch_corr_binary_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.glitch_corr_binary_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user1.attribute.glitch_corr_binary_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.glitch_corr_binary_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.user1.attribute.glitch_corr_binary_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.user1.attribute.glitch_corr_binary_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.glitch_corr_binary_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.glitch_corr_binary_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.glitch_corr_binary_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.glitch_corr_binary_vec.min', float(new_val))


class RootLuAnalog_hi_res_outUser1AttributeCalib_sig_source_dir(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        from_input_to_output = 1
        from_output_to_input = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.attribute.calib_sig_source_dir'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_sig_source_dir.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_sig_source_dir.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_sig_source_dir.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_sig_source_dir.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_sig_source_dir.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_sig_source_dir.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser1AttributeOutput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.attribute.output_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.output_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.output_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user1.attribute.output_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.output_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.output_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.output_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.output_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.output_gain.min', float(new_val))


class RootLuAnalog_hi_res_outUser1AttributeModulation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 2
        disabled = 1
        enabled = 0
        analyzer2_reference = 0
        ort_excitation = 3
        hi_res_signal = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.attribute.modulation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user1.attribute.modulation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.modulation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user1.attribute.modulation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.modulation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user1.attribute.modulation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.modulation.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser1AttributeModulation_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.attribute.modulation_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user1.attribute.modulation_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.modulation_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user1.attribute.modulation_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.modulation_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user1.attribute.modulation_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.modulation_input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser1AttributeGlitch_corr_enabled(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.attribute.glitch_corr_enabled'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user1.attribute.glitch_corr_enabled.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.glitch_corr_enabled.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user1.attribute.glitch_corr_enabled.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.glitch_corr_enabled.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user1.attribute.glitch_corr_enabled.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.glitch_corr_enabled.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser1AttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser1AttributeSlew_rate(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.attribute.slew_rate'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.slew_rate.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.slew_rate.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user1.attribute.slew_rate.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.slew_rate.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.slew_rate.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.slew_rate.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.slew_rate.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.slew_rate.min', float(new_val))


class RootLuAnalog_hi_res_outUser1AttributeStatic_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.attribute.static_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.static_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.static_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user1.attribute.static_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.static_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.static_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.static_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.static_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.static_value.min', float(new_val))


class RootLuAnalog_hi_res_outUser1AttributeCalib_lo_word_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.attribute.calib_lo_word_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_lo_word_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_lo_word_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_lo_word_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_lo_word_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_lo_word_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_lo_word_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_lo_word_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_lo_word_gain.min', float(new_val))


class RootLuAnalog_hi_res_outUser1AttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user1.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user1.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.user1.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.user1.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_outUser1AttributeInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.attribute.input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.user1.attribute.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.user1.attribute.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.user1.attribute.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outUser1AttributeCalib_lo_word_delay(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.attribute.calib_lo_word_delay'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_lo_word_delay.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_lo_word_delay.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_lo_word_delay.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_lo_word_delay.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_lo_word_delay.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_lo_word_delay.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_lo_word_delay.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_lo_word_delay.min', float(new_val))


class RootLuAnalog_hi_res_outUser1AttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_outUser1AttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user1.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_outUser1AttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_outUser1AttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.user1.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.user1.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.user1.attribute.current_output_value.min', float(new_val))


class RootLuAnalog_hi_res_outUser1Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1.attribute'
        self.current_output_value = RootLuAnalog_hi_res_outUser1AttributeCurrent_output_value(self._context)
        self.calib_offset = RootLuAnalog_hi_res_outUser1AttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_outUser1AttributeFilter_number(self._context)
        self.calib_gain = RootLuAnalog_hi_res_outUser1AttributeCalib_gain(self._context)
        self.calib_lo_word_delay = RootLuAnalog_hi_res_outUser1AttributeCalib_lo_word_delay(self._context)
        self.input = RootLuAnalog_hi_res_outUser1AttributeInput(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_outUser1AttributeFilter_coeff_vec(self._context)
        self.calib_lo_word_gain = RootLuAnalog_hi_res_outUser1AttributeCalib_lo_word_gain(self._context)
        self.static_value = RootLuAnalog_hi_res_outUser1AttributeStatic_value(self._context)
        self.slew_rate = RootLuAnalog_hi_res_outUser1AttributeSlew_rate(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_outUser1AttributeCalib_polarity(self._context)
        self.glitch_corr_enabled = RootLuAnalog_hi_res_outUser1AttributeGlitch_corr_enabled(self._context)
        self.modulation_input = RootLuAnalog_hi_res_outUser1AttributeModulation_input(self._context)
        self.modulation = RootLuAnalog_hi_res_outUser1AttributeModulation(self._context)
        self.output_gain = RootLuAnalog_hi_res_outUser1AttributeOutput_gain(self._context)
        self.calib_sig_source_dir = RootLuAnalog_hi_res_outUser1AttributeCalib_sig_source_dir(self._context)
        self.glitch_corr_binary_vec = RootLuAnalog_hi_res_outUser1AttributeGlitch_corr_binary_vec(self._context)


class RootLuAnalog_hi_res_outUser1(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.user1'
        self.attribute = RootLuAnalog_hi_res_outUser1Attribute(self._context)
        self.trigger = RootLuAnalog_hi_res_outUser1Trigger(self._context)


class RootLuAnalog_hi_res_outTip_voltageTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.trigger'


class RootLuAnalog_hi_res_outTip_voltageAttributeGlitch_corr_binary_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.attribute.glitch_corr_binary_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.glitch_corr_binary_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.glitch_corr_binary_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.glitch_corr_binary_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.glitch_corr_binary_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.tip_voltage.attribute.glitch_corr_binary_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.tip_voltage.attribute.glitch_corr_binary_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.glitch_corr_binary_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.glitch_corr_binary_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.glitch_corr_binary_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.glitch_corr_binary_vec.min', float(new_val))


class RootLuAnalog_hi_res_outTip_voltageAttributeCalib_sig_source_dir(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        from_input_to_output = 1
        from_output_to_input = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.attribute.calib_sig_source_dir'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_sig_source_dir.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_sig_source_dir.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_sig_source_dir.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_sig_source_dir.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_sig_source_dir.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_sig_source_dir.value_raw', new_val.value)


class RootLuAnalog_hi_res_outTip_voltageAttributeOutput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.attribute.output_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.output_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.output_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.output_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.output_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.output_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.output_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.output_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.output_gain.min', float(new_val))


class RootLuAnalog_hi_res_outTip_voltageAttributeModulation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 2
        disabled = 1
        enabled = 0
        analyzer2_reference = 0
        ort_excitation = 3
        hi_res_signal = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.attribute.modulation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.modulation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.modulation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.modulation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.modulation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.modulation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.modulation.value_raw', new_val.value)


class RootLuAnalog_hi_res_outTip_voltageAttributeModulation_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.attribute.modulation_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.modulation_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.modulation_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.modulation_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.modulation_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.modulation_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.modulation_input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outTip_voltageAttributeGlitch_corr_enabled(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.attribute.glitch_corr_enabled'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.glitch_corr_enabled.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.glitch_corr_enabled.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.glitch_corr_enabled.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.glitch_corr_enabled.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.glitch_corr_enabled.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.glitch_corr_enabled.value_raw', new_val.value)


class RootLuAnalog_hi_res_outTip_voltageAttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_outTip_voltageAttributeSlew_rate(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.attribute.slew_rate'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.slew_rate.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.slew_rate.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.slew_rate.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.slew_rate.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.slew_rate.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.slew_rate.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.slew_rate.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.slew_rate.min', float(new_val))


class RootLuAnalog_hi_res_outTip_voltageAttributeStatic_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.attribute.static_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.static_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.static_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.static_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.static_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.static_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.static_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.static_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.static_value.min', float(new_val))


class RootLuAnalog_hi_res_outTip_voltageAttributeCalib_lo_word_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.attribute.calib_lo_word_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_lo_word_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_lo_word_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_lo_word_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_lo_word_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_lo_word_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_lo_word_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_lo_word_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_lo_word_gain.min', float(new_val))


class RootLuAnalog_hi_res_outTip_voltageAttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.tip_voltage.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.tip_voltage.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_outTip_voltageAttributeInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.attribute.input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outTip_voltageAttributeCalib_lo_word_delay(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.attribute.calib_lo_word_delay'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_lo_word_delay.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_lo_word_delay.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_lo_word_delay.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_lo_word_delay.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_lo_word_delay.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_lo_word_delay.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_lo_word_delay.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_lo_word_delay.min', float(new_val))


class RootLuAnalog_hi_res_outTip_voltageAttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_outTip_voltageAttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_outTip_voltageAttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_outTip_voltageAttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.tip_voltage.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.tip_voltage.attribute.current_output_value.min', float(new_val))


class RootLuAnalog_hi_res_outTip_voltageAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage.attribute'
        self.current_output_value = RootLuAnalog_hi_res_outTip_voltageAttributeCurrent_output_value(self._context)
        self.calib_offset = RootLuAnalog_hi_res_outTip_voltageAttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_outTip_voltageAttributeFilter_number(self._context)
        self.calib_gain = RootLuAnalog_hi_res_outTip_voltageAttributeCalib_gain(self._context)
        self.calib_lo_word_delay = RootLuAnalog_hi_res_outTip_voltageAttributeCalib_lo_word_delay(self._context)
        self.input = RootLuAnalog_hi_res_outTip_voltageAttributeInput(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_outTip_voltageAttributeFilter_coeff_vec(self._context)
        self.calib_lo_word_gain = RootLuAnalog_hi_res_outTip_voltageAttributeCalib_lo_word_gain(self._context)
        self.static_value = RootLuAnalog_hi_res_outTip_voltageAttributeStatic_value(self._context)
        self.slew_rate = RootLuAnalog_hi_res_outTip_voltageAttributeSlew_rate(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_outTip_voltageAttributeCalib_polarity(self._context)
        self.glitch_corr_enabled = RootLuAnalog_hi_res_outTip_voltageAttributeGlitch_corr_enabled(self._context)
        self.modulation_input = RootLuAnalog_hi_res_outTip_voltageAttributeModulation_input(self._context)
        self.modulation = RootLuAnalog_hi_res_outTip_voltageAttributeModulation(self._context)
        self.output_gain = RootLuAnalog_hi_res_outTip_voltageAttributeOutput_gain(self._context)
        self.calib_sig_source_dir = RootLuAnalog_hi_res_outTip_voltageAttributeCalib_sig_source_dir(self._context)
        self.glitch_corr_binary_vec = RootLuAnalog_hi_res_outTip_voltageAttributeGlitch_corr_binary_vec(self._context)


class RootLuAnalog_hi_res_outTip_voltage(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.tip_voltage'
        self.attribute = RootLuAnalog_hi_res_outTip_voltageAttribute(self._context)
        self.trigger = RootLuAnalog_hi_res_outTip_voltageTrigger(self._context)


class RootLuAnalog_hi_res_outOut7Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.trigger'


class RootLuAnalog_hi_res_outOut7AttributeGlitch_corr_binary_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.attribute.glitch_corr_binary_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out7.attribute.glitch_corr_binary_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.glitch_corr_binary_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.out7.attribute.glitch_corr_binary_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.glitch_corr_binary_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.out7.attribute.glitch_corr_binary_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.out7.attribute.glitch_corr_binary_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.glitch_corr_binary_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.glitch_corr_binary_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.glitch_corr_binary_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.glitch_corr_binary_vec.min', float(new_val))


class RootLuAnalog_hi_res_outOut7AttributeCalib_sig_source_dir(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        from_input_to_output = 1
        from_output_to_input = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.attribute.calib_sig_source_dir'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_sig_source_dir.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_sig_source_dir.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_sig_source_dir.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_sig_source_dir.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_sig_source_dir.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_sig_source_dir.value_raw', new_val.value)


class RootLuAnalog_hi_res_outOut7AttributeOutput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.attribute.output_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.output_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.output_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out7.attribute.output_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.output_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.output_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.output_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.output_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.output_gain.min', float(new_val))


class RootLuAnalog_hi_res_outOut7AttributeModulation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 2
        disabled = 1
        enabled = 0
        analyzer2_reference = 0
        ort_excitation = 3
        hi_res_signal = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.attribute.modulation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.out7.attribute.modulation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.modulation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.out7.attribute.modulation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.modulation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.out7.attribute.modulation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.modulation.value_raw', new_val.value)


class RootLuAnalog_hi_res_outOut7AttributeModulation_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.attribute.modulation_input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.out7.attribute.modulation_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.modulation_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.out7.attribute.modulation_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.modulation_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.out7.attribute.modulation_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.modulation_input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outOut7AttributeGlitch_corr_enabled(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.attribute.glitch_corr_enabled'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.out7.attribute.glitch_corr_enabled.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.glitch_corr_enabled.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.out7.attribute.glitch_corr_enabled.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.glitch_corr_enabled.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.out7.attribute.glitch_corr_enabled.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.glitch_corr_enabled.value_raw', new_val.value)


class RootLuAnalog_hi_res_outOut7AttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_hi_res_outOut7AttributeSlew_rate(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.attribute.slew_rate'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.slew_rate.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.slew_rate.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out7.attribute.slew_rate.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.slew_rate.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.slew_rate.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.slew_rate.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.slew_rate.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.slew_rate.min', float(new_val))


class RootLuAnalog_hi_res_outOut7AttributeStatic_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.attribute.static_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.static_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.static_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out7.attribute.static_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.static_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.static_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.static_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.static_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.static_value.min', float(new_val))


class RootLuAnalog_hi_res_outOut7AttributeCalib_lo_word_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.attribute.calib_lo_word_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_lo_word_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_lo_word_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_lo_word_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_lo_word_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_lo_word_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_lo_word_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_lo_word_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_lo_word_gain.min', float(new_val))


class RootLuAnalog_hi_res_outOut7AttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out7.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.out7.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.analog_hi_res_out.out7.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.analog_hi_res_out.out7.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.filter_coeff_vec.min', float(new_val))


class RootLuAnalog_hi_res_outOut7AttributeInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 25
        analyzer1_amplitude = 37
        ramp_gen_max_z = 22
        ctrl_x_out = 29
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 41
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 18
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 38
        memory_gen_position_z = 55
        ctrl_w_out = 31
        analyzer1_y = 39
        analyzer2_amplitude = 43
        in_user1 = 8
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 17
        ramp_gen_position_x = 16
        ctrl_user1_out = 32
        in_tip_current = 12
        in_position_y = 6
        comparator2_in_filtered = 63
        analyzer2_x = 44
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 24
        comparator1_in_filtered = 61
        ctrl_z_nominal = 27
        analyzer1_reference = 70
        analyzer1_phase = 36
        comparator2_out = 64
        analyzer2_phase = 42
        analyzer1_ctrl_delta_f = 34
        memory_gen_drive_y = 54
        ctrl_z_sum = 26
        ramp_gen_alternate_z = 19
        comparator3_in_filtered = 65
        ctrl_user2_out = 33
        analyzer2_ctrl_delta_f = 40
        analyzer2_y = 45
        in_detector_sum = 13
        fast_in2 = 68
        in_position_x = 5
        in_user4 = 11
        static = 0
        ramp_gen_ctrl_z = 21
        ramp_gen_test = 2
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 20
        ramp_gen_approach = 15
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 35
        ctrl_y_out = 30
        ctrl_z_in = 23
        in_position_z = 7
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 14
        ctrl_z_out = 28
        in_user3 = 10
        in_user2 = 9
        in_lateral = 4
        in_deflection = 3
        gen_test_dynamic = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.attribute.input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_hi_res_out.out7.attribute.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_hi_res_out.out7.attribute.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_hi_res_out.out7.attribute.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.input.value_raw', new_val.value)


class RootLuAnalog_hi_res_outOut7AttributeCalib_lo_word_delay(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.attribute.calib_lo_word_delay'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_lo_word_delay.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_lo_word_delay.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_lo_word_delay.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_lo_word_delay.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_lo_word_delay.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_lo_word_delay.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_lo_word_delay.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_lo_word_delay.min', float(new_val))


class RootLuAnalog_hi_res_outOut7AttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_hi_res_outOut7AttributeFilter_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.attribute.filter_number'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.filter_number.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.filter_number.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out7.attribute.filter_number.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.filter_number.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.filter_number.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.filter_number.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.filter_number.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.filter_number.min', float(new_val))


class RootLuAnalog_hi_res_outOut7AttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_hi_res_outOut7AttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_hi_res_out.out7.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_hi_res_out.out7.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_hi_res_out.out7.attribute.current_output_value.min', float(new_val))


class RootLuAnalog_hi_res_outOut7Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7.attribute'
        self.current_output_value = RootLuAnalog_hi_res_outOut7AttributeCurrent_output_value(self._context)
        self.calib_offset = RootLuAnalog_hi_res_outOut7AttributeCalib_offset(self._context)
        self.filter_number = RootLuAnalog_hi_res_outOut7AttributeFilter_number(self._context)
        self.calib_gain = RootLuAnalog_hi_res_outOut7AttributeCalib_gain(self._context)
        self.calib_lo_word_delay = RootLuAnalog_hi_res_outOut7AttributeCalib_lo_word_delay(self._context)
        self.input = RootLuAnalog_hi_res_outOut7AttributeInput(self._context)
        self.filter_coeff_vec = RootLuAnalog_hi_res_outOut7AttributeFilter_coeff_vec(self._context)
        self.calib_lo_word_gain = RootLuAnalog_hi_res_outOut7AttributeCalib_lo_word_gain(self._context)
        self.static_value = RootLuAnalog_hi_res_outOut7AttributeStatic_value(self._context)
        self.slew_rate = RootLuAnalog_hi_res_outOut7AttributeSlew_rate(self._context)
        self.calib_polarity = RootLuAnalog_hi_res_outOut7AttributeCalib_polarity(self._context)
        self.glitch_corr_enabled = RootLuAnalog_hi_res_outOut7AttributeGlitch_corr_enabled(self._context)
        self.modulation_input = RootLuAnalog_hi_res_outOut7AttributeModulation_input(self._context)
        self.modulation = RootLuAnalog_hi_res_outOut7AttributeModulation(self._context)
        self.output_gain = RootLuAnalog_hi_res_outOut7AttributeOutput_gain(self._context)
        self.calib_sig_source_dir = RootLuAnalog_hi_res_outOut7AttributeCalib_sig_source_dir(self._context)
        self.glitch_corr_binary_vec = RootLuAnalog_hi_res_outOut7AttributeGlitch_corr_binary_vec(self._context)


class RootLuAnalog_hi_res_outOut7(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out.out7'
        self.attribute = RootLuAnalog_hi_res_outOut7Attribute(self._context)
        self.trigger = RootLuAnalog_hi_res_outOut7Trigger(self._context)


class RootLuAnalog_hi_res_out(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_hi_res_out'
        self.out7 = RootLuAnalog_hi_res_outOut7(self._context)
        self.tip_voltage = RootLuAnalog_hi_res_outTip_voltage(self._context)
        self.user1 = RootLuAnalog_hi_res_outUser1(self._context)
        self.user2 = RootLuAnalog_hi_res_outUser2(self._context)
        self.user3 = RootLuAnalog_hi_res_outUser3(self._context)
        self.approach = RootLuAnalog_hi_res_outApproach(self._context)
        self.user4 = RootLuAnalog_hi_res_outUser4(self._context)
        self.position_z = RootLuAnalog_hi_res_outPosition_z(self._context)
        self.position_y = RootLuAnalog_hi_res_outPosition_y(self._context)
        self.out8 = RootLuAnalog_hi_res_outOut8(self._context)
        self.position_w = RootLuAnalog_hi_res_outPosition_w(self._context)
        self.position_x = RootLuAnalog_hi_res_outPosition_x(self._context)


class RootLuFrequency_sweep_genInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.frequency_sweep_gen.instance.trigger'

    def user_abort(self) -> None:
        return self._context.call('root.lu.frequency_sweep_gen.instance.trigger.user_abort')

    def start_frequency_sweep(self) -> None:
        return self._context.call('root.lu.frequency_sweep_gen.instance.trigger.start_frequency_sweep')


class RootLuFrequency_sweep_genInstanceAttributeData_group_id(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.frequency_sweep_gen.instance.attribute.data_group_id'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.data_group_id.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.data_group_id.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.data_group_id.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.data_group_id.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.data_group_id.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.data_group_id.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.data_group_id.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.data_group_id.min', float(new_val))


class RootLuFrequency_sweep_genInstanceAttributeData_points(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.frequency_sweep_gen.instance.attribute.data_points'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.data_points.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.data_points.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.data_points.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.data_points.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.data_points.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.data_points.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.data_points.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.data_points.min', float(new_val))


class RootLuFrequency_sweep_genInstanceAttributeEnd_frequency(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.frequency_sweep_gen.instance.attribute.end_frequency'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.end_frequency.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.end_frequency.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.end_frequency.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.end_frequency.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.end_frequency.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.end_frequency.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.end_frequency.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.end_frequency.min', float(new_val))


class RootLuFrequency_sweep_genInstanceAttributeStep_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.frequency_sweep_gen.instance.attribute.step_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.step_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.step_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.step_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.step_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.step_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.step_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.step_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.step_time.min', float(new_val))


class RootLuFrequency_sweep_genInstanceAttributeSettle_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.frequency_sweep_gen.instance.attribute.settle_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.settle_time.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.settle_time.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.settle_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.settle_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.settle_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.settle_time.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.settle_time.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.settle_time.min', float(new_val))


class RootLuFrequency_sweep_genInstanceAttributeLu_sig_analyzer_inst_no(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        inst1 = 0
        inst2 = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.frequency_sweep_gen.instance.attribute.lu_sig_analyzer_inst_no'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.lu_sig_analyzer_inst_no.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.lu_sig_analyzer_inst_no.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.lu_sig_analyzer_inst_no.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.lu_sig_analyzer_inst_no.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.lu_sig_analyzer_inst_no.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.lu_sig_analyzer_inst_no.value_raw', new_val.value)


class RootLuFrequency_sweep_genInstanceAttributeSweep_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.frequency_sweep_gen.instance.attribute.sweep_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.sweep_amplitude.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.sweep_amplitude.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.sweep_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.sweep_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.sweep_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.sweep_amplitude.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.sweep_amplitude.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.sweep_amplitude.min', float(new_val))


class RootLuFrequency_sweep_genInstanceAttributeStart_frequency(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.frequency_sweep_gen.instance.attribute.start_frequency'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.start_frequency.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.start_frequency.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.start_frequency.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.start_frequency.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.start_frequency.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.start_frequency.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.frequency_sweep_gen.instance.attribute.start_frequency.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.frequency_sweep_gen.instance.attribute.start_frequency.min', float(new_val))


class RootLuFrequency_sweep_genInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.frequency_sweep_gen.instance.attribute'
        self.start_frequency = RootLuFrequency_sweep_genInstanceAttributeStart_frequency(self._context)
        self.sweep_amplitude = RootLuFrequency_sweep_genInstanceAttributeSweep_amplitude(self._context)
        self.lu_sig_analyzer_inst_no = RootLuFrequency_sweep_genInstanceAttributeLu_sig_analyzer_inst_no(self._context)
        self.settle_time = RootLuFrequency_sweep_genInstanceAttributeSettle_time(self._context)
        self.step_time = RootLuFrequency_sweep_genInstanceAttributeStep_time(self._context)
        self.end_frequency = RootLuFrequency_sweep_genInstanceAttributeEnd_frequency(self._context)
        self.data_points = RootLuFrequency_sweep_genInstanceAttributeData_points(self._context)
        self.data_group_id = RootLuFrequency_sweep_genInstanceAttributeData_group_id(self._context)


class RootLuFrequency_sweep_genInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.frequency_sweep_gen.instance'
        self.attribute = RootLuFrequency_sweep_genInstanceAttribute(self._context)
        self.trigger = RootLuFrequency_sweep_genInstanceTrigger(self._context)


class RootLuFrequency_sweep_gen(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.frequency_sweep_gen'
        self.instance = RootLuFrequency_sweep_genInstance(self._context)


class RootLuDirect_motor_controlInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.direct_motor_control.instance.trigger'

    def add_transaction_move(self) -> None:
        return self._context.call('root.lu.direct_motor_control.instance.trigger.add_transaction_move')

    def search_reference(self) -> None:
        return self._context.call('root.lu.direct_motor_control.instance.trigger.search_reference')

    def reset_transaction(self) -> None:
        return self._context.call('root.lu.direct_motor_control.instance.trigger.reset_transaction')

    def user_abort(self) -> None:
        return self._context.call('root.lu.direct_motor_control.instance.trigger.user_abort')

    def position_zero_axis(self) -> None:
        return self._context.call('root.lu.direct_motor_control.instance.trigger.position_zero_axis')

    def commit_transaction(self) -> None:
        return self._context.call('root.lu.direct_motor_control.instance.trigger.commit_transaction')


class RootLuDirect_motor_controlInstanceAttributeAxis_max_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.direct_motor_control.instance.attribute.axis_max_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_max_speed.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_max_speed.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_max_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_max_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_max_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_max_speed.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_max_speed.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_max_speed.min', float(new_val))


class RootLuDirect_motor_controlInstanceAttributeAxis_status(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        moving = 3
        idle_unreferenced = 0
        idle_referenced = 1
        referencing = 2
        not_mapped = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.direct_motor_control.instance.attribute.axis_status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_status.value_raw', new_val.value)


class RootLuDirect_motor_controlInstanceAttributeAxis_speed_factor(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.direct_motor_control.instance.attribute.axis_speed_factor'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_speed_factor.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_speed_factor.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_speed_factor.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_speed_factor.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_speed_factor.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_speed_factor.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_speed_factor.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_speed_factor.min', float(new_val))


class RootLuDirect_motor_controlInstanceAttributeAxis_limit_status(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        in_upper_limit = 1
        in_no_limit = 0
        in_lower_limit = 2
        in_both_limits = 3
        in_limit = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.direct_motor_control.instance.attribute.axis_limit_status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_limit_status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_limit_status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_limit_status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_limit_status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_limit_status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_limit_status.value_raw', new_val.value)


class RootLuDirect_motor_controlInstanceAttributeCurrent_layout(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        all = 0
        dummy4 = 4
        p6_mount = 8
        sim = 5
        core = 6
        arac = 7
        p6 = 1
        dummy2 = 2
        dummy3 = 3

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.direct_motor_control.instance.attribute.current_layout'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.direct_motor_control.instance.attribute.current_layout.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.direct_motor_control.instance.attribute.current_layout.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.direct_motor_control.instance.attribute.current_layout.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.direct_motor_control.instance.attribute.current_layout.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.direct_motor_control.instance.attribute.current_layout.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.direct_motor_control.instance.attribute.current_layout.value_raw', new_val.value)


class RootLuDirect_motor_controlInstanceAttributeLayout_status(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        uninitialized = 0
        initialized = 1
        not_loaded = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.direct_motor_control.instance.attribute.layout_status'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.direct_motor_control.instance.attribute.layout_status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.direct_motor_control.instance.attribute.layout_status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.direct_motor_control.instance.attribute.layout_status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.direct_motor_control.instance.attribute.layout_status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.direct_motor_control.instance.attribute.layout_status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.direct_motor_control.instance.attribute.layout_status.value_raw', new_val.value)


class RootLuDirect_motor_controlInstanceAttributeTransaction_move_destination(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.direct_motor_control.instance.attribute.transaction_move_destination'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.direct_motor_control.instance.attribute.transaction_move_destination.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.direct_motor_control.instance.attribute.transaction_move_destination.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.direct_motor_control.instance.attribute.transaction_move_destination.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.direct_motor_control.instance.attribute.transaction_move_destination.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.direct_motor_control.instance.attribute.transaction_move_destination.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.direct_motor_control.instance.attribute.transaction_move_destination.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.direct_motor_control.instance.attribute.transaction_move_destination.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.direct_motor_control.instance.attribute.transaction_move_destination.min', float(new_val))


class RootLuDirect_motor_controlInstanceAttributeTransaction_move_relative(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        relative = 1
        absolute = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.direct_motor_control.instance.attribute.transaction_move_relative'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.direct_motor_control.instance.attribute.transaction_move_relative.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.direct_motor_control.instance.attribute.transaction_move_relative.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.direct_motor_control.instance.attribute.transaction_move_relative.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.direct_motor_control.instance.attribute.transaction_move_relative.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.direct_motor_control.instance.attribute.transaction_move_relative.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.direct_motor_control.instance.attribute.transaction_move_relative.value_raw', new_val.value)


class RootLuDirect_motor_controlInstanceAttributeMove_adjust(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.direct_motor_control.instance.attribute.move_adjust'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.direct_motor_control.instance.attribute.move_adjust.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.direct_motor_control.instance.attribute.move_adjust.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.direct_motor_control.instance.attribute.move_adjust.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.direct_motor_control.instance.attribute.move_adjust.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.direct_motor_control.instance.attribute.move_adjust.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.direct_motor_control.instance.attribute.move_adjust.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.direct_motor_control.instance.attribute.move_adjust.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.direct_motor_control.instance.attribute.move_adjust.min', float(new_val))


class RootLuDirect_motor_controlInstanceAttributeAxis_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.direct_motor_control.instance.attribute.axis_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_position.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_position.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_position.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_position.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_position.min', float(new_val))


class RootLuDirect_motor_controlInstanceAttributeCurrent_axis(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        photothermal_excitation_spot_horz = 1005
        all = 0
        approach_2 = 1003
        beam_deflection_spot_horz = 1007
        lens_gimbal = 1013
        y_axis = 1012
        approach_1 = 1002
        x_axis = 1011
        approach = 1000
        photothermal_excitation_spot_vert = 1006
        photodiode_detector_vert = 1010
        photodiode_detector_horz = 1009
        focus_cantilever_light_source = 1004
        beam_deflection_spot_vert = 1008
        approach_0 = 1001

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.direct_motor_control.instance.attribute.current_axis'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.direct_motor_control.instance.attribute.current_axis.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.direct_motor_control.instance.attribute.current_axis.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.direct_motor_control.instance.attribute.current_axis.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.direct_motor_control.instance.attribute.current_axis.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.direct_motor_control.instance.attribute.current_axis.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.direct_motor_control.instance.attribute.current_axis.value_raw', new_val.value)


class RootLuDirect_motor_controlInstanceAttributeAxis_last_reference_move_distance(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.direct_motor_control.instance.attribute.axis_last_reference_move_distance'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_last_reference_move_distance.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_last_reference_move_distance.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_last_reference_move_distance.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_last_reference_move_distance.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_last_reference_move_distance.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_last_reference_move_distance.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.direct_motor_control.instance.attribute.axis_last_reference_move_distance.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.direct_motor_control.instance.attribute.axis_last_reference_move_distance.min', float(new_val))


class RootLuDirect_motor_controlInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.direct_motor_control.instance.attribute'
        self.axis_last_reference_move_distance = RootLuDirect_motor_controlInstanceAttributeAxis_last_reference_move_distance(self._context)
        self.current_axis = RootLuDirect_motor_controlInstanceAttributeCurrent_axis(self._context)
        self.axis_position = RootLuDirect_motor_controlInstanceAttributeAxis_position(self._context)
        self.move_adjust = RootLuDirect_motor_controlInstanceAttributeMove_adjust(self._context)
        self.transaction_move_relative = RootLuDirect_motor_controlInstanceAttributeTransaction_move_relative(self._context)
        self.transaction_move_destination = RootLuDirect_motor_controlInstanceAttributeTransaction_move_destination(self._context)
        self.layout_status = RootLuDirect_motor_controlInstanceAttributeLayout_status(self._context)
        self.current_layout = RootLuDirect_motor_controlInstanceAttributeCurrent_layout(self._context)
        self.axis_limit_status = RootLuDirect_motor_controlInstanceAttributeAxis_limit_status(self._context)
        self.axis_speed_factor = RootLuDirect_motor_controlInstanceAttributeAxis_speed_factor(self._context)
        self.axis_status = RootLuDirect_motor_controlInstanceAttributeAxis_status(self._context)
        self.axis_max_speed = RootLuDirect_motor_controlInstanceAttributeAxis_max_speed(self._context)


class RootLuDirect_motor_controlInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.direct_motor_control.instance'
        self.attribute = RootLuDirect_motor_controlInstanceAttribute(self._context)
        self.trigger = RootLuDirect_motor_controlInstanceTrigger(self._context)


class RootLuDirect_motor_control(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.direct_motor_control'
        self.instance = RootLuDirect_motor_controlInstance(self._context)


class RootLuRescanInstanceAttributeLine_repetition_count(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.rescan.instance.attribute.line_repetition_count'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.rescan.instance.attribute.line_repetition_count.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.rescan.instance.attribute.line_repetition_count.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.rescan.instance.attribute.line_repetition_count.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.rescan.instance.attribute.line_repetition_count.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.rescan.instance.attribute.line_repetition_count.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.rescan.instance.attribute.line_repetition_count.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.rescan.instance.attribute.line_repetition_count.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.rescan.instance.attribute.line_repetition_count.min', float(new_val))


class RootLuRescanInstanceAttributeEnable(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.rescan.instance.attribute.enable'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.rescan.instance.attribute.enable.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.rescan.instance.attribute.enable.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.rescan.instance.attribute.enable.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.rescan.instance.attribute.enable.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.rescan.instance.attribute.enable.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.rescan.instance.attribute.enable.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.rescan.instance.attribute.enable.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.rescan.instance.attribute.enable.min', float(new_val))


class RootLuRescanInstanceAttributeLine_repetition_max_count(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.rescan.instance.attribute.line_repetition_max_count'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.rescan.instance.attribute.line_repetition_max_count.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.rescan.instance.attribute.line_repetition_max_count.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.rescan.instance.attribute.line_repetition_max_count.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.rescan.instance.attribute.line_repetition_max_count.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.rescan.instance.attribute.line_repetition_max_count.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.rescan.instance.attribute.line_repetition_max_count.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.rescan.instance.attribute.line_repetition_max_count.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.rescan.instance.attribute.line_repetition_max_count.min', float(new_val))


class RootLuRescanInstanceAttributeLine_repetition_max(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.rescan.instance.attribute.line_repetition_max'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.rescan.instance.attribute.line_repetition_max.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.rescan.instance.attribute.line_repetition_max.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.rescan.instance.attribute.line_repetition_max.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.rescan.instance.attribute.line_repetition_max.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.rescan.instance.attribute.line_repetition_max.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.rescan.instance.attribute.line_repetition_max.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.rescan.instance.attribute.line_repetition_max.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.rescan.instance.attribute.line_repetition_max.min', float(new_val))


class RootLuRescanInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.rescan.instance.attribute'
        self.line_repetition_max = RootLuRescanInstanceAttributeLine_repetition_max(self._context)
        self.line_repetition_max_count = RootLuRescanInstanceAttributeLine_repetition_max_count(self._context)
        self.enable = RootLuRescanInstanceAttributeEnable(self._context)
        self.line_repetition_count = RootLuRescanInstanceAttributeLine_repetition_count(self._context)


class RootLuRescanInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.rescan.instance'
        self.attribute = RootLuRescanInstanceAttribute(self._context)


class RootLuRescan(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.rescan'
        self.instance = RootLuRescanInstance(self._context)


class RootLuAnalog_fast_outExcitationTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.excitation.trigger'


class RootLuAnalog_fast_outExcitationAttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.excitation.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.excitation.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.excitation.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.excitation.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_fast_outExcitationAttributeCalib_sig_source_dir(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        from_input_to_output = 1
        from_output_to_input = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.excitation.attribute.calib_sig_source_dir'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.excitation.attribute.calib_sig_source_dir.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.calib_sig_source_dir.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.excitation.attribute.calib_sig_source_dir.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.calib_sig_source_dir.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.excitation.attribute.calib_sig_source_dir.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.calib_sig_source_dir.value_raw', new_val.value)


class RootLuAnalog_fast_outExcitationAttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.excitation.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.excitation.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.excitation.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.excitation.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.excitation.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_fast_outExcitationAttributeModulation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 2
        disabled = 1
        damping = 3
        enabled = 0
        analyzer2_reference = 0
        hi_res_signal = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.excitation.attribute.modulation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.excitation.attribute.modulation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.modulation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.excitation.attribute.modulation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.modulation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.excitation.attribute.modulation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.modulation.value_raw', new_val.value)


class RootLuAnalog_fast_outExcitationAttributeOutput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.excitation.attribute.output_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.excitation.attribute.output_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.output_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.excitation.attribute.output_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.output_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.excitation.attribute.output_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.output_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.excitation.attribute.output_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.output_gain.min', float(new_val))


class RootLuAnalog_fast_outExcitationAttributeStatic_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.excitation.attribute.static_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.excitation.attribute.static_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.static_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.excitation.attribute.static_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.static_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.excitation.attribute.static_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.static_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.excitation.attribute.static_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.static_value.min', float(new_val))


class RootLuAnalog_fast_outExcitationAttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.excitation.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.excitation.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.excitation.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.excitation.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.excitation.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_fast_outExcitationAttributeDamping_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.excitation.attribute.damping_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.excitation.attribute.damping_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.damping_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.excitation.attribute.damping_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.damping_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.excitation.attribute.damping_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.damping_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.excitation.attribute.damping_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.damping_gain.min', float(new_val))


class RootLuAnalog_fast_outExcitationAttributeInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 4
        fast_in2 = 2
        in_user = 3
        ctrl_z_out = 7
        ctrl_w_out = 8
        analyzer2_reference = 5
        static = 0
        ort_excitation = 6
        in_deflection = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.excitation.attribute.input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.excitation.attribute.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.excitation.attribute.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.excitation.attribute.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.input.value_raw', new_val.value)


class RootLuAnalog_fast_outExcitationAttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.excitation.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.excitation.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.excitation.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.excitation.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.excitation.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.current_output_value.min', float(new_val))


class RootLuAnalog_fast_outExcitationAttributeAnalog_output(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 0
        disabled = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.excitation.attribute.analog_output'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.excitation.attribute.analog_output.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.analog_output.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.excitation.attribute.analog_output.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.analog_output.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.excitation.attribute.analog_output.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.excitation.attribute.analog_output.value_raw', new_val.value)


class RootLuAnalog_fast_outExcitationAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.excitation.attribute'
        self.analog_output = RootLuAnalog_fast_outExcitationAttributeAnalog_output(self._context)
        self.current_output_value = RootLuAnalog_fast_outExcitationAttributeCurrent_output_value(self._context)
        self.input = RootLuAnalog_fast_outExcitationAttributeInput(self._context)
        self.damping_gain = RootLuAnalog_fast_outExcitationAttributeDamping_gain(self._context)
        self.calib_offset = RootLuAnalog_fast_outExcitationAttributeCalib_offset(self._context)
        self.static_value = RootLuAnalog_fast_outExcitationAttributeStatic_value(self._context)
        self.output_gain = RootLuAnalog_fast_outExcitationAttributeOutput_gain(self._context)
        self.modulation = RootLuAnalog_fast_outExcitationAttributeModulation(self._context)
        self.calib_gain = RootLuAnalog_fast_outExcitationAttributeCalib_gain(self._context)
        self.calib_sig_source_dir = RootLuAnalog_fast_outExcitationAttributeCalib_sig_source_dir(self._context)
        self.calib_polarity = RootLuAnalog_fast_outExcitationAttributeCalib_polarity(self._context)


class RootLuAnalog_fast_outExcitation(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.excitation'
        self.attribute = RootLuAnalog_fast_outExcitationAttribute(self._context)
        self.trigger = RootLuAnalog_fast_outExcitationTrigger(self._context)


class RootLuAnalog_fast_outFast2Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast2.trigger'


class RootLuAnalog_fast_outFast2AttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast2.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.fast2.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.fast2.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.fast2.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_fast_outFast2AttributeCalib_sig_source_dir(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        from_input_to_output = 1
        from_output_to_input = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast2.attribute.calib_sig_source_dir'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.fast2.attribute.calib_sig_source_dir.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.calib_sig_source_dir.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.fast2.attribute.calib_sig_source_dir.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.calib_sig_source_dir.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.fast2.attribute.calib_sig_source_dir.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.calib_sig_source_dir.value_raw', new_val.value)


class RootLuAnalog_fast_outFast2AttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast2.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast2.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.fast2.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast2.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast2.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_fast_outFast2AttributeModulation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 2
        disabled = 1
        damping = 3
        enabled = 0
        analyzer2_reference = 0
        hi_res_signal = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast2.attribute.modulation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.fast2.attribute.modulation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.modulation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.fast2.attribute.modulation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.modulation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.fast2.attribute.modulation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.modulation.value_raw', new_val.value)


class RootLuAnalog_fast_outFast2AttributeOutput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast2.attribute.output_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast2.attribute.output_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.output_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.fast2.attribute.output_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.output_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast2.attribute.output_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.output_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast2.attribute.output_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.output_gain.min', float(new_val))


class RootLuAnalog_fast_outFast2AttributeStatic_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast2.attribute.static_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast2.attribute.static_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.static_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.fast2.attribute.static_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.static_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast2.attribute.static_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.static_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast2.attribute.static_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.static_value.min', float(new_val))


class RootLuAnalog_fast_outFast2AttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast2.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast2.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.fast2.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast2.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast2.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_fast_outFast2AttributeDamping_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast2.attribute.damping_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast2.attribute.damping_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.damping_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.fast2.attribute.damping_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.damping_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast2.attribute.damping_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.damping_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast2.attribute.damping_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.damping_gain.min', float(new_val))


class RootLuAnalog_fast_outFast2AttributeInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 4
        fast_in2 = 2
        in_user = 3
        ctrl_z_out = 7
        ctrl_w_out = 8
        analyzer2_reference = 5
        static = 0
        ort_excitation = 6
        in_deflection = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast2.attribute.input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.fast2.attribute.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.fast2.attribute.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.fast2.attribute.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.input.value_raw', new_val.value)


class RootLuAnalog_fast_outFast2AttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast2.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast2.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.fast2.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast2.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast2.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.current_output_value.min', float(new_val))


class RootLuAnalog_fast_outFast2AttributeAnalog_output(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 0
        disabled = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast2.attribute.analog_output'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.fast2.attribute.analog_output.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.analog_output.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.fast2.attribute.analog_output.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.analog_output.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.fast2.attribute.analog_output.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.fast2.attribute.analog_output.value_raw', new_val.value)


class RootLuAnalog_fast_outFast2Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast2.attribute'
        self.analog_output = RootLuAnalog_fast_outFast2AttributeAnalog_output(self._context)
        self.current_output_value = RootLuAnalog_fast_outFast2AttributeCurrent_output_value(self._context)
        self.input = RootLuAnalog_fast_outFast2AttributeInput(self._context)
        self.damping_gain = RootLuAnalog_fast_outFast2AttributeDamping_gain(self._context)
        self.calib_offset = RootLuAnalog_fast_outFast2AttributeCalib_offset(self._context)
        self.static_value = RootLuAnalog_fast_outFast2AttributeStatic_value(self._context)
        self.output_gain = RootLuAnalog_fast_outFast2AttributeOutput_gain(self._context)
        self.modulation = RootLuAnalog_fast_outFast2AttributeModulation(self._context)
        self.calib_gain = RootLuAnalog_fast_outFast2AttributeCalib_gain(self._context)
        self.calib_sig_source_dir = RootLuAnalog_fast_outFast2AttributeCalib_sig_source_dir(self._context)
        self.calib_polarity = RootLuAnalog_fast_outFast2AttributeCalib_polarity(self._context)


class RootLuAnalog_fast_outFast2(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast2'
        self.attribute = RootLuAnalog_fast_outFast2Attribute(self._context)
        self.trigger = RootLuAnalog_fast_outFast2Trigger(self._context)


class RootLuAnalog_fast_outFast3Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast3.trigger'


class RootLuAnalog_fast_outFast3AttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast3.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.fast3.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.fast3.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.fast3.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_fast_outFast3AttributeCalib_sig_source_dir(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        from_input_to_output = 1
        from_output_to_input = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast3.attribute.calib_sig_source_dir'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.fast3.attribute.calib_sig_source_dir.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.calib_sig_source_dir.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.fast3.attribute.calib_sig_source_dir.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.calib_sig_source_dir.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.fast3.attribute.calib_sig_source_dir.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.calib_sig_source_dir.value_raw', new_val.value)


class RootLuAnalog_fast_outFast3AttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast3.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast3.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.fast3.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast3.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast3.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_fast_outFast3AttributeModulation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 2
        disabled = 1
        damping = 3
        enabled = 0
        analyzer2_reference = 0
        hi_res_signal = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast3.attribute.modulation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.fast3.attribute.modulation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.modulation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.fast3.attribute.modulation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.modulation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.fast3.attribute.modulation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.modulation.value_raw', new_val.value)


class RootLuAnalog_fast_outFast3AttributeOutput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast3.attribute.output_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast3.attribute.output_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.output_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.fast3.attribute.output_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.output_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast3.attribute.output_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.output_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast3.attribute.output_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.output_gain.min', float(new_val))


class RootLuAnalog_fast_outFast3AttributeStatic_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast3.attribute.static_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast3.attribute.static_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.static_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.fast3.attribute.static_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.static_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast3.attribute.static_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.static_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast3.attribute.static_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.static_value.min', float(new_val))


class RootLuAnalog_fast_outFast3AttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast3.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast3.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.fast3.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast3.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast3.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_fast_outFast3AttributeDamping_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast3.attribute.damping_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast3.attribute.damping_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.damping_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.fast3.attribute.damping_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.damping_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast3.attribute.damping_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.damping_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast3.attribute.damping_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.damping_gain.min', float(new_val))


class RootLuAnalog_fast_outFast3AttributeInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 4
        fast_in2 = 2
        in_user = 3
        ctrl_z_out = 7
        ctrl_w_out = 8
        analyzer2_reference = 5
        static = 0
        ort_excitation = 6
        in_deflection = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast3.attribute.input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.fast3.attribute.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.fast3.attribute.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.fast3.attribute.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.input.value_raw', new_val.value)


class RootLuAnalog_fast_outFast3AttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast3.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast3.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.fast3.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast3.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.fast3.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.current_output_value.min', float(new_val))


class RootLuAnalog_fast_outFast3AttributeAnalog_output(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 0
        disabled = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast3.attribute.analog_output'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.fast3.attribute.analog_output.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.analog_output.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.fast3.attribute.analog_output.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.analog_output.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.fast3.attribute.analog_output.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.fast3.attribute.analog_output.value_raw', new_val.value)


class RootLuAnalog_fast_outFast3Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast3.attribute'
        self.analog_output = RootLuAnalog_fast_outFast3AttributeAnalog_output(self._context)
        self.current_output_value = RootLuAnalog_fast_outFast3AttributeCurrent_output_value(self._context)
        self.input = RootLuAnalog_fast_outFast3AttributeInput(self._context)
        self.damping_gain = RootLuAnalog_fast_outFast3AttributeDamping_gain(self._context)
        self.calib_offset = RootLuAnalog_fast_outFast3AttributeCalib_offset(self._context)
        self.static_value = RootLuAnalog_fast_outFast3AttributeStatic_value(self._context)
        self.output_gain = RootLuAnalog_fast_outFast3AttributeOutput_gain(self._context)
        self.modulation = RootLuAnalog_fast_outFast3AttributeModulation(self._context)
        self.calib_gain = RootLuAnalog_fast_outFast3AttributeCalib_gain(self._context)
        self.calib_sig_source_dir = RootLuAnalog_fast_outFast3AttributeCalib_sig_source_dir(self._context)
        self.calib_polarity = RootLuAnalog_fast_outFast3AttributeCalib_polarity(self._context)


class RootLuAnalog_fast_outFast3(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.fast3'
        self.attribute = RootLuAnalog_fast_outFast3Attribute(self._context)
        self.trigger = RootLuAnalog_fast_outFast3Trigger(self._context)


class RootLuAnalog_fast_outUserTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.user.trigger'


class RootLuAnalog_fast_outUserAttributeCalib_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.user.attribute.calib_polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.user.attribute.calib_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.user.attribute.calib_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.user.attribute.calib_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.user.attribute.calib_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.user.attribute.calib_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.user.attribute.calib_polarity.value_raw', new_val.value)


class RootLuAnalog_fast_outUserAttributeCalib_sig_source_dir(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        from_input_to_output = 1
        from_output_to_input = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.user.attribute.calib_sig_source_dir'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.user.attribute.calib_sig_source_dir.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.user.attribute.calib_sig_source_dir.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.user.attribute.calib_sig_source_dir.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.user.attribute.calib_sig_source_dir.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.user.attribute.calib_sig_source_dir.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.user.attribute.calib_sig_source_dir.value_raw', new_val.value)


class RootLuAnalog_fast_outUserAttributeCalib_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.user.attribute.calib_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.user.attribute.calib_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.user.attribute.calib_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.user.attribute.calib_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.user.attribute.calib_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.user.attribute.calib_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.user.attribute.calib_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.user.attribute.calib_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.user.attribute.calib_gain.min', float(new_val))


class RootLuAnalog_fast_outUserAttributeModulation(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 2
        disabled = 1
        damping = 3
        enabled = 0
        analyzer2_reference = 0
        hi_res_signal = 4

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.user.attribute.modulation'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.user.attribute.modulation.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.user.attribute.modulation.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.user.attribute.modulation.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.user.attribute.modulation.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.user.attribute.modulation.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.user.attribute.modulation.value_raw', new_val.value)


class RootLuAnalog_fast_outUserAttributeOutput_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.user.attribute.output_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.user.attribute.output_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.user.attribute.output_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.user.attribute.output_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.user.attribute.output_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.user.attribute.output_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.user.attribute.output_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.user.attribute.output_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.user.attribute.output_gain.min', float(new_val))


class RootLuAnalog_fast_outUserAttributeStatic_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.user.attribute.static_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.user.attribute.static_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.user.attribute.static_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.user.attribute.static_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.user.attribute.static_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.user.attribute.static_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.user.attribute.static_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.user.attribute.static_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.user.attribute.static_value.min', float(new_val))


class RootLuAnalog_fast_outUserAttributeCalib_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.user.attribute.calib_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.user.attribute.calib_offset.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.user.attribute.calib_offset.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.user.attribute.calib_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.user.attribute.calib_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.user.attribute.calib_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.user.attribute.calib_offset.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.user.attribute.calib_offset.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.user.attribute.calib_offset.min', float(new_val))


class RootLuAnalog_fast_outUserAttributeDamping_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.user.attribute.damping_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.user.attribute.damping_gain.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.user.attribute.damping_gain.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.user.attribute.damping_gain.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.user.attribute.damping_gain.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.user.attribute.damping_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.user.attribute.damping_gain.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.user.attribute.damping_gain.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.user.attribute.damping_gain.min', float(new_val))


class RootLuAnalog_fast_outUserAttributeInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        analyzer1_reference = 4
        fast_in2 = 2
        in_user = 3
        ctrl_z_out = 7
        ctrl_w_out = 8
        analyzer2_reference = 5
        static = 0
        ort_excitation = 6
        in_deflection = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.user.attribute.input'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.user.attribute.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.user.attribute.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.user.attribute.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.user.attribute.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.user.attribute.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.user.attribute.input.value_raw', new_val.value)


class RootLuAnalog_fast_outUserAttributeCurrent_output_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.user.attribute.current_output_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.user.attribute.current_output_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.user.attribute.current_output_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.analog_fast_out.user.attribute.current_output_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.analog_fast_out.user.attribute.current_output_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.user.attribute.current_output_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.user.attribute.current_output_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.analog_fast_out.user.attribute.current_output_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.analog_fast_out.user.attribute.current_output_value.min', float(new_val))


class RootLuAnalog_fast_outUserAttributeAnalog_output(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 0
        disabled = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.user.attribute.analog_output'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.analog_fast_out.user.attribute.analog_output.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.analog_fast_out.user.attribute.analog_output.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.analog_fast_out.user.attribute.analog_output.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.analog_fast_out.user.attribute.analog_output.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.analog_fast_out.user.attribute.analog_output.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.analog_fast_out.user.attribute.analog_output.value_raw', new_val.value)


class RootLuAnalog_fast_outUserAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.user.attribute'
        self.analog_output = RootLuAnalog_fast_outUserAttributeAnalog_output(self._context)
        self.current_output_value = RootLuAnalog_fast_outUserAttributeCurrent_output_value(self._context)
        self.input = RootLuAnalog_fast_outUserAttributeInput(self._context)
        self.damping_gain = RootLuAnalog_fast_outUserAttributeDamping_gain(self._context)
        self.calib_offset = RootLuAnalog_fast_outUserAttributeCalib_offset(self._context)
        self.static_value = RootLuAnalog_fast_outUserAttributeStatic_value(self._context)
        self.output_gain = RootLuAnalog_fast_outUserAttributeOutput_gain(self._context)
        self.modulation = RootLuAnalog_fast_outUserAttributeModulation(self._context)
        self.calib_gain = RootLuAnalog_fast_outUserAttributeCalib_gain(self._context)
        self.calib_sig_source_dir = RootLuAnalog_fast_outUserAttributeCalib_sig_source_dir(self._context)
        self.calib_polarity = RootLuAnalog_fast_outUserAttributeCalib_polarity(self._context)


class RootLuAnalog_fast_outUser(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out.user'
        self.attribute = RootLuAnalog_fast_outUserAttribute(self._context)
        self.trigger = RootLuAnalog_fast_outUserTrigger(self._context)


class RootLuAnalog_fast_out(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.analog_fast_out'
        self.user = RootLuAnalog_fast_outUser(self._context)
        self.fast3 = RootLuAnalog_fast_outFast3(self._context)
        self.fast2 = RootLuAnalog_fast_outFast2(self._context)
        self.excitation = RootLuAnalog_fast_outExcitation(self._context)


class RootLuComparatorComparator2Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator2.trigger'


class RootLuComparatorComparator2AttributeCurrent_out_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator2.attribute.current_out_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator2.attribute.current_out_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comparator.comparator2.attribute.current_out_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comparator.comparator2.attribute.current_out_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comparator.comparator2.attribute.current_out_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator2.attribute.current_out_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comparator.comparator2.attribute.current_out_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator2.attribute.current_out_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comparator.comparator2.attribute.current_out_value.min', float(new_val))


class RootLuComparatorComparator2AttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator2.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comparator.comparator2.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comparator.comparator2.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.comparator.comparator2.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.comparator.comparator2.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.comparator.comparator2.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.comparator.comparator2.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator2.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comparator.comparator2.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator2.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comparator.comparator2.attribute.filter_coeff_vec.min', float(new_val))


class RootLuComparatorComparator2AttributePolarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        equal_or_higher_than = 1
        equal_or_lower_than = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator2.attribute.polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.comparator.comparator2.attribute.polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.comparator.comparator2.attribute.polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.comparator.comparator2.attribute.polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.comparator.comparator2.attribute.polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.comparator.comparator2.attribute.polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.comparator.comparator2.attribute.polarity.value_raw', new_val.value)


class RootLuComparatorComparator2AttributeSource(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator2.attribute.source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.comparator.comparator2.attribute.source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.comparator.comparator2.attribute.source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.comparator.comparator2.attribute.source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.comparator.comparator2.attribute.source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.comparator.comparator2.attribute.source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.comparator.comparator2.attribute.source.value_raw', new_val.value)


class RootLuComparatorComparator2AttributeDigital_true_level(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator2.attribute.digital_true_level'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator2.attribute.digital_true_level.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comparator.comparator2.attribute.digital_true_level.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comparator.comparator2.attribute.digital_true_level.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comparator.comparator2.attribute.digital_true_level.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator2.attribute.digital_true_level.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comparator.comparator2.attribute.digital_true_level.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator2.attribute.digital_true_level.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comparator.comparator2.attribute.digital_true_level.min', float(new_val))


class RootLuComparatorComparator2AttributeCurrent_in_filtered(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator2.attribute.current_in_filtered'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator2.attribute.current_in_filtered.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comparator.comparator2.attribute.current_in_filtered.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comparator.comparator2.attribute.current_in_filtered.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comparator.comparator2.attribute.current_in_filtered.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator2.attribute.current_in_filtered.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comparator.comparator2.attribute.current_in_filtered.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator2.attribute.current_in_filtered.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comparator.comparator2.attribute.current_in_filtered.min', float(new_val))


class RootLuComparatorComparator2AttributeDigital_false_level(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator2.attribute.digital_false_level'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator2.attribute.digital_false_level.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comparator.comparator2.attribute.digital_false_level.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comparator.comparator2.attribute.digital_false_level.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comparator.comparator2.attribute.digital_false_level.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator2.attribute.digital_false_level.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comparator.comparator2.attribute.digital_false_level.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator2.attribute.digital_false_level.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comparator.comparator2.attribute.digital_false_level.min', float(new_val))


class RootLuComparatorComparator2AttributeLevel(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator2.attribute.level'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator2.attribute.level.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comparator.comparator2.attribute.level.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comparator.comparator2.attribute.level.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comparator.comparator2.attribute.level.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator2.attribute.level.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comparator.comparator2.attribute.level.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator2.attribute.level.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comparator.comparator2.attribute.level.min', float(new_val))


class RootLuComparatorComparator2AttributeFilter_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator2.attribute.filter_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.comparator.comparator2.attribute.filter_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.comparator.comparator2.attribute.filter_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.comparator.comparator2.attribute.filter_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.comparator.comparator2.attribute.filter_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.comparator.comparator2.attribute.filter_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.comparator.comparator2.attribute.filter_enable.value_raw', new_val.value)


class RootLuComparatorComparator2Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator2.attribute'
        self.filter_enable = RootLuComparatorComparator2AttributeFilter_enable(self._context)
        self.level = RootLuComparatorComparator2AttributeLevel(self._context)
        self.digital_false_level = RootLuComparatorComparator2AttributeDigital_false_level(self._context)
        self.current_in_filtered = RootLuComparatorComparator2AttributeCurrent_in_filtered(self._context)
        self.digital_true_level = RootLuComparatorComparator2AttributeDigital_true_level(self._context)
        self.source = RootLuComparatorComparator2AttributeSource(self._context)
        self.polarity = RootLuComparatorComparator2AttributePolarity(self._context)
        self.filter_coeff_vec = RootLuComparatorComparator2AttributeFilter_coeff_vec(self._context)
        self.current_out_value = RootLuComparatorComparator2AttributeCurrent_out_value(self._context)


class RootLuComparatorComparator2(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator2'
        self.attribute = RootLuComparatorComparator2Attribute(self._context)
        self.trigger = RootLuComparatorComparator2Trigger(self._context)


class RootLuComparatorComparator3Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator3.trigger'


class RootLuComparatorComparator3AttributeCurrent_out_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator3.attribute.current_out_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator3.attribute.current_out_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comparator.comparator3.attribute.current_out_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comparator.comparator3.attribute.current_out_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comparator.comparator3.attribute.current_out_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator3.attribute.current_out_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comparator.comparator3.attribute.current_out_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator3.attribute.current_out_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comparator.comparator3.attribute.current_out_value.min', float(new_val))


class RootLuComparatorComparator3AttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator3.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comparator.comparator3.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comparator.comparator3.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.comparator.comparator3.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.comparator.comparator3.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.comparator.comparator3.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.comparator.comparator3.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator3.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comparator.comparator3.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator3.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comparator.comparator3.attribute.filter_coeff_vec.min', float(new_val))


class RootLuComparatorComparator3AttributePolarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        equal_or_higher_than = 1
        equal_or_lower_than = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator3.attribute.polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.comparator.comparator3.attribute.polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.comparator.comparator3.attribute.polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.comparator.comparator3.attribute.polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.comparator.comparator3.attribute.polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.comparator.comparator3.attribute.polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.comparator.comparator3.attribute.polarity.value_raw', new_val.value)


class RootLuComparatorComparator3AttributeSource(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator3.attribute.source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.comparator.comparator3.attribute.source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.comparator.comparator3.attribute.source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.comparator.comparator3.attribute.source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.comparator.comparator3.attribute.source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.comparator.comparator3.attribute.source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.comparator.comparator3.attribute.source.value_raw', new_val.value)


class RootLuComparatorComparator3AttributeDigital_true_level(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator3.attribute.digital_true_level'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator3.attribute.digital_true_level.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comparator.comparator3.attribute.digital_true_level.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comparator.comparator3.attribute.digital_true_level.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comparator.comparator3.attribute.digital_true_level.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator3.attribute.digital_true_level.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comparator.comparator3.attribute.digital_true_level.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator3.attribute.digital_true_level.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comparator.comparator3.attribute.digital_true_level.min', float(new_val))


class RootLuComparatorComparator3AttributeCurrent_in_filtered(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator3.attribute.current_in_filtered'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator3.attribute.current_in_filtered.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comparator.comparator3.attribute.current_in_filtered.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comparator.comparator3.attribute.current_in_filtered.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comparator.comparator3.attribute.current_in_filtered.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator3.attribute.current_in_filtered.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comparator.comparator3.attribute.current_in_filtered.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator3.attribute.current_in_filtered.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comparator.comparator3.attribute.current_in_filtered.min', float(new_val))


class RootLuComparatorComparator3AttributeDigital_false_level(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator3.attribute.digital_false_level'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator3.attribute.digital_false_level.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comparator.comparator3.attribute.digital_false_level.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comparator.comparator3.attribute.digital_false_level.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comparator.comparator3.attribute.digital_false_level.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator3.attribute.digital_false_level.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comparator.comparator3.attribute.digital_false_level.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator3.attribute.digital_false_level.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comparator.comparator3.attribute.digital_false_level.min', float(new_val))


class RootLuComparatorComparator3AttributeLevel(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator3.attribute.level'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator3.attribute.level.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comparator.comparator3.attribute.level.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comparator.comparator3.attribute.level.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comparator.comparator3.attribute.level.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator3.attribute.level.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comparator.comparator3.attribute.level.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator3.attribute.level.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comparator.comparator3.attribute.level.min', float(new_val))


class RootLuComparatorComparator3AttributeFilter_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator3.attribute.filter_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.comparator.comparator3.attribute.filter_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.comparator.comparator3.attribute.filter_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.comparator.comparator3.attribute.filter_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.comparator.comparator3.attribute.filter_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.comparator.comparator3.attribute.filter_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.comparator.comparator3.attribute.filter_enable.value_raw', new_val.value)


class RootLuComparatorComparator3Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator3.attribute'
        self.filter_enable = RootLuComparatorComparator3AttributeFilter_enable(self._context)
        self.level = RootLuComparatorComparator3AttributeLevel(self._context)
        self.digital_false_level = RootLuComparatorComparator3AttributeDigital_false_level(self._context)
        self.current_in_filtered = RootLuComparatorComparator3AttributeCurrent_in_filtered(self._context)
        self.digital_true_level = RootLuComparatorComparator3AttributeDigital_true_level(self._context)
        self.source = RootLuComparatorComparator3AttributeSource(self._context)
        self.polarity = RootLuComparatorComparator3AttributePolarity(self._context)
        self.filter_coeff_vec = RootLuComparatorComparator3AttributeFilter_coeff_vec(self._context)
        self.current_out_value = RootLuComparatorComparator3AttributeCurrent_out_value(self._context)


class RootLuComparatorComparator3(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator3'
        self.attribute = RootLuComparatorComparator3Attribute(self._context)
        self.trigger = RootLuComparatorComparator3Trigger(self._context)


class RootLuComparatorComparator1Trigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator1.trigger'


class RootLuComparatorComparator1AttributeCurrent_out_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator1.attribute.current_out_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator1.attribute.current_out_value.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comparator.comparator1.attribute.current_out_value.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comparator.comparator1.attribute.current_out_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comparator.comparator1.attribute.current_out_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator1.attribute.current_out_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comparator.comparator1.attribute.current_out_value.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator1.attribute.current_out_value.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comparator.comparator1.attribute.current_out_value.min', float(new_val))


class RootLuComparatorComparator1AttributeFilter_coeff_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator1.attribute.filter_coeff_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comparator.comparator1.attribute.filter_coeff_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comparator.comparator1.attribute.filter_coeff_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.comparator.comparator1.attribute.filter_coeff_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.comparator.comparator1.attribute.filter_coeff_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.comparator.comparator1.attribute.filter_coeff_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.comparator.comparator1.attribute.filter_coeff_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator1.attribute.filter_coeff_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comparator.comparator1.attribute.filter_coeff_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator1.attribute.filter_coeff_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comparator.comparator1.attribute.filter_coeff_vec.min', float(new_val))


class RootLuComparatorComparator1AttributePolarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        equal_or_higher_than = 1
        equal_or_lower_than = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator1.attribute.polarity'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.comparator.comparator1.attribute.polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.comparator.comparator1.attribute.polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.comparator.comparator1.attribute.polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.comparator.comparator1.attribute.polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.comparator.comparator1.attribute.polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.comparator.comparator1.attribute.polarity.value_raw', new_val.value)


class RootLuComparatorComparator1AttributeSource(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        ctrl_z_pid_command = 39
        analyzer1_amplitude = 16
        ramp_gen_max_z = 38
        ctrl_x_out = 41
        analyzer2_reference = 71
        analyzer2_ctrl_amplitude = 26
        comparator1_out = 62
        ort_excitation = 72
        ramp_gen_tip_voltage = 28
        memory_gen_out8 = 58
        fast_in_user = 69
        analyzer1_x = 18
        memory_gen_position_z = 55
        ctrl_w_out = 43
        analyzer1_y = 19
        analyzer2_amplitude = 22
        in_user1 = 5
        ramp_gen_user4 = 59
        memory_gen_out7 = 57
        ramp_gen_position_y = 35
        ramp_gen_position_x = 34
        ctrl_user1_out = 44
        in_tip_current = 9
        in_position_y = 3
        comparator2_in_filtered = 63
        analyzer2_x = 24
        memory_gen_position_y = 53
        memory_gen_position_x = 51
        ctrl_z_error = 13
        comparator1_in_filtered = 61
        ctrl_z_nominal = 15
        analyzer1_reference = 70
        analyzer1_phase = 17
        comparator2_out = 64
        analyzer2_phase = 23
        analyzer1_ctrl_delta_f = 21
        memory_gen_drive_y = 54
        ctrl_z_sum = 40
        ramp_gen_alternate_z = 29
        comparator3_in_filtered = 65
        ctrl_user2_out = 45
        analyzer2_ctrl_delta_f = 27
        analyzer2_y = 25
        in_detector_sum = 10
        fast_in2 = 68
        in_position_x = 2
        in_user4 = 8
        static = 30
        ramp_gen_ctrl_z = 37
        ramp_gen_test = 32
        memory_gen_drive_z = 56
        ramp_gen_position_w = 60
        comparator3_out = 66
        ramp_gen_plane_z = 36
        ramp_gen_approach = 33
        ort_baseline = 46
        ort_amplitude_reduction = 47
        analyzer1_ctrl_amplitude = 20
        ctrl_y_out = 42
        ctrl_z_in = 12
        in_position_z = 4
        fast_in_deflection = 67
        memory_gen_drive_x = 52
        in6 = 11
        ctrl_z_out = 14
        in_user3 = 7
        in_user2 = 6
        in_lateral = 1
        in_deflection = 0
        gen_test_dynamic = 31

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator1.attribute.source'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.comparator.comparator1.attribute.source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.comparator.comparator1.attribute.source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.comparator.comparator1.attribute.source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.comparator.comparator1.attribute.source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.comparator.comparator1.attribute.source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.comparator.comparator1.attribute.source.value_raw', new_val.value)


class RootLuComparatorComparator1AttributeDigital_true_level(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator1.attribute.digital_true_level'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator1.attribute.digital_true_level.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comparator.comparator1.attribute.digital_true_level.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comparator.comparator1.attribute.digital_true_level.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comparator.comparator1.attribute.digital_true_level.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator1.attribute.digital_true_level.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comparator.comparator1.attribute.digital_true_level.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator1.attribute.digital_true_level.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comparator.comparator1.attribute.digital_true_level.min', float(new_val))


class RootLuComparatorComparator1AttributeCurrent_in_filtered(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator1.attribute.current_in_filtered'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator1.attribute.current_in_filtered.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comparator.comparator1.attribute.current_in_filtered.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comparator.comparator1.attribute.current_in_filtered.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comparator.comparator1.attribute.current_in_filtered.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator1.attribute.current_in_filtered.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comparator.comparator1.attribute.current_in_filtered.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator1.attribute.current_in_filtered.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comparator.comparator1.attribute.current_in_filtered.min', float(new_val))


class RootLuComparatorComparator1AttributeDigital_false_level(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator1.attribute.digital_false_level'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator1.attribute.digital_false_level.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comparator.comparator1.attribute.digital_false_level.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comparator.comparator1.attribute.digital_false_level.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comparator.comparator1.attribute.digital_false_level.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator1.attribute.digital_false_level.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comparator.comparator1.attribute.digital_false_level.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator1.attribute.digital_false_level.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comparator.comparator1.attribute.digital_false_level.min', float(new_val))


class RootLuComparatorComparator1AttributeLevel(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator1.attribute.level'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator1.attribute.level.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.comparator.comparator1.attribute.level.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.comparator.comparator1.attribute.level.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.comparator.comparator1.attribute.level.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator1.attribute.level.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.comparator.comparator1.attribute.level.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.comparator.comparator1.attribute.level.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.comparator.comparator1.attribute.level.min', float(new_val))


class RootLuComparatorComparator1AttributeFilter_enable(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        enabled = 1
        disabled = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator1.attribute.filter_enable'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.lu.comparator.comparator1.attribute.filter_enable.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.lu.comparator.comparator1.attribute.filter_enable.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.lu.comparator.comparator1.attribute.filter_enable.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.lu.comparator.comparator1.attribute.filter_enable.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.lu.comparator.comparator1.attribute.filter_enable.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.lu.comparator.comparator1.attribute.filter_enable.value_raw', new_val.value)


class RootLuComparatorComparator1Attribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator1.attribute'
        self.filter_enable = RootLuComparatorComparator1AttributeFilter_enable(self._context)
        self.level = RootLuComparatorComparator1AttributeLevel(self._context)
        self.digital_false_level = RootLuComparatorComparator1AttributeDigital_false_level(self._context)
        self.current_in_filtered = RootLuComparatorComparator1AttributeCurrent_in_filtered(self._context)
        self.digital_true_level = RootLuComparatorComparator1AttributeDigital_true_level(self._context)
        self.source = RootLuComparatorComparator1AttributeSource(self._context)
        self.polarity = RootLuComparatorComparator1AttributePolarity(self._context)
        self.filter_coeff_vec = RootLuComparatorComparator1AttributeFilter_coeff_vec(self._context)
        self.current_out_value = RootLuComparatorComparator1AttributeCurrent_out_value(self._context)


class RootLuComparatorComparator1(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator.comparator1'
        self.attribute = RootLuComparatorComparator1Attribute(self._context)
        self.trigger = RootLuComparatorComparator1Trigger(self._context)


class RootLuComparator(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.comparator'
        self.comparator1 = RootLuComparatorComparator1(self._context)
        self.comparator3 = RootLuComparatorComparator3(self._context)
        self.comparator2 = RootLuComparatorComparator2(self._context)


class RootLuSequencerInstanceBusy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sequencer.instance.busy'

    @property
    def is_running(self) -> bool:
        return bool(self._context.call('root.lu.sequencer.instance.busy.is_running'))


class RootLuSequencerInstanceTrigger(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sequencer.instance.trigger'

    def step(self) -> None:
        return self._context.call('root.lu.sequencer.instance.trigger.step')

    def abort(self) -> None:
        return self._context.call('root.lu.sequencer.instance.trigger.abort')

    def start(self) -> None:
        return self._context.call('root.lu.sequencer.instance.trigger.start')


class RootLuSequencerInstanceAttributeSynchronized_data_acquisition(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sequencer.instance.attribute.synchronized_data_acquisition'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.sequencer.instance.attribute.synchronized_data_acquisition.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.sequencer.instance.attribute.synchronized_data_acquisition.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.sequencer.instance.attribute.synchronized_data_acquisition.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.sequencer.instance.attribute.synchronized_data_acquisition.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.sequencer.instance.attribute.synchronized_data_acquisition.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.sequencer.instance.attribute.synchronized_data_acquisition.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.sequencer.instance.attribute.synchronized_data_acquisition.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.sequencer.instance.attribute.synchronized_data_acquisition.min', float(new_val))


class RootLuSequencerInstanceAttributeStatus(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sequencer.instance.attribute.status'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.sequencer.instance.attribute.status.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.sequencer.instance.attribute.status.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.sequencer.instance.attribute.status.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.sequencer.instance.attribute.status.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.sequencer.instance.attribute.status.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.sequencer.instance.attribute.status.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.sequencer.instance.attribute.status.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.sequencer.instance.attribute.status.min', float(new_val))


class RootLuSequencerInstanceAttributeMemory_vec(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sequencer.instance.attribute.memory_vec'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.sequencer.instance.attribute.memory_vec.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.sequencer.instance.attribute.memory_vec.unit', str(new_val))

    @property
    def vector(self) -> list:
        return list(self._context.get('root.lu.sequencer.instance.attribute.memory_vec.vector'))

    @vector.setter
    def vector(self, new_val:list):
        self._context.set('root.lu.sequencer.instance.attribute.memory_vec.vector', list(new_val))

    def get_vector_value(self, index:int):
        return self._context.call('root.lu.sequencer.instance.attribute.memory_vec.get_vector_value',int(index))

    def set_vector_value(self, index:int, new_val:float):
        self._context.call('root.lu.sequencer.instance.attribute.memory_vec.set_vector_value', int(index), new_val)

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.sequencer.instance.attribute.memory_vec.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.sequencer.instance.attribute.memory_vec.max', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.sequencer.instance.attribute.memory_vec.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.sequencer.instance.attribute.memory_vec.min', float(new_val))


class RootLuSequencerInstanceAttributeInstruction_pointer(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sequencer.instance.attribute.instruction_pointer'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def max(self) -> float:
        return float(self._context.get('root.lu.sequencer.instance.attribute.instruction_pointer.max'))

    @max.setter
    def max(self, new_val:float):
        self._context.set('root.lu.sequencer.instance.attribute.instruction_pointer.max', float(new_val))

    @property
    def unit(self) -> str:
        return str(self._context.get('root.lu.sequencer.instance.attribute.instruction_pointer.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.lu.sequencer.instance.attribute.instruction_pointer.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.lu.sequencer.instance.attribute.instruction_pointer.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.lu.sequencer.instance.attribute.instruction_pointer.value', float(new_val))

    @property
    def min(self) -> float:
        return float(self._context.get('root.lu.sequencer.instance.attribute.instruction_pointer.min'))

    @min.setter
    def min(self, new_val:float):
        self._context.set('root.lu.sequencer.instance.attribute.instruction_pointer.min', float(new_val))


class RootLuSequencerInstanceAttribute(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sequencer.instance.attribute'
        self.instruction_pointer = RootLuSequencerInstanceAttributeInstruction_pointer(self._context)
        self.memory_vec = RootLuSequencerInstanceAttributeMemory_vec(self._context)
        self.status = RootLuSequencerInstanceAttributeStatus(self._context)
        self.synchronized_data_acquisition = RootLuSequencerInstanceAttributeSynchronized_data_acquisition(self._context)


class RootLuSequencerInstance(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sequencer.instance'
        self.attribute = RootLuSequencerInstanceAttribute(self._context)
        self.trigger = RootLuSequencerInstanceTrigger(self._context)
        self.busy = RootLuSequencerInstanceBusy(self._context)


class RootLuSequencer(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu.sequencer'
        self.instance = RootLuSequencerInstance(self._context)


class RootLu(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.lu'
        self.sequencer = RootLuSequencer(self._context)
        self.comparator = RootLuComparator(self._context)
        self.analog_fast_out = RootLuAnalog_fast_out(self._context)
        self.rescan = RootLuRescan(self._context)
        self.direct_motor_control = RootLuDirect_motor_control(self._context)
        self.frequency_sweep_gen = RootLuFrequency_sweep_gen(self._context)
        self.analog_hi_res_out = RootLuAnalog_hi_res_out(self._context)
        self.cantilever_properties = RootLuCantilever_properties(self._context)
        self.litho = RootLuLitho(self._context)
        self.data_acquisition = RootLuData_acquisition(self._context)
        self.auto_alignment = RootLuAuto_alignment(self._context)
        self.pid_controller = RootLuPid_controller(self._context)
        self.comp_dc = RootLuComp_dc(self._context)
        self.thermal_tuning = RootLuThermal_tuning(self._context)
        self.event_manager = RootLuEvent_manager(self._context)
        self.oscilloscope = RootLuOscilloscope(self._context)
        self.signal_analyzer = RootLuSignal_analyzer(self._context)
        self.analog_fast_in = RootLuAnalog_fast_in(self._context)
        self.system_infra = RootLuSystem_infra(self._context)
        self.scanhead = RootLuScanhead(self._context)
        self.analog_hi_res_in = RootLuAnalog_hi_res_in(self._context)
        self.system = RootLuSystem(self._context)
        self.hv_amplifier = RootLuHv_amplifier(self._context)
        self.z_controller_ex = RootLuZ_controller_ex(self._context)
        self.digi_user_io = RootLuDigi_user_io(self._context)
        self.timer = RootLuTimer(self._context)
        self.test = RootLuTest(self._context)
        self.memory_signal_gen = RootLuMemory_signal_gen(self._context)
        self.ort = RootLuOrt(self._context)
        self.isostage = RootLuIsostage(self._context)
        self.approach = RootLuApproach(self._context)
        self.ramp_generator = RootLuRamp_generator(self._context)
        self.position_control = RootLuPosition_control(self._context)
        self.scan = RootLuScan(self._context)
        self.sensor_control = RootLuSensor_control(self._context)
        self.mainboard_relays = RootLuMainboard_relays(self._context)
        self.timestamper = RootLuTimestamper(self._context)


class RootCoreDirect_laser_motor_control_none(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.direct_laser_motor_control_none'


class RootCoreFrequency_sweep(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.frequency_sweep'


class RootCoreHv_amp_holder_controlPropertyHigh_voltage_signal_source(wrap.CmdTreeProp):

    class ValueMask(enum.IntEnum):
        User_Input = 1
        CX_Controller = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.hv_amp_holder_control.property.high_voltage_signal_source'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.core.hv_amp_holder_control.property.high_voltage_signal_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.core.hv_amp_holder_control.property.high_voltage_signal_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.core.hv_amp_holder_control.property.high_voltage_signal_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.core.hv_amp_holder_control.property.high_voltage_signal_source.enum', list(new_val))

    @property
    def value(self) -> int:
        return int(self._context.get('root.core.hv_amp_holder_control.property.high_voltage_signal_source.value_raw'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.core.hv_amp_holder_control.property.high_voltage_signal_source.value_raw', int(new_val))


class RootCoreHv_amp_holder_controlPropertyFast_z_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.hv_amp_holder_control.property.fast_z_enabled'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.core.hv_amp_holder_control.property.fast_z_enabled.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.core.hv_amp_holder_control.property.fast_z_enabled.value', bool(new_val))


class RootCoreHv_amp_holder_controlProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.hv_amp_holder_control.property'
        self.fast_z_enabled = RootCoreHv_amp_holder_controlPropertyFast_z_enabled(self._context)
        self.high_voltage_signal_source = RootCoreHv_amp_holder_controlPropertyHigh_voltage_signal_source(self._context)


class RootCoreHv_amp_holder_control(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.hv_amp_holder_control'
        self.property = RootCoreHv_amp_holder_controlProperty(self._context)


class RootCoreTemplatePropertyName_prefix(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.template.property.name_prefix'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value(self) -> str:
        return str(self._context.get('root.core.template.property.name_prefix.value'))

    @value.setter
    def value(self, new_val:str):
        self._context.set('root.core.template.property.name_prefix.value', str(new_val))


class RootCoreTemplateProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.template.property'
        self.name_prefix = RootCoreTemplatePropertyName_prefix(self._context)


class RootCoreTemplateSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.template.signal'


class RootCoreTemplate(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.template'
        self.signal = RootCoreTemplateSignal(self._context)
        self.property = RootCoreTemplateProperty(self._context)

    def apply(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.template.apply', *args, **kwargs)


class RootCoreSpectroscopy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.spectroscopy'


class RootCoreConfig(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.config'


class RootCoreApproachPropertyDeflection_offset_voltage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach.property.deflection_offset_voltage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.approach.property.deflection_offset_voltage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.approach.property.deflection_offset_voltage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.approach.property.deflection_offset_voltage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.approach.property.deflection_offset_voltage.value', float(new_val))


class RootCoreApproachPropertyGentle_approach_enable(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach.property.gentle_approach_enable'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.core.approach.property.gentle_approach_enable.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.core.approach.property.gentle_approach_enable.value', bool(new_val))


class RootCoreApproachPropertyStep_by_step_coarse_step_size_percentage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach.property.step_by_step_coarse_step_size_percentage'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.approach.property.step_by_step_coarse_step_size_percentage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.approach.property.step_by_step_coarse_step_size_percentage.unit', str(new_val))

    @property
    def value(self) -> int:
        return int(self._context.get('root.core.approach.property.step_by_step_coarse_step_size_percentage.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.core.approach.property.step_by_step_coarse_step_size_percentage.value', int(new_val))


class RootCoreApproachPropertyWithdraw_step_distance(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach.property.withdraw_step_distance'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.approach.property.withdraw_step_distance.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.approach.property.withdraw_step_distance.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.approach.property.withdraw_step_distance.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.approach.property.withdraw_step_distance.value', float(new_val))


class RootCoreApproachPropertyStep_by_step_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach.property.step_by_step_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.approach.property.step_by_step_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.approach.property.step_by_step_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.approach.property.step_by_step_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.approach.property.step_by_step_speed.value', float(new_val))


class RootCoreApproachPropertyStep_by_step_fine_step_size_percentage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach.property.step_by_step_fine_step_size_percentage'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.approach.property.step_by_step_fine_step_size_percentage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.approach.property.step_by_step_fine_step_size_percentage.unit', str(new_val))

    @property
    def value(self) -> int:
        return int(self._context.get('root.core.approach.property.step_by_step_fine_step_size_percentage.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.core.approach.property.step_by_step_fine_step_size_percentage.value', int(new_val))


class RootCoreApproachPropertyStep_period(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach.property.step_period'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.approach.property.step_period.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.approach.property.step_period.value', float(new_val))


class RootCoreApproachPropertyApproach_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        External_Step_by_Step = 2
        Internal_Step_by_Step = 1
        Continuous = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach.property.approach_mode'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.core.approach.property.approach_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.core.approach.property.approach_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.core.approach.property.approach_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.core.approach.property.approach_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.core.approach.property.approach_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.core.approach.property.approach_mode.value_raw', new_val.value)


class RootCoreApproachPropertyWithdraw_step_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach.property.withdraw_step_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.approach.property.withdraw_step_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.approach.property.withdraw_step_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.approach.property.withdraw_step_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.approach.property.withdraw_step_speed.value', float(new_val))


class RootCoreApproachPropertyStep_by_step_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach.property.step_by_step_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.approach.property.step_by_step_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.approach.property.step_by_step_time.value', float(new_val))


class RootCoreApproachPropertyApproach_steps(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach.property.approach_steps'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.core.approach.property.approach_steps.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.core.approach.property.approach_steps.value', int(new_val))


class RootCoreApproachPropertyStep_by_step_slope(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach.property.step_by_step_slope'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.approach.property.step_by_step_slope.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.approach.property.step_by_step_slope.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.approach.property.step_by_step_slope.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.approach.property.step_by_step_slope.value', float(new_val))


class RootCoreApproachPropertyApproach_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach.property.approach_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.approach.property.approach_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.approach.property.approach_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.approach.property.approach_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.approach.property.approach_speed.value', float(new_val))


class RootCoreApproachPropertyApproach_pos(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach.property.approach_pos'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.approach.property.approach_pos.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.approach.property.approach_pos.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.approach.property.approach_pos.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.approach.property.approach_pos.value', float(new_val))


class RootCoreApproachProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach.property'
        self.approach_pos = RootCoreApproachPropertyApproach_pos(self._context)
        self.approach_speed = RootCoreApproachPropertyApproach_speed(self._context)
        self.step_by_step_slope = RootCoreApproachPropertyStep_by_step_slope(self._context)
        self.approach_steps = RootCoreApproachPropertyApproach_steps(self._context)
        self.step_by_step_time = RootCoreApproachPropertyStep_by_step_time(self._context)
        self.withdraw_step_speed = RootCoreApproachPropertyWithdraw_step_speed(self._context)
        self.approach_mode = RootCoreApproachPropertyApproach_mode(self._context)
        self.step_period = RootCoreApproachPropertyStep_period(self._context)
        self.step_by_step_fine_step_size_percentage = RootCoreApproachPropertyStep_by_step_fine_step_size_percentage(self._context)
        self.step_by_step_speed = RootCoreApproachPropertyStep_by_step_speed(self._context)
        self.withdraw_step_distance = RootCoreApproachPropertyWithdraw_step_distance(self._context)
        self.step_by_step_coarse_step_size_percentage = RootCoreApproachPropertyStep_by_step_coarse_step_size_percentage(self._context)
        self.gentle_approach_enable = RootCoreApproachPropertyGentle_approach_enable(self._context)
        self.deflection_offset_voltage = RootCoreApproachPropertyDeflection_offset_voltage(self._context)


class RootCoreApproachSignalApproach_done(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach.signal.approach_done'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.approach.signal.approach_done.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.approach.signal.approach_done.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.approach.signal.approach_done.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.approach.signal.approach_done.call', *args, **kwargs)


class RootCoreApproachSignalWithdraw_done(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach.signal.withdraw_done'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.approach.signal.withdraw_done.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.approach.signal.withdraw_done.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.approach.signal.withdraw_done.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.approach.signal.withdraw_done.call', *args, **kwargs)


class RootCoreApproachSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach.signal'
        self.withdraw_done = RootCoreApproachSignalWithdraw_done(self._context)
        self.approach_done = RootCoreApproachSignalApproach_done(self._context)


class RootCoreApproach(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.approach'
        self.signal = RootCoreApproachSignal(self._context)
        self.property = RootCoreApproachProperty(self._context)

    def approach(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.approach.approach', *args, **kwargs)

    def withdraw(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.approach.withdraw', *args, **kwargs)

    def abort(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.approach.abort', *args, **kwargs)


class RootCoreAcquisition(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.acquisition'

    def lu_data_buffer_timestamp(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.acquisition.lu_data_buffer_timestamp', *args, **kwargs)

    def synchronize_lu_data_buffer(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.acquisition.synchronize_lu_data_buffer', *args, **kwargs)

    def write_lu_data_buffer_raw(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.acquisition.write_lu_data_buffer_raw', *args, **kwargs)

    def lu_data_buffer_channel_range(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.acquisition.lu_data_buffer_channel_range', *args, **kwargs)

    def write_data(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.acquisition.write_data', *args, **kwargs)

    def trim_sampler_buffer(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.acquisition.trim_sampler_buffer', *args, **kwargs)

    def lu_data_buffer_data_type(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.acquisition.lu_data_buffer_data_type', *args, **kwargs)

    def lu_data_buffer_channel_data(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.acquisition.lu_data_buffer_channel_data', *args, **kwargs)

    def erase_lu_data_buffer(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.acquisition.erase_lu_data_buffer', *args, **kwargs)

    def reserve_lu_data_buffer(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.acquisition.reserve_lu_data_buffer', *args, **kwargs)

    def lu_data_buffer_channel_count(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.acquisition.lu_data_buffer_channel_count', *args, **kwargs)

    def lu_data_buffer_state(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.acquisition.lu_data_buffer_state', *args, **kwargs)

    def lu_data_buffer_channel_unit(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.acquisition.lu_data_buffer_channel_unit', *args, **kwargs)

    def lu_data_buffer_channel_name(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.acquisition.lu_data_buffer_channel_name', *args, **kwargs)


class RootCoreLaser_align_driveSignalAuto_align_search_step_finished(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.signal.auto_align_search_step_finished'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.auto_align_search_step_finished.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.auto_align_search_step_finished.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.auto_align_search_step_finished.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.auto_align_search_step_finished.call', *args, **kwargs)


class RootCoreLaser_align_driveSignalProcedure_info(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.signal.procedure_info'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.procedure_info.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.procedure_info.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.procedure_info.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.procedure_info.call', *args, **kwargs)


class RootCoreLaser_align_driveSignalAuto_align_finished(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.signal.auto_align_finished'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.auto_align_finished.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.auto_align_finished.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.auto_align_finished.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.auto_align_finished.call', *args, **kwargs)


class RootCoreLaser_align_driveSignalCenter_detector_finished(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.signal.center_detector_finished'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.center_detector_finished.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.center_detector_finished.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.center_detector_finished.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.center_detector_finished.call', *args, **kwargs)


class RootCoreLaser_align_driveSignalMotor_move_finished(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.signal.motor_move_finished'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.motor_move_finished.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.motor_move_finished.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.motor_move_finished.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.motor_move_finished.call', *args, **kwargs)


class RootCoreLaser_align_driveSignalMotor_move_started(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.signal.motor_move_started'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.motor_move_started.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.motor_move_started.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.motor_move_started.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.laser_align_drive.signal.motor_move_started.call', *args, **kwargs)


class RootCoreLaser_align_driveSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.signal'
        self.motor_move_started = RootCoreLaser_align_driveSignalMotor_move_started(self._context)
        self.motor_move_finished = RootCoreLaser_align_driveSignalMotor_move_finished(self._context)
        self.center_detector_finished = RootCoreLaser_align_driveSignalCenter_detector_finished(self._context)
        self.auto_align_finished = RootCoreLaser_align_driveSignalAuto_align_finished(self._context)
        self.procedure_info = RootCoreLaser_align_driveSignalProcedure_info(self._context)
        self.auto_align_search_step_finished = RootCoreLaser_align_driveSignalAuto_align_search_step_finished(self._context)


class RootCoreLaser_align_drivePropertyDeflection_normal(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.deflection_normal'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.laser_align_drive.property.deflection_normal.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.laser_align_drive.property.deflection_normal.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.laser_align_drive.property.deflection_normal.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.laser_align_drive.property.deflection_normal.value', float(new_val))


class RootCoreLaser_align_drivePropertyLaser_spot_intensity(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.laser_spot_intensity'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.laser_align_drive.property.laser_spot_intensity.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.laser_align_drive.property.laser_spot_intensity.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.laser_align_drive.property.laser_spot_intensity.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.laser_align_drive.property.laser_spot_intensity.value', float(new_val))


class RootCoreLaser_align_drivePropertyMotor_beam_shifter_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.motor_beam_shifter_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.laser_align_drive.property.motor_beam_shifter_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.laser_align_drive.property.motor_beam_shifter_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.laser_align_drive.property.motor_beam_shifter_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.laser_align_drive.property.motor_beam_shifter_position.value', float(new_val))


class RootCoreLaser_align_drivePropertyMotor_laser_clean_drive_y_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.motor_laser_clean_drive_y_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.laser_align_drive.property.motor_laser_clean_drive_y_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.laser_align_drive.property.motor_laser_clean_drive_y_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.laser_align_drive.property.motor_laser_clean_drive_y_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.laser_align_drive.property.motor_laser_clean_drive_y_position.value', float(new_val))


class RootCoreLaser_align_drivePropertyLaser_readout_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.laser_readout_enabled'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.core.laser_align_drive.property.laser_readout_enabled.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.core.laser_align_drive.property.laser_readout_enabled.value', bool(new_val))


class RootCoreLaser_align_drivePropertyMotor_laser_focus_z_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.motor_laser_focus_z_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.laser_align_drive.property.motor_laser_focus_z_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.laser_align_drive.property.motor_laser_focus_z_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.laser_align_drive.property.motor_laser_focus_z_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.laser_align_drive.property.motor_laser_focus_z_position.value', float(new_val))


class RootCoreLaser_align_drivePropertyDeflection_lateral(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.deflection_lateral'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.laser_align_drive.property.deflection_lateral.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.laser_align_drive.property.deflection_lateral.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.laser_align_drive.property.deflection_lateral.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.laser_align_drive.property.deflection_lateral.value', float(new_val))


class RootCoreLaser_align_drivePropertyMotor_speed_optics_motors(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.motor_speed_optics_motors'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.laser_align_drive.property.motor_speed_optics_motors.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.laser_align_drive.property.motor_speed_optics_motors.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.laser_align_drive.property.motor_speed_optics_motors.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.laser_align_drive.property.motor_speed_optics_motors.value', float(new_val))


class RootCoreLaser_align_drivePropertyMotor_laser_readout_x_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.motor_laser_readout_x_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.laser_align_drive.property.motor_laser_readout_x_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.laser_align_drive.property.motor_laser_readout_x_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.laser_align_drive.property.motor_laser_readout_x_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.laser_align_drive.property.motor_laser_readout_x_position.value', float(new_val))


class RootCoreLaser_align_drivePropertyMotor_laser_photodetector_y_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.motor_laser_photodetector_y_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.laser_align_drive.property.motor_laser_photodetector_y_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.laser_align_drive.property.motor_laser_photodetector_y_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.laser_align_drive.property.motor_laser_photodetector_y_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.laser_align_drive.property.motor_laser_photodetector_y_position.value', float(new_val))


class RootCoreLaser_align_drivePropertyMotor_speed_max_beam_shifter(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.motor_speed_max_beam_shifter'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.laser_align_drive.property.motor_speed_max_beam_shifter.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.laser_align_drive.property.motor_speed_max_beam_shifter.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.laser_align_drive.property.motor_speed_max_beam_shifter.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.laser_align_drive.property.motor_speed_max_beam_shifter.value', float(new_val))


class RootCoreLaser_align_drivePropertySensor_status(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Low = 1
        High = 3
        Fail = 4
        Ok = 2
        Undefined = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.sensor_status'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.core.laser_align_drive.property.sensor_status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.core.laser_align_drive.property.sensor_status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.core.laser_align_drive.property.sensor_status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.core.laser_align_drive.property.sensor_status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.core.laser_align_drive.property.sensor_status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.core.laser_align_drive.property.sensor_status.value_raw', new_val.value)


class RootCoreLaser_align_drivePropertyMotor_speed_max_laser_motors(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.motor_speed_max_laser_motors'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.laser_align_drive.property.motor_speed_max_laser_motors.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.laser_align_drive.property.motor_speed_max_laser_motors.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.laser_align_drive.property.motor_speed_max_laser_motors.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.laser_align_drive.property.motor_speed_max_laser_motors.value', float(new_val))


class RootCoreLaser_align_drivePropertyMotor_laser_photodetector_x_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.motor_laser_photodetector_x_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.laser_align_drive.property.motor_laser_photodetector_x_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.laser_align_drive.property.motor_laser_photodetector_x_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.laser_align_drive.property.motor_laser_photodetector_x_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.laser_align_drive.property.motor_laser_photodetector_x_position.value', float(new_val))


class RootCoreLaser_align_drivePropertyMotor_speed_max_laser_focus(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.motor_speed_max_laser_focus'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.laser_align_drive.property.motor_speed_max_laser_focus.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.laser_align_drive.property.motor_speed_max_laser_focus.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.laser_align_drive.property.motor_speed_max_laser_focus.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.laser_align_drive.property.motor_speed_max_laser_focus.value', float(new_val))


class RootCoreLaser_align_drivePropertyMotor_laser_readout_y_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.motor_laser_readout_y_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.laser_align_drive.property.motor_laser_readout_y_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.laser_align_drive.property.motor_laser_readout_y_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.laser_align_drive.property.motor_laser_readout_y_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.laser_align_drive.property.motor_laser_readout_y_position.value', float(new_val))


class RootCoreLaser_align_drivePropertyDeflection_offset_calibration_status(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Calibration_Error = 1
        Sensor_Signal_Failed = 2
        No_Error = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.deflection_offset_calibration_status'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.core.laser_align_drive.property.deflection_offset_calibration_status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.core.laser_align_drive.property.deflection_offset_calibration_status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.core.laser_align_drive.property.deflection_offset_calibration_status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.core.laser_align_drive.property.deflection_offset_calibration_status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.core.laser_align_drive.property.deflection_offset_calibration_status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.core.laser_align_drive.property.deflection_offset_calibration_status.value_raw', new_val.value)


class RootCoreLaser_align_drivePropertyMotor_laser_clean_drive_x_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.motor_laser_clean_drive_x_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.laser_align_drive.property.motor_laser_clean_drive_x_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.laser_align_drive.property.motor_laser_clean_drive_x_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.laser_align_drive.property.motor_laser_clean_drive_x_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.laser_align_drive.property.motor_laser_clean_drive_x_position.value', float(new_val))


class RootCoreLaser_align_drivePropertyLaser_readout_power(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property.laser_readout_power'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.laser_align_drive.property.laser_readout_power.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.laser_align_drive.property.laser_readout_power.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.laser_align_drive.property.laser_readout_power.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.laser_align_drive.property.laser_readout_power.value', float(new_val))


class RootCoreLaser_align_driveProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive.property'
        self.laser_readout_power = RootCoreLaser_align_drivePropertyLaser_readout_power(self._context)
        self.motor_laser_clean_drive_x_position = RootCoreLaser_align_drivePropertyMotor_laser_clean_drive_x_position(self._context)
        self.deflection_offset_calibration_status = RootCoreLaser_align_drivePropertyDeflection_offset_calibration_status(self._context)
        self.motor_laser_readout_y_position = RootCoreLaser_align_drivePropertyMotor_laser_readout_y_position(self._context)
        self.motor_speed_max_laser_focus = RootCoreLaser_align_drivePropertyMotor_speed_max_laser_focus(self._context)
        self.motor_laser_photodetector_x_position = RootCoreLaser_align_drivePropertyMotor_laser_photodetector_x_position(self._context)
        self.motor_speed_max_laser_motors = RootCoreLaser_align_drivePropertyMotor_speed_max_laser_motors(self._context)
        self.sensor_status = RootCoreLaser_align_drivePropertySensor_status(self._context)
        self.motor_speed_max_beam_shifter = RootCoreLaser_align_drivePropertyMotor_speed_max_beam_shifter(self._context)
        self.motor_laser_photodetector_y_position = RootCoreLaser_align_drivePropertyMotor_laser_photodetector_y_position(self._context)
        self.motor_laser_readout_x_position = RootCoreLaser_align_drivePropertyMotor_laser_readout_x_position(self._context)
        self.motor_speed_optics_motors = RootCoreLaser_align_drivePropertyMotor_speed_optics_motors(self._context)
        self.deflection_lateral = RootCoreLaser_align_drivePropertyDeflection_lateral(self._context)
        self.motor_laser_focus_z_position = RootCoreLaser_align_drivePropertyMotor_laser_focus_z_position(self._context)
        self.laser_readout_enabled = RootCoreLaser_align_drivePropertyLaser_readout_enabled(self._context)
        self.motor_laser_clean_drive_y_position = RootCoreLaser_align_drivePropertyMotor_laser_clean_drive_y_position(self._context)
        self.motor_beam_shifter_position = RootCoreLaser_align_drivePropertyMotor_beam_shifter_position(self._context)
        self.laser_spot_intensity = RootCoreLaser_align_drivePropertyLaser_spot_intensity(self._context)
        self.deflection_normal = RootCoreLaser_align_drivePropertyDeflection_normal(self._context)


class RootCoreLaser_align_drive(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.laser_align_drive'
        self.property = RootCoreLaser_align_driveProperty(self._context)
        self.signal = RootCoreLaser_align_driveSignal(self._context)


class RootCoreMonitoring(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.monitoring'


class RootCoreMeasurement_setup(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.measurement_setup'


class RootCoreDirect_approach_motor_control_drivePropertyRelative_motor_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.direct_approach_motor_control_drive.property.relative_motor_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.direct_approach_motor_control_drive.property.relative_motor_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.direct_approach_motor_control_drive.property.relative_motor_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.direct_approach_motor_control_drive.property.relative_motor_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.direct_approach_motor_control_drive.property.relative_motor_speed.value', float(new_val))


class RootCoreDirect_approach_motor_control_driveProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.direct_approach_motor_control_drive.property'
        self.relative_motor_speed = RootCoreDirect_approach_motor_control_drivePropertyRelative_motor_speed(self._context)


class RootCoreDirect_approach_motor_control_driveSignalMotor_approach_position_changed(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.direct_approach_motor_control_drive.signal.motor_approach_position_changed'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.direct_approach_motor_control_drive.signal.motor_approach_position_changed.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.direct_approach_motor_control_drive.signal.motor_approach_position_changed.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.direct_approach_motor_control_drive.signal.motor_approach_position_changed.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.direct_approach_motor_control_drive.signal.motor_approach_position_changed.call', *args, **kwargs)


class RootCoreDirect_approach_motor_control_driveSignalMotor_approach_move_started(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.direct_approach_motor_control_drive.signal.motor_approach_move_started'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.direct_approach_motor_control_drive.signal.motor_approach_move_started.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.direct_approach_motor_control_drive.signal.motor_approach_move_started.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.direct_approach_motor_control_drive.signal.motor_approach_move_started.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.direct_approach_motor_control_drive.signal.motor_approach_move_started.call', *args, **kwargs)


class RootCoreDirect_approach_motor_control_driveSignalMotor_approach_move_finished(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.direct_approach_motor_control_drive.signal.motor_approach_move_finished'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.direct_approach_motor_control_drive.signal.motor_approach_move_finished.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.direct_approach_motor_control_drive.signal.motor_approach_move_finished.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.direct_approach_motor_control_drive.signal.motor_approach_move_finished.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.direct_approach_motor_control_drive.signal.motor_approach_move_finished.call', *args, **kwargs)


class RootCoreDirect_approach_motor_control_driveSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.direct_approach_motor_control_drive.signal'
        self.motor_approach_move_finished = RootCoreDirect_approach_motor_control_driveSignalMotor_approach_move_finished(self._context)
        self.motor_approach_move_started = RootCoreDirect_approach_motor_control_driveSignalMotor_approach_move_started(self._context)
        self.motor_approach_position_changed = RootCoreDirect_approach_motor_control_driveSignalMotor_approach_position_changed(self._context)


class RootCoreDirect_approach_motor_control_drive(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.direct_approach_motor_control_drive'
        self.signal = RootCoreDirect_approach_motor_control_driveSignal(self._context)
        self.property = RootCoreDirect_approach_motor_control_driveProperty(self._context)

    def start_moving_motors(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.direct_approach_motor_control_drive.start_moving_motors', *args, **kwargs)

    def stop_motors(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.direct_approach_motor_control_drive.stop_motors', *args, **kwargs)

    def move_motors_by_step(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.direct_approach_motor_control_drive.move_motors_by_step', *args, **kwargs)

    def zero_position(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.direct_approach_motor_control_drive.zero_position', *args, **kwargs)

    def reference_motors(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.direct_approach_motor_control_drive.reference_motors', *args, **kwargs)


class RootCoreSignal_registration(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.signal_registration'


class RootCorePosition_control(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.position_control'


class RootCoreScan_head(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.scan_head'


class RootCoreVshi(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.vshi'


class RootCoreImaging(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.imaging'


class RootCoreExcitation_laser(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.excitation_laser'


class RootCoreSpm_probes_database(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.spm_probes_database'


class RootCoreI2c(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.i2c'


class RootCoreSampler(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.sampler'


class RootCoreTest_data_generator(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.test_data_generator'


class RootCoreHv_amp_head_control_sim(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.hv_amp_head_control_sim'


class RootCoreSpm_controller(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.spm_controller'


class RootCoreExcitation_piezo(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.excitation_piezo'


class RootCoreUser_outPropertyHi_res_input1(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Fast_In_Deflection = 16
        Analyzer_1_Phase_Error = 77
        Ramp_User_Out_3 = 53
        Analyzer_2_Ctrl_Amp_ = 85
        Z_Controller_In = 63
        Fast_In_2 = 17
        User_In_1 = 9
        Fast_Z_Axis_Controller_Out = 71
        Generator_Drive_X = 46
        Comparator_2_Out = 100
        Ramp_Gen_X = 54
        Z_Controller_Nominal = 68
        Generator_Nominal_X = 45
        Ramp_Tip_Voltage = 57
        Analyzer_1_Amplitude = 78
        Analyzer_1_X = 79
        Generator_Drive_Z = 50
        Position_Z = 8
        Comparator_1_In_Filtered = 97
        Analyzer_2_Reference = 90
        Deflection = 4
        Comparator_1_Out = 98
        Analyzer_1_Y = 80
        Ramp_Gen_Z_Max = 62
        Z_Controller_Out = 67
        Analyzer_2_X = 88
        Ramp_Gen_Fast_Z_Axis = 56
        Y_Controller_Out = 70
        X_Controller_Out = 69
        Controller_User_1_Out = 72
        Ramp_Gen_Z_Plane = 60
        Comparator_3_In_Filtered = 101
        Analyzer_1_Reference = 81
        Tip_Current = 13
        Controller_User_2_Out = 73
        Comparator_3_Out = 102
        Lateral = 5
        Analyzer_1_Ctrl_Delta_f = 75
        Gen_Test_Dynamic = 2
        Position_X = 6
        User_In_4 = 12
        User_In_3 = 11
        Static = 0
        Z_Controller_Sum = 66
        WaveMode_Baseline = 93
        Generator_Spare_7 = 51
        Analyzer_1_Ctrl_Amp_ = 76
        Detector_Sum = 14
        Analyzer_2_Ctrl_Delta_f = 84
        Ramp_Gen_Y = 55
        Generator_Drive_Y = 48
        Ramp_User_Out_4 = 59
        Z_Controller_Error = 64
        Interface_In_Aux = 15
        WaveMode_Amp_Reduct_ = 94
        Fast_In_User = 18
        User_In_2 = 10
        Z_Controller_PID_Out = 65
        Ramp_User_Out_2 = 3
        Position_Y = 7
        Analyzer_2_Amplitude = 87
        Ramp_Gen_Z_Ctrl_ = 61
        Ramp_User_Out_1 = 58
        WaveMode_Excitation = 95
        Analyzer_2_Phase_Error = 86
        Analyzer_2_Y = 89
        Generator_Nominal_Y = 47
        Comparator_2_In_Filtered = 99
        Generator_Nominal_Z = 49
        Generator_Spare_8 = 52

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.user_out.property.hi_res_input1'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.core.user_out.property.hi_res_input1.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.core.user_out.property.hi_res_input1.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.core.user_out.property.hi_res_input1.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.core.user_out.property.hi_res_input1.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.core.user_out.property.hi_res_input1.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.core.user_out.property.hi_res_input1.value_raw', new_val.value)


class RootCoreUser_outPropertyFast_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Fast_In_User = 18
        Fast_Z_Axis_Controller_Out = 71
        Z_Controller_Out = 67
        Analyzer_1_Reference = 81
        Fast_In_2 = 17
        Analyzer_2_Reference = 90
        Deflection = 4
        WaveMode_Excitation = 95
        Static = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.user_out.property.fast_input'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.core.user_out.property.fast_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.core.user_out.property.fast_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.core.user_out.property.fast_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.core.user_out.property.fast_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.core.user_out.property.fast_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.core.user_out.property.fast_input.value_raw', new_val.value)


class RootCoreUser_outPropertyHi_res2_ramp_voltage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.user_out.property.hi_res2_ramp_voltage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.user_out.property.hi_res2_ramp_voltage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.user_out.property.hi_res2_ramp_voltage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.user_out.property.hi_res2_ramp_voltage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.user_out.property.hi_res2_ramp_voltage.value', float(new_val))


class RootCoreUser_outPropertyHi_res4_ramp_voltage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.user_out.property.hi_res4_ramp_voltage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.user_out.property.hi_res4_ramp_voltage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.user_out.property.hi_res4_ramp_voltage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.user_out.property.hi_res4_ramp_voltage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.user_out.property.hi_res4_ramp_voltage.value', float(new_val))


class RootCoreUser_outPropertyHi_res_input4(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Fast_In_Deflection = 16
        Analyzer_1_Phase_Error = 77
        Ramp_User_Out_3 = 53
        Analyzer_2_Ctrl_Amp_ = 85
        Z_Controller_In = 63
        Fast_In_2 = 17
        User_In_1 = 9
        Fast_Z_Axis_Controller_Out = 71
        Generator_Drive_X = 46
        Comparator_2_Out = 100
        Ramp_Gen_X = 54
        Z_Controller_Nominal = 68
        Generator_Nominal_X = 45
        Ramp_Tip_Voltage = 57
        Analyzer_1_Amplitude = 78
        Analyzer_1_X = 79
        Generator_Drive_Z = 50
        Position_Z = 8
        Comparator_1_In_Filtered = 97
        Analyzer_2_Reference = 90
        Deflection = 4
        Comparator_1_Out = 98
        Analyzer_1_Y = 80
        Ramp_Gen_Z_Max = 62
        Z_Controller_Out = 67
        Analyzer_2_X = 88
        Ramp_Gen_Fast_Z_Axis = 56
        Y_Controller_Out = 70
        X_Controller_Out = 69
        Controller_User_1_Out = 72
        Ramp_Gen_Z_Plane = 60
        Comparator_3_In_Filtered = 101
        Analyzer_1_Reference = 81
        Tip_Current = 13
        Controller_User_2_Out = 73
        Comparator_3_Out = 102
        Lateral = 5
        Analyzer_1_Ctrl_Delta_f = 75
        Gen_Test_Dynamic = 2
        Position_X = 6
        User_In_4 = 12
        User_In_3 = 11
        Static = 0
        Z_Controller_Sum = 66
        WaveMode_Baseline = 93
        Generator_Spare_7 = 51
        Analyzer_1_Ctrl_Amp_ = 76
        Detector_Sum = 14
        Analyzer_2_Ctrl_Delta_f = 84
        Ramp_Gen_Y = 55
        Generator_Drive_Y = 48
        Ramp_User_Out_4 = 59
        Z_Controller_Error = 64
        Interface_In_Aux = 15
        WaveMode_Amp_Reduct_ = 94
        Fast_In_User = 18
        User_In_2 = 10
        Z_Controller_PID_Out = 65
        Ramp_User_Out_2 = 3
        Position_Y = 7
        Analyzer_2_Amplitude = 87
        Ramp_Gen_Z_Ctrl_ = 61
        Ramp_User_Out_1 = 58
        WaveMode_Excitation = 95
        Analyzer_2_Phase_Error = 86
        Analyzer_2_Y = 89
        Generator_Nominal_Y = 47
        Comparator_2_In_Filtered = 99
        Generator_Nominal_Z = 49
        Generator_Spare_8 = 52

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.user_out.property.hi_res_input4'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.core.user_out.property.hi_res_input4.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.core.user_out.property.hi_res_input4.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.core.user_out.property.hi_res_input4.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.core.user_out.property.hi_res_input4.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.core.user_out.property.hi_res_input4.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.core.user_out.property.hi_res_input4.value_raw', new_val.value)


class RootCoreUser_outPropertyHi_res1_ramp_voltage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.user_out.property.hi_res1_ramp_voltage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.user_out.property.hi_res1_ramp_voltage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.user_out.property.hi_res1_ramp_voltage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.user_out.property.hi_res1_ramp_voltage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.user_out.property.hi_res1_ramp_voltage.value', float(new_val))


class RootCoreUser_outPropertyHi_res_input2(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Fast_In_Deflection = 16
        Analyzer_1_Phase_Error = 77
        Ramp_User_Out_3 = 53
        Analyzer_2_Ctrl_Amp_ = 85
        Z_Controller_In = 63
        Fast_In_2 = 17
        User_In_1 = 9
        Fast_Z_Axis_Controller_Out = 71
        Generator_Drive_X = 46
        Comparator_2_Out = 100
        Ramp_Gen_X = 54
        Z_Controller_Nominal = 68
        Generator_Nominal_X = 45
        Ramp_Tip_Voltage = 57
        Analyzer_1_Amplitude = 78
        Analyzer_1_X = 79
        Generator_Drive_Z = 50
        Position_Z = 8
        Comparator_1_In_Filtered = 97
        Analyzer_2_Reference = 90
        Deflection = 4
        Comparator_1_Out = 98
        Analyzer_1_Y = 80
        Ramp_Gen_Z_Max = 62
        Z_Controller_Out = 67
        Analyzer_2_X = 88
        Ramp_Gen_Fast_Z_Axis = 56
        Y_Controller_Out = 70
        X_Controller_Out = 69
        Controller_User_1_Out = 72
        Ramp_Gen_Z_Plane = 60
        Comparator_3_In_Filtered = 101
        Analyzer_1_Reference = 81
        Tip_Current = 13
        Controller_User_2_Out = 73
        Comparator_3_Out = 102
        Lateral = 5
        Analyzer_1_Ctrl_Delta_f = 75
        Gen_Test_Dynamic = 2
        Position_X = 6
        User_In_4 = 12
        User_In_3 = 11
        Static = 0
        Z_Controller_Sum = 66
        WaveMode_Baseline = 93
        Generator_Spare_7 = 51
        Analyzer_1_Ctrl_Amp_ = 76
        Detector_Sum = 14
        Analyzer_2_Ctrl_Delta_f = 84
        Ramp_Gen_Y = 55
        Generator_Drive_Y = 48
        Ramp_User_Out_4 = 59
        Z_Controller_Error = 64
        Interface_In_Aux = 15
        WaveMode_Amp_Reduct_ = 94
        Fast_In_User = 18
        User_In_2 = 10
        Z_Controller_PID_Out = 65
        Ramp_User_Out_2 = 3
        Position_Y = 7
        Analyzer_2_Amplitude = 87
        Ramp_Gen_Z_Ctrl_ = 61
        Ramp_User_Out_1 = 58
        WaveMode_Excitation = 95
        Analyzer_2_Phase_Error = 86
        Analyzer_2_Y = 89
        Generator_Nominal_Y = 47
        Comparator_2_In_Filtered = 99
        Generator_Nominal_Z = 49
        Generator_Spare_8 = 52

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.user_out.property.hi_res_input2'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.core.user_out.property.hi_res_input2.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.core.user_out.property.hi_res_input2.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.core.user_out.property.hi_res_input2.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.core.user_out.property.hi_res_input2.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.core.user_out.property.hi_res_input2.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.core.user_out.property.hi_res_input2.value_raw', new_val.value)


class RootCoreUser_outPropertyHi_res_input3(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Fast_In_Deflection = 16
        Analyzer_1_Phase_Error = 77
        Ramp_User_Out_3 = 53
        Analyzer_2_Ctrl_Amp_ = 85
        Z_Controller_In = 63
        Fast_In_2 = 17
        User_In_1 = 9
        Fast_Z_Axis_Controller_Out = 71
        Generator_Drive_X = 46
        Comparator_2_Out = 100
        Ramp_Gen_X = 54
        Z_Controller_Nominal = 68
        Generator_Nominal_X = 45
        Ramp_Tip_Voltage = 57
        Analyzer_1_Amplitude = 78
        Analyzer_1_X = 79
        Generator_Drive_Z = 50
        Position_Z = 8
        Comparator_1_In_Filtered = 97
        Analyzer_2_Reference = 90
        Deflection = 4
        Comparator_1_Out = 98
        Analyzer_1_Y = 80
        Ramp_Gen_Z_Max = 62
        Z_Controller_Out = 67
        Analyzer_2_X = 88
        Ramp_Gen_Fast_Z_Axis = 56
        Y_Controller_Out = 70
        X_Controller_Out = 69
        Controller_User_1_Out = 72
        Ramp_Gen_Z_Plane = 60
        Comparator_3_In_Filtered = 101
        Analyzer_1_Reference = 81
        Tip_Current = 13
        Controller_User_2_Out = 73
        Comparator_3_Out = 102
        Lateral = 5
        Analyzer_1_Ctrl_Delta_f = 75
        Gen_Test_Dynamic = 2
        Position_X = 6
        User_In_4 = 12
        User_In_3 = 11
        Static = 0
        Z_Controller_Sum = 66
        WaveMode_Baseline = 93
        Generator_Spare_7 = 51
        Analyzer_1_Ctrl_Amp_ = 76
        Detector_Sum = 14
        Analyzer_2_Ctrl_Delta_f = 84
        Ramp_Gen_Y = 55
        Generator_Drive_Y = 48
        Ramp_User_Out_4 = 59
        Z_Controller_Error = 64
        Interface_In_Aux = 15
        WaveMode_Amp_Reduct_ = 94
        Fast_In_User = 18
        User_In_2 = 10
        Z_Controller_PID_Out = 65
        Ramp_User_Out_2 = 3
        Position_Y = 7
        Analyzer_2_Amplitude = 87
        Ramp_Gen_Z_Ctrl_ = 61
        Ramp_User_Out_1 = 58
        WaveMode_Excitation = 95
        Analyzer_2_Phase_Error = 86
        Analyzer_2_Y = 89
        Generator_Nominal_Y = 47
        Comparator_2_In_Filtered = 99
        Generator_Nominal_Z = 49
        Generator_Spare_8 = 52

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.user_out.property.hi_res_input3'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.core.user_out.property.hi_res_input3.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.core.user_out.property.hi_res_input3.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.core.user_out.property.hi_res_input3.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.core.user_out.property.hi_res_input3.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.core.user_out.property.hi_res_input3.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.core.user_out.property.hi_res_input3.value_raw', new_val.value)


class RootCoreUser_outPropertyHi_res3_ramp_voltage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.user_out.property.hi_res3_ramp_voltage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.user_out.property.hi_res3_ramp_voltage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.user_out.property.hi_res3_ramp_voltage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.user_out.property.hi_res3_ramp_voltage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.user_out.property.hi_res3_ramp_voltage.value', float(new_val))


class RootCoreUser_outProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.user_out.property'
        self.hi_res3_ramp_voltage = RootCoreUser_outPropertyHi_res3_ramp_voltage(self._context)
        self.hi_res_input3 = RootCoreUser_outPropertyHi_res_input3(self._context)
        self.hi_res_input2 = RootCoreUser_outPropertyHi_res_input2(self._context)
        self.hi_res1_ramp_voltage = RootCoreUser_outPropertyHi_res1_ramp_voltage(self._context)
        self.hi_res_input4 = RootCoreUser_outPropertyHi_res_input4(self._context)
        self.hi_res4_ramp_voltage = RootCoreUser_outPropertyHi_res4_ramp_voltage(self._context)
        self.hi_res2_ramp_voltage = RootCoreUser_outPropertyHi_res2_ramp_voltage(self._context)
        self.fast_input = RootCoreUser_outPropertyFast_input(self._context)
        self.hi_res_input1 = RootCoreUser_outPropertyHi_res_input1(self._context)


class RootCoreUser_out(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.user_out'
        self.property = RootCoreUser_outProperty(self._context)


class RootCoreStorage(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.storage'

    def open_file(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.storage.open_file', *args, **kwargs)

    def is_file_open(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.storage.is_file_open', *args, **kwargs)


class RootCoreTip_voltagePropertyTip_ramp_voltage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.tip_voltage.property.tip_ramp_voltage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.tip_voltage.property.tip_ramp_voltage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.tip_voltage.property.tip_ramp_voltage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.tip_voltage.property.tip_ramp_voltage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.tip_voltage.property.tip_ramp_voltage.value', float(new_val))


class RootCoreTip_voltagePropertyInput(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Fast_In_Deflection = 16
        Analyzer_1_Phase_Error = 77
        Ramp_User_Out_3 = 53
        Analyzer_2_Ctrl_Amp_ = 85
        Z_Controller_In = 63
        Fast_In_2 = 17
        User_In_1 = 9
        Fast_Z_Axis_Controller_Out = 71
        Generator_Drive_X = 46
        Comparator_2_Out = 100
        Ramp_Gen_X = 54
        Z_Controller_Nominal = 68
        Generator_Nominal_X = 45
        Ramp_Tip_Voltage = 57
        Analyzer_1_Amplitude = 78
        Analyzer_1_X = 79
        Generator_Drive_Z = 50
        Position_Z = 8
        Comparator_1_In_Filtered = 97
        Analyzer_2_Reference = 90
        Deflection = 4
        Comparator_1_Out = 98
        Analyzer_1_Y = 80
        Ramp_Gen_Z_Max = 62
        Z_Controller_Out = 67
        Analyzer_2_X = 88
        Ramp_Gen_Fast_Z_Axis = 56
        Y_Controller_Out = 70
        X_Controller_Out = 69
        Controller_User_1_Out = 72
        Ramp_Gen_Z_Plane = 60
        Comparator_3_In_Filtered = 101
        Analyzer_1_Reference = 81
        Tip_Current = 13
        Controller_User_2_Out = 73
        Comparator_3_Out = 102
        Lateral = 5
        Analyzer_1_Ctrl_Delta_f = 75
        Gen_Test_Dynamic = 2
        Position_X = 6
        User_In_4 = 12
        User_In_3 = 11
        Static = 0
        Z_Controller_Sum = 66
        WaveMode_Baseline = 93
        Generator_Spare_7 = 51
        Analyzer_1_Ctrl_Amp_ = 76
        Detector_Sum = 14
        Analyzer_2_Ctrl_Delta_f = 84
        Ramp_Gen_Y = 55
        Generator_Drive_Y = 48
        Ramp_User_Out_4 = 59
        Z_Controller_Error = 64
        Interface_In_Aux = 15
        WaveMode_Amp_Reduct_ = 94
        Fast_In_User = 18
        User_In_2 = 10
        Z_Controller_PID_Out = 65
        Ramp_User_Out_2 = 3
        Position_Y = 7
        Analyzer_2_Amplitude = 87
        Ramp_Gen_Z_Ctrl_ = 61
        Ramp_User_Out_1 = 58
        WaveMode_Excitation = 95
        Analyzer_2_Phase_Error = 86
        Analyzer_2_Y = 89
        Generator_Nominal_Y = 47
        Comparator_2_In_Filtered = 99
        Generator_Nominal_Z = 49
        Generator_Spare_8 = 52

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.tip_voltage.property.input'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.core.tip_voltage.property.input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.core.tip_voltage.property.input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.core.tip_voltage.property.input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.core.tip_voltage.property.input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.core.tip_voltage.property.input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.core.tip_voltage.property.input.value_raw', new_val.value)


class RootCoreTip_voltageProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.tip_voltage.property'
        self.input = RootCoreTip_voltagePropertyInput(self._context)
        self.tip_ramp_voltage = RootCoreTip_voltagePropertyTip_ramp_voltage(self._context)


class RootCoreTip_voltage(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.tip_voltage'
        self.property = RootCoreTip_voltageProperty(self._context)

    def apply(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.tip_voltage.apply', *args, **kwargs)


class RootCoreOrtPropertyDown_sample_factor(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.ort.property.down_sample_factor'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.core.ort.property.down_sample_factor.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.core.ort.property.down_sample_factor.value', int(new_val))


class RootCoreOrtPropertyBaseline_window_end(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.ort.property.baseline_window_end'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.ort.property.baseline_window_end.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.ort.property.baseline_window_end.value', float(new_val))


class RootCoreOrtPropertyFeedback_amplitude_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.ort.property.feedback_amplitude_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.ort.property.feedback_amplitude_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.ort.property.feedback_amplitude_position.value', float(new_val))


class RootCoreOrtPropertyFeedback_amplitude_average_width(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.ort.property.feedback_amplitude_average_width'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.ort.property.feedback_amplitude_average_width.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.ort.property.feedback_amplitude_average_width.value', float(new_val))


class RootCoreOrtPropertyAverage_periods(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.ort.property.average_periods'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.core.ort.property.average_periods.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.core.ort.property.average_periods.value', int(new_val))


class RootCoreOrtPropertyBaseline_frequency(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.ort.property.baseline_frequency'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.ort.property.baseline_frequency.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.ort.property.baseline_frequency.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.ort.property.baseline_frequency.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.ort.property.baseline_frequency.value', float(new_val))


class RootCoreOrtPropertyInput_select(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Fast_In_Deflection = 0
        Fast_In_Deflection_at_Hi_Res_Rate = 4
        Fast_In_User_at_Hi_Res_Rate = 5
        Hi_Res_In_User1 = 3
        Fast_In_User = 2
        Hi_Res_In_Deflection = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.ort.property.input_select'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.core.ort.property.input_select.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.core.ort.property.input_select.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.core.ort.property.input_select.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.core.ort.property.input_select.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.core.ort.property.input_select.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.core.ort.property.input_select.value_raw', new_val.value)


class RootCoreOrtPropertyBaseline_controller_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.ort.property.baseline_controller_enabled'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.core.ort.property.baseline_controller_enabled.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.core.ort.property.baseline_controller_enabled.value', bool(new_val))


class RootCoreOrtPropertyBaseline_window_begin(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.ort.property.baseline_window_begin'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.ort.property.baseline_window_begin.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.ort.property.baseline_window_begin.value', float(new_val))


class RootCoreOrtPropertyPeriod_duration(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.ort.property.period_duration'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.ort.property.period_duration.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.ort.property.period_duration.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.ort.property.period_duration.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.ort.property.period_duration.value', float(new_val))


class RootCoreOrtProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.ort.property'
        self.period_duration = RootCoreOrtPropertyPeriod_duration(self._context)
        self.baseline_window_begin = RootCoreOrtPropertyBaseline_window_begin(self._context)
        self.baseline_controller_enabled = RootCoreOrtPropertyBaseline_controller_enabled(self._context)
        self.input_select = RootCoreOrtPropertyInput_select(self._context)
        self.baseline_frequency = RootCoreOrtPropertyBaseline_frequency(self._context)
        self.average_periods = RootCoreOrtPropertyAverage_periods(self._context)
        self.feedback_amplitude_average_width = RootCoreOrtPropertyFeedback_amplitude_average_width(self._context)
        self.feedback_amplitude_position = RootCoreOrtPropertyFeedback_amplitude_position(self._context)
        self.baseline_window_end = RootCoreOrtPropertyBaseline_window_end(self._context)
        self.down_sample_factor = RootCoreOrtPropertyDown_sample_factor(self._context)


class RootCoreOrt(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.ort'
        self.property = RootCoreOrtProperty(self._context)

    def apply_period_duration(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.ort.apply_period_duration', *args, **kwargs)

    def update_free_wave(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.ort.update_free_wave', *args, **kwargs)

    def excitation_amplitude(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.ort.excitation_amplitude', *args, **kwargs)

    def is_averaging(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.ort.is_averaging', *args, **kwargs)

    def select_input(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.ort.select_input', *args, **kwargs)

    def apply_samples_values(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.ort.apply_samples_values', *args, **kwargs)


class RootCoreZ_controllerPropertyP_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_controller.property.p_gain'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.core.z_controller.property.p_gain.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.core.z_controller.property.p_gain.value', int(new_val))


class RootCoreZ_controllerPropertyIdle_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Enable_Z_Controller = 0
        Keep_Last_Z_Position = 2
        Set_Z_Position = 3
        Retract_Tip = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_controller.property.idle_mode'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.core.z_controller.property.idle_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.core.z_controller.property.idle_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.core.z_controller.property.idle_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.core.z_controller.property.idle_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.core.z_controller.property.idle_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.core.z_controller.property.idle_mode.value_raw', new_val.value)


class RootCoreZ_controllerPropertyMin_z_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_controller.property.min_z_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.z_controller.property.min_z_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.z_controller.property.min_z_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.z_controller.property.min_z_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.z_controller.property.min_z_value.value', float(new_val))


class RootCoreZ_controllerPropertyFeedback_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        negative = 1
        positive = 0
        invalid = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_controller.property.feedback_polarity'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.core.z_controller.property.feedback_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.core.z_controller.property.feedback_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.core.z_controller.property.feedback_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.core.z_controller.property.feedback_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.core.z_controller.property.feedback_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.core.z_controller.property.feedback_polarity.value_raw', new_val.value)


class RootCoreZ_controllerPropertySetpoint(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_controller.property.setpoint'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.z_controller.property.setpoint.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.z_controller.property.setpoint.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.z_controller.property.setpoint.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.z_controller.property.setpoint.value', float(new_val))


class RootCoreZ_controllerPropertyClosed_loop_d_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_controller.property.closed_loop_d_gain'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.core.z_controller.property.closed_loop_d_gain.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.core.z_controller.property.closed_loop_d_gain.value', int(new_val))


class RootCoreZ_controllerPropertyClosed_loop_p_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_controller.property.closed_loop_p_gain'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.core.z_controller.property.closed_loop_p_gain.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.core.z_controller.property.closed_loop_p_gain.value', int(new_val))


class RootCoreZ_controllerPropertyStep_size(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_controller.property.step_size'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.z_controller.property.step_size.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.z_controller.property.step_size.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.z_controller.property.step_size.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.z_controller.property.step_size.value', float(new_val))


class RootCoreZ_controllerPropertyI_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_controller.property.i_gain'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.core.z_controller.property.i_gain.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.core.z_controller.property.i_gain.value', int(new_val))


class RootCoreZ_controllerPropertyIdle_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_controller.property.idle_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.z_controller.property.idle_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.z_controller.property.idle_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.z_controller.property.idle_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.z_controller.property.idle_position.value', float(new_val))


class RootCoreZ_controllerPropertyD_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_controller.property.d_gain'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.core.z_controller.property.d_gain.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.core.z_controller.property.d_gain.value', int(new_val))


class RootCoreZ_controllerPropertyClosed_loop_i_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_controller.property.closed_loop_i_gain'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.core.z_controller.property.closed_loop_i_gain.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.core.z_controller.property.closed_loop_i_gain.value', int(new_val))


class RootCoreZ_controllerPropertyActual_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Fast_In_Deflection = 16
        Analyzer_1_Phase_Error = 77
        Ramp_User_Out_3 = 53
        Analyzer_2_Ctrl_Amp_ = 85
        Z_Controller_In = 63
        Fast_In_2 = 17
        User_In_1 = 9
        Fast_Z_Axis_Controller_Out = 71
        Generator_Drive_X = 46
        Comparator_2_Out = 100
        Ramp_Gen_X = 54
        Z_Controller_Nominal = 68
        Generator_Nominal_X = 45
        Ramp_Tip_Voltage = 57
        Analyzer_1_Amplitude = 78
        Analyzer_1_X = 79
        Generator_Drive_Z = 50
        Position_Z = 8
        Comparator_1_In_Filtered = 97
        Analyzer_2_Reference = 90
        Deflection = 4
        Comparator_1_Out = 98
        Analyzer_1_Y = 80
        Ramp_Gen_Z_Max = 62
        Z_Controller_Out = 67
        Analyzer_2_X = 88
        Ramp_Gen_Fast_Z_Axis = 56
        Y_Controller_Out = 70
        X_Controller_Out = 69
        Controller_User_1_Out = 72
        Ramp_Gen_Z_Plane = 60
        Comparator_3_In_Filtered = 101
        Analyzer_1_Reference = 81
        Tip_Current = 13
        Controller_User_2_Out = 73
        Comparator_3_Out = 102
        Lateral = 5
        Analyzer_1_Ctrl_Delta_f = 75
        Gen_Test_Dynamic = 2
        Position_X = 6
        User_In_4 = 12
        User_In_3 = 11
        Static = 0
        Z_Controller_Sum = 66
        WaveMode_Baseline = 93
        Generator_Spare_7 = 51
        Analyzer_1_Ctrl_Amp_ = 76
        Detector_Sum = 14
        Analyzer_2_Ctrl_Delta_f = 84
        Ramp_Gen_Y = 55
        Generator_Drive_Y = 48
        Ramp_User_Out_4 = 59
        Z_Controller_Error = 64
        Interface_In_Aux = 15
        WaveMode_Amp_Reduct_ = 94
        Fast_In_User = 18
        User_In_2 = 10
        Z_Controller_PID_Out = 65
        Ramp_User_Out_2 = 3
        Position_Y = 7
        Analyzer_2_Amplitude = 87
        Ramp_Gen_Z_Ctrl_ = 61
        Ramp_User_Out_1 = 58
        WaveMode_Excitation = 95
        Analyzer_2_Phase_Error = 86
        Analyzer_2_Y = 89
        Generator_Nominal_Y = 47
        Comparator_2_In_Filtered = 99
        Generator_Nominal_Z = 49
        Generator_Spare_8 = 52

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_controller.property.actual_input'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.core.z_controller.property.actual_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.core.z_controller.property.actual_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.core.z_controller.property.actual_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.core.z_controller.property.actual_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.core.z_controller.property.actual_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.core.z_controller.property.actual_input.value_raw', new_val.value)


class RootCoreZ_controllerProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_controller.property'
        self.actual_input = RootCoreZ_controllerPropertyActual_input(self._context)
        self.closed_loop_i_gain = RootCoreZ_controllerPropertyClosed_loop_i_gain(self._context)
        self.d_gain = RootCoreZ_controllerPropertyD_gain(self._context)
        self.idle_position = RootCoreZ_controllerPropertyIdle_position(self._context)
        self.i_gain = RootCoreZ_controllerPropertyI_gain(self._context)
        self.step_size = RootCoreZ_controllerPropertyStep_size(self._context)
        self.closed_loop_p_gain = RootCoreZ_controllerPropertyClosed_loop_p_gain(self._context)
        self.closed_loop_d_gain = RootCoreZ_controllerPropertyClosed_loop_d_gain(self._context)
        self.setpoint = RootCoreZ_controllerPropertySetpoint(self._context)
        self.feedback_polarity = RootCoreZ_controllerPropertyFeedback_polarity(self._context)
        self.min_z_value = RootCoreZ_controllerPropertyMin_z_value(self._context)
        self.idle_mode = RootCoreZ_controllerPropertyIdle_mode(self._context)
        self.p_gain = RootCoreZ_controllerPropertyP_gain(self._context)


class RootCoreZ_controllerSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_controller.signal'


class RootCoreZ_controller(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_controller'
        self.signal = RootCoreZ_controllerSignal(self._context)
        self.property = RootCoreZ_controllerProperty(self._context)

    def retract_tip(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.z_controller.retract_tip', *args, **kwargs)


class RootCoreOptions(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.options'


class RootCoreHwm(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.hwm'


class RootCoreZ_external_controllerPropertyAxis_connected(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_external_controller.property.axis_connected'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.core.z_external_controller.property.axis_connected.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.core.z_external_controller.property.axis_connected.value', bool(new_val))


class RootCoreZ_external_controllerPropertyIdle_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Retract_Axis = 0
        Set_Z_Position = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_external_controller.property.idle_mode'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.core.z_external_controller.property.idle_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.core.z_external_controller.property.idle_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.core.z_external_controller.property.idle_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.core.z_external_controller.property.idle_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.core.z_external_controller.property.idle_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.core.z_external_controller.property.idle_mode.value_raw', new_val.value)


class RootCoreZ_external_controllerPropertyIdle_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_external_controller.property.idle_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.z_external_controller.property.idle_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.z_external_controller.property.idle_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.z_external_controller.property.idle_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.z_external_controller.property.idle_position.value', float(new_val))


class RootCoreZ_external_controllerProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_external_controller.property'
        self.idle_position = RootCoreZ_external_controllerPropertyIdle_position(self._context)
        self.idle_mode = RootCoreZ_external_controllerPropertyIdle_mode(self._context)
        self.axis_connected = RootCoreZ_external_controllerPropertyAxis_connected(self._context)


class RootCoreZ_external_controller(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_external_controller'
        self.property = RootCoreZ_external_controllerProperty(self._context)


class RootCoreComp_dc(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.comp_dc'


class RootCoreZ_fast_controller_simPropertyIdle_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Retract_Axis = 1
        Enable_Fast_Z_Controller = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_fast_controller_sim.property.idle_mode'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.core.z_fast_controller_sim.property.idle_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.core.z_fast_controller_sim.property.idle_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.core.z_fast_controller_sim.property.idle_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.core.z_fast_controller_sim.property.idle_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.core.z_fast_controller_sim.property.idle_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.core.z_fast_controller_sim.property.idle_mode.value_raw', new_val.value)


class RootCoreZ_fast_controller_simPropertyI_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_fast_controller_sim.property.i_gain'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.core.z_fast_controller_sim.property.i_gain.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.core.z_fast_controller_sim.property.i_gain.value', int(new_val))


class RootCoreZ_fast_controller_simProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_fast_controller_sim.property'
        self.i_gain = RootCoreZ_fast_controller_simPropertyI_gain(self._context)
        self.idle_mode = RootCoreZ_fast_controller_simPropertyIdle_mode(self._context)


class RootCoreZ_fast_controller_sim(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.z_fast_controller_sim'
        self.property = RootCoreZ_fast_controller_simProperty(self._context)


class RootCoreOptions_store(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.options_store'


class RootCoreThermal_tunePropertyResolution(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.thermal_tune.property.resolution'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.thermal_tune.property.resolution.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.thermal_tune.property.resolution.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.thermal_tune.property.resolution.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.thermal_tune.property.resolution.value', float(new_val))


class RootCoreThermal_tunePropertyMeasurement_environment(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Air = 0
        Liquid = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.thermal_tune.property.measurement_environment'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.core.thermal_tune.property.measurement_environment.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.core.thermal_tune.property.measurement_environment.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.core.thermal_tune.property.measurement_environment.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.core.thermal_tune.property.measurement_environment.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.core.thermal_tune.property.measurement_environment.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.core.thermal_tune.property.measurement_environment.value_raw', new_val.value)


class RootCoreThermal_tunePropertyTemperature(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.thermal_tune.property.temperature'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.thermal_tune.property.temperature.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.thermal_tune.property.temperature.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.thermal_tune.property.temperature.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.thermal_tune.property.temperature.value', float(new_val))


class RootCoreThermal_tunePropertyFit_frequency_lower_bound(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.thermal_tune.property.fit_frequency_lower_bound'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.thermal_tune.property.fit_frequency_lower_bound.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.thermal_tune.property.fit_frequency_lower_bound.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.thermal_tune.property.fit_frequency_lower_bound.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.thermal_tune.property.fit_frequency_lower_bound.value', float(new_val))


class RootCoreThermal_tunePropertyMax_frequency(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.thermal_tune.property.max_frequency'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.thermal_tune.property.max_frequency.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.thermal_tune.property.max_frequency.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.thermal_tune.property.max_frequency.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.thermal_tune.property.max_frequency.value', float(new_val))


class RootCoreThermal_tunePropertyFit_frequency_upper_bound(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.thermal_tune.property.fit_frequency_upper_bound'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.core.thermal_tune.property.fit_frequency_upper_bound.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.core.thermal_tune.property.fit_frequency_upper_bound.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.core.thermal_tune.property.fit_frequency_upper_bound.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.core.thermal_tune.property.fit_frequency_upper_bound.value', float(new_val))


class RootCoreThermal_tunePropertyIterations(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.thermal_tune.property.iterations'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.core.thermal_tune.property.iterations.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.core.thermal_tune.property.iterations.value', int(new_val))


class RootCoreThermal_tuneProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.thermal_tune.property'
        self.iterations = RootCoreThermal_tunePropertyIterations(self._context)
        self.fit_frequency_upper_bound = RootCoreThermal_tunePropertyFit_frequency_upper_bound(self._context)
        self.max_frequency = RootCoreThermal_tunePropertyMax_frequency(self._context)
        self.fit_frequency_lower_bound = RootCoreThermal_tunePropertyFit_frequency_lower_bound(self._context)
        self.temperature = RootCoreThermal_tunePropertyTemperature(self._context)
        self.measurement_environment = RootCoreThermal_tunePropertyMeasurement_environment(self._context)
        self.resolution = RootCoreThermal_tunePropertyResolution(self._context)


class RootCoreThermal_tuneSignalFetch_blocks_end(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.thermal_tune.signal.fetch_blocks_end'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.fetch_blocks_end.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.fetch_blocks_end.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.fetch_blocks_end.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.fetch_blocks_end.call', *args, **kwargs)


class RootCoreThermal_tuneSignalData_invalidated(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.thermal_tune.signal.data_invalidated'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.data_invalidated.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.data_invalidated.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.data_invalidated.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.data_invalidated.call', *args, **kwargs)


class RootCoreThermal_tuneSignalNew_calibration_data(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.thermal_tune.signal.new_calibration_data'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.new_calibration_data.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.new_calibration_data.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.new_calibration_data.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.new_calibration_data.call', *args, **kwargs)


class RootCoreThermal_tuneSignalFit_failed(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.thermal_tune.signal.fit_failed'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.fit_failed.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.fit_failed.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.fit_failed.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.fit_failed.call', *args, **kwargs)


class RootCoreThermal_tuneSignalNew_data_block(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.thermal_tune.signal.new_data_block'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.new_data_block.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.new_data_block.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.new_data_block.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.new_data_block.call', *args, **kwargs)


class RootCoreThermal_tuneSignalNew_fit(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.thermal_tune.signal.new_fit'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.new_fit.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.new_fit.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.new_fit.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.new_fit.call', *args, **kwargs)


class RootCoreThermal_tuneSignalNew_average(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.thermal_tune.signal.new_average'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.new_average.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.new_average.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.new_average.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.signal.new_average.call', *args, **kwargs)


class RootCoreThermal_tuneSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.thermal_tune.signal'
        self.new_average = RootCoreThermal_tuneSignalNew_average(self._context)
        self.new_fit = RootCoreThermal_tuneSignalNew_fit(self._context)
        self.new_data_block = RootCoreThermal_tuneSignalNew_data_block(self._context)
        self.fit_failed = RootCoreThermal_tuneSignalFit_failed(self._context)
        self.new_calibration_data = RootCoreThermal_tuneSignalNew_calibration_data(self._context)
        self.data_invalidated = RootCoreThermal_tuneSignalData_invalidated(self._context)
        self.fetch_blocks_end = RootCoreThermal_tuneSignalFetch_blocks_end(self._context)


class RootCoreThermal_tune(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.thermal_tune'
        self.signal = RootCoreThermal_tuneSignal(self._context)
        self.property = RootCoreThermal_tuneProperty(self._context)

    def create_fit_from_fft_average_buffer(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.create_fit_from_fft_average_buffer', *args, **kwargs)

    def generate_frequency_list(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.generate_frequency_list', *args, **kwargs)

    def start(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.start', *args, **kwargs)

    def abort(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.abort', *args, **kwargs)

    def add_raw_data_to_fft_average_buffer(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.add_raw_data_to_fft_average_buffer', *args, **kwargs)

    def set_thermal_tune_parameters(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.set_thermal_tune_parameters', *args, **kwargs)

    def calculate_cantilever_calibration(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.thermal_tune.calculate_cantilever_calibration', *args, **kwargs)


class RootCoreStageSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.stage.signal'


class RootCoreStage(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.stage'
        self.signal = RootCoreStageSignal(self._context)

    def stages(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.stage.stages', *args, **kwargs)

    def remove_stage(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.stage.remove_stage', *args, **kwargs)

    def instances(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.stage.instances', *args, **kwargs)

    def delete_instance(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.stage.delete_instance', *args, **kwargs)

    def init_stages(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.stage.init_stages', *args, **kwargs)

    def add_stage(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.stage.add_stage', *args, **kwargs)

    def create_instance(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.stage.create_instance', *args, **kwargs)


class RootCoreConverter_channel_correction(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.converter_channel_correction'


class RootCoreGain_finderSignalGain_finder_failed(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.gain_finder.signal.gain_finder_failed'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.signal.gain_finder_failed.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.signal.gain_finder_failed.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.signal.gain_finder_failed.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.signal.gain_finder_failed.call', *args, **kwargs)


class RootCoreGain_finderSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.gain_finder.signal'
        self.gain_finder_failed = RootCoreGain_finderSignalGain_finder_failed(self._context)


class RootCoreGain_finder(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.gain_finder'
        self.signal = RootCoreGain_finderSignal(self._context)

    def sample_std_dev_of_error(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.sample_std_dev_of_error', *args, **kwargs)

    def set_initial_loop_std_dev_min(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.set_initial_loop_std_dev_min', *args, **kwargs)

    def sample_mean_of_error(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.sample_mean_of_error', *args, **kwargs)

    def reset_proposal_for_igain_to_original(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.reset_proposal_for_igain_to_original', *args, **kwargs)

    def set_original_z_controller_igain(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.set_original_z_controller_igain', *args, **kwargs)

    def set_up_data_sampler(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.set_up_data_sampler', *args, **kwargs)

    def set_initial_loop_igain_step_size(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.set_initial_loop_igain_step_size', *args, **kwargs)

    def get_gain_finder_loop_igain(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.get_gain_finder_loop_igain', *args, **kwargs)

    def z_controller_output_at_limit(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.z_controller_output_at_limit', *args, **kwargs)

    def update_proposal_for_igain(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.update_proposal_for_igain', *args, **kwargs)

    def update_loop_igain(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.update_loop_igain', *args, **kwargs)

    def get_original_z_controller_igain(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.get_original_z_controller_igain', *args, **kwargs)

    def threshold_violated_by_samples(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.threshold_violated_by_samples', *args, **kwargs)

    def threshold_for_mean_error_satisfied(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.threshold_for_mean_error_satisfied', *args, **kwargs)

    def max_allowed_igain_surpassed(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.max_allowed_igain_surpassed', *args, **kwargs)

    def set_initial_loop_igain(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.set_initial_loop_igain', *args, **kwargs)

    def abort_sampling(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.abort_sampling', *args, **kwargs)

    def set_initial_loop_max_mean_error(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.gain_finder.set_initial_loop_max_mean_error', *args, **kwargs)


class RootCoreCantilever(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.cantilever'


class RootCoreScanner_ddcSignalSweep_progress(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.scanner_ddc.signal.sweep_progress'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.signal.sweep_progress.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.signal.sweep_progress.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.signal.sweep_progress.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.signal.sweep_progress.call', *args, **kwargs)


class RootCoreScanner_ddcSignalSweep_failed(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.scanner_ddc.signal.sweep_failed'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.signal.sweep_failed.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.signal.sweep_failed.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.signal.sweep_failed.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.signal.sweep_failed.call', *args, **kwargs)


class RootCoreScanner_ddcSignalSweep_succeeded(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.scanner_ddc.signal.sweep_succeeded'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.signal.sweep_succeeded.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.signal.sweep_succeeded.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.signal.sweep_succeeded.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.signal.sweep_succeeded.call', *args, **kwargs)


class RootCoreScanner_ddcSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.scanner_ddc.signal'
        self.sweep_succeeded = RootCoreScanner_ddcSignalSweep_succeeded(self._context)
        self.sweep_failed = RootCoreScanner_ddcSignalSweep_failed(self._context)
        self.sweep_progress = RootCoreScanner_ddcSignalSweep_progress(self._context)


class RootCoreScanner_ddc(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.scanner_ddc'
        self.signal = RootCoreScanner_ddcSignal(self._context)

    def process_sweep_data(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.process_sweep_data', *args, **kwargs)

    def load_from_config(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.load_from_config', *args, **kwargs)

    def init(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.init', *args, **kwargs)

    def save_to_config(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.save_to_config', *args, **kwargs)

    def set_ddc_filter_rate(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.set_ddc_filter_rate', *args, **kwargs)

    def apply_results(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.apply_results', *args, **kwargs)

    def abort_sweep(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.abort_sweep', *args, **kwargs)

    def start_sweep(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.start_sweep', *args, **kwargs)

    def set_ddc_filter(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.scanner_ddc.set_ddc_filter', *args, **kwargs)


class RootCoreNice_sim(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.nice_sim'


class RootCoreEnvironment(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.environment'


class RootCoreSystem_checks(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.system_checks'


class RootCoreFluid_fm(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.fluid_fm'


class RootCoreSignal_store(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.signal_store'

    def connect_signals_non_linear(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.signal_store.connect_signals_non_linear', *args, **kwargs)

    def create_signal(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.signal_store.create_signal', *args, **kwargs)

    def connect_signals_logarithmic(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.signal_store.connect_signals_logarithmic', *args, **kwargs)

    def connect_signals_linear(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.signal_store.connect_signals_linear', *args, **kwargs)

    def remove_signal(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.signal_store.remove_signal', *args, **kwargs)

    def signal_calibration_unit(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.signal_store.signal_calibration_unit', *args, **kwargs)

    def connect_signals_exponential(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.signal_store.connect_signals_exponential', *args, **kwargs)

    def signal_calibration_minmax(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.signal_store.signal_calibration_minmax', *args, **kwargs)

    def export_calibration_graph(self, *args, **kwargs) -> Any:
        return self._context.call('root.core.signal_store.export_calibration_graph', *args, **kwargs)


class RootCoreSignal_analyzer1(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.signal_analyzer1'


class RootCoreLoaded_calibration(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core.loaded_calibration'


class RootCore(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.core'
        self.loaded_calibration = RootCoreLoaded_calibration(self._context)
        self.signal_analyzer1 = RootCoreSignal_analyzer1(self._context)
        self.signal_store = RootCoreSignal_store(self._context)
        self.fluid_fm = RootCoreFluid_fm(self._context)
        self.system_checks = RootCoreSystem_checks(self._context)
        self.environment = RootCoreEnvironment(self._context)
        self.nice_sim = RootCoreNice_sim(self._context)
        self.scanner_ddc = RootCoreScanner_ddc(self._context)
        self.cantilever = RootCoreCantilever(self._context)
        self.gain_finder = RootCoreGain_finder(self._context)
        self.converter_channel_correction = RootCoreConverter_channel_correction(self._context)
        self.stage = RootCoreStage(self._context)
        self.thermal_tune = RootCoreThermal_tune(self._context)
        self.options_store = RootCoreOptions_store(self._context)
        self.z_fast_controller_sim = RootCoreZ_fast_controller_sim(self._context)
        self.comp_dc = RootCoreComp_dc(self._context)
        self.z_external_controller = RootCoreZ_external_controller(self._context)
        self.hwm = RootCoreHwm(self._context)
        self.options = RootCoreOptions(self._context)
        self.z_controller = RootCoreZ_controller(self._context)
        self.ort = RootCoreOrt(self._context)
        self.tip_voltage = RootCoreTip_voltage(self._context)
        self.storage = RootCoreStorage(self._context)
        self.user_out = RootCoreUser_out(self._context)
        self.excitation_piezo = RootCoreExcitation_piezo(self._context)
        self.spm_controller = RootCoreSpm_controller(self._context)
        self.hv_amp_head_control_sim = RootCoreHv_amp_head_control_sim(self._context)
        self.test_data_generator = RootCoreTest_data_generator(self._context)
        self.sampler = RootCoreSampler(self._context)
        self.i2c = RootCoreI2c(self._context)
        self.spm_probes_database = RootCoreSpm_probes_database(self._context)
        self.excitation_laser = RootCoreExcitation_laser(self._context)
        self.imaging = RootCoreImaging(self._context)
        self.vshi = RootCoreVshi(self._context)
        self.scan_head = RootCoreScan_head(self._context)
        self.position_control = RootCorePosition_control(self._context)
        self.signal_registration = RootCoreSignal_registration(self._context)
        self.direct_approach_motor_control_drive = RootCoreDirect_approach_motor_control_drive(self._context)
        self.measurement_setup = RootCoreMeasurement_setup(self._context)
        self.monitoring = RootCoreMonitoring(self._context)
        self.laser_align_drive = RootCoreLaser_align_drive(self._context)
        self.acquisition = RootCoreAcquisition(self._context)
        self.approach = RootCoreApproach(self._context)
        self.config = RootCoreConfig(self._context)
        self.spectroscopy = RootCoreSpectroscopy(self._context)
        self.template = RootCoreTemplate(self._context)
        self.hv_amp_holder_control = RootCoreHv_amp_holder_control(self._context)
        self.frequency_sweep = RootCoreFrequency_sweep(self._context)
        self.direct_laser_motor_control_none = RootCoreDirect_laser_motor_control_none(self._context)


class RootWorkflowAuto_setup(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.auto_setup'

    def auto_setup_start(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.auto_setup.auto_setup_start', *args, **kwargs)

    def auto_setup_stop(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.auto_setup.auto_setup_stop', *args, **kwargs)


class RootWorkflowDynamic(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.dynamic'


class RootWorkflowFrequency_sweepPropertyExcitation_amplitude_laser(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.property.excitation_amplitude_laser'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.frequency_sweep.property.excitation_amplitude_laser.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.frequency_sweep.property.excitation_amplitude_laser.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.frequency_sweep.property.excitation_amplitude_laser.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.frequency_sweep.property.excitation_amplitude_laser.value', float(new_val))


class RootWorkflowFrequency_sweepPropertySweep_frequency_step(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.property.sweep_frequency_step'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.frequency_sweep.property.sweep_frequency_step.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.frequency_sweep.property.sweep_frequency_step.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.frequency_sweep.property.sweep_frequency_step.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.frequency_sweep.property.sweep_frequency_step.value', float(new_val))


class RootWorkflowFrequency_sweepPropertyCalculated_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.property.calculated_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.frequency_sweep.property.calculated_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.frequency_sweep.property.calculated_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.frequency_sweep.property.calculated_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.frequency_sweep.property.calculated_amplitude.value', float(new_val))


class RootWorkflowFrequency_sweepPropertyFrequency_selection_criteria(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Above_Peak = 1
        Below_Peak = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.property.frequency_selection_criteria'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.frequency_sweep.property.frequency_selection_criteria.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.frequency_sweep.property.frequency_selection_criteria.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.frequency_sweep.property.frequency_selection_criteria.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.frequency_sweep.property.frequency_selection_criteria.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.frequency_sweep.property.frequency_selection_criteria.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.frequency_sweep.property.frequency_selection_criteria.value_raw', new_val.value)


class RootWorkflowFrequency_sweepPropertyMeasurement_environment(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Air = 0
        Liquid = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.property.measurement_environment'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.frequency_sweep.property.measurement_environment.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.frequency_sweep.property.measurement_environment.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.frequency_sweep.property.measurement_environment.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.frequency_sweep.property.measurement_environment.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.frequency_sweep.property.measurement_environment.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.frequency_sweep.property.measurement_environment.value_raw', new_val.value)


class RootWorkflowFrequency_sweepPropertyExcitation_amplitude_piezo(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.property.excitation_amplitude_piezo'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.frequency_sweep.property.excitation_amplitude_piezo.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.frequency_sweep.property.excitation_amplitude_piezo.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.frequency_sweep.property.excitation_amplitude_piezo.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.frequency_sweep.property.excitation_amplitude_piezo.value', float(new_val))


class RootWorkflowFrequency_sweepPropertyAnalyzer_demodulator_bandwidth(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        num_100_kHz = 13
        num_12_kHz = 10
        num_23_kHz = 11
        num_1500_Hz = 7
        num_750_Hz = 6
        num_3_kHz = 8
        num_500_kHz = 15
        num_360_Hz = 5
        num_230_kHz = 14
        num_180_Hz = 4
        num_6_kHz = 9
        num_90_Hz = 3
        num_45_kHz = 12

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.property.analyzer_demodulator_bandwidth'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.frequency_sweep.property.analyzer_demodulator_bandwidth.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.frequency_sweep.property.analyzer_demodulator_bandwidth.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.frequency_sweep.property.analyzer_demodulator_bandwidth.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.frequency_sweep.property.analyzer_demodulator_bandwidth.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.frequency_sweep.property.analyzer_demodulator_bandwidth.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.frequency_sweep.property.analyzer_demodulator_bandwidth.value_raw', new_val.value)


class RootWorkflowFrequency_sweepPropertyNew_excitation_frequency(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.property.new_excitation_frequency'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.frequency_sweep.property.new_excitation_frequency.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.frequency_sweep.property.new_excitation_frequency.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.frequency_sweep.property.new_excitation_frequency.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.frequency_sweep.property.new_excitation_frequency.value', float(new_val))


class RootWorkflowFrequency_sweepPropertyCurrent_sweep_range(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Coarse = 0
        Fine = 1
        Custom = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.property.current_sweep_range'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.frequency_sweep.property.current_sweep_range.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.frequency_sweep.property.current_sweep_range.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.frequency_sweep.property.current_sweep_range.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.frequency_sweep.property.current_sweep_range.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.frequency_sweep.property.current_sweep_range.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.frequency_sweep.property.current_sweep_range.value_raw', new_val.value)


class RootWorkflowFrequency_sweepPropertyNew_spring_constant(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.property.new_spring_constant'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.frequency_sweep.property.new_spring_constant.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.frequency_sweep.property.new_spring_constant.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.frequency_sweep.property.new_spring_constant.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.frequency_sweep.property.new_spring_constant.value', float(new_val))


class RootWorkflowFrequency_sweepPropertySweep_frequency_lower_bound(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.property.sweep_frequency_lower_bound'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.frequency_sweep.property.sweep_frequency_lower_bound.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.frequency_sweep.property.sweep_frequency_lower_bound.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.frequency_sweep.property.sweep_frequency_lower_bound.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.frequency_sweep.property.sweep_frequency_lower_bound.value', float(new_val))


class RootWorkflowFrequency_sweepPropertyFit_frequency_lower_bound(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.property.fit_frequency_lower_bound'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.frequency_sweep.property.fit_frequency_lower_bound.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.frequency_sweep.property.fit_frequency_lower_bound.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.frequency_sweep.property.fit_frequency_lower_bound.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.frequency_sweep.property.fit_frequency_lower_bound.value', float(new_val))


class RootWorkflowFrequency_sweepPropertyFit_frequency_upper_bound(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.property.fit_frequency_upper_bound'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.frequency_sweep.property.fit_frequency_upper_bound.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.frequency_sweep.property.fit_frequency_upper_bound.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.frequency_sweep.property.fit_frequency_upper_bound.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.frequency_sweep.property.fit_frequency_upper_bound.value', float(new_val))


class RootWorkflowFrequency_sweepPropertyAmplitude_reduction(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.property.amplitude_reduction'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.frequency_sweep.property.amplitude_reduction.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.frequency_sweep.property.amplitude_reduction.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.frequency_sweep.property.amplitude_reduction.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.frequency_sweep.property.amplitude_reduction.value', float(new_val))


class RootWorkflowFrequency_sweepPropertySweep_frequency_upper_bound(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.property.sweep_frequency_upper_bound'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.frequency_sweep.property.sweep_frequency_upper_bound.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.frequency_sweep.property.sweep_frequency_upper_bound.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.frequency_sweep.property.sweep_frequency_upper_bound.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.frequency_sweep.property.sweep_frequency_upper_bound.value', float(new_val))


class RootWorkflowFrequency_sweepProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.property'
        self.sweep_frequency_upper_bound = RootWorkflowFrequency_sweepPropertySweep_frequency_upper_bound(self._context)
        self.amplitude_reduction = RootWorkflowFrequency_sweepPropertyAmplitude_reduction(self._context)
        self.fit_frequency_upper_bound = RootWorkflowFrequency_sweepPropertyFit_frequency_upper_bound(self._context)
        self.fit_frequency_lower_bound = RootWorkflowFrequency_sweepPropertyFit_frequency_lower_bound(self._context)
        self.sweep_frequency_lower_bound = RootWorkflowFrequency_sweepPropertySweep_frequency_lower_bound(self._context)
        self.new_spring_constant = RootWorkflowFrequency_sweepPropertyNew_spring_constant(self._context)
        self.current_sweep_range = RootWorkflowFrequency_sweepPropertyCurrent_sweep_range(self._context)
        self.new_excitation_frequency = RootWorkflowFrequency_sweepPropertyNew_excitation_frequency(self._context)
        self.analyzer_demodulator_bandwidth = RootWorkflowFrequency_sweepPropertyAnalyzer_demodulator_bandwidth(self._context)
        self.excitation_amplitude_piezo = RootWorkflowFrequency_sweepPropertyExcitation_amplitude_piezo(self._context)
        self.measurement_environment = RootWorkflowFrequency_sweepPropertyMeasurement_environment(self._context)
        self.frequency_selection_criteria = RootWorkflowFrequency_sweepPropertyFrequency_selection_criteria(self._context)
        self.calculated_amplitude = RootWorkflowFrequency_sweepPropertyCalculated_amplitude(self._context)
        self.sweep_frequency_step = RootWorkflowFrequency_sweepPropertySweep_frequency_step(self._context)
        self.excitation_amplitude_laser = RootWorkflowFrequency_sweepPropertyExcitation_amplitude_laser(self._context)


class RootWorkflowFrequency_sweepSignalStarted(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.signal.started'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.started.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.started.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.started.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.started.call', *args, **kwargs)


class RootWorkflowFrequency_sweepSignalData_invalidated(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.signal.data_invalidated'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.data_invalidated.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.data_invalidated.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.data_invalidated.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.data_invalidated.call', *args, **kwargs)


class RootWorkflowFrequency_sweepSignalEnded(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.signal.ended'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.ended.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.ended.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.ended.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.ended.call', *args, **kwargs)


class RootWorkflowFrequency_sweepSignalProcedure_info(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.signal.procedure_info'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.procedure_info.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.procedure_info.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.procedure_info.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.procedure_info.call', *args, **kwargs)


class RootWorkflowFrequency_sweepSignalNew_fit_data(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.signal.new_fit_data'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.new_fit_data.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.new_fit_data.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.new_fit_data.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.new_fit_data.call', *args, **kwargs)


class RootWorkflowFrequency_sweepSignalSho_fit_failed(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.signal.sho_fit_failed'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.sho_fit_failed.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.sho_fit_failed.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.sho_fit_failed.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.sho_fit_failed.call', *args, **kwargs)


class RootWorkflowFrequency_sweepSignalNew_sweep_data(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.signal.new_sweep_data'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.new_sweep_data.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.new_sweep_data.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.new_sweep_data.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.new_sweep_data.call', *args, **kwargs)


class RootWorkflowFrequency_sweepSignalSweep_progress(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.signal.sweep_progress'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.sweep_progress.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.sweep_progress.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.sweep_progress.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.signal.sweep_progress.call', *args, **kwargs)


class RootWorkflowFrequency_sweepSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep.signal'
        self.sweep_progress = RootWorkflowFrequency_sweepSignalSweep_progress(self._context)
        self.new_sweep_data = RootWorkflowFrequency_sweepSignalNew_sweep_data(self._context)
        self.sho_fit_failed = RootWorkflowFrequency_sweepSignalSho_fit_failed(self._context)
        self.new_fit_data = RootWorkflowFrequency_sweepSignalNew_fit_data(self._context)
        self.procedure_info = RootWorkflowFrequency_sweepSignalProcedure_info(self._context)
        self.ended = RootWorkflowFrequency_sweepSignalEnded(self._context)
        self.data_invalidated = RootWorkflowFrequency_sweepSignalData_invalidated(self._context)
        self.started = RootWorkflowFrequency_sweepSignalStarted(self._context)


class RootWorkflowFrequency_sweep(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.frequency_sweep'
        self.signal = RootWorkflowFrequency_sweepSignal(self._context)
        self.property = RootWorkflowFrequency_sweepProperty(self._context)

    def process_sweep_data(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.process_sweep_data', *args, **kwargs)

    def start(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.start', *args, **kwargs)

    def abort(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.frequency_sweep.abort', *args, **kwargs)


class RootWorkflowMode_loaderPropertyDynamicExcitation_amplitude_laser(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.dynamic.excitation_amplitude_laser'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.mode_loader.property.dynamic.excitation_amplitude_laser.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.mode_loader.property.dynamic.excitation_amplitude_laser.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.dynamic.excitation_amplitude_laser.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.dynamic.excitation_amplitude_laser.value', float(new_val))


class RootWorkflowMode_loaderPropertyDynamicExcitation_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        CleanDrive = 0
        Piezo_Electric = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.dynamic.excitation_source'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.mode_loader.property.dynamic.excitation_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.mode_loader.property.dynamic.excitation_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.mode_loader.property.dynamic.excitation_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.mode_loader.property.dynamic.excitation_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.mode_loader.property.dynamic.excitation_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.mode_loader.property.dynamic.excitation_source.value_raw', new_val.value)


class RootWorkflowMode_loaderPropertyDynamicExcitation_amplitude_piezo(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.dynamic.excitation_amplitude_piezo'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.mode_loader.property.dynamic.excitation_amplitude_piezo.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.mode_loader.property.dynamic.excitation_amplitude_piezo.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.dynamic.excitation_amplitude_piezo.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.dynamic.excitation_amplitude_piezo.value', float(new_val))


class RootWorkflowMode_loaderPropertyDynamicFree_vibration_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.dynamic.free_vibration_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.mode_loader.property.dynamic.free_vibration_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.mode_loader.property.dynamic.free_vibration_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.dynamic.free_vibration_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.dynamic.free_vibration_amplitude.value', float(new_val))


class RootWorkflowMode_loaderPropertyDynamicAuto_optimize_reference_phase(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.dynamic.auto_optimize_reference_phase'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.mode_loader.property.dynamic.auto_optimize_reference_phase.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.mode_loader.property.dynamic.auto_optimize_reference_phase.value', bool(new_val))


class RootWorkflowMode_loaderPropertyDynamicReference_phase(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.dynamic.reference_phase'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.mode_loader.property.dynamic.reference_phase.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.mode_loader.property.dynamic.reference_phase.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.dynamic.reference_phase.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.dynamic.reference_phase.value', float(new_val))


class RootWorkflowMode_loaderPropertyDynamicExcitation_control(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Fixed_Excitation = 0
        Target_Amplitude = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.dynamic.excitation_control'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.mode_loader.property.dynamic.excitation_control.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.mode_loader.property.dynamic.excitation_control.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.mode_loader.property.dynamic.excitation_control.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.mode_loader.property.dynamic.excitation_control.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.mode_loader.property.dynamic.excitation_control.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.mode_loader.property.dynamic.excitation_control.value_raw', new_val.value)


class RootWorkflowMode_loaderPropertyDynamicExcitation_frequency(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.dynamic.excitation_frequency'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.mode_loader.property.dynamic.excitation_frequency.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.mode_loader.property.dynamic.excitation_frequency.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.dynamic.excitation_frequency.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.dynamic.excitation_frequency.value', float(new_val))


class RootWorkflowMode_loaderPropertyDynamicTarget_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.dynamic.target_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.mode_loader.property.dynamic.target_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.mode_loader.property.dynamic.target_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.dynamic.target_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.dynamic.target_amplitude.value', float(new_val))


class RootWorkflowMode_loaderPropertyDynamic(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.dynamic'
        self.target_amplitude = RootWorkflowMode_loaderPropertyDynamicTarget_amplitude(self._context)
        self.excitation_frequency = RootWorkflowMode_loaderPropertyDynamicExcitation_frequency(self._context)
        self.excitation_control = RootWorkflowMode_loaderPropertyDynamicExcitation_control(self._context)
        self.reference_phase = RootWorkflowMode_loaderPropertyDynamicReference_phase(self._context)
        self.auto_optimize_reference_phase = RootWorkflowMode_loaderPropertyDynamicAuto_optimize_reference_phase(self._context)
        self.free_vibration_amplitude = RootWorkflowMode_loaderPropertyDynamicFree_vibration_amplitude(self._context)
        self.excitation_amplitude_piezo = RootWorkflowMode_loaderPropertyDynamicExcitation_amplitude_piezo(self._context)
        self.excitation_source = RootWorkflowMode_loaderPropertyDynamicExcitation_source(self._context)
        self.excitation_amplitude_laser = RootWorkflowMode_loaderPropertyDynamicExcitation_amplitude_laser(self._context)


class RootWorkflowMode_loaderPropertyWavemode_feedbackLift_height(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode_feedback.lift_height'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.mode_loader.property.wavemode_feedback.lift_height.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.mode_loader.property.wavemode_feedback.lift_height.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.wavemode_feedback.lift_height.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.wavemode_feedback.lift_height.value', float(new_val))


class RootWorkflowMode_loaderPropertyWavemode_feedback(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode_feedback'
        self.lift_height = RootWorkflowMode_loaderPropertyWavemode_feedbackLift_height(self._context)


class RootWorkflowMode_loaderPropertyMode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Static_C_AFM = 5
        WaveMode_NMA = 4
        Static_Mode = 1
        Static_SSRM = 6
        Dynamic_Mode = 2
        _Undefined = 0
        WaveMode = 3

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.mode'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.mode_loader.property.mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.mode_loader.property.mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.mode_loader.property.mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.mode_loader.property.mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.mode_loader.property.mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.mode_loader.property.mode.value_raw', new_val.value)


class RootWorkflowMode_loaderPropertyStatic_feedbackLift_height(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.static_feedback.lift_height'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.mode_loader.property.static_feedback.lift_height.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.mode_loader.property.static_feedback.lift_height.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.static_feedback.lift_height.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.static_feedback.lift_height.value', float(new_val))


class RootWorkflowMode_loaderPropertyStatic_feedback(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.static_feedback'
        self.lift_height = RootWorkflowMode_loaderPropertyStatic_feedbackLift_height(self._context)


class RootWorkflowMode_loaderPropertyStatic(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.static'


class RootWorkflowMode_loaderPropertyWavemodeDown_sample_factor(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.down_sample_factor'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.mode_loader.property.wavemode.down_sample_factor.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.mode_loader.property.wavemode.down_sample_factor.value', int(new_val))


class RootWorkflowMode_loaderPropertyWavemodeDesired_excitation_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.desired_excitation_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.mode_loader.property.wavemode.desired_excitation_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.mode_loader.property.wavemode.desired_excitation_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.wavemode.desired_excitation_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.wavemode.desired_excitation_amplitude.value', float(new_val))


class RootWorkflowMode_loaderPropertyWavemodeDefault_excitation_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.default_excitation_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.mode_loader.property.wavemode.default_excitation_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.mode_loader.property.wavemode.default_excitation_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.wavemode.default_excitation_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.wavemode.default_excitation_amplitude.value', float(new_val))


class RootWorkflowMode_loaderPropertyWavemodeFeedback_amplitude_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.feedback_amplitude_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.wavemode.feedback_amplitude_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.wavemode.feedback_amplitude_position.value', float(new_val))


class RootWorkflowMode_loaderPropertyWavemodeFeedback_amplitude_average_width(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.feedback_amplitude_average_width'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.wavemode.feedback_amplitude_average_width.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.wavemode.feedback_amplitude_average_width.value', float(new_val))


class RootWorkflowMode_loaderPropertyWavemodeAverage_periods(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.average_periods'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.mode_loader.property.wavemode.average_periods.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.mode_loader.property.wavemode.average_periods.value', int(new_val))


class RootWorkflowMode_loaderPropertyWavemodeBaseline_frequency(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.baseline_frequency'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.mode_loader.property.wavemode.baseline_frequency.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.mode_loader.property.wavemode.baseline_frequency.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.wavemode.baseline_frequency.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.wavemode.baseline_frequency.value', float(new_val))


class RootWorkflowMode_loaderPropertyWavemodeDamping_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.damping_enabled'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.mode_loader.property.wavemode.damping_enabled.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.mode_loader.property.wavemode.damping_enabled.value', bool(new_val))


class RootWorkflowMode_loaderPropertyWavemodeBaseline_controller_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.baseline_controller_enabled'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.mode_loader.property.wavemode.baseline_controller_enabled.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.mode_loader.property.wavemode.baseline_controller_enabled.value', bool(new_val))


class RootWorkflowMode_loaderPropertyWavemodeFree_wave_amplitude_correction(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.free_wave_amplitude_correction'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.wavemode.free_wave_amplitude_correction.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.wavemode.free_wave_amplitude_correction.value', float(new_val))


class RootWorkflowMode_loaderPropertyWavemodeAuto_wave_frequency(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.auto_wave_frequency'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.mode_loader.property.wavemode.auto_wave_frequency.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.mode_loader.property.wavemode.auto_wave_frequency.value', bool(new_val))


class RootWorkflowMode_loaderPropertyWavemodeBaseline_window_begin(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.baseline_window_begin'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.wavemode.baseline_window_begin.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.wavemode.baseline_window_begin.value', float(new_val))


class RootWorkflowMode_loaderPropertyWavemodeFree_wave_phase_delay(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.free_wave_phase_delay'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.mode_loader.property.wavemode.free_wave_phase_delay.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.mode_loader.property.wavemode.free_wave_phase_delay.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.wavemode.free_wave_phase_delay.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.wavemode.free_wave_phase_delay.value', float(new_val))


class RootWorkflowMode_loaderPropertyWavemodeExcitation_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.excitation_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.mode_loader.property.wavemode.excitation_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.mode_loader.property.wavemode.excitation_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.wavemode.excitation_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.wavemode.excitation_amplitude.value', float(new_val))


class RootWorkflowMode_loaderPropertyWavemodeInput_select(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Fast_In_Deflection = 0
        Fast_In_Deflection_at_Hi_Res_Rate = 4
        Fast_In_User_at_Hi_Res_Rate = 5
        Hi_Res_In_User1 = 3
        Fast_In_User = 2
        Hi_Res_In_Deflection = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.input_select'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.mode_loader.property.wavemode.input_select.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.mode_loader.property.wavemode.input_select.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.mode_loader.property.wavemode.input_select.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.mode_loader.property.wavemode.input_select.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.mode_loader.property.wavemode.input_select.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.mode_loader.property.wavemode.input_select.value_raw', new_val.value)


class RootWorkflowMode_loaderPropertyWavemodeWave_frequency(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.wave_frequency'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.mode_loader.property.wavemode.wave_frequency.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.mode_loader.property.wavemode.wave_frequency.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.wavemode.wave_frequency.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.wavemode.wave_frequency.value', float(new_val))


class RootWorkflowMode_loaderPropertyWavemodeAuto_free_wave_calibration(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.auto_free_wave_calibration'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.mode_loader.property.wavemode.auto_free_wave_calibration.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.mode_loader.property.wavemode.auto_free_wave_calibration.value', bool(new_val))


class RootWorkflowMode_loaderPropertyWavemodeBaseline_window_end(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.baseline_window_end'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.wavemode.baseline_window_end.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.wavemode.baseline_window_end.value', float(new_val))


class RootWorkflowMode_loaderPropertyWavemodeWave_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.wave_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.mode_loader.property.wavemode.wave_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.mode_loader.property.wavemode.wave_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.wavemode.wave_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.wavemode.wave_amplitude.value', float(new_val))


class RootWorkflowMode_loaderPropertyWavemodeDamping_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.damping_gain'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.wavemode.damping_gain.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.wavemode.damping_gain.value', float(new_val))


class RootWorkflowMode_loaderPropertyWavemodeExcitation_control(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Fixed_Excitation = 0
        Target_Amplitude = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.excitation_control'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.mode_loader.property.wavemode.excitation_control.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.mode_loader.property.wavemode.excitation_control.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.mode_loader.property.wavemode.excitation_control.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.mode_loader.property.wavemode.excitation_control.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.mode_loader.property.wavemode.excitation_control.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.mode_loader.property.wavemode.excitation_control.value_raw', new_val.value)


class RootWorkflowMode_loaderPropertyWavemodeCapture_datapoints(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.capture_datapoints'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.mode_loader.property.wavemode.capture_datapoints.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.mode_loader.property.wavemode.capture_datapoints.value', int(new_val))


class RootWorkflowMode_loaderPropertyWavemodePeriod_duration(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.period_duration'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.mode_loader.property.wavemode.period_duration.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.mode_loader.property.wavemode.period_duration.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.wavemode.period_duration.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.wavemode.period_duration.value', float(new_val))


class RootWorkflowMode_loaderPropertyWavemodeTarget_wave_amplitude(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode.target_wave_amplitude'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.mode_loader.property.wavemode.target_wave_amplitude.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.mode_loader.property.wavemode.target_wave_amplitude.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.mode_loader.property.wavemode.target_wave_amplitude.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.mode_loader.property.wavemode.target_wave_amplitude.value', float(new_val))


class RootWorkflowMode_loaderPropertyWavemode(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode'
        self.target_wave_amplitude = RootWorkflowMode_loaderPropertyWavemodeTarget_wave_amplitude(self._context)
        self.period_duration = RootWorkflowMode_loaderPropertyWavemodePeriod_duration(self._context)
        self.capture_datapoints = RootWorkflowMode_loaderPropertyWavemodeCapture_datapoints(self._context)
        self.excitation_control = RootWorkflowMode_loaderPropertyWavemodeExcitation_control(self._context)
        self.damping_gain = RootWorkflowMode_loaderPropertyWavemodeDamping_gain(self._context)
        self.wave_amplitude = RootWorkflowMode_loaderPropertyWavemodeWave_amplitude(self._context)
        self.baseline_window_end = RootWorkflowMode_loaderPropertyWavemodeBaseline_window_end(self._context)
        self.auto_free_wave_calibration = RootWorkflowMode_loaderPropertyWavemodeAuto_free_wave_calibration(self._context)
        self.wave_frequency = RootWorkflowMode_loaderPropertyWavemodeWave_frequency(self._context)
        self.input_select = RootWorkflowMode_loaderPropertyWavemodeInput_select(self._context)
        self.excitation_amplitude = RootWorkflowMode_loaderPropertyWavemodeExcitation_amplitude(self._context)
        self.free_wave_phase_delay = RootWorkflowMode_loaderPropertyWavemodeFree_wave_phase_delay(self._context)
        self.baseline_window_begin = RootWorkflowMode_loaderPropertyWavemodeBaseline_window_begin(self._context)
        self.auto_wave_frequency = RootWorkflowMode_loaderPropertyWavemodeAuto_wave_frequency(self._context)
        self.free_wave_amplitude_correction = RootWorkflowMode_loaderPropertyWavemodeFree_wave_amplitude_correction(self._context)
        self.baseline_controller_enabled = RootWorkflowMode_loaderPropertyWavemodeBaseline_controller_enabled(self._context)
        self.damping_enabled = RootWorkflowMode_loaderPropertyWavemodeDamping_enabled(self._context)
        self.baseline_frequency = RootWorkflowMode_loaderPropertyWavemodeBaseline_frequency(self._context)
        self.average_periods = RootWorkflowMode_loaderPropertyWavemodeAverage_periods(self._context)
        self.feedback_amplitude_average_width = RootWorkflowMode_loaderPropertyWavemodeFeedback_amplitude_average_width(self._context)
        self.feedback_amplitude_position = RootWorkflowMode_loaderPropertyWavemodeFeedback_amplitude_position(self._context)
        self.default_excitation_amplitude = RootWorkflowMode_loaderPropertyWavemodeDefault_excitation_amplitude(self._context)
        self.desired_excitation_amplitude = RootWorkflowMode_loaderPropertyWavemodeDesired_excitation_amplitude(self._context)
        self.down_sample_factor = RootWorkflowMode_loaderPropertyWavemodeDown_sample_factor(self._context)


class RootWorkflowMode_loaderPropertyWavemode_nma(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property.wavemode_nma'


class RootWorkflowMode_loaderProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader.property'
        self.wavemode_nma = RootWorkflowMode_loaderPropertyWavemode_nma(self._context)
        self.wavemode = RootWorkflowMode_loaderPropertyWavemode(self._context)
        self.static = RootWorkflowMode_loaderPropertyStatic(self._context)
        self.static_feedback = RootWorkflowMode_loaderPropertyStatic_feedback(self._context)
        self.mode = RootWorkflowMode_loaderPropertyMode(self._context)
        self.wavemode_feedback = RootWorkflowMode_loaderPropertyWavemode_feedback(self._context)
        self.dynamic = RootWorkflowMode_loaderPropertyDynamic(self._context)


class RootWorkflowMode_loader(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.mode_loader'
        self.property = RootWorkflowMode_loaderProperty(self._context)

    def update(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.mode_loader.update', *args, **kwargs)

    def load_wavemode_nma(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.mode_loader.load_wavemode_nma', *args, **kwargs)

    def apply(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.mode_loader.apply', *args, **kwargs)

    def load_static_force_mode(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.mode_loader.load_static_force_mode', *args, **kwargs)

    def load_dynamic_force_mode(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.mode_loader.load_dynamic_force_mode', *args, **kwargs)

    def load_wavemode(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.mode_loader.load_wavemode', *args, **kwargs)


class RootWorkflowCantilever_browser(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_browser'


class RootWorkflowImagingPropertyImage_offset_x(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.image_offset_x'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.imaging.property.image_offset_x.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.imaging.property.image_offset_x.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.imaging.property.image_offset_x.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.imaging.property.image_offset_x.value', float(new_val))


class RootWorkflowImagingPropertyPrevious_lines_for_linearization(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.previous_lines_for_linearization'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.imaging.property.previous_lines_for_linearization.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.imaging.property.previous_lines_for_linearization.value', int(new_val))


class RootWorkflowImagingPropertyLinearization_smoothing_factor(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.linearization_smoothing_factor'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.imaging.property.linearization_smoothing_factor.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.imaging.property.linearization_smoothing_factor.value', float(new_val))


class RootWorkflowImagingPropertyLine_rate(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.line_rate'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.imaging.property.line_rate.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.imaging.property.line_rate.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.imaging.property.line_rate.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.imaging.property.line_rate.value', float(new_val))


class RootWorkflowImagingPropertyTip_velocity(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.tip_velocity'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.imaging.property.tip_velocity.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.imaging.property.tip_velocity.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.imaging.property.tip_velocity.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.imaging.property.tip_velocity.value', float(new_val))


class RootWorkflowImagingPropertyScan_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Single_Frame = 1
        Continuous = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.scan_mode'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.imaging.property.scan_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.imaging.property.scan_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.imaging.property.scan_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.imaging.property.scan_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.imaging.property.scan_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.imaging.property.scan_mode.value_raw', new_val.value)


class RootWorkflowImagingPropertyMove_speed_xy(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.move_speed_xy'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.imaging.property.move_speed_xy.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.imaging.property.move_speed_xy.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.imaging.property.move_speed_xy.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.imaging.property.move_speed_xy.value', float(new_val))


class RootWorkflowImagingPropertyOverscan_distance(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.overscan_distance'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.imaging.property.overscan_distance.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.imaging.property.overscan_distance.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.imaging.property.overscan_distance.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.imaging.property.overscan_distance.value', float(new_val))


class RootWorkflowImagingPropertyScan_range_fast_axis(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.scan_range_fast_axis'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.imaging.property.scan_range_fast_axis.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.imaging.property.scan_range_fast_axis.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.imaging.property.scan_range_fast_axis.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.imaging.property.scan_range_fast_axis.value', float(new_val))


class RootWorkflowImagingPropertySlope_y(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.slope_y'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.imaging.property.slope_y.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.imaging.property.slope_y.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.imaging.property.slope_y.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.imaging.property.slope_y.value', float(new_val))


class RootWorkflowImagingPropertyAuto_generator(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.auto_generator'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.imaging.property.auto_generator.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.imaging.property.auto_generator.value', bool(new_val))


class RootWorkflowImagingPropertySlow_axis_scan_direction(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Bounce = 2
        Downward = 0
        Upward = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.slow_axis_scan_direction'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.imaging.property.slow_axis_scan_direction.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.imaging.property.slow_axis_scan_direction.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.imaging.property.slow_axis_scan_direction.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.imaging.property.slow_axis_scan_direction.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.imaging.property.slow_axis_scan_direction.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.imaging.property.slow_axis_scan_direction.value_raw', new_val.value)


class RootWorkflowImagingPropertyTime_per_line(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.time_per_line'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.imaging.property.time_per_line.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.imaging.property.time_per_line.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.imaging.property.time_per_line.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.imaging.property.time_per_line.value', float(new_val))


class RootWorkflowImagingPropertyFinish_current_frame_and_stop(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.finish_current_frame_and_stop'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.imaging.property.finish_current_frame_and_stop.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.imaging.property.finish_current_frame_and_stop.value', bool(new_val))


class RootWorkflowImagingPropertyRotation(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.rotation'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.imaging.property.rotation.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.imaging.property.rotation.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.imaging.property.rotation.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.imaging.property.rotation.value', float(new_val))


class RootWorkflowImagingPropertyUpdate_interaction_before_frame(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.update_interaction_before_frame'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.imaging.property.update_interaction_before_frame.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.imaging.property.update_interaction_before_frame.value', bool(new_val))


class RootWorkflowImagingPropertyOverscan(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.overscan'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.imaging.property.overscan.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.imaging.property.overscan.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.imaging.property.overscan.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.imaging.property.overscan.value', float(new_val))


class RootWorkflowImagingPropertyImage_offset_y(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.image_offset_y'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.imaging.property.image_offset_y.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.imaging.property.image_offset_y.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.imaging.property.image_offset_y.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.imaging.property.image_offset_y.value', float(new_val))


class RootWorkflowImagingPropertyBackward_points_per_line(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.backward_points_per_line'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.imaging.property.backward_points_per_line.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.imaging.property.backward_points_per_line.value', int(new_val))


class RootWorkflowImagingPropertyLines_per_frame(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.lines_per_frame'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.imaging.property.lines_per_frame.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.imaging.property.lines_per_frame.value', int(new_val))


class RootWorkflowImagingPropertyScan_range_slow_axis(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.scan_range_slow_axis'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.imaging.property.scan_range_slow_axis.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.imaging.property.scan_range_slow_axis.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.imaging.property.scan_range_slow_axis.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.imaging.property.scan_range_slow_axis.value', float(new_val))


class RootWorkflowImagingPropertyFirst_line_repetition(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.first_line_repetition'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.imaging.property.first_line_repetition.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.imaging.property.first_line_repetition.value', int(new_val))


class RootWorkflowImagingPropertyGenerator(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Spiral_Scan = 3
        Smooth_Frame = 2
        Linear_Line = 0
        Smooth_Line = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.generator'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.imaging.property.generator.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.imaging.property.generator.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.imaging.property.generator.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.imaging.property.generator.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.imaging.property.generator.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.imaging.property.generator.value_raw', new_val.value)


class RootWorkflowImagingPropertySlow_axis_move_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Continuous_Zigzag = 2
        Stepwise = 0
        Serpentine = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.slow_axis_move_mode'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.imaging.property.slow_axis_move_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.imaging.property.slow_axis_move_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.imaging.property.slow_axis_move_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.imaging.property.slow_axis_move_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.imaging.property.slow_axis_move_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.imaging.property.slow_axis_move_mode.value_raw', new_val.value)


class RootWorkflowImagingPropertyPoints_per_line(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.points_per_line'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.imaging.property.points_per_line.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.imaging.property.points_per_line.value', int(new_val))


class RootWorkflowImagingPropertySlope_x(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property.slope_x'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.imaging.property.slope_x.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.imaging.property.slope_x.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.imaging.property.slope_x.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.imaging.property.slope_x.value', float(new_val))


class RootWorkflowImagingProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.property'
        self.slope_x = RootWorkflowImagingPropertySlope_x(self._context)
        self.points_per_line = RootWorkflowImagingPropertyPoints_per_line(self._context)
        self.slow_axis_move_mode = RootWorkflowImagingPropertySlow_axis_move_mode(self._context)
        self.generator = RootWorkflowImagingPropertyGenerator(self._context)
        self.first_line_repetition = RootWorkflowImagingPropertyFirst_line_repetition(self._context)
        self.scan_range_slow_axis = RootWorkflowImagingPropertyScan_range_slow_axis(self._context)
        self.lines_per_frame = RootWorkflowImagingPropertyLines_per_frame(self._context)
        self.backward_points_per_line = RootWorkflowImagingPropertyBackward_points_per_line(self._context)
        self.image_offset_y = RootWorkflowImagingPropertyImage_offset_y(self._context)
        self.overscan = RootWorkflowImagingPropertyOverscan(self._context)
        self.update_interaction_before_frame = RootWorkflowImagingPropertyUpdate_interaction_before_frame(self._context)
        self.rotation = RootWorkflowImagingPropertyRotation(self._context)
        self.finish_current_frame_and_stop = RootWorkflowImagingPropertyFinish_current_frame_and_stop(self._context)
        self.time_per_line = RootWorkflowImagingPropertyTime_per_line(self._context)
        self.slow_axis_scan_direction = RootWorkflowImagingPropertySlow_axis_scan_direction(self._context)
        self.auto_generator = RootWorkflowImagingPropertyAuto_generator(self._context)
        self.slope_y = RootWorkflowImagingPropertySlope_y(self._context)
        self.scan_range_fast_axis = RootWorkflowImagingPropertyScan_range_fast_axis(self._context)
        self.overscan_distance = RootWorkflowImagingPropertyOverscan_distance(self._context)
        self.move_speed_xy = RootWorkflowImagingPropertyMove_speed_xy(self._context)
        self.scan_mode = RootWorkflowImagingPropertyScan_mode(self._context)
        self.tip_velocity = RootWorkflowImagingPropertyTip_velocity(self._context)
        self.line_rate = RootWorkflowImagingPropertyLine_rate(self._context)
        self.linearization_smoothing_factor = RootWorkflowImagingPropertyLinearization_smoothing_factor(self._context)
        self.previous_lines_for_linearization = RootWorkflowImagingPropertyPrevious_lines_for_linearization(self._context)
        self.image_offset_x = RootWorkflowImagingPropertyImage_offset_x(self._context)


class RootWorkflowImagingSignalScanning_finished(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.signal.scanning_finished'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.scanning_finished.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.scanning_finished.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.scanning_finished.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.scanning_finished.call', *args, **kwargs)


class RootWorkflowImagingSignalScanning_paused(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.signal.scanning_paused'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.scanning_paused.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.scanning_paused.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.scanning_paused.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.scanning_paused.call', *args, **kwargs)


class RootWorkflowImagingSignalProcedure_info(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.signal.procedure_info'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.procedure_info.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.procedure_info.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.procedure_info.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.procedure_info.call', *args, **kwargs)


class RootWorkflowImagingSignalScanning_started(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.signal.scanning_started'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.scanning_started.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.scanning_started.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.scanning_started.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.scanning_started.call', *args, **kwargs)


class RootWorkflowImagingSignalScanning_resumed(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.signal.scanning_resumed'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.scanning_resumed.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.scanning_resumed.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.scanning_resumed.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.scanning_resumed.call', *args, **kwargs)


class RootWorkflowImagingSignalRemaining_scan_time_changed(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.signal.remaining_scan_time_changed'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.remaining_scan_time_changed.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.remaining_scan_time_changed.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.remaining_scan_time_changed.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.signal.remaining_scan_time_changed.call', *args, **kwargs)


class RootWorkflowImagingSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging.signal'
        self.remaining_scan_time_changed = RootWorkflowImagingSignalRemaining_scan_time_changed(self._context)
        self.scanning_resumed = RootWorkflowImagingSignalScanning_resumed(self._context)
        self.scanning_started = RootWorkflowImagingSignalScanning_started(self._context)
        self.procedure_info = RootWorkflowImagingSignalProcedure_info(self._context)
        self.scanning_paused = RootWorkflowImagingSignalScanning_paused(self._context)
        self.scanning_finished = RootWorkflowImagingSignalScanning_finished(self._context)


class RootWorkflowImaging(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.imaging'
        self.signal = RootWorkflowImagingSignal(self._context)
        self.property = RootWorkflowImagingProperty(self._context)

    def stop_imaging(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.stop_imaging', *args, **kwargs)

    def is_scanning(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.is_scanning', *args, **kwargs)

    def start_imaging(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.imaging.start_imaging', *args, **kwargs)


class RootWorkflowApproachPropertyApproach_validation(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.property.approach_validation'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.approach.property.approach_validation.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.approach.property.approach_validation.value', bool(new_val))


class RootWorkflowApproachPropertyGentle_approach_enable(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.property.gentle_approach_enable'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.approach.property.gentle_approach_enable.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.approach.property.gentle_approach_enable.value', bool(new_val))


class RootWorkflowApproachPropertyStep_by_step_coarse_step_size_percentage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.property.step_by_step_coarse_step_size_percentage'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach.property.step_by_step_coarse_step_size_percentage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach.property.step_by_step_coarse_step_size_percentage.unit', str(new_val))

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.approach.property.step_by_step_coarse_step_size_percentage.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.approach.property.step_by_step_coarse_step_size_percentage.value', int(new_val))


class RootWorkflowApproachPropertyApproach_speed_absolute(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.property.approach_speed_absolute'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach.property.approach_speed_absolute.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach.property.approach_speed_absolute.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach.property.approach_speed_absolute.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach.property.approach_speed_absolute.value', float(new_val))


class RootWorkflowApproachPropertyStep_by_step_fine_step_size_percentage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.property.step_by_step_fine_step_size_percentage'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach.property.step_by_step_fine_step_size_percentage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach.property.step_by_step_fine_step_size_percentage.unit', str(new_val))

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.approach.property.step_by_step_fine_step_size_percentage.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.approach.property.step_by_step_fine_step_size_percentage.value', int(new_val))


class RootWorkflowApproachPropertyStep_by_step_deflection_offset_voltage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.property.step_by_step_deflection_offset_voltage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach.property.step_by_step_deflection_offset_voltage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach.property.step_by_step_deflection_offset_voltage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach.property.step_by_step_deflection_offset_voltage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach.property.step_by_step_deflection_offset_voltage.value', float(new_val))


class RootWorkflowApproachPropertyStep_by_step_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.property.step_by_step_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach.property.step_by_step_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach.property.step_by_step_time.value', float(new_val))


class RootWorkflowApproachPropertyApproach_steps(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.property.approach_steps'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.approach.property.approach_steps.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.approach.property.approach_steps.value', int(new_val))


class RootWorkflowApproachPropertyStep_by_step_slope(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.property.step_by_step_slope'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach.property.step_by_step_slope.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach.property.step_by_step_slope.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach.property.step_by_step_slope.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach.property.step_by_step_slope.value', float(new_val))


class RootWorkflowApproachPropertyApproach_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.property.approach_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach.property.approach_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach.property.approach_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach.property.approach_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach.property.approach_speed.value', float(new_val))


class RootWorkflowApproachPropertyApproach_state(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Retracted = 1
        Unknown = 0
        Approached = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.property.approach_state'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.approach.property.approach_state.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.approach.property.approach_state.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.approach.property.approach_state.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.approach.property.approach_state.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.approach.property.approach_state.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.approach.property.approach_state.value_raw', new_val.value)


class RootWorkflowApproachPropertyAdvance_retract_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.property.advance_retract_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach.property.advance_retract_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach.property.advance_retract_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach.property.advance_retract_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach.property.advance_retract_speed.value', float(new_val))


class RootWorkflowApproachPropertyWithdraw_step_distance(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.property.withdraw_step_distance'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach.property.withdraw_step_distance.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach.property.withdraw_step_distance.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach.property.withdraw_step_distance.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach.property.withdraw_step_distance.value', float(new_val))


class RootWorkflowApproachPropertyStep_by_step_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.property.step_by_step_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach.property.step_by_step_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach.property.step_by_step_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach.property.step_by_step_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach.property.step_by_step_speed.value', float(new_val))


class RootWorkflowApproachPropertyAdvance_retract_step(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.property.advance_retract_step'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach.property.advance_retract_step.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach.property.advance_retract_step.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach.property.advance_retract_step.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach.property.advance_retract_step.value', float(new_val))


class RootWorkflowApproachPropertyWithdraw_step_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.property.withdraw_step_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach.property.withdraw_step_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach.property.withdraw_step_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach.property.withdraw_step_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach.property.withdraw_step_speed.value', float(new_val))


class RootWorkflowApproachPropertyApproach_pos(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.property.approach_pos'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach.property.approach_pos.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach.property.approach_pos.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach.property.approach_pos.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach.property.approach_pos.value', float(new_val))


class RootWorkflowApproachProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.property'
        self.approach_pos = RootWorkflowApproachPropertyApproach_pos(self._context)
        self.withdraw_step_speed = RootWorkflowApproachPropertyWithdraw_step_speed(self._context)
        self.advance_retract_step = RootWorkflowApproachPropertyAdvance_retract_step(self._context)
        self.step_by_step_speed = RootWorkflowApproachPropertyStep_by_step_speed(self._context)
        self.withdraw_step_distance = RootWorkflowApproachPropertyWithdraw_step_distance(self._context)
        self.advance_retract_speed = RootWorkflowApproachPropertyAdvance_retract_speed(self._context)
        self.approach_state = RootWorkflowApproachPropertyApproach_state(self._context)
        self.approach_speed = RootWorkflowApproachPropertyApproach_speed(self._context)
        self.step_by_step_slope = RootWorkflowApproachPropertyStep_by_step_slope(self._context)
        self.approach_steps = RootWorkflowApproachPropertyApproach_steps(self._context)
        self.step_by_step_time = RootWorkflowApproachPropertyStep_by_step_time(self._context)
        self.step_by_step_deflection_offset_voltage = RootWorkflowApproachPropertyStep_by_step_deflection_offset_voltage(self._context)
        self.step_by_step_fine_step_size_percentage = RootWorkflowApproachPropertyStep_by_step_fine_step_size_percentage(self._context)
        self.approach_speed_absolute = RootWorkflowApproachPropertyApproach_speed_absolute(self._context)
        self.step_by_step_coarse_step_size_percentage = RootWorkflowApproachPropertyStep_by_step_coarse_step_size_percentage(self._context)
        self.gentle_approach_enable = RootWorkflowApproachPropertyGentle_approach_enable(self._context)
        self.approach_validation = RootWorkflowApproachPropertyApproach_validation(self._context)


class RootWorkflowApproachSignalApproach_started(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.signal.approach_started'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.approach_started.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.approach_started.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.approach_started.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.approach_started.call', *args, **kwargs)


class RootWorkflowApproachSignalApproach_or_withdraw_finished(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.signal.approach_or_withdraw_finished'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.approach_or_withdraw_finished.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.approach_or_withdraw_finished.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.approach_or_withdraw_finished.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.approach_or_withdraw_finished.call', *args, **kwargs)


class RootWorkflowApproachSignalProcedure_info(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.signal.procedure_info'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.procedure_info.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.procedure_info.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.procedure_info.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.procedure_info.call', *args, **kwargs)


class RootWorkflowApproachSignalAdvance_or_retract_finished(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.signal.advance_or_retract_finished'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.advance_or_retract_finished.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.advance_or_retract_finished.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.advance_or_retract_finished.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.advance_or_retract_finished.call', *args, **kwargs)


class RootWorkflowApproachSignalWithdraw_started(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.signal.withdraw_started'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.withdraw_started.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.withdraw_started.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.withdraw_started.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.signal.withdraw_started.call', *args, **kwargs)


class RootWorkflowApproachSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach.signal'
        self.withdraw_started = RootWorkflowApproachSignalWithdraw_started(self._context)
        self.advance_or_retract_finished = RootWorkflowApproachSignalAdvance_or_retract_finished(self._context)
        self.procedure_info = RootWorkflowApproachSignalProcedure_info(self._context)
        self.approach_or_withdraw_finished = RootWorkflowApproachSignalApproach_or_withdraw_finished(self._context)
        self.approach_started = RootWorkflowApproachSignalApproach_started(self._context)


class RootWorkflowApproach(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach'
        self.signal = RootWorkflowApproachSignal(self._context)
        self.property = RootWorkflowApproachProperty(self._context)

    def start_withdraw(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.start_withdraw', *args, **kwargs)

    def start_approach(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.start_approach', *args, **kwargs)

    def start_advance(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.start_advance', *args, **kwargs)

    def abort(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.abort', *args, **kwargs)

    def start_retract(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach.start_retract', *args, **kwargs)


class RootWorkflowLaser_manual_alignPropertyDeflection_normal(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.deflection_normal'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.laser_manual_align.property.deflection_normal.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.laser_manual_align.property.deflection_normal.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.laser_manual_align.property.deflection_normal.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.laser_manual_align.property.deflection_normal.value', float(new_val))


class RootWorkflowLaser_manual_alignPropertyEnable_laser_clean_drive(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.enable_laser_clean_drive'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.laser_manual_align.property.enable_laser_clean_drive.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.laser_manual_align.property.enable_laser_clean_drive.value', bool(new_val))


class RootWorkflowLaser_manual_alignPropertyLaser_readout_power(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.laser_readout_power'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.laser_manual_align.property.laser_readout_power.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.laser_manual_align.property.laser_readout_power.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.laser_manual_align.property.laser_readout_power.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.laser_manual_align.property.laser_readout_power.value', float(new_val))


class RootWorkflowLaser_manual_alignPropertyLaser_spot_intensity(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.laser_spot_intensity'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.laser_manual_align.property.laser_spot_intensity.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.laser_manual_align.property.laser_spot_intensity.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.laser_manual_align.property.laser_spot_intensity.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.laser_manual_align.property.laser_spot_intensity.value', float(new_val))


class RootWorkflowLaser_manual_alignPropertyLaser_readout_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.laser_readout_enabled'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.laser_manual_align.property.laser_readout_enabled.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.laser_manual_align.property.laser_readout_enabled.value', bool(new_val))


class RootWorkflowLaser_manual_alignPropertyMotor_beam_shifter_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.motor_beam_shifter_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.laser_manual_align.property.motor_beam_shifter_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.laser_manual_align.property.motor_beam_shifter_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.laser_manual_align.property.motor_beam_shifter_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.laser_manual_align.property.motor_beam_shifter_position.value', float(new_val))


class RootWorkflowLaser_manual_alignPropertyDeflection_lateral(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.deflection_lateral'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.laser_manual_align.property.deflection_lateral.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.laser_manual_align.property.deflection_lateral.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.laser_manual_align.property.deflection_lateral.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.laser_manual_align.property.deflection_lateral.value', float(new_val))


class RootWorkflowLaser_manual_alignPropertyMotor_speed_optics_motors(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.motor_speed_optics_motors'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.laser_manual_align.property.motor_speed_optics_motors.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.laser_manual_align.property.motor_speed_optics_motors.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.laser_manual_align.property.motor_speed_optics_motors.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.laser_manual_align.property.motor_speed_optics_motors.value', float(new_val))


class RootWorkflowLaser_manual_alignPropertyMotor_laser_focus_z_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.motor_laser_focus_z_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.laser_manual_align.property.motor_laser_focus_z_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.laser_manual_align.property.motor_laser_focus_z_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.laser_manual_align.property.motor_laser_focus_z_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.laser_manual_align.property.motor_laser_focus_z_position.value', float(new_val))


class RootWorkflowLaser_manual_alignPropertyMotor_laser_photodetector_y_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.motor_laser_photodetector_y_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.laser_manual_align.property.motor_laser_photodetector_y_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.laser_manual_align.property.motor_laser_photodetector_y_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.laser_manual_align.property.motor_laser_photodetector_y_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.laser_manual_align.property.motor_laser_photodetector_y_position.value', float(new_val))


class RootWorkflowLaser_manual_alignPropertyMotor_laser_photodetector_x_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.motor_laser_photodetector_x_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.laser_manual_align.property.motor_laser_photodetector_x_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.laser_manual_align.property.motor_laser_photodetector_x_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.laser_manual_align.property.motor_laser_photodetector_x_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.laser_manual_align.property.motor_laser_photodetector_x_position.value', float(new_val))


class RootWorkflowLaser_manual_alignPropertySensor_status(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Low = 1
        High = 3
        Fail = 4
        Ok = 2
        Undefined = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.sensor_status'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.laser_manual_align.property.sensor_status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.laser_manual_align.property.sensor_status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.laser_manual_align.property.sensor_status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.laser_manual_align.property.sensor_status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.laser_manual_align.property.sensor_status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.laser_manual_align.property.sensor_status.value_raw', new_val.value)


class RootWorkflowLaser_manual_alignPropertyMotor_speed_max_laser_motors(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.motor_speed_max_laser_motors'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.laser_manual_align.property.motor_speed_max_laser_motors.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.laser_manual_align.property.motor_speed_max_laser_motors.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.laser_manual_align.property.motor_speed_max_laser_motors.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.laser_manual_align.property.motor_speed_max_laser_motors.value', float(new_val))


class RootWorkflowLaser_manual_alignPropertyMotor_laser_clean_drive_y_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.motor_laser_clean_drive_y_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.laser_manual_align.property.motor_laser_clean_drive_y_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.laser_manual_align.property.motor_laser_clean_drive_y_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.laser_manual_align.property.motor_laser_clean_drive_y_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.laser_manual_align.property.motor_laser_clean_drive_y_position.value', float(new_val))


class RootWorkflowLaser_manual_alignPropertyMotor_step(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.motor_step'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.laser_manual_align.property.motor_step.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.laser_manual_align.property.motor_step.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.laser_manual_align.property.motor_step.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.laser_manual_align.property.motor_step.value', float(new_val))


class RootWorkflowLaser_manual_alignPropertyMotor_laser_readout_y_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.motor_laser_readout_y_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.laser_manual_align.property.motor_laser_readout_y_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.laser_manual_align.property.motor_laser_readout_y_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.laser_manual_align.property.motor_laser_readout_y_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.laser_manual_align.property.motor_laser_readout_y_position.value', float(new_val))


class RootWorkflowLaser_manual_alignPropertyMotor_laser_readout_x_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.motor_laser_readout_x_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.laser_manual_align.property.motor_laser_readout_x_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.laser_manual_align.property.motor_laser_readout_x_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.laser_manual_align.property.motor_laser_readout_x_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.laser_manual_align.property.motor_laser_readout_x_position.value', float(new_val))


class RootWorkflowLaser_manual_alignPropertyUpdate_detector_rate(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.update_detector_rate'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.laser_manual_align.property.update_detector_rate.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.laser_manual_align.property.update_detector_rate.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.laser_manual_align.property.update_detector_rate.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.laser_manual_align.property.update_detector_rate.value', float(new_val))


class RootWorkflowLaser_manual_alignPropertyDeflection_offset_calibration_status(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Calibration_Error = 1
        Sensor_Signal_Failed = 2
        No_Error = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.deflection_offset_calibration_status'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.laser_manual_align.property.deflection_offset_calibration_status.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.laser_manual_align.property.deflection_offset_calibration_status.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.laser_manual_align.property.deflection_offset_calibration_status.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.laser_manual_align.property.deflection_offset_calibration_status.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.laser_manual_align.property.deflection_offset_calibration_status.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.laser_manual_align.property.deflection_offset_calibration_status.value_raw', new_val.value)


class RootWorkflowLaser_manual_alignPropertyMotor_laser_clean_drive_x_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.motor_laser_clean_drive_x_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.laser_manual_align.property.motor_laser_clean_drive_x_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.laser_manual_align.property.motor_laser_clean_drive_x_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.laser_manual_align.property.motor_laser_clean_drive_x_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.laser_manual_align.property.motor_laser_clean_drive_x_position.value', float(new_val))


class RootWorkflowLaser_manual_alignPropertyLaser_cleandrive_power(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property.laser_cleandrive_power'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.laser_manual_align.property.laser_cleandrive_power.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.laser_manual_align.property.laser_cleandrive_power.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.laser_manual_align.property.laser_cleandrive_power.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.laser_manual_align.property.laser_cleandrive_power.value', float(new_val))


class RootWorkflowLaser_manual_alignProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.property'
        self.laser_cleandrive_power = RootWorkflowLaser_manual_alignPropertyLaser_cleandrive_power(self._context)
        self.motor_laser_clean_drive_x_position = RootWorkflowLaser_manual_alignPropertyMotor_laser_clean_drive_x_position(self._context)
        self.deflection_offset_calibration_status = RootWorkflowLaser_manual_alignPropertyDeflection_offset_calibration_status(self._context)
        self.update_detector_rate = RootWorkflowLaser_manual_alignPropertyUpdate_detector_rate(self._context)
        self.motor_laser_readout_x_position = RootWorkflowLaser_manual_alignPropertyMotor_laser_readout_x_position(self._context)
        self.motor_laser_readout_y_position = RootWorkflowLaser_manual_alignPropertyMotor_laser_readout_y_position(self._context)
        self.motor_step = RootWorkflowLaser_manual_alignPropertyMotor_step(self._context)
        self.motor_laser_clean_drive_y_position = RootWorkflowLaser_manual_alignPropertyMotor_laser_clean_drive_y_position(self._context)
        self.motor_speed_max_laser_motors = RootWorkflowLaser_manual_alignPropertyMotor_speed_max_laser_motors(self._context)
        self.sensor_status = RootWorkflowLaser_manual_alignPropertySensor_status(self._context)
        self.motor_laser_photodetector_x_position = RootWorkflowLaser_manual_alignPropertyMotor_laser_photodetector_x_position(self._context)
        self.motor_laser_photodetector_y_position = RootWorkflowLaser_manual_alignPropertyMotor_laser_photodetector_y_position(self._context)
        self.motor_laser_focus_z_position = RootWorkflowLaser_manual_alignPropertyMotor_laser_focus_z_position(self._context)
        self.motor_speed_optics_motors = RootWorkflowLaser_manual_alignPropertyMotor_speed_optics_motors(self._context)
        self.deflection_lateral = RootWorkflowLaser_manual_alignPropertyDeflection_lateral(self._context)
        self.motor_beam_shifter_position = RootWorkflowLaser_manual_alignPropertyMotor_beam_shifter_position(self._context)
        self.laser_readout_enabled = RootWorkflowLaser_manual_alignPropertyLaser_readout_enabled(self._context)
        self.laser_spot_intensity = RootWorkflowLaser_manual_alignPropertyLaser_spot_intensity(self._context)
        self.laser_readout_power = RootWorkflowLaser_manual_alignPropertyLaser_readout_power(self._context)
        self.enable_laser_clean_drive = RootWorkflowLaser_manual_alignPropertyEnable_laser_clean_drive(self._context)
        self.deflection_normal = RootWorkflowLaser_manual_alignPropertyDeflection_normal(self._context)


class RootWorkflowLaser_manual_alignSignalWf_finished(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.signal.wf_finished'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_manual_align.signal.wf_finished.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_manual_align.signal.wf_finished.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_manual_align.signal.wf_finished.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_manual_align.signal.wf_finished.call', *args, **kwargs)


class RootWorkflowLaser_manual_alignSignalProcedure_info(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.signal.procedure_info'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_manual_align.signal.procedure_info.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_manual_align.signal.procedure_info.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_manual_align.signal.procedure_info.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_manual_align.signal.procedure_info.call', *args, **kwargs)


class RootWorkflowLaser_manual_alignSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align.signal'
        self.procedure_info = RootWorkflowLaser_manual_alignSignalProcedure_info(self._context)
        self.wf_finished = RootWorkflowLaser_manual_alignSignalWf_finished(self._context)


class RootWorkflowLaser_manual_align(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_manual_align'
        self.signal = RootWorkflowLaser_manual_alignSignal(self._context)
        self.property = RootWorkflowLaser_manual_alignProperty(self._context)

    def start_moving_motors(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_manual_align.start_moving_motors', *args, **kwargs)

    def stop_motors(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_manual_align.stop_motors', *args, **kwargs)

    def start_updating_detector_status(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_manual_align.start_updating_detector_status', *args, **kwargs)

    def update_motor_move(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_manual_align.update_motor_move', *args, **kwargs)

    def stop_updating_detector_status(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_manual_align.stop_updating_detector_status', *args, **kwargs)


class RootWorkflowManager(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.manager'

    @property
    def session_name(self) -> str:
        return str(self._context.get('root.workflow.manager.session_name'))

    @session_name.setter
    def session_name(self, new_val:str):
        self._context.set('root.workflow.manager.session_name', str(new_val))


class RootWorkflowMonitoring(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.monitoring'


class RootWorkflowXy_closed_loopPropertyXy_closed_loop_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.xy_closed_loop.property.xy_closed_loop_enabled'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.xy_closed_loop.property.xy_closed_loop_enabled.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.xy_closed_loop.property.xy_closed_loop_enabled.value', bool(new_val))


class RootWorkflowXy_closed_loopPropertyXy_closed_loop_idle_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.xy_closed_loop.property.xy_closed_loop_idle_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.xy_closed_loop.property.xy_closed_loop_idle_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.xy_closed_loop.property.xy_closed_loop_idle_speed.value', float(new_val))


class RootWorkflowXy_closed_loopPropertyXy_closed_loop_idle_speed_reduction(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.xy_closed_loop.property.xy_closed_loop_idle_speed_reduction'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.xy_closed_loop.property.xy_closed_loop_idle_speed_reduction.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.xy_closed_loop.property.xy_closed_loop_idle_speed_reduction.value', float(new_val))


class RootWorkflowXy_closed_loopPropertyXy_closed_loop_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.xy_closed_loop.property.xy_closed_loop_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.xy_closed_loop.property.xy_closed_loop_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.xy_closed_loop.property.xy_closed_loop_speed.value', float(new_val))


class RootWorkflowXy_closed_loopProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.xy_closed_loop.property'
        self.xy_closed_loop_speed = RootWorkflowXy_closed_loopPropertyXy_closed_loop_speed(self._context)
        self.xy_closed_loop_idle_speed_reduction = RootWorkflowXy_closed_loopPropertyXy_closed_loop_idle_speed_reduction(self._context)
        self.xy_closed_loop_idle_speed = RootWorkflowXy_closed_loopPropertyXy_closed_loop_idle_speed(self._context)
        self.xy_closed_loop_enabled = RootWorkflowXy_closed_loopPropertyXy_closed_loop_enabled(self._context)


class RootWorkflowXy_closed_loop(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.xy_closed_loop'
        self.property = RootWorkflowXy_closed_loopProperty(self._context)

    def start_xyz_sensor_calibration(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.xy_closed_loop.start_xyz_sensor_calibration', *args, **kwargs)

    def toggle_xy_closed_loop(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.xy_closed_loop.toggle_xy_closed_loop', *args, **kwargs)


class RootWorkflowData_processing(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.data_processing'


class RootWorkflowApproach_motorsSignalProcedure_info(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach_motors.signal.procedure_info'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach_motors.signal.procedure_info.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach_motors.signal.procedure_info.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach_motors.signal.procedure_info.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach_motors.signal.procedure_info.call', *args, **kwargs)


class RootWorkflowApproach_motorsSignalMotor_move_finished(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach_motors.signal.motor_move_finished'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach_motors.signal.motor_move_finished.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach_motors.signal.motor_move_finished.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach_motors.signal.motor_move_finished.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach_motors.signal.motor_move_finished.call', *args, **kwargs)


class RootWorkflowApproach_motorsSignalMotor_move_started(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach_motors.signal.motor_move_started'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach_motors.signal.motor_move_started.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach_motors.signal.motor_move_started.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach_motors.signal.motor_move_started.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.approach_motors.signal.motor_move_started.call', *args, **kwargs)


class RootWorkflowApproach_motorsSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach_motors.signal'
        self.motor_move_started = RootWorkflowApproach_motorsSignalMotor_move_started(self._context)
        self.motor_move_finished = RootWorkflowApproach_motorsSignalMotor_move_finished(self._context)
        self.procedure_info = RootWorkflowApproach_motorsSignalProcedure_info(self._context)


class RootWorkflowApproach_motorsPropertyMotor_front_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach_motors.property.motor_front_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach_motors.property.motor_front_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach_motors.property.motor_front_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach_motors.property.motor_front_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach_motors.property.motor_front_position.value', float(new_val))


class RootWorkflowApproach_motorsPropertyMotor_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach_motors.property.motor_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach_motors.property.motor_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach_motors.property.motor_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach_motors.property.motor_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach_motors.property.motor_speed.value', float(new_val))


class RootWorkflowApproach_motorsPropertyMax_motor_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach_motors.property.max_motor_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach_motors.property.max_motor_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach_motors.property.max_motor_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach_motors.property.max_motor_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach_motors.property.max_motor_speed.value', float(new_val))


class RootWorkflowApproach_motorsPropertyRelative_motor_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach_motors.property.relative_motor_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach_motors.property.relative_motor_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach_motors.property.relative_motor_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach_motors.property.relative_motor_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach_motors.property.relative_motor_speed.value', float(new_val))


class RootWorkflowApproach_motorsPropertyMotor_right_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach_motors.property.motor_right_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach_motors.property.motor_right_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach_motors.property.motor_right_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach_motors.property.motor_right_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach_motors.property.motor_right_position.value', float(new_val))


class RootWorkflowApproach_motorsPropertyMotor_left_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach_motors.property.motor_left_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach_motors.property.motor_left_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach_motors.property.motor_left_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach_motors.property.motor_left_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach_motors.property.motor_left_position.value', float(new_val))


class RootWorkflowApproach_motorsPropertyMotor_step(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach_motors.property.motor_step'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach_motors.property.motor_step.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach_motors.property.motor_step.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach_motors.property.motor_step.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach_motors.property.motor_step.value', float(new_val))


class RootWorkflowApproach_motorsPropertyRelative_tip_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach_motors.property.relative_tip_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.approach_motors.property.relative_tip_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.approach_motors.property.relative_tip_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.approach_motors.property.relative_tip_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.approach_motors.property.relative_tip_position.value', float(new_val))


class RootWorkflowApproach_motorsProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach_motors.property'
        self.relative_tip_position = RootWorkflowApproach_motorsPropertyRelative_tip_position(self._context)
        self.motor_step = RootWorkflowApproach_motorsPropertyMotor_step(self._context)
        self.motor_left_position = RootWorkflowApproach_motorsPropertyMotor_left_position(self._context)
        self.motor_right_position = RootWorkflowApproach_motorsPropertyMotor_right_position(self._context)
        self.relative_motor_speed = RootWorkflowApproach_motorsPropertyRelative_motor_speed(self._context)
        self.max_motor_speed = RootWorkflowApproach_motorsPropertyMax_motor_speed(self._context)
        self.motor_speed = RootWorkflowApproach_motorsPropertyMotor_speed(self._context)
        self.motor_front_position = RootWorkflowApproach_motorsPropertyMotor_front_position(self._context)


class RootWorkflowApproach_motors(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.approach_motors'
        self.property = RootWorkflowApproach_motorsProperty(self._context)
        self.signal = RootWorkflowApproach_motorsSignal(self._context)


class RootWorkflowMeasurement_setup(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.measurement_setup'


class RootWorkflowParameters(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.parameters'

    def load_from_file(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.parameters.load_from_file', *args, **kwargs)

    def save_to_file(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.parameters.save_to_file', *args, **kwargs)


class RootWorkflowSignal_selection(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.signal_selection'


class RootWorkflowData_source_controller(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.data_source_controller'


class RootWorkflowLaser_auto_alignPropertyThermal_check_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_auto_align.property.thermal_check_enabled'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.laser_auto_align.property.thermal_check_enabled.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.laser_auto_align.property.thermal_check_enabled.value', bool(new_val))


class RootWorkflowLaser_auto_alignProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_auto_align.property'
        self.thermal_check_enabled = RootWorkflowLaser_auto_alignPropertyThermal_check_enabled(self._context)


class RootWorkflowLaser_auto_alignSignalProcedure_info(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_auto_align.signal.procedure_info'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_auto_align.signal.procedure_info.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_auto_align.signal.procedure_info.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_auto_align.signal.procedure_info.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_auto_align.signal.procedure_info.call', *args, **kwargs)


class RootWorkflowLaser_auto_alignSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_auto_align.signal'
        self.procedure_info = RootWorkflowLaser_auto_alignSignalProcedure_info(self._context)


class RootWorkflowLaser_auto_align(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.laser_auto_align'
        self.signal = RootWorkflowLaser_auto_alignSignal(self._context)
        self.property = RootWorkflowLaser_auto_alignProperty(self._context)

    def go_to_default_beam_shifter_position(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_auto_align.go_to_default_beam_shifter_position', *args, **kwargs)

    def auto_align_all(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_auto_align.auto_align_all', *args, **kwargs)

    def is_idle(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_auto_align.is_idle', *args, **kwargs)

    def optimize_focus(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_auto_align.optimize_focus', *args, **kwargs)

    def abort(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_auto_align.abort', *args, **kwargs)

    def auto_align_cleandrive_laser(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_auto_align.auto_align_cleandrive_laser', *args, **kwargs)

    def go_to_default_focus_position(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_auto_align.go_to_default_focus_position', *args, **kwargs)

    def is_checking_thermal(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_auto_align.is_checking_thermal', *args, **kwargs)

    def go_to_optical_centers(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_auto_align.go_to_optical_centers', *args, **kwargs)

    def center_detector(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_auto_align.center_detector', *args, **kwargs)

    def auto_align_readout_laser(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.laser_auto_align.auto_align_readout_laser', *args, **kwargs)


class RootWorkflowSpectroscopy(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.spectroscopy'

    def start_grid(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy.start_grid', *args, **kwargs)

    def stop(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy.stop', *args, **kwargs)

    def start_cycle(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy.start_cycle', *args, **kwargs)


class RootWorkflowSpectroscopy_setupSignalProcedure_info(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.spectroscopy_setup.signal.procedure_info'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.signal.procedure_info.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.signal.procedure_info.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.signal.procedure_info.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.signal.procedure_info.call', *args, **kwargs)


class RootWorkflowSpectroscopy_setupSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.spectroscopy_setup.signal'
        self.procedure_info = RootWorkflowSpectroscopy_setupSignalProcedure_info(self._context)


class RootWorkflowSpectroscopy_setupPropertyOffset_y(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.spectroscopy_setup.property.offset_y'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.spectroscopy_setup.property.offset_y.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.spectroscopy_setup.property.offset_y.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.spectroscopy_setup.property.offset_y.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.spectroscopy_setup.property.offset_y.value', float(new_val))


class RootWorkflowSpectroscopy_setupPropertySelected_cycle(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.spectroscopy_setup.property.selected_cycle'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.spectroscopy_setup.property.selected_cycle.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.spectroscopy_setup.property.selected_cycle.value', int(new_val))


class RootWorkflowSpectroscopy_setupPropertyXy_move_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.spectroscopy_setup.property.xy_move_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.spectroscopy_setup.property.xy_move_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.spectroscopy_setup.property.xy_move_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.spectroscopy_setup.property.xy_move_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.spectroscopy_setup.property.xy_move_speed.value', float(new_val))


class RootWorkflowSpectroscopy_setupPropertyZ_closed_loop_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.spectroscopy_setup.property.z_closed_loop_enabled'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.spectroscopy_setup.property.z_closed_loop_enabled.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.spectroscopy_setup.property.z_closed_loop_enabled.value', bool(new_val))


class RootWorkflowSpectroscopy_setupPropertyNumber_of_columns(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.spectroscopy_setup.property.number_of_columns'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.spectroscopy_setup.property.number_of_columns.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.spectroscopy_setup.property.number_of_columns.value', int(new_val))


class RootWorkflowSpectroscopy_setupPropertyOffset_x(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.spectroscopy_setup.property.offset_x'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.spectroscopy_setup.property.offset_x.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.spectroscopy_setup.property.offset_x.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.spectroscopy_setup.property.offset_x.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.spectroscopy_setup.property.offset_x.value', float(new_val))


class RootWorkflowSpectroscopy_setupPropertySize_y(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.spectroscopy_setup.property.size_y'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.spectroscopy_setup.property.size_y.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.spectroscopy_setup.property.size_y.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.spectroscopy_setup.property.size_y.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.spectroscopy_setup.property.size_y.value', float(new_val))


class RootWorkflowSpectroscopy_setupPropertyRotation(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.spectroscopy_setup.property.rotation'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.spectroscopy_setup.property.rotation.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.spectroscopy_setup.property.rotation.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.spectroscopy_setup.property.rotation.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.spectroscopy_setup.property.rotation.value', float(new_val))


class RootWorkflowSpectroscopy_setupPropertyNumber_of_rows(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.spectroscopy_setup.property.number_of_rows'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.spectroscopy_setup.property.number_of_rows.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.spectroscopy_setup.property.number_of_rows.value', int(new_val))


class RootWorkflowSpectroscopy_setupPropertySize_x(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.spectroscopy_setup.property.size_x'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.spectroscopy_setup.property.size_x.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.spectroscopy_setup.property.size_x.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.spectroscopy_setup.property.size_x.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.spectroscopy_setup.property.size_x.value', float(new_val))


class RootWorkflowSpectroscopy_setupProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.spectroscopy_setup.property'
        self.size_x = RootWorkflowSpectroscopy_setupPropertySize_x(self._context)
        self.number_of_rows = RootWorkflowSpectroscopy_setupPropertyNumber_of_rows(self._context)
        self.rotation = RootWorkflowSpectroscopy_setupPropertyRotation(self._context)
        self.size_y = RootWorkflowSpectroscopy_setupPropertySize_y(self._context)
        self.offset_x = RootWorkflowSpectroscopy_setupPropertyOffset_x(self._context)
        self.number_of_columns = RootWorkflowSpectroscopy_setupPropertyNumber_of_columns(self._context)
        self.z_closed_loop_enabled = RootWorkflowSpectroscopy_setupPropertyZ_closed_loop_enabled(self._context)
        self.xy_move_speed = RootWorkflowSpectroscopy_setupPropertyXy_move_speed(self._context)
        self.selected_cycle = RootWorkflowSpectroscopy_setupPropertySelected_cycle(self._context)
        self.offset_y = RootWorkflowSpectroscopy_setupPropertyOffset_y(self._context)


class RootWorkflowSpectroscopy_setup(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.spectroscopy_setup'
        self.property = RootWorkflowSpectroscopy_setupProperty(self._context)
        self.signal = RootWorkflowSpectroscopy_setupSignal(self._context)

    def cycle_repetitions(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.cycle_repetitions', *args, **kwargs)

    def cycle_index_by_name(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.cycle_index_by_name', *args, **kwargs)

    def add_configured_segment(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.add_configured_segment', *args, **kwargs)

    def inter_cycle_idle_mode(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.inter_cycle_idle_mode', *args, **kwargs)

    def cycle_count(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.cycle_count', *args, **kwargs)

    def segment_count(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.segment_count', *args, **kwargs)

    def segment_configuration(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.segment_configuration', *args, **kwargs)

    def add_custom_cycle(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.add_custom_cycle', *args, **kwargs)

    def transform_segment(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.transform_segment', *args, **kwargs)

    def select_cycle(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.select_cycle', *args, **kwargs)

    def add_new_segment(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.add_new_segment', *args, **kwargs)

    def select_cycle_by_name(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.select_cycle_by_name', *args, **kwargs)

    def remove_segment(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.remove_segment', *args, **kwargs)

    def move_segment(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.move_segment', *args, **kwargs)

    def cycle_name(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.spectroscopy_setup.cycle_name', *args, **kwargs)


class RootWorkflowSpm_resource_requester(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.spm_resource_requester'


class RootWorkflowStoragePropertyGwy_backend_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.storage.property.gwy_backend_enabled'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.storage.property.gwy_backend_enabled.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.storage.property.gwy_backend_enabled.value', bool(new_val))


class RootWorkflowStoragePropertyNhf_auto_store_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Off = 0
        Current_File = 2
        New_File = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.storage.property.nhf_auto_store_mode'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.storage.property.nhf_auto_store_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.storage.property.nhf_auto_store_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.storage.property.nhf_auto_store_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.storage.property.nhf_auto_store_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.storage.property.nhf_auto_store_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.storage.property.nhf_auto_store_mode.value_raw', new_val.value)


class RootWorkflowStoragePropertyName_pattern(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.storage.property.name_pattern'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value(self) -> str:
        return str(self._context.get('root.workflow.storage.property.name_pattern.value'))

    @value.setter
    def value(self, new_val:str):
        self._context.set('root.workflow.storage.property.name_pattern.value', str(new_val))


class RootWorkflowStoragePropertyGallery_directory(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.storage.property.gallery_directory'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value(self) -> str:
        return str(self._context.get('root.workflow.storage.property.gallery_directory.value'))

    @value.setter
    def value(self, new_val:str):
        self._context.set('root.workflow.storage.property.gallery_directory.value', str(new_val))


class RootWorkflowStoragePropertyNext_file_index(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.storage.property.next_file_index'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.storage.property.next_file_index.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.storage.property.next_file_index.value', int(new_val))


class RootWorkflowStoragePropertyAuto_save_measurements_on_abort(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.storage.property.auto_save_measurements_on_abort'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.storage.property.auto_save_measurements_on_abort.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.storage.property.auto_save_measurements_on_abort.value', bool(new_val))


class RootWorkflowStoragePropertyNhf_backend_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.storage.property.nhf_backend_enabled'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.storage.property.nhf_backend_enabled.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.storage.property.nhf_backend_enabled.value', bool(new_val))


class RootWorkflowStorageProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.storage.property'
        self.nhf_backend_enabled = RootWorkflowStoragePropertyNhf_backend_enabled(self._context)
        self.auto_save_measurements_on_abort = RootWorkflowStoragePropertyAuto_save_measurements_on_abort(self._context)
        self.next_file_index = RootWorkflowStoragePropertyNext_file_index(self._context)
        self.gallery_directory = RootWorkflowStoragePropertyGallery_directory(self._context)
        self.name_pattern = RootWorkflowStoragePropertyName_pattern(self._context)
        self.nhf_auto_store_mode = RootWorkflowStoragePropertyNhf_auto_store_mode(self._context)
        self.gwy_backend_enabled = RootWorkflowStoragePropertyGwy_backend_enabled(self._context)


class RootWorkflowStorageSignalMeasurement_image_opened(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.storage.signal.measurement_image_opened'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.storage.signal.measurement_image_opened.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.storage.signal.measurement_image_opened.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.storage.signal.measurement_image_opened.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.storage.signal.measurement_image_opened.call', *args, **kwargs)


class RootWorkflowStorageSignalCurrent_measurement_image_changed(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.storage.signal.current_measurement_image_changed'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.storage.signal.current_measurement_image_changed.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.storage.signal.current_measurement_image_changed.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.storage.signal.current_measurement_image_changed.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.storage.signal.current_measurement_image_changed.call', *args, **kwargs)


class RootWorkflowStorageSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.storage.signal'
        self.current_measurement_image_changed = RootWorkflowStorageSignalCurrent_measurement_image_changed(self._context)
        self.measurement_image_opened = RootWorkflowStorageSignalMeasurement_image_opened(self._context)


class RootWorkflowStorage(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.storage'
        self.signal = RootWorkflowStorageSignal(self._context)
        self.property = RootWorkflowStorageProperty(self._context)

    def open_measurement(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.storage.open_measurement', *args, **kwargs)


class RootWorkflowSystem_startup(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.system_startup'


class RootWorkflowTemplateSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.template.signal'


class RootWorkflowTemplatePropertySeparator(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Minus = 0
        Underscore = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.template.property.separator'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.template.property.separator.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.template.property.separator.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.template.property.separator.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.template.property.separator.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.template.property.separator.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.template.property.separator.value_raw', new_val.value)


class RootWorkflowTemplatePropertyName_prefix(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.template.property.name_prefix'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value(self) -> str:
        return str(self._context.get('root.workflow.template.property.name_prefix.value'))

    @value.setter
    def value(self, new_val:str):
        self._context.set('root.workflow.template.property.name_prefix.value', str(new_val))


class RootWorkflowTemplateProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.template.property'
        self.name_prefix = RootWorkflowTemplatePropertyName_prefix(self._context)
        self.separator = RootWorkflowTemplatePropertySeparator(self._context)


class RootWorkflowTemplate(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.template'
        self.property = RootWorkflowTemplateProperty(self._context)
        self.signal = RootWorkflowTemplateSignal(self._context)

    def apply(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.template.apply', *args, **kwargs)

    def full_name(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.template.full_name', *args, **kwargs)

    def new_name(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.template.new_name', *args, **kwargs)


class RootWorkflowTip_guardSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.tip_guard.signal'


class RootWorkflowTip_guardProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.tip_guard.property'


class RootWorkflowTip_guard(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.tip_guard'
        self.property = RootWorkflowTip_guardProperty(self._context)
        self.signal = RootWorkflowTip_guardSignal(self._context)


class RootWorkflowWafer_alignment(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.wafer_alignment'


class RootWorkflowNecPropertyOut_user1_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.nec.property.out_user1_enabled'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.nec.property.out_user1_enabled.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.nec.property.out_user1_enabled.value', bool(new_val))


class RootWorkflowNecPropertyCafm_tip_current_max(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.nec.property.cafm_tip_current_max'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def index(self) -> int:
        return int(self._context.get('root.workflow.nec.property.cafm_tip_current_max.index'))

    @index.setter
    def index(self, new_val:int):
        self._context.set('root.workflow.nec.property.cafm_tip_current_max.index', int(new_val))

    @property
    def value(self) -> str:
        return str(self._context.get('root.workflow.nec.property.cafm_tip_current_max.value'))

    @value.setter
    def value(self, new_val:str):
        self._context.set('root.workflow.nec.property.cafm_tip_current_max.value', str(new_val))


class RootWorkflowNecPropertySsrm_calibration(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Log = 0
        Calibration_Table = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.nec.property.ssrm_calibration'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.nec.property.ssrm_calibration.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.nec.property.ssrm_calibration.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.nec.property.ssrm_calibration.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.nec.property.ssrm_calibration.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.nec.property.ssrm_calibration.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.nec.property.ssrm_calibration.value_raw', new_val.value)


class RootWorkflowNecPropertyOut_user4_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.nec.property.out_user4_enabled'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.nec.property.out_user4_enabled.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.nec.property.out_user4_enabled.value', bool(new_val))


class RootWorkflowNecPropertyOut_user3_voltage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.nec.property.out_user3_voltage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.nec.property.out_user3_voltage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.nec.property.out_user3_voltage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.nec.property.out_user3_voltage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.nec.property.out_user3_voltage.value', float(new_val))


class RootWorkflowNecPropertyOut_user2_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.nec.property.out_user2_enabled'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.nec.property.out_user2_enabled.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.nec.property.out_user2_enabled.value', bool(new_val))


class RootWorkflowNecPropertyOut_user4_voltage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.nec.property.out_user4_voltage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.nec.property.out_user4_voltage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.nec.property.out_user4_voltage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.nec.property.out_user4_voltage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.nec.property.out_user4_voltage.value', float(new_val))


class RootWorkflowNecPropertyOut_user3_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.nec.property.out_user3_enabled'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.nec.property.out_user3_enabled.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.nec.property.out_user3_enabled.value', bool(new_val))


class RootWorkflowNecPropertyCurrent_offset_sample_number(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.nec.property.current_offset_sample_number'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.nec.property.current_offset_sample_number.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.nec.property.current_offset_sample_number.value', int(new_val))


class RootWorkflowNecPropertyCurrent_offset(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.nec.property.current_offset'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.nec.property.current_offset.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.nec.property.current_offset.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.nec.property.current_offset.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.nec.property.current_offset.value', float(new_val))


class RootWorkflowNecPropertySsrm_polarity(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        positive = 0
        negative = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.nec.property.ssrm_polarity'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.nec.property.ssrm_polarity.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.nec.property.ssrm_polarity.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.nec.property.ssrm_polarity.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.nec.property.ssrm_polarity.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.nec.property.ssrm_polarity.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.nec.property.ssrm_polarity.value_raw', new_val.value)


class RootWorkflowNecPropertyOut_user1_voltage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.nec.property.out_user1_voltage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.nec.property.out_user1_voltage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.nec.property.out_user1_voltage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.nec.property.out_user1_voltage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.nec.property.out_user1_voltage.value', float(new_val))


class RootWorkflowNecPropertyCurrent_offset_measure_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.nec.property.current_offset_measure_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.nec.property.current_offset_measure_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.nec.property.current_offset_measure_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.nec.property.current_offset_measure_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.nec.property.current_offset_measure_time.value', float(new_val))


class RootWorkflowNecPropertyOut_user2_voltage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.nec.property.out_user2_voltage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.nec.property.out_user2_voltage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.nec.property.out_user2_voltage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.nec.property.out_user2_voltage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.nec.property.out_user2_voltage.value', float(new_val))


class RootWorkflowNecPropertyTip_voltage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.nec.property.tip_voltage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.nec.property.tip_voltage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.nec.property.tip_voltage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.nec.property.tip_voltage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.nec.property.tip_voltage.value', float(new_val))


class RootWorkflowNecProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.nec.property'
        self.tip_voltage = RootWorkflowNecPropertyTip_voltage(self._context)
        self.out_user2_voltage = RootWorkflowNecPropertyOut_user2_voltage(self._context)
        self.current_offset_measure_time = RootWorkflowNecPropertyCurrent_offset_measure_time(self._context)
        self.out_user1_voltage = RootWorkflowNecPropertyOut_user1_voltage(self._context)
        self.ssrm_polarity = RootWorkflowNecPropertySsrm_polarity(self._context)
        self.current_offset = RootWorkflowNecPropertyCurrent_offset(self._context)
        self.current_offset_sample_number = RootWorkflowNecPropertyCurrent_offset_sample_number(self._context)
        self.out_user3_enabled = RootWorkflowNecPropertyOut_user3_enabled(self._context)
        self.out_user4_voltage = RootWorkflowNecPropertyOut_user4_voltage(self._context)
        self.out_user2_enabled = RootWorkflowNecPropertyOut_user2_enabled(self._context)
        self.out_user3_voltage = RootWorkflowNecPropertyOut_user3_voltage(self._context)
        self.out_user4_enabled = RootWorkflowNecPropertyOut_user4_enabled(self._context)
        self.ssrm_calibration = RootWorkflowNecPropertySsrm_calibration(self._context)
        self.cafm_tip_current_max = RootWorkflowNecPropertyCafm_tip_current_max(self._context)
        self.out_user1_enabled = RootWorkflowNecPropertyOut_user1_enabled(self._context)


class RootWorkflowNecSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.nec.signal'


class RootWorkflowNec(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.nec'
        self.signal = RootWorkflowNecSignal(self._context)
        self.property = RootWorkflowNecProperty(self._context)

    def auto_current_offset(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.nec.auto_current_offset', *args, **kwargs)


class RootWorkflowWafer_chuck(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.wafer_chuck'


class RootWorkflowWafer_defects(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.wafer_defects'

    def import_all_defects_into_workspace(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.wafer_defects.import_all_defects_into_workspace', *args, **kwargs)

    def import_defect_into_workspace(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.wafer_defects.import_defect_into_workspace', *args, **kwargs)

    def defect_count(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.wafer_defects.defect_count', *args, **kwargs)

    def load_klarf(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.wafer_defects.load_klarf', *args, **kwargs)

    def klarf_wafer_ids(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.wafer_defects.klarf_wafer_ids', *args, **kwargs)

    def defect_ids(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.wafer_defects.defect_ids', *args, **kwargs)

    def import_defects_into_workspace(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.wafer_defects.import_defects_into_workspace', *args, **kwargs)


class RootWorkflowSettingsPropertyPreference_gallery_directory(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.settings.property.preference_gallery_directory'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value(self) -> str:
        return str(self._context.get('root.workflow.settings.property.preference_gallery_directory.value'))

    @value.setter
    def value(self, new_val:str):
        self._context.set('root.workflow.settings.property.preference_gallery_directory.value', str(new_val))


class RootWorkflowSettingsPropertyPreference_filename_mask(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.settings.property.preference_filename_mask'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value(self) -> str:
        return str(self._context.get('root.workflow.settings.property.preference_filename_mask.value'))

    @value.setter
    def value(self, new_val:str):
        self._context.set('root.workflow.settings.property.preference_filename_mask.value', str(new_val))


class RootWorkflowSettingsProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.settings.property'
        self.preference_filename_mask = RootWorkflowSettingsPropertyPreference_filename_mask(self._context)
        self.preference_gallery_directory = RootWorkflowSettingsPropertyPreference_gallery_directory(self._context)


class RootWorkflowSettings(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.settings'
        self.property = RootWorkflowSettingsProperty(self._context)


class RootWorkflowOptions(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.options'

    def has_option(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.options.has_option', *args, **kwargs)


class RootWorkflowI2cEnums(wrap.CmdTreeProp):

    class Status_type(enum.Enum):
        not_connected = 1
        error_see_log = 2
        ok = 0
        failed_with_autolock = 3

    class Bus_ids(enum.Enum):
        controller = 0
        hv = 3
        interface_box = 1
        scan_head = 2
        user = 4

    class I2c_speed(enum.Enum):
        khz_default = 0
        khz_200 = 2
        khz_400 = 3
        khz_100 = 1

    class I2c_write_sync_mode(enum.Enum):
        nosync = 1
        sync = 0

    class Bus_types(enum.Enum):
        mcp2221 = 2
        cx_linux = 0
        cx_user = 1

    class I2c_single_byte_mode(enum.Enum):
        off = 1
        on = 0

    class Offset_type(enum.Enum):
        u8 = 1
        u16lsb = 3
        none = 0
        u16msb = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.i2c.enums'

class RootWorkflowI2c(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.i2c'

    @property
    def enums(self) -> RootWorkflowI2cEnums:
        return RootWorkflowI2cEnums(self._context)

    def write(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.i2c.write', *args, **kwargs)

    def read(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.i2c.read', *args, **kwargs)

    def map_bus_id_to_address(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.i2c.map_bus_id_to_address', *args, **kwargs)

    def connected(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.i2c.connected', *args, **kwargs)

    def lock(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.i2c.lock', *args, **kwargs)

    def create_metadata(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.i2c.create_metadata', *args, **kwargs)


class RootWorkflowWorkspace(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.workspace'

    def clear_item_pre_actions(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.clear_item_pre_actions', *args, **kwargs)

    def item_id_by_name(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.item_id_by_name', *args, **kwargs)

    def save_to_file(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.save_to_file', *args, **kwargs)

    def add_item_pre_action(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.add_item_pre_action', *args, **kwargs)

    def all_item_ids_in_layer(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.all_item_ids_in_layer', *args, **kwargs)

    def get_item_rotation(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.get_item_rotation', *args, **kwargs)

    def get_item_position(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.get_item_position', *args, **kwargs)

    def delete_all_items(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.delete_all_items', *args, **kwargs)

    def add_frame(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.add_frame', *args, **kwargs)

    def selected_item_id(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.selected_item_id', *args, **kwargs)

    def get_item_position_x(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.get_item_position_x', *args, **kwargs)

    def get_item_position_y(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.get_item_position_y', *args, **kwargs)

    def add_point(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.add_point', *args, **kwargs)

    def get_linked_item_id(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.get_linked_item_id', *args, **kwargs)

    def default_afm_item_id(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.default_afm_item_id', *args, **kwargs)

    def active_item_id(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.active_item_id', *args, **kwargs)

    def get_item_name(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.get_item_name', *args, **kwargs)

    def set_item_visible(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.set_item_visible', *args, **kwargs)

    def set_item_transparency(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.set_item_transparency', *args, **kwargs)

    def set_item_size(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.set_item_size', *args, **kwargs)

    def set_item_rotation(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.set_item_rotation', *args, **kwargs)

    def delete_all_items_in_layer_except_one(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.delete_all_items_in_layer_except_one', *args, **kwargs)

    def set_item_resolution(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.set_item_resolution', *args, **kwargs)

    def set_item_position(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.set_item_position', *args, **kwargs)

    def set_item_name(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.set_item_name', *args, **kwargs)

    def load_from_file(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.load_from_file', *args, **kwargs)

    def get_item_resolution(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.get_item_resolution', *args, **kwargs)

    def add_grid(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.add_grid', *args, **kwargs)

    def get_item_post_actions(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.get_item_post_actions', *args, **kwargs)

    def item_count(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.item_count', *args, **kwargs)

    def last_known_tip_position(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.last_known_tip_position', *args, **kwargs)

    def delete_all_items_in_layer(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.delete_all_items_in_layer', *args, **kwargs)

    def clear_item_post_actions(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.clear_item_post_actions', *args, **kwargs)

    def set_item_description(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.set_item_description', *args, **kwargs)

    def all_item_ids(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.all_item_ids', *args, **kwargs)

    def layer_count(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.layer_count', *args, **kwargs)

    def item_exists(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.item_exists', *args, **kwargs)

    def get_item_description(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.get_item_description', *args, **kwargs)

    def get_item_size(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.get_item_size', *args, **kwargs)

    def default_camera_item_id(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.default_camera_item_id', *args, **kwargs)

    def get_item_pre_actions(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.get_item_pre_actions', *args, **kwargs)

    def delete_item(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.delete_item', *args, **kwargs)

    def add_item_post_action(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.add_item_post_action', *args, **kwargs)

    def active_sample_id(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.active_sample_id', *args, **kwargs)

    def set_item_line_rate(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.workspace.set_item_line_rate', *args, **kwargs)


class RootWorkflowComp_dcPropertyCrosstalk_calibration_ok(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.comp_dc.property.crosstalk_calibration_ok'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.comp_dc.property.crosstalk_calibration_ok.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.comp_dc.property.crosstalk_calibration_ok.value', bool(new_val))


class RootWorkflowComp_dcPropertyMove_time(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.comp_dc.property.move_time'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.comp_dc.property.move_time.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.comp_dc.property.move_time.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.comp_dc.property.move_time.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.comp_dc.property.move_time.value', float(new_val))


class RootWorkflowComp_dcProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.comp_dc.property'
        self.move_time = RootWorkflowComp_dcPropertyMove_time(self._context)
        self.crosstalk_calibration_ok = RootWorkflowComp_dcPropertyCrosstalk_calibration_ok(self._context)


class RootWorkflowComp_dc(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.comp_dc'
        self.property = RootWorkflowComp_dcProperty(self._context)

    def reset_crosstalk_calibration(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.comp_dc.reset_crosstalk_calibration', *args, **kwargs)

    def start_crosstalk_calibration(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.comp_dc.start_crosstalk_calibration', *args, **kwargs)


class RootWorkflowHardware_detection(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.hardware_detection'


class RootWorkflowZ_controllerPropertyTopography(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Standard_Z = 0
        Fast_Z = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.z_controller.property.topography'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.z_controller.property.topography.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.z_controller.property.topography.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.z_controller.property.topography.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.z_controller.property.topography.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.z_controller.property.topography.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.z_controller.property.topography.value_raw', new_val.value)


class RootWorkflowZ_controllerPropertyZ_closed_loop_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.z_controller.property.z_closed_loop_enabled'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.z_controller.property.z_closed_loop_enabled.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.z_controller.property.z_closed_loop_enabled.value', bool(new_val))


class RootWorkflowZ_controllerPropertyZ_internal_current_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.z_controller.property.z_internal_current_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.z_controller.property.z_internal_current_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.z_controller.property.z_internal_current_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.z_controller.property.z_internal_current_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.z_controller.property.z_internal_current_position.value', float(new_val))


class RootWorkflowZ_controllerPropertyActual_feedback_value(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.z_controller.property.actual_feedback_value'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.z_controller.property.actual_feedback_value.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.z_controller.property.actual_feedback_value.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.z_controller.property.actual_feedback_value.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.z_controller.property.actual_feedback_value.value', float(new_val))


class RootWorkflowZ_controllerPropertySetpoint(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.z_controller.property.setpoint'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.z_controller.property.setpoint.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.z_controller.property.setpoint.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.z_controller.property.setpoint.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.z_controller.property.setpoint.value', float(new_val))


class RootWorkflowZ_controllerPropertyZ_fast_hv_enabled(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.z_controller.property.z_fast_hv_enabled'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.z_controller.property.z_fast_hv_enabled.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.z_controller.property.z_fast_hv_enabled.value', bool(new_val))


class RootWorkflowZ_controllerPropertyFeedback_signal(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.z_controller.property.feedback_signal'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value(self) -> str:
        return str(self._context.get('root.workflow.z_controller.property.feedback_signal.value'))

    @value.setter
    def value(self, new_val:str):
        self._context.set('root.workflow.z_controller.property.feedback_signal.value', str(new_val))


class RootWorkflowZ_controllerPropertyZ_fast_current_position(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.z_controller.property.z_fast_current_position'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.z_controller.property.z_fast_current_position.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.z_controller.property.z_fast_current_position.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.z_controller.property.z_fast_current_position.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.z_controller.property.z_fast_current_position.value', float(new_val))


class RootWorkflowZ_controllerProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.z_controller.property'
        self.z_fast_current_position = RootWorkflowZ_controllerPropertyZ_fast_current_position(self._context)
        self.feedback_signal = RootWorkflowZ_controllerPropertyFeedback_signal(self._context)
        self.z_fast_hv_enabled = RootWorkflowZ_controllerPropertyZ_fast_hv_enabled(self._context)
        self.setpoint = RootWorkflowZ_controllerPropertySetpoint(self._context)
        self.actual_feedback_value = RootWorkflowZ_controllerPropertyActual_feedback_value(self._context)
        self.z_internal_current_position = RootWorkflowZ_controllerPropertyZ_internal_current_position(self._context)
        self.z_closed_loop_enabled = RootWorkflowZ_controllerPropertyZ_closed_loop_enabled(self._context)
        self.topography = RootWorkflowZ_controllerPropertyTopography(self._context)


class RootWorkflowZ_controller(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.z_controller'
        self.property = RootWorkflowZ_controllerProperty(self._context)

    def tip_position_lower_limit(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.z_controller.tip_position_lower_limit', *args, **kwargs)

    def retract_tip(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.z_controller.retract_tip', *args, **kwargs)


class RootWorkflowWavemode_calibrationPropertyExcitation_frequency_min(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.wavemode_calibration.property.excitation_frequency_min'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.wavemode_calibration.property.excitation_frequency_min.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.wavemode_calibration.property.excitation_frequency_min.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.wavemode_calibration.property.excitation_frequency_min.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.wavemode_calibration.property.excitation_frequency_min.value', float(new_val))


class RootWorkflowWavemode_calibrationPropertyI_gain(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.wavemode_calibration.property.i_gain'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.wavemode_calibration.property.i_gain.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.wavemode_calibration.property.i_gain.value', int(new_val))


class RootWorkflowWavemode_calibrationPropertyNumber_averages_deflection(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.wavemode_calibration.property.number_averages_deflection'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.wavemode_calibration.property.number_averages_deflection.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.wavemode_calibration.property.number_averages_deflection.value', int(new_val))


class RootWorkflowWavemode_calibrationPropertyLaser_cleandrive_power_max(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.wavemode_calibration.property.laser_cleandrive_power_max'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.wavemode_calibration.property.laser_cleandrive_power_max.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.wavemode_calibration.property.laser_cleandrive_power_max.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.wavemode_calibration.property.laser_cleandrive_power_max.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.wavemode_calibration.property.laser_cleandrive_power_max.value', float(new_val))


class RootWorkflowWavemode_calibrationPropertyExcitation_amplitude_max(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.wavemode_calibration.property.excitation_amplitude_max'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.wavemode_calibration.property.excitation_amplitude_max.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.wavemode_calibration.property.excitation_amplitude_max.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.wavemode_calibration.property.excitation_amplitude_max.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.wavemode_calibration.property.excitation_amplitude_max.value', float(new_val))


class RootWorkflowWavemode_calibrationPropertyNumber_calibration_frequencies(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.wavemode_calibration.property.number_calibration_frequencies'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.wavemode_calibration.property.number_calibration_frequencies.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.wavemode_calibration.property.number_calibration_frequencies.value', int(new_val))


class RootWorkflowWavemode_calibrationPropertySetpoint(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.wavemode_calibration.property.setpoint'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.wavemode_calibration.property.setpoint.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.wavemode_calibration.property.setpoint.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.wavemode_calibration.property.setpoint.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.wavemode_calibration.property.setpoint.value', float(new_val))


class RootWorkflowWavemode_calibrationPropertyExcitation_frequency_max(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.wavemode_calibration.property.excitation_frequency_max'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.wavemode_calibration.property.excitation_frequency_max.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.wavemode_calibration.property.excitation_frequency_max.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.wavemode_calibration.property.excitation_frequency_max.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.wavemode_calibration.property.excitation_frequency_max.value', float(new_val))


class RootWorkflowWavemode_calibrationProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.wavemode_calibration.property'
        self.excitation_frequency_max = RootWorkflowWavemode_calibrationPropertyExcitation_frequency_max(self._context)
        self.setpoint = RootWorkflowWavemode_calibrationPropertySetpoint(self._context)
        self.number_calibration_frequencies = RootWorkflowWavemode_calibrationPropertyNumber_calibration_frequencies(self._context)
        self.excitation_amplitude_max = RootWorkflowWavemode_calibrationPropertyExcitation_amplitude_max(self._context)
        self.laser_cleandrive_power_max = RootWorkflowWavemode_calibrationPropertyLaser_cleandrive_power_max(self._context)
        self.number_averages_deflection = RootWorkflowWavemode_calibrationPropertyNumber_averages_deflection(self._context)
        self.i_gain = RootWorkflowWavemode_calibrationPropertyI_gain(self._context)
        self.excitation_frequency_min = RootWorkflowWavemode_calibrationPropertyExcitation_frequency_min(self._context)


class RootWorkflowWavemode_calibration(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.wavemode_calibration'
        self.property = RootWorkflowWavemode_calibrationProperty(self._context)

    def calibration_frequencies(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.wavemode_calibration.calibration_frequencies', *args, **kwargs)

    def apply(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.wavemode_calibration.apply', *args, **kwargs)

    def start(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.wavemode_calibration.start', *args, **kwargs)

    def calibration_phase_delays(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.wavemode_calibration.calibration_phase_delays', *args, **kwargs)

    def calibration_target_amplitude(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.wavemode_calibration.calibration_target_amplitude', *args, **kwargs)

    def abort(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.wavemode_calibration.abort', *args, **kwargs)

    def calibration_amplitude_correction_factors(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.wavemode_calibration.calibration_amplitude_correction_factors', *args, **kwargs)


class RootWorkflowThermal_tunePropertyResolution(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.property.resolution'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.thermal_tune.property.resolution.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.thermal_tune.property.resolution.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.thermal_tune.property.resolution.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.thermal_tune.property.resolution.value', float(new_val))


class RootWorkflowThermal_tunePropertyMeasurement_environment(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Air = 0
        Liquid = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.property.measurement_environment'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.thermal_tune.property.measurement_environment.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.thermal_tune.property.measurement_environment.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.thermal_tune.property.measurement_environment.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.thermal_tune.property.measurement_environment.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.thermal_tune.property.measurement_environment.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.thermal_tune.property.measurement_environment.value_raw', new_val.value)


class RootWorkflowThermal_tunePropertyTemperature(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.property.temperature'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.thermal_tune.property.temperature.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.thermal_tune.property.temperature.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.thermal_tune.property.temperature.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.thermal_tune.property.temperature.value', float(new_val))


class RootWorkflowThermal_tunePropertyFit_frequency_lower_bound(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.property.fit_frequency_lower_bound'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.thermal_tune.property.fit_frequency_lower_bound.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.thermal_tune.property.fit_frequency_lower_bound.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.thermal_tune.property.fit_frequency_lower_bound.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.thermal_tune.property.fit_frequency_lower_bound.value', float(new_val))


class RootWorkflowThermal_tunePropertyMax_frequency(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.property.max_frequency'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.thermal_tune.property.max_frequency.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.thermal_tune.property.max_frequency.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.thermal_tune.property.max_frequency.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.thermal_tune.property.max_frequency.value', float(new_val))


class RootWorkflowThermal_tunePropertyFit_frequency_upper_bound(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.property.fit_frequency_upper_bound'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.thermal_tune.property.fit_frequency_upper_bound.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.thermal_tune.property.fit_frequency_upper_bound.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.thermal_tune.property.fit_frequency_upper_bound.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.thermal_tune.property.fit_frequency_upper_bound.value', float(new_val))


class RootWorkflowThermal_tunePropertyIterations(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.property.iterations'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.thermal_tune.property.iterations.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.thermal_tune.property.iterations.value', int(new_val))


class RootWorkflowThermal_tunePropertyReduce_hires_artifacts(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.property.reduce_hires_artifacts'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.thermal_tune.property.reduce_hires_artifacts.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.thermal_tune.property.reduce_hires_artifacts.value', bool(new_val))


class RootWorkflowThermal_tuneProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.property'
        self.reduce_hires_artifacts = RootWorkflowThermal_tunePropertyReduce_hires_artifacts(self._context)
        self.iterations = RootWorkflowThermal_tunePropertyIterations(self._context)
        self.fit_frequency_upper_bound = RootWorkflowThermal_tunePropertyFit_frequency_upper_bound(self._context)
        self.max_frequency = RootWorkflowThermal_tunePropertyMax_frequency(self._context)
        self.fit_frequency_lower_bound = RootWorkflowThermal_tunePropertyFit_frequency_lower_bound(self._context)
        self.temperature = RootWorkflowThermal_tunePropertyTemperature(self._context)
        self.measurement_environment = RootWorkflowThermal_tunePropertyMeasurement_environment(self._context)
        self.resolution = RootWorkflowThermal_tunePropertyResolution(self._context)


class RootWorkflowThermal_tuneSignalNew_calibration_data(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.signal.new_calibration_data'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.new_calibration_data.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.new_calibration_data.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.new_calibration_data.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.new_calibration_data.call', *args, **kwargs)


class RootWorkflowThermal_tuneSignalStarted(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.signal.started'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.started.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.started.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.started.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.started.call', *args, **kwargs)


class RootWorkflowThermal_tuneSignalProgress(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.signal.progress'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.progress.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.progress.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.progress.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.progress.call', *args, **kwargs)


class RootWorkflowThermal_tuneSignalCurrent_calibration_changed(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.signal.current_calibration_changed'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.current_calibration_changed.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.current_calibration_changed.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.current_calibration_changed.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.current_calibration_changed.call', *args, **kwargs)


class RootWorkflowThermal_tuneSignalNew_average(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.signal.new_average'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.new_average.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.new_average.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.new_average.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.new_average.call', *args, **kwargs)


class RootWorkflowThermal_tuneSignalData_invalidated(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.signal.data_invalidated'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.data_invalidated.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.data_invalidated.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.data_invalidated.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.data_invalidated.call', *args, **kwargs)


class RootWorkflowThermal_tuneSignalEnded(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.signal.ended'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.ended.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.ended.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.ended.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.ended.call', *args, **kwargs)


class RootWorkflowThermal_tuneSignalProcedure_info(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.signal.procedure_info'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.procedure_info.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.procedure_info.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.procedure_info.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.procedure_info.call', *args, **kwargs)


class RootWorkflowThermal_tuneSignalNew_fit(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.signal.new_fit'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.new_fit.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.new_fit.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.new_fit.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.signal.new_fit.call', *args, **kwargs)


class RootWorkflowThermal_tuneSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune.signal'
        self.new_fit = RootWorkflowThermal_tuneSignalNew_fit(self._context)
        self.procedure_info = RootWorkflowThermal_tuneSignalProcedure_info(self._context)
        self.ended = RootWorkflowThermal_tuneSignalEnded(self._context)
        self.data_invalidated = RootWorkflowThermal_tuneSignalData_invalidated(self._context)
        self.new_average = RootWorkflowThermal_tuneSignalNew_average(self._context)
        self.current_calibration_changed = RootWorkflowThermal_tuneSignalCurrent_calibration_changed(self._context)
        self.progress = RootWorkflowThermal_tuneSignalProgress(self._context)
        self.started = RootWorkflowThermal_tuneSignalStarted(self._context)
        self.new_calibration_data = RootWorkflowThermal_tuneSignalNew_calibration_data(self._context)


class RootWorkflowThermal_tune(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.thermal_tune'
        self.signal = RootWorkflowThermal_tuneSignal(self._context)
        self.property = RootWorkflowThermal_tuneProperty(self._context)

    def start(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.start', *args, **kwargs)

    def abort(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.abort', *args, **kwargs)

    def apply(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.apply', *args, **kwargs)

    def current_calibration(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.current_calibration', *args, **kwargs)

    def wait_for_async_tasks_to_finish(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.wait_for_async_tasks_to_finish', *args, **kwargs)

    def is_busy(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.is_busy', *args, **kwargs)

    def refit(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.thermal_tune.refit', *args, **kwargs)


class RootWorkflowStageProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.stage.property'


class RootWorkflowStageSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.stage.signal'


class RootWorkflowStage(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.stage'
        self.signal = RootWorkflowStageSignal(self._context)
        self.property = RootWorkflowStageProperty(self._context)

    def stages(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.stage.stages', *args, **kwargs)

    def remove_stage(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.stage.remove_stage', *args, **kwargs)

    def init_stages(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.stage.init_stages', *args, **kwargs)

    def add_stage(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.stage.add_stage', *args, **kwargs)


class RootWorkflowCamera(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.camera'

    def get_exposure_auto(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.get_exposure_auto', *args, **kwargs)

    def move_focus_up_for_duration(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.move_focus_up_for_duration', *args, **kwargs)

    def set_exposure(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.set_exposure', *args, **kwargs)

    def get_focus(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.get_focus', *args, **kwargs)

    def resolution_list(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.resolution_list', *args, **kwargs)

    def get_gain(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.get_gain', *args, **kwargs)

    def is_connected(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.is_connected', *args, **kwargs)

    def set_gain_auto(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.set_gain_auto', *args, **kwargs)

    def has_illumination(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.has_illumination', *args, **kwargs)

    def get_illumination(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.get_illumination', *args, **kwargs)

    def get_exposure(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.get_exposure', *args, **kwargs)

    def camera_list(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.camera_list', *args, **kwargs)

    def focus_idle(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.focus_idle', *args, **kwargs)

    def set_gain(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.set_gain', *args, **kwargs)

    def set_resolution(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.set_resolution', *args, **kwargs)

    def save_current_frame_to_file(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.save_current_frame_to_file', *args, **kwargs)

    def set_exposure_auto(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.set_exposure_auto', *args, **kwargs)

    def get_resolution(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.get_resolution', *args, **kwargs)

    def set_illumination(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.set_illumination', *args, **kwargs)

    def move_focus_by_distance(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.move_focus_by_distance', *args, **kwargs)

    def move_focus_down_for_duration(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.move_focus_down_for_duration', *args, **kwargs)

    def has_gain_auto(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.has_gain_auto', *args, **kwargs)

    def has_focus(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.has_focus', *args, **kwargs)

    def get_gain_auto(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.get_gain_auto', *args, **kwargs)

    def has_exposure_auto(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.camera.has_exposure_auto', *args, **kwargs)


class RootWorkflowGain_finderSignalProcedure_info(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.gain_finder.signal.procedure_info'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.gain_finder.signal.procedure_info.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.gain_finder.signal.procedure_info.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.gain_finder.signal.procedure_info.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.gain_finder.signal.procedure_info.call', *args, **kwargs)


class RootWorkflowGain_finderSignalStarted(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.gain_finder.signal.started'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.gain_finder.signal.started.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.gain_finder.signal.started.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.gain_finder.signal.started.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.gain_finder.signal.started.call', *args, **kwargs)


class RootWorkflowGain_finderSignalFinished(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.gain_finder.signal.finished'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.gain_finder.signal.finished.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.gain_finder.signal.finished.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.gain_finder.signal.finished.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.gain_finder.signal.finished.call', *args, **kwargs)


class RootWorkflowGain_finderSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.gain_finder.signal'
        self.finished = RootWorkflowGain_finderSignalFinished(self._context)
        self.started = RootWorkflowGain_finderSignalStarted(self._context)
        self.procedure_info = RootWorkflowGain_finderSignalProcedure_info(self._context)


class RootWorkflowGain_finder(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.gain_finder'
        self.signal = RootWorkflowGain_finderSignal(self._context)

    def shutdown(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.gain_finder.shutdown', *args, **kwargs)

    def abort(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.gain_finder.abort', *args, **kwargs)

    def start(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.gain_finder.start', *args, **kwargs)


class RootWorkflowData_view(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.data_view'


class RootWorkflowCantileverPropertyCurrent_cantilever_q_factor(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever.property.current_cantilever_q_factor'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.cantilever.property.current_cantilever_q_factor.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.cantilever.property.current_cantilever_q_factor.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.cantilever.property.current_cantilever_q_factor.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.cantilever.property.current_cantilever_q_factor.value', float(new_val))


class RootWorkflowCantileverPropertyCurrent_cantilever_resonance_frequency(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever.property.current_cantilever_resonance_frequency'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.cantilever.property.current_cantilever_resonance_frequency.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.cantilever.property.current_cantilever_resonance_frequency.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.cantilever.property.current_cantilever_resonance_frequency.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.cantilever.property.current_cantilever_resonance_frequency.value', float(new_val))


class RootWorkflowCantileverPropertyCurrent_cantilever_deflection_sensitivity(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever.property.current_cantilever_deflection_sensitivity'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.cantilever.property.current_cantilever_deflection_sensitivity.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.cantilever.property.current_cantilever_deflection_sensitivity.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.cantilever.property.current_cantilever_deflection_sensitivity.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.cantilever.property.current_cantilever_deflection_sensitivity.value', float(new_val))


class RootWorkflowCantileverPropertyCurrent_cantilever_spring_constant(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever.property.current_cantilever_spring_constant'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.cantilever.property.current_cantilever_spring_constant.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.cantilever.property.current_cantilever_spring_constant.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.cantilever.property.current_cantilever_spring_constant.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.cantilever.property.current_cantilever_spring_constant.value', float(new_val))


class RootWorkflowCantileverProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever.property'
        self.current_cantilever_spring_constant = RootWorkflowCantileverPropertyCurrent_cantilever_spring_constant(self._context)
        self.current_cantilever_deflection_sensitivity = RootWorkflowCantileverPropertyCurrent_cantilever_deflection_sensitivity(self._context)
        self.current_cantilever_resonance_frequency = RootWorkflowCantileverPropertyCurrent_cantilever_resonance_frequency(self._context)
        self.current_cantilever_q_factor = RootWorkflowCantileverPropertyCurrent_cantilever_q_factor(self._context)


class RootWorkflowCantilever(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever'
        self.property = RootWorkflowCantileverProperty(self._context)

    def apply(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever.apply', *args, **kwargs)

    def current_cantilever(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever.current_cantilever', *args, **kwargs)


class RootWorkflowScanner_ddcSignalProcedure_finished(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.scanner_ddc.signal.procedure_finished'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.scanner_ddc.signal.procedure_finished.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.scanner_ddc.signal.procedure_finished.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.scanner_ddc.signal.procedure_finished.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.scanner_ddc.signal.procedure_finished.call', *args, **kwargs)


class RootWorkflowScanner_ddcSignalProcedure_progress(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.scanner_ddc.signal.procedure_progress'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.scanner_ddc.signal.procedure_progress.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.scanner_ddc.signal.procedure_progress.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.scanner_ddc.signal.procedure_progress.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.scanner_ddc.signal.procedure_progress.call', *args, **kwargs)


class RootWorkflowScanner_ddcSignalProcedure_info(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.scanner_ddc.signal.procedure_info'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.scanner_ddc.signal.procedure_info.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.scanner_ddc.signal.procedure_info.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.scanner_ddc.signal.procedure_info.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.scanner_ddc.signal.procedure_info.call', *args, **kwargs)


class RootWorkflowScanner_ddcSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.scanner_ddc.signal'
        self.procedure_info = RootWorkflowScanner_ddcSignalProcedure_info(self._context)
        self.procedure_progress = RootWorkflowScanner_ddcSignalProcedure_progress(self._context)
        self.procedure_finished = RootWorkflowScanner_ddcSignalProcedure_finished(self._context)


class RootWorkflowScanner_ddc(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.scanner_ddc'
        self.signal = RootWorkflowScanner_ddcSignal(self._context)

    def reset(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.scanner_ddc.reset', *args, **kwargs)

    def shutdown(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.scanner_ddc.shutdown', *args, **kwargs)

    def start(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.scanner_ddc.start', *args, **kwargs)

    def save(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.scanner_ddc.save', *args, **kwargs)

    def load(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.scanner_ddc.load', *args, **kwargs)

    def abort(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.scanner_ddc.abort', *args, **kwargs)


class RootWorkflowAutomationPropertyQueue_index(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.automation.property.queue_index'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.automation.property.queue_index.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.automation.property.queue_index.value', int(new_val))


class RootWorkflowAutomationPropertyStage_move_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.automation.property.stage_move_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.automation.property.stage_move_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.automation.property.stage_move_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.automation.property.stage_move_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.automation.property.stage_move_speed.value', float(new_val))


class RootWorkflowAutomationPropertyQueue_size(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.automation.property.queue_size'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.automation.property.queue_size.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.automation.property.queue_size.value', int(new_val))


class RootWorkflowAutomationProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.automation.property'
        self.queue_size = RootWorkflowAutomationPropertyQueue_size(self._context)
        self.stage_move_speed = RootWorkflowAutomationPropertyStage_move_speed(self._context)
        self.queue_index = RootWorkflowAutomationPropertyQueue_index(self._context)


class RootWorkflowAutomation(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.automation'
        self.property = RootWorkflowAutomationProperty(self._context)

    def pause(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.pause', *args, **kwargs)

    def add_all_accessible_items_to_queue(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.add_all_accessible_items_to_queue', *args, **kwargs)

    def is_idle(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.is_idle', *args, **kwargs)

    def abort(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.abort', *args, **kwargs)

    def is_running(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.is_running', *args, **kwargs)

    def remove_from_queue(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.remove_from_queue', *args, **kwargs)

    def clear_queue(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.clear_queue', *args, **kwargs)

    def process(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.process', *args, **kwargs)

    def update_queue_entry(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.update_queue_entry', *args, **kwargs)

    def add_to_queue(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.add_to_queue', *args, **kwargs)

    def queue_index_by_item_id(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.queue_index_by_item_id', *args, **kwargs)

    def start(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.start', *args, **kwargs)

    def resume(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.resume', *args, **kwargs)

    def reset_queue(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.reset_queue', *args, **kwargs)

    def is_item_queued(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.is_item_queued', *args, **kwargs)

    def queue_size(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.queue_size', *args, **kwargs)

    def queue_index_by_item_name(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.queue_index_by_item_name', *args, **kwargs)

    def queue_info(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.queue_info', *args, **kwargs)

    def move_queue_entry(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.move_queue_entry', *args, **kwargs)

    def is_paused(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.is_paused', *args, **kwargs)

    def insert_in_queue(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.automation.insert_in_queue', *args, **kwargs)


class RootWorkflowUser_ioSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.user_io.signal'


class RootWorkflowUser_ioPropertyOut_user3_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Fast_In_Deflection = 16
        Analyzer_1_Phase_Error = 77
        Ramp_User_Out_3 = 53
        Analyzer_2_Ctrl_Amp_ = 85
        Z_Controller_In = 63
        Fast_In_2 = 17
        User_In_1 = 9
        Fast_Z_Axis_Controller_Out = 71
        Generator_Drive_X = 46
        Comparator_2_Out = 100
        Ramp_Gen_X = 54
        Z_Controller_Nominal = 68
        Generator_Nominal_X = 45
        Ramp_Tip_Voltage = 57
        Analyzer_1_Amplitude = 78
        Analyzer_1_X = 79
        Generator_Drive_Z = 50
        Position_Z = 8
        Comparator_1_In_Filtered = 97
        Analyzer_2_Reference = 90
        Deflection = 4
        Comparator_1_Out = 98
        Analyzer_1_Y = 80
        Ramp_Gen_Z_Max = 62
        Z_Controller_Out = 67
        Analyzer_2_X = 88
        Ramp_Gen_Fast_Z_Axis = 56
        Y_Controller_Out = 70
        X_Controller_Out = 69
        Controller_User_1_Out = 72
        Ramp_Gen_Z_Plane = 60
        Comparator_3_In_Filtered = 101
        Analyzer_1_Reference = 81
        Tip_Current = 13
        Controller_User_2_Out = 73
        Comparator_3_Out = 102
        Lateral = 5
        Analyzer_1_Ctrl_Delta_f = 75
        Gen_Test_Dynamic = 2
        Position_X = 6
        User_In_4 = 12
        User_In_3 = 11
        Static = 0
        Z_Controller_Sum = 66
        WaveMode_Baseline = 93
        Generator_Spare_7 = 51
        Analyzer_1_Ctrl_Amp_ = 76
        Detector_Sum = 14
        Analyzer_2_Ctrl_Delta_f = 84
        Ramp_Gen_Y = 55
        Generator_Drive_Y = 48
        Ramp_User_Out_4 = 59
        Z_Controller_Error = 64
        Interface_In_Aux = 15
        WaveMode_Amp_Reduct_ = 94
        Fast_In_User = 18
        User_In_2 = 10
        Z_Controller_PID_Out = 65
        Ramp_User_Out_2 = 3
        Position_Y = 7
        Analyzer_2_Amplitude = 87
        Ramp_Gen_Z_Ctrl_ = 61
        Ramp_User_Out_1 = 58
        WaveMode_Excitation = 95
        Analyzer_2_Phase_Error = 86
        Analyzer_2_Y = 89
        Generator_Nominal_Y = 47
        Comparator_2_In_Filtered = 99
        Generator_Nominal_Z = 49
        Generator_Spare_8 = 52

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.user_io.property.out_user3_input'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.user_io.property.out_user3_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.user_io.property.out_user3_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.user_io.property.out_user3_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.user_io.property.out_user3_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.user_io.property.out_user3_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.user_io.property.out_user3_input.value_raw', new_val.value)


class RootWorkflowUser_ioPropertyOut_user1_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Fast_In_Deflection = 16
        Analyzer_1_Phase_Error = 77
        Ramp_User_Out_3 = 53
        Analyzer_2_Ctrl_Amp_ = 85
        Z_Controller_In = 63
        Fast_In_2 = 17
        User_In_1 = 9
        Fast_Z_Axis_Controller_Out = 71
        Generator_Drive_X = 46
        Comparator_2_Out = 100
        Ramp_Gen_X = 54
        Z_Controller_Nominal = 68
        Generator_Nominal_X = 45
        Ramp_Tip_Voltage = 57
        Analyzer_1_Amplitude = 78
        Analyzer_1_X = 79
        Generator_Drive_Z = 50
        Position_Z = 8
        Comparator_1_In_Filtered = 97
        Analyzer_2_Reference = 90
        Deflection = 4
        Comparator_1_Out = 98
        Analyzer_1_Y = 80
        Ramp_Gen_Z_Max = 62
        Z_Controller_Out = 67
        Analyzer_2_X = 88
        Ramp_Gen_Fast_Z_Axis = 56
        Y_Controller_Out = 70
        X_Controller_Out = 69
        Controller_User_1_Out = 72
        Ramp_Gen_Z_Plane = 60
        Comparator_3_In_Filtered = 101
        Analyzer_1_Reference = 81
        Tip_Current = 13
        Controller_User_2_Out = 73
        Comparator_3_Out = 102
        Lateral = 5
        Analyzer_1_Ctrl_Delta_f = 75
        Gen_Test_Dynamic = 2
        Position_X = 6
        User_In_4 = 12
        User_In_3 = 11
        Static = 0
        Z_Controller_Sum = 66
        WaveMode_Baseline = 93
        Generator_Spare_7 = 51
        Analyzer_1_Ctrl_Amp_ = 76
        Detector_Sum = 14
        Analyzer_2_Ctrl_Delta_f = 84
        Ramp_Gen_Y = 55
        Generator_Drive_Y = 48
        Ramp_User_Out_4 = 59
        Z_Controller_Error = 64
        Interface_In_Aux = 15
        WaveMode_Amp_Reduct_ = 94
        Fast_In_User = 18
        User_In_2 = 10
        Z_Controller_PID_Out = 65
        Ramp_User_Out_2 = 3
        Position_Y = 7
        Analyzer_2_Amplitude = 87
        Ramp_Gen_Z_Ctrl_ = 61
        Ramp_User_Out_1 = 58
        WaveMode_Excitation = 95
        Analyzer_2_Phase_Error = 86
        Analyzer_2_Y = 89
        Generator_Nominal_Y = 47
        Comparator_2_In_Filtered = 99
        Generator_Nominal_Z = 49
        Generator_Spare_8 = 52

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.user_io.property.out_user1_input'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.user_io.property.out_user1_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.user_io.property.out_user1_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.user_io.property.out_user1_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.user_io.property.out_user1_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.user_io.property.out_user1_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.user_io.property.out_user1_input.value_raw', new_val.value)


class RootWorkflowUser_ioPropertyOut_user2_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Fast_In_Deflection = 16
        Analyzer_1_Phase_Error = 77
        Ramp_User_Out_3 = 53
        Analyzer_2_Ctrl_Amp_ = 85
        Z_Controller_In = 63
        Fast_In_2 = 17
        User_In_1 = 9
        Fast_Z_Axis_Controller_Out = 71
        Generator_Drive_X = 46
        Comparator_2_Out = 100
        Ramp_Gen_X = 54
        Z_Controller_Nominal = 68
        Generator_Nominal_X = 45
        Ramp_Tip_Voltage = 57
        Analyzer_1_Amplitude = 78
        Analyzer_1_X = 79
        Generator_Drive_Z = 50
        Position_Z = 8
        Comparator_1_In_Filtered = 97
        Analyzer_2_Reference = 90
        Deflection = 4
        Comparator_1_Out = 98
        Analyzer_1_Y = 80
        Ramp_Gen_Z_Max = 62
        Z_Controller_Out = 67
        Analyzer_2_X = 88
        Ramp_Gen_Fast_Z_Axis = 56
        Y_Controller_Out = 70
        X_Controller_Out = 69
        Controller_User_1_Out = 72
        Ramp_Gen_Z_Plane = 60
        Comparator_3_In_Filtered = 101
        Analyzer_1_Reference = 81
        Tip_Current = 13
        Controller_User_2_Out = 73
        Comparator_3_Out = 102
        Lateral = 5
        Analyzer_1_Ctrl_Delta_f = 75
        Gen_Test_Dynamic = 2
        Position_X = 6
        User_In_4 = 12
        User_In_3 = 11
        Static = 0
        Z_Controller_Sum = 66
        WaveMode_Baseline = 93
        Generator_Spare_7 = 51
        Analyzer_1_Ctrl_Amp_ = 76
        Detector_Sum = 14
        Analyzer_2_Ctrl_Delta_f = 84
        Ramp_Gen_Y = 55
        Generator_Drive_Y = 48
        Ramp_User_Out_4 = 59
        Z_Controller_Error = 64
        Interface_In_Aux = 15
        WaveMode_Amp_Reduct_ = 94
        Fast_In_User = 18
        User_In_2 = 10
        Z_Controller_PID_Out = 65
        Ramp_User_Out_2 = 3
        Position_Y = 7
        Analyzer_2_Amplitude = 87
        Ramp_Gen_Z_Ctrl_ = 61
        Ramp_User_Out_1 = 58
        WaveMode_Excitation = 95
        Analyzer_2_Phase_Error = 86
        Analyzer_2_Y = 89
        Generator_Nominal_Y = 47
        Comparator_2_In_Filtered = 99
        Generator_Nominal_Z = 49
        Generator_Spare_8 = 52

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.user_io.property.out_user2_input'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.user_io.property.out_user2_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.user_io.property.out_user2_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.user_io.property.out_user2_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.user_io.property.out_user2_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.user_io.property.out_user2_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.user_io.property.out_user2_input.value_raw', new_val.value)


class RootWorkflowUser_ioPropertyOut_fast_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Fast_In_User = 18
        Fast_Z_Axis_Controller_Out = 71
        Z_Controller_Out = 67
        Analyzer_1_Reference = 81
        Fast_In_2 = 17
        Analyzer_2_Reference = 90
        Deflection = 4
        WaveMode_Excitation = 95
        Static = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.user_io.property.out_fast_input'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.user_io.property.out_fast_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.user_io.property.out_fast_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.user_io.property.out_fast_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.user_io.property.out_fast_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.user_io.property.out_fast_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.user_io.property.out_fast_input.value_raw', new_val.value)


class RootWorkflowUser_ioPropertyOut_user3_voltage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.user_io.property.out_user3_voltage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.user_io.property.out_user3_voltage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.user_io.property.out_user3_voltage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.user_io.property.out_user3_voltage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.user_io.property.out_user3_voltage.value', float(new_val))


class RootWorkflowUser_ioPropertyOut_user4_input(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Fast_In_Deflection = 16
        Analyzer_1_Phase_Error = 77
        Ramp_User_Out_3 = 53
        Analyzer_2_Ctrl_Amp_ = 85
        Z_Controller_In = 63
        Fast_In_2 = 17
        User_In_1 = 9
        Fast_Z_Axis_Controller_Out = 71
        Generator_Drive_X = 46
        Comparator_2_Out = 100
        Ramp_Gen_X = 54
        Z_Controller_Nominal = 68
        Generator_Nominal_X = 45
        Ramp_Tip_Voltage = 57
        Analyzer_1_Amplitude = 78
        Analyzer_1_X = 79
        Generator_Drive_Z = 50
        Position_Z = 8
        Comparator_1_In_Filtered = 97
        Analyzer_2_Reference = 90
        Deflection = 4
        Comparator_1_Out = 98
        Analyzer_1_Y = 80
        Ramp_Gen_Z_Max = 62
        Z_Controller_Out = 67
        Analyzer_2_X = 88
        Ramp_Gen_Fast_Z_Axis = 56
        Y_Controller_Out = 70
        X_Controller_Out = 69
        Controller_User_1_Out = 72
        Ramp_Gen_Z_Plane = 60
        Comparator_3_In_Filtered = 101
        Analyzer_1_Reference = 81
        Tip_Current = 13
        Controller_User_2_Out = 73
        Comparator_3_Out = 102
        Lateral = 5
        Analyzer_1_Ctrl_Delta_f = 75
        Gen_Test_Dynamic = 2
        Position_X = 6
        User_In_4 = 12
        User_In_3 = 11
        Static = 0
        Z_Controller_Sum = 66
        WaveMode_Baseline = 93
        Generator_Spare_7 = 51
        Analyzer_1_Ctrl_Amp_ = 76
        Detector_Sum = 14
        Analyzer_2_Ctrl_Delta_f = 84
        Ramp_Gen_Y = 55
        Generator_Drive_Y = 48
        Ramp_User_Out_4 = 59
        Z_Controller_Error = 64
        Interface_In_Aux = 15
        WaveMode_Amp_Reduct_ = 94
        Fast_In_User = 18
        User_In_2 = 10
        Z_Controller_PID_Out = 65
        Ramp_User_Out_2 = 3
        Position_Y = 7
        Analyzer_2_Amplitude = 87
        Ramp_Gen_Z_Ctrl_ = 61
        Ramp_User_Out_1 = 58
        WaveMode_Excitation = 95
        Analyzer_2_Phase_Error = 86
        Analyzer_2_Y = 89
        Generator_Nominal_Y = 47
        Comparator_2_In_Filtered = 99
        Generator_Nominal_Z = 49
        Generator_Spare_8 = 52

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.user_io.property.out_user4_input'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.user_io.property.out_user4_input.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.user_io.property.out_user4_input.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.user_io.property.out_user4_input.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.user_io.property.out_user4_input.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.user_io.property.out_user4_input.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.user_io.property.out_user4_input.value_raw', new_val.value)


class RootWorkflowUser_ioPropertyOut_user1_voltage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.user_io.property.out_user1_voltage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.user_io.property.out_user1_voltage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.user_io.property.out_user1_voltage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.user_io.property.out_user1_voltage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.user_io.property.out_user1_voltage.value', float(new_val))


class RootWorkflowUser_ioPropertyOut_user4_voltage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.user_io.property.out_user4_voltage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.user_io.property.out_user4_voltage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.user_io.property.out_user4_voltage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.user_io.property.out_user4_voltage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.user_io.property.out_user4_voltage.value', float(new_val))


class RootWorkflowUser_ioPropertyOut_user2_voltage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.user_io.property.out_user2_voltage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.user_io.property.out_user2_voltage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.user_io.property.out_user2_voltage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.user_io.property.out_user2_voltage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.user_io.property.out_user2_voltage.value', float(new_val))


class RootWorkflowUser_ioProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.user_io.property'
        self.out_user2_voltage = RootWorkflowUser_ioPropertyOut_user2_voltage(self._context)
        self.out_user4_voltage = RootWorkflowUser_ioPropertyOut_user4_voltage(self._context)
        self.out_user1_voltage = RootWorkflowUser_ioPropertyOut_user1_voltage(self._context)
        self.out_user4_input = RootWorkflowUser_ioPropertyOut_user4_input(self._context)
        self.out_user3_voltage = RootWorkflowUser_ioPropertyOut_user3_voltage(self._context)
        self.out_fast_input = RootWorkflowUser_ioPropertyOut_fast_input(self._context)
        self.out_user2_input = RootWorkflowUser_ioPropertyOut_user2_input(self._context)
        self.out_user1_input = RootWorkflowUser_ioPropertyOut_user1_input(self._context)
        self.out_user3_input = RootWorkflowUser_ioPropertyOut_user3_input(self._context)


class RootWorkflowUser_io(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.user_io'
        self.property = RootWorkflowUser_ioProperty(self._context)
        self.signal = RootWorkflowUser_ioSignal(self._context)


class RootWorkflowImage_importerPropertyImport_folder(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.image_importer.property.import_folder'
        self._lua_value_type = wrap.LuaType('str')

    @property
    def value(self) -> str:
        return str(self._context.get('root.workflow.image_importer.property.import_folder.value'))

    @value.setter
    def value(self, new_val:str):
        self._context.set('root.workflow.image_importer.property.import_folder.value', str(new_val))


class RootWorkflowImage_importerProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.image_importer.property'
        self.import_folder = RootWorkflowImage_importerPropertyImport_folder(self._context)


class RootWorkflowImage_importer(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.image_importer'
        self.property = RootWorkflowImage_importerProperty(self._context)

    def start_auto_import(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.image_importer.start_auto_import', *args, **kwargs)

    def import_and_add_to_workspace(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.image_importer.import_and_add_to_workspace', *args, **kwargs)

    def stop_auto_import(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.image_importer.stop_auto_import', *args, **kwargs)


class RootWorkflowCantilever_calibrationPropertySpectroscopy_cycle_repetitions(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.property.spectroscopy_cycle_repetitions'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.cantilever_calibration.property.spectroscopy_cycle_repetitions.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.cantilever_calibration.property.spectroscopy_cycle_repetitions.value', int(new_val))


class RootWorkflowCantilever_calibrationPropertyDeflection_sensitivity(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.property.deflection_sensitivity'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.cantilever_calibration.property.deflection_sensitivity.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.cantilever_calibration.property.deflection_sensitivity.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.cantilever_calibration.property.deflection_sensitivity.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.cantilever_calibration.property.deflection_sensitivity.value', float(new_val))


class RootWorkflowCantilever_calibrationPropertyAuto_cleandrive_off(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.property.auto_cleandrive_off'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.cantilever_calibration.property.auto_cleandrive_off.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.cantilever_calibration.property.auto_cleandrive_off.value', bool(new_val))


class RootWorkflowCantilever_calibrationPropertySpectroscopy_discarded_segments(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.property.spectroscopy_discarded_segments'
        self._lua_value_type = wrap.LuaType('int')

    @property
    def value(self) -> int:
        return int(self._context.get('root.workflow.cantilever_calibration.property.spectroscopy_discarded_segments.value'))

    @value.setter
    def value(self, new_val:int):
        self._context.set('root.workflow.cantilever_calibration.property.spectroscopy_discarded_segments.value', int(new_val))


class RootWorkflowCantilever_calibrationPropertySpectroscopy_withdraw_distance(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.property.spectroscopy_withdraw_distance'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.cantilever_calibration.property.spectroscopy_withdraw_distance.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.cantilever_calibration.property.spectroscopy_withdraw_distance.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.cantilever_calibration.property.spectroscopy_withdraw_distance.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.cantilever_calibration.property.spectroscopy_withdraw_distance.value', float(new_val))


class RootWorkflowCantilever_calibrationPropertySpectroscopy_distance(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.property.spectroscopy_distance'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.cantilever_calibration.property.spectroscopy_distance.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.cantilever_calibration.property.spectroscopy_distance.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.cantilever_calibration.property.spectroscopy_distance.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.cantilever_calibration.property.spectroscopy_distance.value', float(new_val))


class RootWorkflowCantilever_calibrationPropertyWavemode_calibration(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.property.wavemode_calibration'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.cantilever_calibration.property.wavemode_calibration.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.cantilever_calibration.property.wavemode_calibration.value', bool(new_val))


class RootWorkflowCantilever_calibrationPropertySpectroscopy_approach(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.property.spectroscopy_approach'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.cantilever_calibration.property.spectroscopy_approach.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.cantilever_calibration.property.spectroscopy_approach.value', bool(new_val))


class RootWorkflowCantilever_calibrationPropertySpectroscopy_used_segments(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Retract = 1
        Advance = 0
        Advance_and_Retract = 2

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.property.spectroscopy_used_segments'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.cantilever_calibration.property.spectroscopy_used_segments.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.cantilever_calibration.property.spectroscopy_used_segments.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.cantilever_calibration.property.spectroscopy_used_segments.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.cantilever_calibration.property.spectroscopy_used_segments.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.cantilever_calibration.property.spectroscopy_used_segments.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.cantilever_calibration.property.spectroscopy_used_segments.value_raw', new_val.value)


class RootWorkflowCantilever_calibrationPropertySpectroscopy_save_calibration_segments(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.property.spectroscopy_save_calibration_segments'
        self._lua_value_type = wrap.LuaType('bool')

    @property
    def value(self) -> bool:
        return bool(self._context.get('root.workflow.cantilever_calibration.property.spectroscopy_save_calibration_segments.value'))

    @value.setter
    def value(self, new_val:bool):
        self._context.set('root.workflow.cantilever_calibration.property.spectroscopy_save_calibration_segments.value', bool(new_val))


class RootWorkflowCantilever_calibrationPropertyOperation_mode(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        Contact = 1
        Non_Contact = 0

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.property.operation_mode'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.cantilever_calibration.property.operation_mode.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.cantilever_calibration.property.operation_mode.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.cantilever_calibration.property.operation_mode.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.cantilever_calibration.property.operation_mode.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.cantilever_calibration.property.operation_mode.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.cantilever_calibration.property.operation_mode.value_raw', new_val.value)


class RootWorkflowCantilever_calibrationPropertySpring_constant(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.property.spring_constant'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.cantilever_calibration.property.spring_constant.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.cantilever_calibration.property.spring_constant.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.cantilever_calibration.property.spring_constant.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.cantilever_calibration.property.spring_constant.value', float(new_val))


class RootWorkflowCantilever_calibrationPropertySpectroscopy_setpoint(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.property.spectroscopy_setpoint'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.cantilever_calibration.property.spectroscopy_setpoint.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.cantilever_calibration.property.spectroscopy_setpoint.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.cantilever_calibration.property.spectroscopy_setpoint.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.cantilever_calibration.property.spectroscopy_setpoint.value', float(new_val))


class RootWorkflowCantilever_calibrationProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.property'
        self.spectroscopy_setpoint = RootWorkflowCantilever_calibrationPropertySpectroscopy_setpoint(self._context)
        self.spring_constant = RootWorkflowCantilever_calibrationPropertySpring_constant(self._context)
        self.operation_mode = RootWorkflowCantilever_calibrationPropertyOperation_mode(self._context)
        self.spectroscopy_save_calibration_segments = RootWorkflowCantilever_calibrationPropertySpectroscopy_save_calibration_segments(self._context)
        self.spectroscopy_used_segments = RootWorkflowCantilever_calibrationPropertySpectroscopy_used_segments(self._context)
        self.spectroscopy_approach = RootWorkflowCantilever_calibrationPropertySpectroscopy_approach(self._context)
        self.wavemode_calibration = RootWorkflowCantilever_calibrationPropertyWavemode_calibration(self._context)
        self.spectroscopy_distance = RootWorkflowCantilever_calibrationPropertySpectroscopy_distance(self._context)
        self.spectroscopy_withdraw_distance = RootWorkflowCantilever_calibrationPropertySpectroscopy_withdraw_distance(self._context)
        self.spectroscopy_discarded_segments = RootWorkflowCantilever_calibrationPropertySpectroscopy_discarded_segments(self._context)
        self.auto_cleandrive_off = RootWorkflowCantilever_calibrationPropertyAuto_cleandrive_off(self._context)
        self.deflection_sensitivity = RootWorkflowCantilever_calibrationPropertyDeflection_sensitivity(self._context)
        self.spectroscopy_cycle_repetitions = RootWorkflowCantilever_calibrationPropertySpectroscopy_cycle_repetitions(self._context)


class RootWorkflowCantilever_calibrationSignalSpectroscopy_processing_results(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.signal.spectroscopy_processing_results'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.signal.spectroscopy_processing_results.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.signal.spectroscopy_processing_results.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.signal.spectroscopy_processing_results.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.signal.spectroscopy_processing_results.call', *args, **kwargs)


class RootWorkflowCantilever_calibrationSignalProcedure_finished(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.signal.procedure_finished'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.signal.procedure_finished.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.signal.procedure_finished.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.signal.procedure_finished.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.signal.procedure_finished.call', *args, **kwargs)


class RootWorkflowCantilever_calibrationSignalSpectroscopy_results_reset(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.signal.spectroscopy_results_reset'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.signal.spectroscopy_results_reset.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.signal.spectroscopy_results_reset.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.signal.spectroscopy_results_reset.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.signal.spectroscopy_results_reset.call', *args, **kwargs)


class RootWorkflowCantilever_calibrationSignalProcedure_info(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.signal.procedure_info'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.signal.procedure_info.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.signal.procedure_info.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.signal.procedure_info.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.signal.procedure_info.call', *args, **kwargs)


class RootWorkflowCantilever_calibrationSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration.signal'
        self.procedure_info = RootWorkflowCantilever_calibrationSignalProcedure_info(self._context)
        self.spectroscopy_results_reset = RootWorkflowCantilever_calibrationSignalSpectroscopy_results_reset(self._context)
        self.procedure_finished = RootWorkflowCantilever_calibrationSignalProcedure_finished(self._context)
        self.spectroscopy_processing_results = RootWorkflowCantilever_calibrationSignalSpectroscopy_processing_results(self._context)


class RootWorkflowCantilever_calibration(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.cantilever_calibration'
        self.signal = RootWorkflowCantilever_calibrationSignal(self._context)
        self.property = RootWorkflowCantilever_calibrationProperty(self._context)

    def shutdown(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.shutdown', *args, **kwargs)

    def apply(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.apply', *args, **kwargs)

    def start(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.start', *args, **kwargs)

    def init(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.init', *args, **kwargs)

    def abort(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.cantilever_calibration.abort', *args, **kwargs)


class RootWorkflowFluid_fm(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.fluid_fm'


class RootWorkflowFast_and_gentle_approachPropertyExcitation_source(wrap.CmdTreeProp):

    class ValueEnum(enum.Enum):
        CleanDrive = 0
        Piezo_Electric = 1

    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.fast_and_gentle_approach.property.excitation_source'
        self._lua_value_type = wrap.LuaType('list')

    @property
    def value_raw(self) -> int:
        return int(self._context.get('root.workflow.fast_and_gentle_approach.property.excitation_source.value_raw'))

    @value_raw.setter
    def value_raw(self, new_val:int):
        self._context.set('root.workflow.fast_and_gentle_approach.property.excitation_source.value_raw', int(new_val))

    @property
    def enum(self) -> list:
        return list(self._context.get('root.workflow.fast_and_gentle_approach.property.excitation_source.enum'))

    @enum.setter
    def enum(self, new_val:list):
        self._context.set('root.workflow.fast_and_gentle_approach.property.excitation_source.enum', list(new_val))

    @property
    def value(self) -> ValueEnum:
        return self.ValueEnum(self._context.get('root.workflow.fast_and_gentle_approach.property.excitation_source.value_raw'))

    @value.setter
    def value(self, new_val:ValueEnum):
        self._context.set('root.workflow.fast_and_gentle_approach.property.excitation_source.value_raw', new_val.value)


class RootWorkflowFast_and_gentle_approachPropertyApproach_speed(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.fast_and_gentle_approach.property.approach_speed'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.fast_and_gentle_approach.property.approach_speed.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.fast_and_gentle_approach.property.approach_speed.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.fast_and_gentle_approach.property.approach_speed.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.fast_and_gentle_approach.property.approach_speed.value', float(new_val))


class RootWorkflowFast_and_gentle_approachPropertySetpoint_percentage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.fast_and_gentle_approach.property.setpoint_percentage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.fast_and_gentle_approach.property.setpoint_percentage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.fast_and_gentle_approach.property.setpoint_percentage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.fast_and_gentle_approach.property.setpoint_percentage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.fast_and_gentle_approach.property.setpoint_percentage.value', float(new_val))


class RootWorkflowFast_and_gentle_approachPropertyApproach_speed_percentage(wrap.CmdTreeProp):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.fast_and_gentle_approach.property.approach_speed_percentage'
        self._lua_value_type = wrap.LuaType('float')

    @property
    def unit(self) -> str:
        return str(self._context.get('root.workflow.fast_and_gentle_approach.property.approach_speed_percentage.unit'))

    @unit.setter
    def unit(self, new_val:str):
        self._context.set('root.workflow.fast_and_gentle_approach.property.approach_speed_percentage.unit', str(new_val))

    @property
    def value(self) -> float:
        return float(self._context.get('root.workflow.fast_and_gentle_approach.property.approach_speed_percentage.value'))

    @value.setter
    def value(self, new_val:float):
        self._context.set('root.workflow.fast_and_gentle_approach.property.approach_speed_percentage.value', float(new_val))


class RootWorkflowFast_and_gentle_approachProperty(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.fast_and_gentle_approach.property'
        self.approach_speed_percentage = RootWorkflowFast_and_gentle_approachPropertyApproach_speed_percentage(self._context)
        self.setpoint_percentage = RootWorkflowFast_and_gentle_approachPropertySetpoint_percentage(self._context)
        self.approach_speed = RootWorkflowFast_and_gentle_approachPropertyApproach_speed(self._context)
        self.excitation_source = RootWorkflowFast_and_gentle_approachPropertyExcitation_source(self._context)


class RootWorkflowFast_and_gentle_approachSignalProcedure_info(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.fast_and_gentle_approach.signal.procedure_info'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.fast_and_gentle_approach.signal.procedure_info.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.fast_and_gentle_approach.signal.procedure_info.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.fast_and_gentle_approach.signal.procedure_info.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.fast_and_gentle_approach.signal.procedure_info.call', *args, **kwargs)


class RootWorkflowFast_and_gentle_approachSignalProcedure_finished(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.fast_and_gentle_approach.signal.procedure_finished'

    def empty(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.fast_and_gentle_approach.signal.procedure_finished.empty', *args, **kwargs)

    def connect_extended(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.fast_and_gentle_approach.signal.procedure_finished.connect_extended', *args, **kwargs)

    def connect(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.fast_and_gentle_approach.signal.procedure_finished.connect', *args, **kwargs)

    def call(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.fast_and_gentle_approach.signal.procedure_finished.call', *args, **kwargs)


class RootWorkflowFast_and_gentle_approachSignal(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.fast_and_gentle_approach.signal'
        self.procedure_finished = RootWorkflowFast_and_gentle_approachSignalProcedure_finished(self._context)
        self.procedure_info = RootWorkflowFast_and_gentle_approachSignalProcedure_info(self._context)


class RootWorkflowFast_and_gentle_approach(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.fast_and_gentle_approach'
        self.signal = RootWorkflowFast_and_gentle_approachSignal(self._context)
        self.property = RootWorkflowFast_and_gentle_approachProperty(self._context)

    def shutdown(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.fast_and_gentle_approach.shutdown', *args, **kwargs)

    def start(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.fast_and_gentle_approach.start', *args, **kwargs)

    def init(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.fast_and_gentle_approach.init', *args, **kwargs)

    def abort(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.fast_and_gentle_approach.abort', *args, **kwargs)


class RootWorkflowDevices(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.devices'


class RootWorkflowWavemode(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow.wavemode'

    def update(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.wavemode.update', *args, **kwargs)

    def update_free_wave(self, *args, **kwargs) -> Any:
        return self._context.call('root.workflow.wavemode.update_free_wave', *args, **kwargs)


class RootWorkflow(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root.workflow'
        self.wavemode = RootWorkflowWavemode(self._context)
        self.devices = RootWorkflowDevices(self._context)
        self.fast_and_gentle_approach = RootWorkflowFast_and_gentle_approach(self._context)
        self.fluid_fm = RootWorkflowFluid_fm(self._context)
        self.cantilever_calibration = RootWorkflowCantilever_calibration(self._context)
        self.image_importer = RootWorkflowImage_importer(self._context)
        self.user_io = RootWorkflowUser_io(self._context)
        self.automation = RootWorkflowAutomation(self._context)
        self.scanner_ddc = RootWorkflowScanner_ddc(self._context)
        self.cantilever = RootWorkflowCantilever(self._context)
        self.data_view = RootWorkflowData_view(self._context)
        self.gain_finder = RootWorkflowGain_finder(self._context)
        self.camera = RootWorkflowCamera(self._context)
        self.stage = RootWorkflowStage(self._context)
        self.thermal_tune = RootWorkflowThermal_tune(self._context)
        self.wavemode_calibration = RootWorkflowWavemode_calibration(self._context)
        self.z_controller = RootWorkflowZ_controller(self._context)
        self.hardware_detection = RootWorkflowHardware_detection(self._context)
        self.comp_dc = RootWorkflowComp_dc(self._context)
        self.workspace = RootWorkflowWorkspace(self._context)
        self.i2c = RootWorkflowI2c(self._context)
        self.options = RootWorkflowOptions(self._context)
        self.settings = RootWorkflowSettings(self._context)
        self.wafer_defects = RootWorkflowWafer_defects(self._context)
        self.wafer_chuck = RootWorkflowWafer_chuck(self._context)
        self.nec = RootWorkflowNec(self._context)
        self.wafer_alignment = RootWorkflowWafer_alignment(self._context)
        self.tip_guard = RootWorkflowTip_guard(self._context)
        self.template = RootWorkflowTemplate(self._context)
        self.system_startup = RootWorkflowSystem_startup(self._context)
        self.storage = RootWorkflowStorage(self._context)
        self.spm_resource_requester = RootWorkflowSpm_resource_requester(self._context)
        self.spectroscopy_setup = RootWorkflowSpectroscopy_setup(self._context)
        self.spectroscopy = RootWorkflowSpectroscopy(self._context)
        self.laser_auto_align = RootWorkflowLaser_auto_align(self._context)
        self.data_source_controller = RootWorkflowData_source_controller(self._context)
        self.signal_selection = RootWorkflowSignal_selection(self._context)
        self.parameters = RootWorkflowParameters(self._context)
        self.measurement_setup = RootWorkflowMeasurement_setup(self._context)
        self.approach_motors = RootWorkflowApproach_motors(self._context)
        self.data_processing = RootWorkflowData_processing(self._context)
        self.xy_closed_loop = RootWorkflowXy_closed_loop(self._context)
        self.monitoring = RootWorkflowMonitoring(self._context)
        self.manager = RootWorkflowManager(self._context)
        self.laser_manual_align = RootWorkflowLaser_manual_align(self._context)
        self.approach = RootWorkflowApproach(self._context)
        self.imaging = RootWorkflowImaging(self._context)
        self.cantilever_browser = RootWorkflowCantilever_browser(self._context)
        self.mode_loader = RootWorkflowMode_loader(self._context)
        self.frequency_sweep = RootWorkflowFrequency_sweep(self._context)
        self.dynamic = RootWorkflowDynamic(self._context)
        self.auto_setup = RootWorkflowAuto_setup(self._context)


class Root(wrap.CmdTreeNode):
    def __init__(self, context: 'StudioScriptContext'):
        super().__init__()
        self._context = context
        self._lua_tree_name = 'root'
        self.workflow = RootWorkflow(self._context)
        self.core = RootCore(self._context)
        self.lu = RootLu(self._context)
        self.session = RootSession(self._context)
        self.util = RootUtil(self._context)

    def log_debug(self, *args, **kwargs) -> Any:
        return self._context.call('root.log_debug', *args, **kwargs)

    @property
    def init_complete(self) -> bool:
        return bool(self._context.get('root.init_complete'))

    @init_complete.setter
    def init_complete(self, new_val:bool):
        self._context.set('root.init_complete', bool(new_val))

    def log_fatal(self, *args, **kwargs) -> Any:
        return self._context.call('root.log_fatal', *args, **kwargs)

    def log_info(self, *args, **kwargs) -> Any:
        return self._context.call('root.log_info', *args, **kwargs)

    def log_warn(self, *args, **kwargs) -> Any:
        return self._context.call('root.log_warn', *args, **kwargs)

    def log_error(self, *args, **kwargs) -> Any:
        return self._context.call('root.log_error', *args, **kwargs)


