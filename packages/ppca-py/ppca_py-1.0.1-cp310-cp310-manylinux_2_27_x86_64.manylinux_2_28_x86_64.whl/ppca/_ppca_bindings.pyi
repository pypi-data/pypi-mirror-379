# Copyright 2025 brdav

# Use of this source code is governed by an MIT-style
# license that can be found in the LICENSE file or at
# https://opensource.org/licenses/MIT.

from __future__ import annotations

from typing import Any, Mapping, Tuple

import numpy as np
from numpy.typing import ArrayLike, NDArray

class PPCA:
    def __init__(
        self,
        n_components: int,
        max_iter: int,
        min_iter: int,
        rtol: float,
        rotate_to_orthogonal: bool,
        batch_size: int | None,
        random_state: int | None,
    ) -> None: ...
    def fit(self, X: ArrayLike) -> None: ...
    def score(self, X: ArrayLike) -> float: ...
    def score_samples(self, X: ArrayLike) -> NDArray[np.floating]: ...
    def get_covariance(self) -> NDArray[np.floating]: ...
    def get_precision(self) -> NDArray[np.floating]: ...
    def posterior_latent(
        self, X: ArrayLike
    ) -> Tuple[NDArray[np.floating], NDArray[np.floating]]: ...
    def likelihood(
        self, Z: ArrayLike
    ) -> Tuple[NDArray[np.floating], NDArray[np.floating]]: ...
    def impute_missing(
        self, X: ArrayLike
    ) -> Tuple[NDArray[np.floating], NDArray[np.floating]]: ...
    def sample_posterior_latent(
        self, X: ArrayLike, n_draws: int = ...
    ) -> NDArray[np.floating]: ...
    def sample_likelihood(
        self, Z: ArrayLike, n_draws: int = ...
    ) -> NDArray[np.floating]: ...
    def sample_missing(
        self, X: ArrayLike, n_draws: int = ...
    ) -> NDArray[np.floating]: ...
    def lmmse_reconstruction(self, Z: ArrayLike) -> NDArray[np.floating]: ...
    def get_params(self) -> Mapping[str, Any]: ...
    def set_params(self, params: Mapping[str, Any]) -> None: ...

    # Exposed attributes/properties
    @property
    def components(self) -> NDArray[np.floating]: ...
    @property
    def mean(self) -> NDArray[np.floating]: ...
    @property
    def noise_variance(self) -> Any: ...
    @property
    def explained_variance(self) -> NDArray[np.floating]: ...
    @property
    def explained_variance_ratio(self) -> NDArray[np.floating]: ...
    @property
    def n_samples(self) -> int: ...
    @property
    def n_features_in(self) -> int: ...
    @property
    def n_components(self) -> int: ...
