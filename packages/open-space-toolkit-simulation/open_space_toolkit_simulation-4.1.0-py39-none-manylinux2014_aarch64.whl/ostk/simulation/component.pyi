from __future__ import annotations
import ostk.core.type
import ostk.mathematics.geometry.d3.object
import ostk.physics.coordinate
import ostk.physics.environment.object
import ostk.simulation
import typing
__all__ = ['Geometry', 'GeometryConfiguration', 'State']
class Geometry:
    @staticmethod
    def configure(configuration: typing.Any, component: ostk.simulation.Component) -> Geometry:
        ...
    @staticmethod
    def undefined() -> Geometry:
        ...
    def __init__(self, name: ostk.core.type.String, composite: ostk.mathematics.geometry.d3.object.Composite, component: ostk.simulation.Component) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def access_component(self) -> ostk.simulation.Component:
        ...
    def access_composite(self) -> ostk.mathematics.geometry.d3.object.Composite:
        ...
    def access_frame(self) -> ostk.physics.coordinate.Frame:
        ...
    @typing.overload
    def contains(self, geometry: ostk.physics.environment.object.Geometry) -> bool:
        ...
    @typing.overload
    def contains(self, geometry: ostk.physics.environment.object.Celestial) -> bool:
        ...
    def get_geometry_in(self, frame: ostk.physics.coordinate.Frame) -> ostk.physics.environment.object.Geometry:
        ...
    def get_name(self) -> ostk.core.type.String:
        ...
    @typing.overload
    def intersection_with(self, geometry: ostk.physics.environment.object.Geometry) -> ostk.physics.environment.object.Geometry:
        ...
    @typing.overload
    def intersection_with(self, celestial_object: ostk.physics.environment.object.Celestial) -> ostk.physics.environment.object.Geometry:
        ...
    @typing.overload
    def intersects(self, geometry: ostk.physics.environment.object.Geometry) -> bool:
        ...
    @typing.overload
    def intersects(self, celestial_object: ostk.physics.environment.object.Celestial) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
class GeometryConfiguration:
    def __init__(self, name: ostk.core.type.String, composite: ostk.mathematics.geometry.d3.object.Composite) -> None:
        ...
class State:
    class Status:
        """
        Members:
        
          Undefined
        
          Disabled
        
          Idle
        
          Busy
        
          Error
        """
        Busy: typing.ClassVar[State.Status]  # value = <Status.Busy: 3>
        Disabled: typing.ClassVar[State.Status]  # value = <Status.Disabled: 1>
        Error: typing.ClassVar[State.Status]  # value = <Status.Error: 4>
        Idle: typing.ClassVar[State.Status]  # value = <Status.Idle: 2>
        Undefined: typing.ClassVar[State.Status]  # value = <Status.Undefined: 0>
        __members__: typing.ClassVar[dict[str, State.Status]]  # value = {'Undefined': <Status.Undefined: 0>, 'Disabled': <Status.Disabled: 1>, 'Idle': <Status.Idle: 2>, 'Busy': <Status.Busy: 3>, 'Error': <Status.Error: 4>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    @staticmethod
    def undefined() -> State:
        ...
    def __init__(self, arg0: typing.Any) -> None:
        ...
    def get_status(self) -> ...:
        ...
    def is_defined(self) -> bool:
        ...
