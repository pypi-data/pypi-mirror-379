# coding: utf-8

"""
    FreeClimb API

    FreeClimb is a cloud-based application programming interface (API) that puts the power of the Vail platform in your hands. FreeClimb simplifies the process of creating applications that can use a full range of telephony features without requiring specialized or on-site telephony equipment. Using the FreeClimb REST API to write applications is easy! You have the option to use the language of your choice or hit the API directly. Your application can execute a command by issuing a RESTful request to the FreeClimb API. The base URL to send HTTP requests to the FreeClimb REST API is: /apiserver. FreeClimb authenticates and processes your request.

    The version of the OpenAPI document: 1.0.0
    Contact: support@freeclimb.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from freeclimb.models.barge_in_reason import BargeInReason
from freeclimb.models.record_utterance_term_reason import RecordUtteranceTermReason
from freeclimb.models.transcribe_reason import TranscribeReason
from freeclimb.models.transcribe_term_reason import TranscribeTermReason
from freeclimb.models.webhook import Webhook
from pydantic import StrictStr
from typing import Optional, Set
from typing_extensions import Self


class TranscribeWebhook(
    Webhook, populate_by_name=True, validate_assignment=True, protected_namespaces=()
):
    """
    TranscribeWebhook
    """  # noqa: E501

    request_type: Optional[StrictStr] = Field(
        default=None,
        description="The context or reason why this request is being made. Will be transcribe - The TranscribeUtterance command has completed and its actionUrl is being invoked.",
        alias="requestType",
    )
    account_id: Optional[StrictStr] = Field(
        default=None,
        description="Account ID associated with your account.",
        alias="accountId",
    )
    call_id: Optional[StrictStr] = Field(
        default=None,
        description="Unique identifier for this Call, generated by FreeClimb",
        alias="callId",
    )
    var_from: Optional[StrictStr] = Field(
        default=None,
        description="Phone number of the party that initiated the Call (in E.164 format).",
        alias="from",
    )
    to: Optional[StrictStr] = Field(
        default=None,
        description="Phone number provisioned to the customer and to which this Call is directed (in E.164 format).",
    )
    recording_id: Optional[StrictStr] = Field(
        default=None,
        description="The ID of the recording. If no recording was made due to errors or the 'saveRecording' flag being disabled this field will be set to null.",
        alias="recordingId",
    )
    recording_url: Optional[StrictStr] = Field(
        default=None,
        description="The URL of the recorded audio file. This URL can be used as is in a Play command to play the recording (no authentication needed). It can also be used to download the recording file via the REST API.",
        alias="recordingUrl",
    )
    recording_size: Optional[StrictInt] = Field(
        default=None,
        description="The size of the recording in bytes.",
        alias="recordingSize",
    )
    recording_format: Optional[StrictStr] = Field(
        default=None,
        description="The media type of the recording.",
        alias="recordingFormat",
    )
    recording_duration_ms: Optional[StrictInt] = Field(
        default=None,
        description="The duration of the recorded audio in milliseconds.",
        alias="recordingDurationMs",
    )
    term_reason: Optional[TranscribeTermReason] = Field(
        default=None, alias="termReason"
    )
    record_term_reason: Optional[RecordUtteranceTermReason] = Field(
        default=None, alias="recordTermReason"
    )
    digit: Optional[StrictStr] = Field(
        default=None,
        description="If recordTermReason is digit, this will be the digit that was pressed. Otherwise it will be null.",
    )
    privacy_for_logging: Optional[StrictBool] = Field(
        default=None,
        description="Echo back of the privacyForLogging flag as specified in the transcribe utterance command – confirmation of logging protection has been applied. Can be used by application to know it should also apply protection when handling this request.",
        alias="privacyForLogging",
    )
    privacy_for_recording: Optional[StrictBool] = Field(
        default=None,
        description="Echo back of the privacyForRecording flag as specified in the transcribe utterance command – confirmation of logging protection has been applied. Can be used by application to know it should also apply protection when handling this request.",
        alias="privacyForRecording",
    )
    barge_in_reason: Optional[BargeInReason] = Field(
        default=None, alias="bargeInReason"
    )
    barged_in_prompt_no: Optional[StrictInt] = Field(
        default=None, alias="bargedInPromptNo"
    )
    barged_in_prompt_ms: Optional[StrictInt] = Field(
        default=None,
        description="duration in ms bargedInPromptNo prompt was executing until barge-in occurred.",
        alias="bargedInPromptMs",
    )
    barged_in_prompt_loop_no: Optional[StrictInt] = Field(
        default=None, alias="bargedInPromptLoopNo"
    )
    barge_in_time_ms: Optional[StrictInt] = Field(
        default=None, description="epoch time in ms", alias="bargeInTimeMs"
    )
    transcript: Optional[StrictStr] = Field(
        default=None,
        description="Transcribed text of the recording. Can be empty or null. null means there was a failure in transcribing the audio, refer to transcribeReason for detailed failure reason.",
    )
    transcribe_reason: Optional[TranscribeReason] = Field(
        default=None, alias="transcribeReason"
    )
    transcription_duration_ms: Optional[StrictInt] = Field(
        default=None,
        description="The duration of the audio being transcribed in milliseconds",
        alias="transcriptionDurationMs",
    )

    __properties: ClassVar[List[str]] = [
        "requestType",
        "accountId",
        "callId",
        "from",
        "to",
        "recordingId",
        "recordingUrl",
        "recordingSize",
        "recordingFormat",
        "recordingDurationMs",
        "termReason",
        "recordTermReason",
        "digit",
        "privacyForLogging",
        "privacyForRecording",
        "bargeInReason",
        "bargedInPromptNo",
        "bargedInPromptMs",
        "bargedInPromptLoopNo",
        "bargeInTimeMs",
        "transcript",
        "transcribeReason",
        "transcriptionDurationMs",
    ]

    @classmethod
    def deserialize(cls, payload: str) -> Optional[Self]:
        return cls.from_json(payload)

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TranscribeWebhook from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if recording_id (nullable) is None
        # and model_fields_set contains the field
        if self.recording_id is None and "recording_id" in self.model_fields_set:
            _dict["recordingId"] = None

        # set to None if recording_url (nullable) is None
        # and model_fields_set contains the field
        if self.recording_url is None and "recording_url" in self.model_fields_set:
            _dict["recordingUrl"] = None

        # set to None if recording_format (nullable) is None
        # and model_fields_set contains the field
        if (
            self.recording_format is None
            and "recording_format" in self.model_fields_set
        ):
            _dict["recordingFormat"] = None

        # set to None if digit (nullable) is None
        # and model_fields_set contains the field
        if self.digit is None and "digit" in self.model_fields_set:
            _dict["digit"] = None

        # set to None if transcript (nullable) is None
        # and model_fields_set contains the field
        if self.transcript is None and "transcript" in self.model_fields_set:
            _dict["transcript"] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TranscribeWebhook from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "requestType": obj.get("requestType"),
                "accountId": obj.get("accountId"),
                "callId": obj.get("callId"),
                "from": obj.get("from"),
                "to": obj.get("to"),
                "recordingId": obj.get("recordingId"),
                "recordingUrl": obj.get("recordingUrl"),
                "recordingSize": obj.get("recordingSize"),
                "recordingFormat": obj.get("recordingFormat"),
                "recordingDurationMs": obj.get("recordingDurationMs"),
                "termReason": obj.get("termReason"),
                "recordTermReason": obj.get("recordTermReason"),
                "digit": obj.get("digit"),
                "privacyForLogging": obj.get("privacyForLogging"),
                "privacyForRecording": obj.get("privacyForRecording"),
                "bargeInReason": obj.get("bargeInReason"),
                "bargedInPromptNo": obj.get("bargedInPromptNo"),
                "bargedInPromptMs": obj.get("bargedInPromptMs"),
                "bargedInPromptLoopNo": obj.get("bargedInPromptLoopNo"),
                "bargeInTimeMs": obj.get("bargeInTimeMs"),
                "transcript": obj.get("transcript"),
                "transcribeReason": obj.get("transcribeReason"),
                "transcriptionDurationMs": obj.get("transcriptionDurationMs"),
            }
        )
        return _obj
