# coding: utf-8

"""
    FreeClimb API

    FreeClimb is a cloud-based application programming interface (API) that puts the power of the Vail platform in your hands. FreeClimb simplifies the process of creating applications that can use a full range of telephony features without requiring specialized or on-site telephony equipment. Using the FreeClimb REST API to write applications is easy! You have the option to use the language of your choice or hit the API directly. Your application can execute a command by issuing a RESTful request to the FreeClimb API. The base URL to send HTTP requests to the FreeClimb REST API is: /apiserver. FreeClimb authenticates and processes your request.

    The version of the OpenAPI document: 1.0.0
    Contact: support@freeclimb.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from freeclimb.models.percl_command import PerclCommand
from pydantic import StrictStr
from typing import Optional, Set
from typing_extensions import Self


class RecordUtterance(
    PerclCommand,
    populate_by_name=True,
    validate_assignment=True,
    protected_namespaces=(),
):
    """
    The `RecordUtterance` command records the caller's voice and returns the URL of a file containing the audio recording. `RecordUtterance` is blocking and is a terminal command. As such, the `actionUrl` property is required, and control of the Call picks up using the PerCL returned in response to the `actionUrl`. Recording information is returned in the `actionUrl` request.
    """  # noqa: E501

    action_url: StrictStr = Field(
        description="URL to which information on the completed recording is submitted. The PerCL received in response is then used to continue with Call processing.",
        alias="actionUrl",
    )
    silence_timeout_ms: Optional[StrictInt] = Field(
        default=None,
        description="Interval of silence that should elapse before ending the recording.",
        alias="silenceTimeoutMs",
    )
    finish_on_key: Optional[StrictStr] = Field(
        default=None,
        description="Key that triggers the end of the recording. any digit, '#', or '*'",
        alias="finishOnKey",
    )
    max_length_sec: Optional[StrictInt] = Field(
        default=None,
        description="Maximum length for the command execution in seconds.",
        alias="maxLengthSec",
    )
    play_beep: Optional[StrictBool] = Field(
        default=None,
        description="Indicates whether to play a beep sound before the start of the recording. If set to `false`, no beep is played.",
        alias="playBeep",
    )
    auto_start: Optional[StrictBool] = Field(
        default=None,
        description="If `false`, recording begins immediately after the RecordUtterance command is processed. If `true`, recording begins when audio is present and if audio begins before the `maxLengthSec` timeout. If no audio begins before `maxLengthSec`, no recording is generated.",
        alias="autoStart",
    )
    privacy_mode: Optional[StrictBool] = Field(
        default=None,
        description="Parameter `privacyMode` will not log the `text` as required by PCI compliance.",
        alias="privacyMode",
    )
    command: StrictStr = "RecordUtterance"

    __properties: ClassVar[List[str]] = [
        "command",
        "actionUrl",
        "silenceTimeoutMs",
        "finishOnKey",
        "maxLengthSec",
        "playBeep",
        "autoStart",
        "privacyMode",
    ]

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of RecordUtterance from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of RecordUtterance from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "command": obj.get("command"),
                "actionUrl": obj.get("actionUrl"),
                "silenceTimeoutMs": obj.get("silenceTimeoutMs"),
                "finishOnKey": obj.get("finishOnKey"),
                "maxLengthSec": obj.get("maxLengthSec"),
                "playBeep": obj.get("playBeep"),
                "autoStart": obj.get("autoStart"),
                "privacyMode": obj.get("privacyMode"),
            }
        )
        return _obj
