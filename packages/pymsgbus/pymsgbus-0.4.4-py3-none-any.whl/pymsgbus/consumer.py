# Copyright 2025 Eric Hermosis
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You can obtain a copy of the License at:
# 
#     http://www.apache.org/licenses/LICENSE-2.0
#
# This software is distributed "AS IS," without warranties or conditions.
# See the License for specific terms.  

from re import sub
from typing import Callable
from typing import Any
from typing import Union 
from inspect import signature 
from dataclasses import dataclass
from pymsgbus.depends import inject, Provider
from pymsgbus.depends import Depends as Depends

def event(cls: type):
    """ 
    A decorator to define an Event message. An event will store weak references to objects
    and is meant to be consumed by consumers inside the scope where they are produced.
    
    Args:
        cls (type): The ocurrence of something that happened represented by a class

    Returns:
        type: A dataclass representing the event.
    """
    return dataclass(slots=True, weakref_slot=True)(cls)

class Consumer:    
    """
    A **consumer** is a component that listens for and reacts to ocurrences in a **bounded context**. Occurrences
    can be modeled as events and should contain all the information needed to describe what happened in
    the system. Then **consumers** are responsible for processing events and triggering side effects in response
    to them.

    Unlike a **subscriber**, that receive messages routed by the **publisher**, a **consumer** is responsible
    for deciding which handlers to invoke based on the type of the event it consumes. The event type should
    describe the ocurrence in past tense as DDD suggests when modeling events.

    The **events** should be modeled with **ubiquitous language**. This means that the names of the events should reflect
    the domain ocurrences that the consumer is responsible for. Keep this in mind when naming the events that will
    be consumed by the consumer. The consumer maps it's handlers to keys generated by the **event**'s name.

    Methods: 
        handler:
            Decorator for registering a handler function for one or more message types.

        consume:
            Consumes an event by invoking its registered handler functions. 

    Example:
        ```python	
        from pymsgbus import Consumer, event

        @event
        class ModelTrained:
            model: Callable
            metrics: Sequence

        @event
        class ModelEvaluated:
            model: Callable
            metrics: Sequence
        ...

        consumer = Consumer()

        @consumer.hander
        def handle_iteration(event: ModelTrained | ModelEvaluated):
            ...
            #your logic here...

        @consumer.hander
        def handle_training(event: ModelTrained):
            ...
            #your logic here...

        consumer.consume(ModelTrained(model, [{'name': 'loss', 'value': 0.1}])) 
        # Will call both handle iteration and training. I
        # If ModelEvaluated passed will only handle iteration.      
        ```        
    """
    def __init__(
        self, 
        provider: Provider | None = None,
        *, 
        generator: Callable[[str], str] = lambda name: sub(r'(?<!^)(?=[A-Z])', '-', name).lower()
    ): 
        self.handlers = dict[str, list[Callable[[Any], None]]]()
        self.types = dict[str, Any]()
        self.generator = generator
        self.provider = provider or Provider()

    @property
    def dependency_overrides(self) -> dict:
        """
        Returns the dependency overrides for the consumer. This is useful for late binding, 
        testing and changing the behavior of the consumer in runtime.

        Returns:
            dict: A dictionary of the dependency map.
        """
        return self.provider.dependency_overrides
    

    def override(self, dependency: Callable, implementation: Callable):
        """
        Overrides a dependency with an implementation. 

        Args:
            dependency (Callable): The dependency function to override.
            implementation (Callable): The implementation of the function.
        """
        self.dependency_overrides[dependency] = implementation


    def register(self, annotation: Any, handler: Callable[..., None]) -> Callable[..., None]:
        """
        Registers an event type and its corresponding handler function. Handles nested or generic annotations
        and union types. If the annotation is a union type, it will register the handler for each of its arguments.

        This method is used to register a handler from the `handler` method and should not be called directly. Use
        the `handler` decorator instead.

        Args:
            annotation (Any): The event annotation to be registered.
            handler (Callable[..., None]): The handler function to be registered.

        Returns:
            Callable[..., None]: The injected handler function at the end of the recursion.
        """
        if hasattr(annotation, '__origin__'):
            origin = getattr(annotation, '__origin__')
            if isinstance(origin, type(Union)):
                for arg in getattr(annotation, '__args__'):
                    self.register(arg if not hasattr(arg, '__origin__') else getattr(arg, '__origin__'), handler)
            else:
                self.register(origin, handler)

        elif hasattr(annotation, '__args__'):
            for arg in getattr(annotation, '__args__'):
                self.register(arg if not hasattr(arg, '__origin__') else getattr(arg, '__origin__'), handler)
        else:
            key = self.generator(annotation.__name__)
            self.types[key] = annotation    
            injected = inject(self.provider)(handler)
            self.handlers.setdefault(key, []).append(injected)
            return injected    
        return handler

    def handler(self, wrapped: Callable[..., None]) -> Callable[..., None]:
        """
        Decorator for registering a handler function for one or more message types. The handler is registered
        with the name of the function as the key. The handler is also injected with the dependencies provided by
        the consumer.

        Each message type can have multiple handlers registered to it and each handler can be registered to multiple
        message at the same time using unions. 

        Args:
            wrapped (Callable[..., None]): The function to be registered as a handler.

        Returns:
            Callable[..., None]: The injected handler function.
        """
        function_signature = signature(wrapped)
        parameter = next(iter(function_signature.parameters.values()))
        injected = self.register(parameter.annotation, wrapped)
        return injected

    def consume(self, event: Any):
        """
        Consumes an event by invoking its registered handler functions. If the event type is not registered
        with any handler, it will be ignored.

        Args:
            event (Any): The message to consume.
        """
        key = self.generator(event.__class__.__name__)
        for handler in self.handlers.get(key, []):
            handler(event) 