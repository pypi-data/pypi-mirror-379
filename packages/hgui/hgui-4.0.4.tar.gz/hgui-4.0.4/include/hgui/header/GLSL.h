#pragma once

#define HGUI_GLSL_VERTEX_CIRCLE "#version 330 core\nlayout (location = 0) in vec2 vertex;\nuniform mat4 projectionMatrix;\nvoid main()\n{\n	gl_Position = projectionMatrix * vec4(vertex, 0.0, 1.0);\n}"
#define HGUI_GLSL_VERTEX_RECTANGLE "#version 330 core\nlayout (location = 0) in vec2 vertex;\nuniform mat4 projectionMatrix;\nvoid main()\n{\n	gl_Position = projectionMatrix * vec4(vertex, 0.0, 1.0);\n}"
#define HGUI_GLSL_VERTEX_STRAIGHTLINE "#version 330 core\nlayout (location = 0) in vec2 vertex;\nuniform mat4 projectionMatrix;\nvoid main()\n{\n	gl_Position = projectionMatrix * vec4(vertex, 0.0, 1.0);\n}"
#define HGUI_GLSL_VERTEX_TRIANGLE "#version 330 core\nlayout (location = 0) in vec2 vertex;\nuniform mat4 projectionMatrix;\nvoid main()\n{\n	gl_Position = projectionMatrix * vec4(vertex, 0.0, 1.0);\n}"
#define HGUI_GLSL_VERTEX_SPRITE "#version 330 core\nlayout (location = 0) in vec4 vertex;\nout vec2 texturePosition;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nvoid main()\n{\n    texturePosition = vertex.zw;\n    gl_Position = projectionMatrix * modelMatrix * vec4(vertex.xy, 0.0, 1.0);\n}"
#define HGUI_GLSL_VERTEX_BUTTON "#version 330 core\nlayout (location = 0) in vec4 vertex;\nout vec2 texturePosition;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nvoid main()\n{\n    gl_Position = projectionMatrix * modelMatrix * vec4(vertex.xy, 0.0, 1.0);\n    texturePosition = vertex.zw;\n}"
#define HGUI_GLSL_VERTEX_CANVAS "#version 330 core\nlayout (location = 0) in vec2 vertex;\nlayout (location = 1) in vec4 vertexColor;\nout vec4 color;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nvoid main()\n{\n    gl_Position = projectionMatrix * modelMatrix * vec4(vertex, 0.0, 1.0);\n    color = vertexColor;\n}"
#define HGUI_GLSL_VERTEX_LABEL "#version 330 core\nlayout (location = 0) in vec4 vertex;\nout vec2 texturePosition;\nuniform mat4 projectionMatrix;\nvoid main()\n{\n    gl_Position = projectionMatrix * vec4(vertex.xy, 0.0, 1.0);\n    texturePosition = vertex.zw;\n}"
#define HGUI_GLSL_VERTEX_BUFFER "#version 330 core\nlayout (location = 0) in vec4 vertex;\nout vec2 texturePosition;\nvoid main()\n{\n    texturePosition = vertex.zw;\n    gl_Position = vec4(vertex.xy, 0.0, 1.0);\n}"
#define HGUI_GLSL_VERTEX_TEXTINPUT "#version 330 core\nlayout (location = 0) in vec2 vertex;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nvoid main()\n{\n    gl_Position = projectionMatrix * modelMatrix * vec4(vertex.xy, 0.0, 1.0);\n}"

#define HGUI_GLSL_FRAGMENT_CIRCLE "#version 330 core\nlayout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;\nout vec4 fragmentColor;\nuniform vec2 canvasPosition;\nuniform vec2 canvasSize;\nuniform vec2 center;\nuniform vec4 color;\nuniform float radius;\nuniform float thickness;\nuniform bool fill;\nbool is_in_rectangle(const vec2 A, const vec2 B, const vec2 D, const vec2 point);\nvoid main()\n{\n    vec2 pixelCoords = gl_FragCoord.xy;\n    if (!is_in_rectangle(canvasPosition, canvasPosition + vec2(canvasSize.x, 0.0),\n        canvasPosition + vec2(0.0, canvasSize.y), pixelCoords)  ||\n        (fill && distance(pixelCoords, center) > radius) ||\n        (!fill && (distance(pixelCoords, center) > radius + thickness ||\n        distance(pixelCoords, center) < radius - thickness)))\n    {\n        discard;\n    }\n    fragmentColor = color;\n}\nbool is_in_rectangle(const vec2 A, const vec2 B, const vec2 D, const vec2 point)\n{\n    float dotAMAB = dot(point - A, B - A), dotAMAD = dot(point - A, D - A);\n    return (0.0 < dotAMAB && dotAMAB < dot(B - A, B - A)) && (0.0 < dotAMAD && dotAMAD < dot(D - A, D - A));\n}"
#define HGUI_GLSL_FRAGMENT_RECTANGLE "#version 330 core\nlayout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;\nout vec4 fragmentColor;\nuniform vec2 canvasPosition;\nuniform vec2 canvasSize;\nuniform vec2 center;\nuniform vec4 color;\nuniform float radius;\nuniform bool circle;\nbool is_in_rectangle(const vec2 A, const vec2 B, const vec2 D, const vec2 point);\nvoid main()\n{\n    vec2 pixelCoords = gl_FragCoord.xy;\n    if (!is_in_rectangle(canvasPosition, canvasPosition + vec2(canvasSize.x, 0.0),\n        canvasPosition + vec2(0.0, canvasSize.y), pixelCoords) ||\n        (circle && distance(pixelCoords, center) > radius))\n    {\n        discard;\n    }\n    fragmentColor = color;\n}\nbool is_in_rectangle(const vec2 A, const vec2 B, const vec2 D, const vec2 point)\n{\n    float dotAMAB = dot(point - A, B - A), dotAMAD = dot(point - A, D - A);\n    return (0.0 < dotAMAB && dotAMAB < dot(B - A, B - A)) && (0.0 < dotAMAD && dotAMAD < dot(D - A, D - A));\n}"
#define HGUI_GLSL_FRAGMENT_STRAIGHTLINE "#version 330 core\nlayout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;\nout vec4 fragmentColor;\nuniform vec2 canvasPosition;\nuniform vec2 canvasSize;\nuniform vec2 center;\nuniform vec4 color;\nuniform float radius;\nuniform bool circle;\nbool is_in_rectangle(const vec2 A, const vec2 B, const vec2 D, const vec2 point);\nvoid main()\n{\n    vec2 pixelCoords = gl_FragCoord.xy;\n    if (!is_in_rectangle(canvasPosition, canvasPosition + vec2(canvasSize.x, 0.0),\n        canvasPosition + vec2(0.0, canvasSize.y), pixelCoords) ||\n        (circle && distance(pixelCoords, center) > radius))\n    {\n        discard;\n    }\n    fragmentColor = color;\n}\nbool is_in_rectangle(const vec2 A, const vec2 B, const vec2 D, const vec2 point)\n{\n    float dotAMAB = dot(point - A, B - A), dotAMAD = dot(point - A, D - A);\n    return (0.0 < dotAMAB && dotAMAB < dot(B - A, B - A)) && (0.0 < dotAMAD && dotAMAD < dot(D - A, D - A));\n}"
#define HGUI_GLSL_FRAGMENT_TRIANGLE "#version 330 core\nlayout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;\nout vec4 fragmentColor;\nuniform vec2 canvasPosition;\nuniform vec2 canvasSize;\nuniform vec2 center;\nuniform vec4 color;\nuniform float radius;\nuniform bool circle;\nbool is_in_rectangle(const vec2 A, const vec2 B, const vec2 D, const vec2 point);\nvoid main()\n{\n    vec2 pixelCoords = gl_FragCoord.xy;\n    if (!is_in_rectangle(canvasPosition, canvasPosition + vec2(canvasSize.x, 0.0),\n        canvasPosition + vec2(0.0, canvasSize.y), pixelCoords) ||\n        (circle && distance(pixelCoords, center) > radius))\n    {\n        discard;\n    }\n    fragmentColor = color;\n}\nbool is_in_rectangle(const vec2 A, const vec2 B, const vec2 D, const vec2 point)\n{\n    float dotAMAB = dot(point - A, B - A), dotAMAD = dot(point - A, D - A);\n    return (0.0 < dotAMAB && dotAMAB < dot(B - A, B - A)) && (0.0 < dotAMAD && dotAMAD < dot(D - A, D - A));\n}"
#define HGUI_GLSL_FRAGMENT_SPRITE "#version 330 core\nin vec2 texturePosition;\nout vec4 fragmentColor;\nuniform sampler2D sprite;\nuniform vec4 spriteColor;\nvoid main()\n{\n    fragmentColor = spriteColor * texture(sprite, texturePosition);\n}"
#define HGUI_GLSL_FRAGMENT_BUTTON "#version 330 core\nin vec2 texturePosition;\nout vec4 fragmentColor;\nuniform sampler2D button;\nuniform vec4 buttonColor;\nuniform int focused;\nuniform bool custom;\nuniform bool dark;\nuniform bool blurrOnHover;\nvoid main()\n{\n    if (!custom)\n    {\n        fragmentColor = vec4(buttonColor);\n    }\n    else\n    {\n        fragmentColor = vec4(buttonColor) * texture(button, texturePosition);\n    }\n    if (blurrOnHover)\n    {\n        if (focused == 1)\n        {\n            if (fragmentColor.w < 1)\n            {\n                if (dark)\n                {\n                    fragmentColor = vec4(vec3(1.0), 0.05);\n                }\n                else\n                {\n                    fragmentColor = vec4(vec3(0.0), 0.05);\n                }\n            }\n            else\n            {\n                if (all(greaterThan(fragmentColor.xyz, vec3(0.1))))\n                {\n                    fragmentColor.xyz *= 0.95;\n                }\n                else\n                {\n                    fragmentColor.xyz += 0.05;\n                }\n            }\n        }\n        else if (focused == 2)\n        {\n            if (fragmentColor.w < 1)\n            {\n                if (dark)\n                {\n                    fragmentColor = vec4(vec3(1.0), 0.1);\n                }\n                else\n                {\n                    fragmentColor = vec4(vec3(0.0), 0.1);\n                }\n            }\n            else\n            {\n                if (all(greaterThan(fragmentColor.xyz, vec3(0.1))))\n                {\n                    fragmentColor.xyz *= 0.9;\n                }\n                else\n                {\n                    fragmentColor.xyz += 0.1;\n                }\n            }\n        }\n    }\n}"
#define HGUI_GLSL_FRAGMENT_CANVAS "#version 330 core\nin vec4 color;\nout vec4 fragmentColor;\nvoid main()\n{\n    fragmentColor = color;\n}"
#define HGUI_GLSL_FRAGMENT_LABEL "#version 330 core\nin vec2 texturePosition;\nout vec4 fragmentColor;\nuniform sampler2D text;\nuniform vec4 textColor;\nvoid main()\n{\n    vec4 sampled = vec4(1.0, 1.0, 1.0, texture(text, texturePosition).r);\n    fragmentColor = textColor * sampled;\n}"
#define HGUI_GLSL_FRAGMENT_BUFFER "#version 330 core\nout vec4 fragmentColor;\nin vec2 texturePosition;\nuniform sampler2D screenTexture;\nuniform vec2 screenSize;\nuniform int type;\nvoid main()\n{\n    if (type == 1)\n    {\n        float squarredPi = 6.28318530718;\n        float direction = 32.0;\n        float quality = 8.0;\n        float size = 16.0;\n        vec2 radius = size/screenSize.xy;\n        vec2 uv = gl_FragCoord.xy/screenSize.xy;\n        vec4 color = texture(screenTexture, uv);\n        for (float d=0.0; d<squarredPi; d+=squarredPi/direction)\n        {\n            for (float i=1.0/quality; i<1.001; i+=1.0/quality)\n            {\n                color += texture(screenTexture, uv+vec2(cos(d), sin(d))*radius*i);\n            }\n        }\n        color /= quality * direction + 1.0;\n        fragmentColor =  color;\n    }\n    else if (type == 2)\n    {\n        fragmentColor = vec4(vec3(1.0) - vec3(texture(screenTexture, texturePosition)), 1.0);\n    }\n    else\n    {\n        fragmentColor = vec4(vec3(texture(screenTexture, texturePosition)), 1.0);\n    }\n}"
#define HGUI_GLSL_FRAGMENT_TEXTINPUT "#version 330 core\nout vec4 fragmentColor;\nuniform vec4 color;\nvoid main()\n{\n    fragmentColor = vec4(color);\n}"
