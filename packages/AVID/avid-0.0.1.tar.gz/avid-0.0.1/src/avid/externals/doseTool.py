# SPDX-FileCopyrightText: 2024, German Cancer Research Center (DKFZ), Division of Medical Image Computing (MIC)
#
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# or find it in LICENSE.txt.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import logging
import os
import xml.etree.ElementTree as ElementTree
from builtins import object, str

from avid.common.artefact.fileHelper import indent

logger = logging.getLogger(__name__)

XML_STATISTICS = "statistics"
XML_CONFIG = "config"
XML_REQUESTED_STRUCT_REGEX = "requestedStructRegex"
XML_STRUCT_NAME = "structName"
XML_DOSE_ID = "doseUID"
XML_DOSE_FILE = "doseFile"
XML_STRUCT_FILE = "structFile"
XML_RESULTS = "results"
XML_PROPERTY = "property"
XML_VOXEL = "voxel"
XML_VOXEL_GRID_ID = "voxelGridID"
XML_WORLD_COORDINATE = "worldCoordinate"
XML_ATTR_NAME = "name"


def _getPropertyFullname(name, **attr):
    '''returns the full identifying name of the property. It is generationg with
    the following pattern: <attr "name" value>[_<attr x name>=<attr x value>]*.
    It always starts with name, all other attributes are sorted alphabeticly.
    Example: "DX_x=10"'''
    result = name

    for key in sorted(attr):
        if not key == XML_ATTR_NAME:
            result = result + "_" + str(key) + "=" + str(attr[key])

    return result


class DoseProperty(object):
    """Object that represents the values of a statistic aspect (e.g. maximum.) generated by DoseTool."""

    def __init__(self):
        # attributes describing the property (e.g. name)
        self.attributes = {}
        # the value of the property
        self.value = None

        # if list off voxels that represent this value (e.g. all points that have the maximum dose
        # @TODO the voxel support is currently not implemented. Enlist issue
        self.voxels = list()

    @property
    def name(self):
        """returns value of the name attribute."""
        return self.attributes[XML_ATTR_NAME]

    @property
    def fullname(self):
        '''returns the full identifying name of the property. It is generationg with
        the following pattern: <attr "name" value>[_<attr x name>=<attr x value>]*.
        It always starts with name, all other attributes are sorted alphabeticly.
        Example: "DX_x=10"'''

        attributes = self.attributes.copy()
        attributes.pop(XML_ATTR_NAME, None)
        result = _getPropertyFullname(self.name, **attributes)

        return result


class DoseToolResultContainer(object):
    """Helper object that contains the information of an dosetool output."""

    def __init__(self):
        """"""
        # Dictionary wiht config informations
        self.config = {}
        # Dictionary with all dose properties [fullname]:DoseProperty-instance
        self.results = dict()
        # The raw xml nodes of the result file
        self.resultsXML = None

    def getProperty(self, name, **attr):
        """searches in the result for a property with the full name specified by
        the parameter name and any passed attribute."""
        fullname = _getPropertyFullname(name, **attr)
        result = None
        if fullname in self.results:
            result = self.results[fullname]

        return result


def _extractConfigDict(xmlNode):
    """Extracts all sub elements of the config nodes and stores it in a dictionary.
    Key is the element name. Value is the element value."""
    result = {}
    for element in xmlNode.findall(".//" + XML_CONFIG + "/*"):
        result[element.tag] = element.text
    return result


def _extractResultsDict(xmlNode):
    """Extracts all dose property results from the xml tree and stores them in
    dictionary of DoseProperty instances."""
    result = {}
    for element in xmlNode.findall(".//" + XML_RESULTS + "/" + XML_PROPERTY):
        prop = DoseProperty()
        prop.value = element.text.strip()
        prop.attributes = element.attrib

        result[prop.fullname] = prop

    return result


def loadResult(fileName):
    """parse the passed input file. and returns an instance of DoseToolResultContainer filled with the content"""

    result = DoseToolResultContainer()
    try:
        tree = ElementTree.parse(fileName)

        result.resultsXML = tree.find(".//" + XML_RESULTS)
        result.config = _extractConfigDict(tree)
        result.results = _extractResultsDict(tree)
    except:
        logger.error("Error while parsing dose tool result xml file: %s", fileName)
        raise

    return result


def saveSimpleDictAsResultXML(resultDict, resultPath):
    """Helper that stores the passed dictionary in a RTTB dose tool compliant xml
    format.
    @param resultDict Dictionary with the values that should be stored
    @param resultPath Path where the xml output should be stored."""

    builder = ElementTree.TreeBuilder()

    builder.start(XML_STATISTICS, {})
    builder.start(XML_RESULTS, {})
    for key in resultDict:
        builder.start(XML_PROPERTY, {XML_ATTR_NAME: key})
        builder.data(str(resultDict[key]))
        builder.end(XML_PROPERTY)
    builder.end(XML_RESULTS)
    builder.end(XML_STATISTICS)

    root = builder.close()
    tree = ElementTree.ElementTree(root)
    indent(root)

    try:
        os.makedirs(os.path.split(resultPath)[0])
    except:
        pass

    if os.path.isfile(resultPath):
        os.remove(resultPath)

    tree.write(resultPath, xml_declaration=True)
