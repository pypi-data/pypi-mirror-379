# SPDX-FileCopyrightText: 2024, German Cancer Research Center (DKFZ), Division of Medical Image Computing (MIC)
#
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# or find it in LICENSE.txt.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from builtins import object


class LinkerBase(object):
    """Linkers serve as delegate to generate secondary sub selections that have some semantic
    linkage (e.g. only seconadry selections that have the same case id or time point like
    the primary selection) to indicated primary selection
    (list of artefact; e.g. generated by splitter).
    Linker might alter a secondary selection before it is passed back as a
    linked selection (e.g. change the order of the artefact in the selection,
    its content or adding None elements to indicate that an artifact in the primary selection
    has no semantically linked counterpart in the linked selection.)
    """

    def __init__(self, allowOnlyFullLinkage=True):
        """@param allowOnlyFullLinkage If yes the linker returns only linked selection that contain no none elements
        and has the same size then the relvant primary selection."""
        self._allowOnlyFullLinkage = allowOnlyFullLinkage

    def _sanityCheck(self, primarySelection, linkedSelections):
        """
        Sanity check to only return valid linked selections
        :param primarySelection: the primary selection to link to
        :param linkedSelections: the linked selection candidates that should be checked.
        """
        result = list()

        if self._allowOnlyFullLinkage:
            for linkedSelection in linkedSelections:
                if (
                    len(linkedSelection) == len(primarySelection)
                    and not None in linkedSelection
                ):
                    result.append(linkedSelection)
        else:
            result = linkedSelections

        return result

    def getLinkedSelection(self, primaryIndex, primarySelections, secondarySelections):
        """Get the subset (splits) of secondary selections that has a meaningful semantic link
        to the primary selection/index. To change the behavior reimplement
        self._getLinkedSelection(). The default implementation just passes through
        the secondarySelections (so everything gets linked).
        Linker might alter a secondary selections before they are passed back as
        linked selections (e.g. change the order of the artefact in the selection or
        its content)
        @result List of all valid selections (list) of linked artefacts.
        Therefore all selections of artefacts from secondarySelections
        that fullfill the link criterion in respect to the primary selection.
        @param primaryIndex index of the entry in the primarySelections that is defining
        for the link.
        @param primarySelections the list of all selections that contain sets of primary artefacts
        @param secondarySelections the list that is used to generate/pick the linked selections from.
        """
        linkedSelections = self._getLinkedSelection(
            primaryIndex=primaryIndex,
            primarySelections=primarySelections,
            secondarySelections=secondarySelections,
        )
        primarySelection = primarySelections[primaryIndex]
        return self._sanityCheck(
            primarySelection=primarySelection, linkedSelections=linkedSelections
        )

    def _getLinkedSelection(self, primaryIndex, primarySelections, secondarySelections):
        """Default implementation how to get the subset (splits) of secondary selections that has a meaningful
        semantic lin to the primary selection/index. To change the behavior reimplement
        this method.
        Linker might alter a secondary selections before they are passed back as
        linked selections (e.g. change the order of the artefact in the selection or
        its content)
        @result List of all valid selections (list) of linked artefacts.
        Therefore all selections of artefacts from secondarySelections
        that fullfill the link criterion in respect to the primary selection.
        @param primaryIndex index of the entry in the primarySelections that is defining
        for the link.
        @param primarySelections the list of all selections that contain sets of primary artefacts
        @param secondarySelections the list that is used to generate/pick the linked selections from.
        """
        return secondarySelections

    def __add__(self, other):
        """Creates an AndLinker with both operands."""
        andLinker = AndLinker(
            self,
            other,
            allowOnlyFullLinkage=self._allowOnlyFullLinkage
            or other._allowOnlyFullLinkage,
        )
        return andLinker


class InnerLinkerBase(LinkerBase):
    """
    Linker that also supports inner linkage of elements (details see __init__).
    """

    def __init__(self, allowOnlyFullLinkage=True, performInternalLinkage=False):
        """@param performInternalLinkage If internal linkage is activated, the linker will not only search
        for linked secondary selections. The linker will then also link each primary selection artefact to a
        fitting artefact in the secondary selection and(!) adds the found linked secondary artefact to the respective
        position of the linked selection. This behavior has to effects: 1) a linked selection has always the same
        size than the primary selection; 2) the artefacts in the linked selection correspond to the artefacts in
        the primary selection at the respective position (e.g. the first artefact in the linked selection is linked
        to the first artefact in the primary selection); 3) This my alter the order of the linked secondary
        artefacts and their content (because if multiple secondary artefacts would fit, the first will
        always be picked.); 4) Linked secondary selections may be skipped if the very same selection is already
        present in the result.
        If performInternalLinkage is True and no link artefact can be found for a primary artefact, None
        will be added in the linked selections.
        If performInternalLinkage is False, it is only relevant that at least one primary artefact has
        a link.
        @param allowOnlyFullLinkage If True, one will only get linked selection where 1) every primary
        artefact has a corresponding linked secondary artefact and 2) the linked selection as the same number of
        artefacts then the primary selection. REMARK: This must not mean that every artefact in the linked secondary
        selection has also a semantic link. It is enough if at least one artefact in the secondary selection is
        semantically linked.
        If set to False, the result depends on the setting of performInternalLinkage. If performInternalLinkage
        is True, the returned linked selections may contain None if a primary artefact could not be linked to
        any secondary artefact in the selection.
        If performInternalLinkage is False, every secondary selection is valid if at least one primary artefact
        finds a link.

        """
        LinkerBase.__init__(self, allowOnlyFullLinkage=allowOnlyFullLinkage)
        self._performeInternalLinkage = performInternalLinkage

    def _findLinkedArtefactOptions(self, primaryArtefact, secondarySelection):
        raise NotImplementedError("reimplement this function in derived classes.")

    def _getLinkedSelection(self, primaryIndex, primarySelections, secondarySelections):
        """Filters the given list of entries and returns all selected entries"""
        primarySelection = primarySelections[primaryIndex]

        resultSelections = list(
            list(),
        )

        for secondarySelection in secondarySelections:
            addSelection = self._performeInternalLinkage or self._allowOnlyFullLinkage

            linkedSelection = list()

            if not self._performeInternalLinkage:
                linkedSelection = secondarySelection

            for primeArtefact in primarySelection:
                try:
                    foundArtefact = self._findLinkedArtefactOptions(
                        primeArtefact, secondarySelection
                    )
                    foundArtefact = foundArtefact[0]
                except:
                    foundArtefact = None

                if self._performeInternalLinkage:
                    linkedSelection.append(foundArtefact)
                else:
                    if foundArtefact is not None and not self._allowOnlyFullLinkage:
                        addSelection = True
                        break
                    elif foundArtefact is None and self._allowOnlyFullLinkage:
                        addSelection = False
                        break

            if self._performeInternalLinkage:
                addSelection = (
                    len([x for x in linkedSelection if x is not None]) > 0
                    and not linkedSelection in resultSelections
                )
                # do not add if 1) all linked elements are none, then linkage has failed or 2) the selection is already in the
                # result list. The rest will be checked and sanitized by LinkerBase.

            if addSelection:
                resultSelections.append(linkedSelection)

        return resultSelections


class AndLinker(LinkerBase):
    """
    Special linker that works like an and operation on to child linkers.
    The selection result of the AndLinker is the intersection of the selection
    of both child linkers.
    """

    def __init__(self, linker1, linker2, allowOnlyFullLinkage=True):
        """init"""
        LinkerBase.__init__(self, allowOnlyFullLinkage=allowOnlyFullLinkage)
        self._linker1 = linker1
        self._linker2 = linker2

    def _getLinkedSelection(self, primaryIndex, primarySelections, secondarySelections):
        """Filters the given list of entries and returns all selected entries"""
        selections1 = self._linker1.getLinkedSelection(
            primaryIndex=primaryIndex,
            primarySelections=primarySelections,
            secondarySelections=secondarySelections,
        )
        selections2 = self._linker2.getLinkedSelection(
            primaryIndex=primaryIndex,
            primarySelections=primarySelections,
            secondarySelections=secondarySelections,
        )
        resultSelections = list(
            list(),
        )
        for item1 in selections1:
            for item2 in selections2:
                if item1 == item2:
                    resultSelections.append(item1)
                    selections2.remove(item2)
                    break

        return resultSelections


from .caseInstanceLinker import CaseInstanceLinker
from .fractionLinker import FractionLinker
from .keyValueLinker import CaseLinker, KeyValueLinker, TimePointLinker
from .proximityLinker import TimePointProximityLinker
