"""
This is the top-level module in the pdf subpackage, assembling content
generated by section submodules for processing by ReportLab Platypus,
and applying non-sectional items such as headers and footers.
"""

import os

from reportlab.platypus import (
    Frame,
    IndexingFlowable,
    Paragraph,
    SimpleDocTemplate,
)

from .. import id as id_
from . import (
    approval,
    environ,
    equip,
    layout,
    notes,
    objective,
    precondition,
    procedure,
    refs,
    title,
)
from .textstyle import stylesheet


# Common content used across all tests; initialized by init() when the
# build worker process is started.
IMAGES = None
VERSION = None


class BuildError(Exception):
    """Exception chained from a PDF generation failure."""


def init(images, version):
    """Initalizes the build process with common content used by all tests.

    This is the initializer function given to ProcessPoolExecutor. Pylint
    global-statement is disabled because the content held by these
    constants is not available when the module is imported, and must be
    set when the build worker process is started.
    """
    global IMAGES  # pylint: disable=global-statement
    global VERSION  # pylint: disable=global-statement
    IMAGES = images
    VERSION = version


def build(test, cached_page_count, path):
    """Builds a PDF document for a given test instance."""
    try:
        doc = TestDocument(test, cached_page_count, path)
    except Exception as e:
        tid = id_.to_string(test.id)
        raise BuildError(f"Failed to build PDF for {tid} {test.title}: {e}") from e

    # Return data to be written to the cache file.
    return {test.id: doc.page_count.last_page}


class TestDocument:
    """This class creates a PDF for a single Test instance."""

    def __init__(self, test, cached_page_count, path):
        self.test = test

        self.bottom_margin = layout.BOTTOM_MARGIN

        if test.copyright:
            self.copyright = Paragraph(
                test.copyright,
                stylesheet["CopyrightNotice"],
            )

            # Compute the vertical height needed to hold the copyright
            # notice when wrapped to within the document body width.
            self.copyright_height = (
                self.copyright.wrap(layout.BODY_WIDTH, 0)[1]
                # Additional space for descenders on the bottom line.
                + stylesheet["CopyrightNotice"].fontSize * 0.25
            )

            # Enlarge the bottom margin to accommodate the copyright notice.
            self.bottom_margin += self.copyright_height

        doc = self._get_doc(path)
        self.page_count = PageCount(doc, cached_page_count)
        body = [self.page_count]
        body.extend(self._build_body(test))
        doc.multiBuild(
            body,
            maxPasses=1,  # Page count takes up to two, zero-based count.
            onFirstPage=self.on_first_page,
            onLaterPages=self.on_later_pages,
        )

    def _get_doc(self, path):
        """Creates the document template."""
        pdfname = self.test.full_name + ".pdf"
        os.makedirs(path, exist_ok=True)
        filename = os.path.join(path, pdfname)
        return SimpleDocTemplate(
            filename,
            pagesize=layout.PAGE_SIZE,
            leftMargin=layout.LEFT_MARGIN,
            rightMargin=layout.RIGHT_MARGIN,
            topMargin=layout.TOP_MARGIN,
            bottomMargin=self.bottom_margin,
        )

    def on_first_page(self, canvas, doc):
        """Document template callback for the first page."""
        self._on_every_page(canvas, doc)

        # Use a simple header on the first page if a full title block
        # was not generated.
        if self.no_title_block:
            self._header(canvas, doc)

    def on_later_pages(self, canvas, doc):
        """Document template callback for all pages after the first."""
        self._on_every_page(canvas, doc)
        self._header(canvas, doc)

    def _on_every_page(self, canvas, doc):
        """Draws common content placed on every page."""
        if VERSION == "draft":
            self._draftmark(canvas, doc)

        self._footer(canvas, doc)

    def _header(self, canvas, doc):
        """Draws the page header."""
        self._set_canvas_text_style(canvas, "Header")
        baseline = doc.pagesize[1] - layout.TOP_MARGIN
        canvas.drawString(
            layout.LEFT_MARGIN,
            baseline,
            self.test.full_name,
        )

    def _footer(self, canvas, doc):
        """Draws the page footer."""
        baseline = self.bottom_margin

        # The copyright notice is placed in a dedicated frame so the text
        # can be wrapped as necessary.
        if self.test.copyright:
            baseline -= self.copyright_height
            frame = Frame(
                layout.LEFT_MARGIN,
                baseline,
                layout.BODY_WIDTH,
                self.copyright_height,
                leftPadding=0,
                rightPadding=0,
                topPadding=0,
                bottomPadding=0,
            )
            frame.addFromList([self.copyright], canvas)

        self._set_canvas_text_style(canvas, "Footer")

        # Offset text relative to the font size.
        baseline -= stylesheet["Footer"].fontSize * 1.2

        pages = f"Page {doc.page} of {self.page_count.last_page}"
        canvas.drawCentredString(doc.pagesize[0] / 2, baseline, pages)

        # Add version information if available.
        if VERSION and (VERSION != "draft"):
            x = doc.pagesize[0] - layout.RIGHT_MARGIN
            version_text = f"Document Version: {VERSION}"
            canvas.drawRightString(x, baseline, version_text)

    def _set_canvas_text_style(self, canvas, style):
        """Sets the current canvas font to a given style."""
        style = stylesheet[style]
        canvas.setFont(style.fontName, style.fontSize)

    def _build_body(self, test):
        """
        Assembles the list of flowables representing all content other
        than the header and footer.
        """
        flowables = [
            title.make_title(test, IMAGES),
            objective.make_objective(test.objective),
            refs.make_references(test.references),
            environ.make_environment(test.fields),
            equip.make_equipment(test.equipment),
            precondition.make_preconditions(test.preconditions),
            procedure.make_procedure(test.procedure, IMAGES),
            notes.make_notes(),
            approval.make_approval(test),
        ]

        self.no_title_block = flowables[0] is None

        return [f for f in flowables if f]

    def _draftmark(self, canvas, doc):
        """Creates a draft watermark."""
        canvas.saveState()
        self._set_canvas_text_style(canvas, "Draftmark")

        # Translate origin to center of page.
        canvas.translate(doc.pagesize[0] / 2, doc.pagesize[1] / 2)

        canvas.rotate(45)
        canvas.setFillColor(layout.DRAFTMARK_COLOR)

        # Offset y coordinate by half the font size because the text
        # is anchored at its baseline, not the midpoint.
        y = stylesheet["Draftmark"].fontSize / -2

        canvas.drawCentredString(0, y, "DRAFT")
        canvas.restoreState()


class PageCount(IndexingFlowable):
    """Total page count accumulator.

    This object captures the total number of pages. It is implemented as an
    IndexingFlowable so document template multiBuild() can handle runnning
    multiple build passes to determine the total number of pages.
    """

    def __init__(self, doc, page_count):
        super().__init__()
        self.doc = doc
        self.last_page = page_count

    def isSatisfied(self):
        """Document template multiBuild() hook to enable another build pass."""
        # The build is complete if the page number equals the cached last
        # page number.
        if self.last_page == self.doc.page:
            return True

        # Update cached last page and build again.
        self.last_page = self.doc.page
        return False

    def draw(self):
        """This flowable doesn't draw anything."""
