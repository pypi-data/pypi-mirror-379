"""API for ipykernel-helper"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['transient', 'run_cmd', 'get_md', 'scrape_url', 'read_url', 'load_ipython_extension']

# %% ../nbs/00_core.ipynb
from fastcore.meta import delegates
from fastcore.utils import patch,dict2obj
from types import ModuleType, FunctionType, MethodType, BuiltinFunctionType
from inspect import signature, currentframe
from functools import cmp_to_key,partial
from collections.abc import Mapping
from textwrap import dedent
from cloudscraper import create_scraper
from toolslm.funccall import *

import typing,warnings,re

from IPython.core.interactiveshell import InteractiveShell
from IPython.core.completer import ProvisionalCompleterWarning
from jedi import Interpreter, Script as jscript

from IPython.core.display import DisplayObject
from IPython.display import display,Markdown,HTML
from IPython.core.oinspect import Inspector

# %% ../nbs/00_core.ipynb
warnings.filterwarnings('ignore', category=ProvisionalCompleterWarning)

# %% ../nbs/00_core.ipynb
def _safe_repr(obj, max_len=200):
    "Safely get the repr() of an object, truncating if it exceeds max_len."
    try:
        s = str(obj)
        return s[:max_len] + ("â€¦" if len(s)>max_len else "")
    except Exception as e: return f"<repr error: {str(e)}>"

# %% ../nbs/00_core.ipynb
@patch
def user_items(self:InteractiveShell, max_len=200, xtra_skip=()):
    "Get user-defined vars & funcs from namespace."
    ns,nsh = self.user_ns,self.user_ns_hidden
    ignore = {'nbmeta', 'receive_nbmeta'}
    ignore.add(xtra_skip)
    rm_types = (
        type, FunctionType, ModuleType, MethodType, BuiltinFunctionType,
        getattr(typing, '_SpecialGenericAlias', ()),
        getattr(typing, '_GenericAlias', ()),
        getattr(typing, '_SpecialForm', ())
    )
    user_items = {k:v for k, v in ns.items()
                  if not k in ignore and k not in nsh}
    user_vars = {k:_safe_repr(v, max_len=max_len)
                 for k, v in user_items.items() if not k.startswith('_') and not isinstance(v, rm_types)}
    user_fns = {k:str(signature(v)) for k, v in user_items.items()
                if isinstance(v, FunctionType) and v.__module__ == '__main__' and not k.startswith('__')}
    return user_vars,user_fns

# %% ../nbs/00_core.ipynb
def _rank(c, s):
    "Rank a completion `c` for text `s` with namespace `ns`."
    parts = s.split('.')
    is_public = not c.text.startswith('_')
    if c.type=='param': r=1
    elif c.mod=='__main__': r=2 # local
    elif len(parts)>1 and parts[0]==c.mod: r=3 # module
    elif c.mod=='builtins': r=4
    else: r=5
    return r if is_public else r+0.1

# %% ../nbs/00_core.ipynb
@patch
def ranked_complete(self:InteractiveShell, code, line_no=None, col_no=None):
    ns = self.user_ns
    lines = code.splitlines(True)
    if line_no: offset = sum(len(lines[i]) for i in range(line_no-1)) + col_no -1
    else: offset = len(code)
    cs = self.Completer.completions(code, offset)
    def _c(a):
        res = dict2obj({attr: getattr(a, attr) for attr in dir(a) if attr[0]!='_'})
        res['mod']= getattr(ns.get(a.text, None), '__module__', None)
        res['rank'] = _rank(res, s=code)
        return res
    # Remove dunder vars, unless the user seems to be looking for them explicitly
    return [_c(c) for c in cs if not c.text.startswith('__') or '__' in code]

# %% ../nbs/00_core.ipynb
def _signatures(ns, s, line, col):
    ctx = Interpreter(s, [ns]).get_signatures(line, col)
    if not ctx: ctx = jscript(s).get_signatures(line, col)
    return ctx

@patch
def sig_help(self:InteractiveShell, code, line_no=None, col_no=None):
    ns = self.user_ns
    ctx = _signatures(ns, code, line=line_no, col=col_no)
    def _s(s): return {'label':s.description,'typ':s.type, 'mod':s.module_name, 'doc':s.docstring(),
                       'idx':s.index, 'params':[{'name':p.name, 'desc':p.description} for p in s.params]}
    return [_s(opt) for opt in ctx]

# %% ../nbs/00_core.ipynb
@patch
def get_vars(self:InteractiveShell, vs:list):
    "Get variables from namespace."
    ns = self.user_ns
    return {v:ns[v] for v in vs if v in ns}

# %% ../nbs/00_core.ipynb
def _get_schema(ns: dict, t):
    "Check if tool `t` has errors."
    if t not in ns: return f"`{t}` not found. Did you run it?"
    try: return get_schema(ns[t])
    except Exception as e: return f"`{t}`: {e}."

@patch
def get_schemas(self:InteractiveShell, fs:list):
    "Get schemas from namespace."
    ns = self.user_ns
    return {f:_get_schema(ns,f) for f in fs}

# %% ../nbs/00_core.ipynb
@patch
def xpush(self:InteractiveShell, interactive=False, **kw):
    "Like `push`, but with kwargs"
    self.push(kw, interactive=interactive)

# %% ../nbs/00_core.ipynb
@patch
def publish(self:InteractiveShell, data='', subtype='plain', mimetype='text', meta=None, update=False, **kw):
    if isinstance(data, DisplayObject): data,_ = self.display_formatter.format(data)
    elif not isinstance(data, Mapping): data = {f'{mimetype}/{subtype}': data}
    self.display_pub.publish(data, metadata=meta, transient=kw, update=update)

# %% ../nbs/00_core.ipynb
def transient(data='', subtype='plain', mimetype='text', meta=None, update=False, **kw):
    display({f'{mimetype}/{subtype}': data}, raw=True, metadata=meta, transient=kw, update=update)

# %% ../nbs/00_core.ipynb
def run_cmd(cmd, data='', meta=None, update=False, **kw):
    transient(data, meta=meta, update=update, cmd=cmd, **kw)

# %% ../nbs/00_core.ipynb
def get_md(cts):
    from html2text import HTML2Text
    h2t = HTML2Text(bodywidth=5000)
    h2t.ignore_links = False
    h2t.mark_code = True
    h2t.ignore_images = False
    res = h2t.handle(cts)
    def _f(m): return f'```\n{dedent(m.group(1))}\n```'
    return re.sub(r'\[code]\s*\n(.*?)\n\[/code]', _f, res or '', flags=re.DOTALL).strip()

# %% ../nbs/00_core.ipynb
def scrape_url(url): return create_scraper().get(url)

# %% ../nbs/00_core.ipynb
def read_url(
    url:str, # URL to read
    as_md:bool=True, # Convert HTML to Markdown?
    extract_section:bool=True, # If url has an anchor, return only that section
    selector:str=None # Select section(s) using BeautifulSoup.select (overrides extract_section)
):
    "Read URL and return contents"
    from urllib.parse import urlparse
    from bs4 import BeautifulSoup
    
    res = scrape_url(url).text
    soup = BeautifulSoup(res, "html.parser")
    
    if selector:
        sections = soup.select(selector)
        if sections: res = '\n\n'.join(str(section) for section in sections)
        else: res = ''
    elif extract_section:
        parsed = urlparse(url)
        if parsed.fragment:
            section = soup.find(id=parsed.fragment)
            if section:
                tag_name = section.name
                elements = [section]
                current = section.next_sibling
                while current:
                    if hasattr(current, 'name') and current.name == tag_name: break
                    elements.append(current)
                    current = current.next_sibling
                res = ''.join(str(el) for el in elements)
            else: res = ''
    if as_md: return get_md(res)
    return res

# %% ../nbs/00_core.ipynb
@patch
def _get_info(self:Inspector, obj, oname='', formatter=None, info=None, detail_level=0, omit_sections=()):
    "Custom formatter for ?? output"
    orig = self._orig__get_info(obj, oname=oname, formatter=formatter, info=info,
                               detail_level=detail_level, omit_sections=omit_sections)
    if detail_level==0: return orig
    info_dict = self.info(obj, oname=oname, info=info, detail_level=detail_level)
    out = []
    if c:=info_dict.get('source'): out.append(f"\n```python\n{dedent(c)}\n```")
    if c:=info_dict.get('file'): out.append(f"**File:** `{c}`")
    return {'text/markdown': '\n\n'.join(out), 'text/html': '', 'text/plain': orig['text/plain']}

# %% ../nbs/00_core.ipynb
def load_ipython_extension(ip):
    from ipykernel_helper import transient,run_cmd
    ns = ip.user_ns
    ns['read_url'],ns['transient'],ns['run_cmd'] = read_url,transient,run_cmd
