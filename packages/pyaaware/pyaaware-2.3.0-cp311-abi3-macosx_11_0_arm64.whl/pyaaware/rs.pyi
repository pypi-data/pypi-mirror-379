from typing import Any

import numpy as np


class FeatureGenerator:
    def __init__(self, feature_mode: str, truth_parameters: dict[str, dict[str, int | None]] | None = None) -> None: ...

    @property
    def feature_mode(self) -> str: ...

    @property
    def total_truth_parameters(self) -> int: ...

    @property
    def bin_start(self) -> int: ...

    @property
    def bin_end(self) -> int: ...

    @property
    def feature_parameters(self) -> int: ...

    @property
    def stride(self) -> int: ...

    @property
    def step(self) -> int: ...

    @property
    def delay(self) -> int: ...

    @property
    def decimation(self) -> int: ...

    @property
    def feature_size(self) -> int: ...

    @property
    def ftransform_length(self) -> int: ...

    @property
    def ftransform_overlap(self) -> int: ...

    @property
    def ftransform_ttype(self) -> str: ...

    @property
    def eftransform_length(self) -> int: ...

    @property
    def eftransform_overlap(self) -> int: ...

    @property
    def eftransform_ttype(self) -> str: ...

    @property
    def itransform_length(self) -> int: ...

    @property
    def itransform_overlap(self) -> int: ...

    @property
    def itransform_ttype(self) -> str: ...

    def reset(self) -> None: ...

    def execute_tf_all(
            self,
            xf: np.ndarray,
            truth_in: dict[str, dict[str, Any]] | None = None,
    ) -> tuple[np.ndarray, dict[str, dict[str, Any]] | None]: ...

    def execute_all(
            self,
            xt: np.ndarray,
            truth_in: dict[str, dict[str, Any]] | None = None,
    ) -> tuple[np.ndarray, dict[str, dict[str, Any]] | None]: ...


class ForwardTransform:
    def __init__(self, length: int, overlap: int, bin_start: int, bin_end: int, ttype: str) -> None: ...

    @property
    def length(self) -> int: ...

    @property
    def overlap(self) -> int: ...

    @property
    def bin_start(self) -> int: ...

    @property
    def bin_end(self) -> int: ...

    @property
    def ttype(self) -> str: ...

    @property
    def bins(self) -> int: ...

    @property
    def window(self) -> np.ndarray: ...

    def reset(self) -> None: ...

    def execute_all(self, xt: np.ndarray) -> np.ndarray: ...

    def execute_all_with_energy(self, xt: np.ndarray) -> tuple[np.ndarray, np.ndarray]: ...

    def execute(self, xt: np.ndarray) -> np.ndarray: ...

    def execute_with_energy(self, xt: np.ndarray) -> tuple[np.ndarray, np.float32]: ...


class InverseTransform:
    def __init__(
            self, length: int, overlap: int, bin_start: int, bin_end: int, ttype: str, gain: float, trim: bool
    ) -> None: ...

    @property
    def length(self) -> int: ...

    @property
    def overlap(self) -> int: ...

    @property
    def bin_start(self) -> int: ...

    @property
    def bin_end(self) -> int: ...

    @property
    def ttype(self) -> str: ...

    @property
    def gain(self) -> float: ...

    @property
    def trim(self) -> bool: ...

    @property
    def bins(self) -> int: ...

    @property
    def window(self) -> np.ndarray: ...

    def reset(self) -> None: ...

    def execute_all(self, xf: np.ndarray) -> np.ndarray: ...

    def execute_all_with_energy(self, xf: np.ndarray) -> tuple[np.ndarray, np.ndarray]: ...

    def execute(self, xt: np.ndarray) -> np.ndarray: ...

    def execute_with_energy(self, xt: np.ndarray) -> tuple[np.ndarray, np.float32]: ...


class StreamingResampler:
    def __init__(self, orig_sr: int, target_sr: int, mode: str, buffer_size: int | None = None) -> None: ...

    @property
    def orig_sr(self) -> int: ...

    @property
    def target_sr(self) -> int: ...

    @property
    def ratio(self) -> float: ...

    @property
    def mode(self) -> str: ...

    @property
    def delay(self) -> int: ...

    def process_chunk(self, input: np.ndarray, output: np.ndarray) -> int: ...

    def process(self, input: np.ndarray) -> np.ndarray: ...

    def flush(self) -> np.ndarray: ...

    def estimate_output_size(self, input_size: int) -> int: ...


def power_compress(feature: np.ndarray) -> np.ndarray: ...


def power_uncompress(compressed_features: np.ndarray) -> np.ndarray: ...


def sov2nov(feature: np.ndarray, feature_mode: str) -> np.ndarray: ...


def get_audio_from_feature(feature: np.ndarray, feature_mode: str) -> np.ndarray: ...


def get_feature_from_audio(audio: np.ndarray, feature_mode: str) -> np.ndarray: ...


def stack_complex(unstacked: np.ndarray) -> np.ndarray: ...


def unstack_complex(stacked: np.ndarray) -> np.ndarray: ...


def stacked_complex_real(stacked: np.ndarray) -> np.ndarray: ...


def stacked_complex_imag(stacked: np.ndarray) -> np.ndarray: ...


def raw_read_audio(path: str) -> tuple[np.ndarray, int]: ...


def read_audio(path: str, target_sr: int, resample_mode: str | None) -> np.ndarray: ...


def resample(audio: np.ndarray, orig_sr: int, target_sr: int, mode: str) -> np.ndarray: ...


def write_wav(path: str, audio: np.ndarray, sample_rate: int) -> None: ...


__version__: str
