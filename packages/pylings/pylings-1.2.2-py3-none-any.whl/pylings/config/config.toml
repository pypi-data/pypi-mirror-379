[settings]
welcome_message = """
Is this your first time? Don't worry, Pylings is made for beginners!
We are going to teach you a lot of things about Python, but before we can
get started, here are some notes about how Pylings operates:

1. The central concept behind Pylings is that you solve exercises. These
   exercises usually contain some compiler or logic errors which cause the
   exercise to fail compilation or testing. It's your job to find all errors
   and fix them!

2. Make sure to have your editor open in the `pylings/` directory. Pylings
   will show you the path of the current exercise under the progress bar. Open
   the exercise file in your editor, fix errors and save the file. Pylings
   will automatically detect the file change and rerun the exercise. If all
   errors are fixed, Pylings will ask you to move on to the next exercise.

3. If you're stuck on an exercise, enter `h` to show a hint.

4. If an exercise doesn't make sense to you, feel free to open an issue on
   GitHub! (https://github.com/CompEng0001/pylings). We look at every issue, and
   sometimes, other learners do too so you can help each other out!

5. Check every now and then to see if the pylings has a new version at 
   (https://pypi.org/project/pylings/)
"""

final_message = """
We hope you enjoyed learning about the various aspects of Python!
If you noticed any issues, don't hesitate to report them on Github.
You can also contribute your own exercises to help the greater community!
Before reporting an issue or contributing, please read our guidelines:
https://github.com/CompEng0001/pylings/blob/main/CONTRIBUTING.md
"""

[exercise_intro1]
name = "intro1"
dir = "00_intro"
hint = """
Press `n` to continue to next exercise, or press 'r' to reset file if erroring
"""

[exercise_variables1]
name = "variables1"
dir = "01_variables"
hint = """
Read the comments they really help:

- Make sure that all variables have the correct data type
"""

[exercise_variables2]
name = "variables2"
dir = "01_variables"
hint = """
- Make sure that all variables have the correct data types?

- Are you doing the calculations correctly?
"""

[exercise_variables3]
name = "variables3"
dir = "01_variables"
hint = """
The comments in the exercise really help, see some hints below:

- + str()
- {}
- .format()
- * some number
"""

[exercise_variables4]
name = "variables4"
dir = "01_variables"
hint = """
Comments really help guide you in this exercise, however here are some extra hints:

- try casting int()
- rememeber from variables3.py where you multiplied a string
- these operators; '/', '-', '+', '*' could be useful
"""

[exercise_variables5]
name = "variables5"
dir = "01_variables"
hint = """
Comments in this execise point to using indexing and slicing: 

- somestring[index]
- somestring[index:index]
- when slicing you can use the '-' operator to subtract from a given index
"""

[exercise_data_structures1]
name = "data_structures1"
dir = "02_data_structures"
hint = """
The comments in the exercise really help, most extensions require arguments such as:

- the fruit
- number
- or both
"""

[exercise_data_structures2]
name = "data_structures2"
dir = "02_data_structures"
hint = """
The `TODO` comments in the exercise really help.
"""

[exercise_data_structures3]
name = "data_structures3"
dir = "02_data_structures"
hint = """
The syntax is [key][value], and keys are strings in this exercise.

If you are really struggling look at the assert blocks.
"""

[exercise_data_structures4]
name = "data_structures4"
dir = "02_data_structures"
hint = """
The `TODO` comments in the exercise really help,
"""

[exercise_functions1]
name = "functions1"
dir = "03_functions"
hint = """
- Replace the pass keyword with return
- Remember it is a string the functions need to return
"""

[exercise_functions2]
name = "functions2"
dir = "03_functions"
hint = """
Remember to replace pass keyword with return

multiply_numbers()
- Functions can take arguments that are seperated by the ','
- You can return the result of multiplication without the need of a variable

welcome_message()
- Default values are very userful function_name(variable="value")
"""

[exercise_functions3]
name = "functions3"
dir = "03_functions"
hint = """
- Remember to use the primitive data types as arugments and return values in the 
  funtion signature.
- Seperate the variable name and the data type with `:`
"""

[exercise_functions4]
name = "functions4"
dir = "03_functions"
hint = """
- Use the `=` to assign a value to a data type
"""

[exercise_functions5]
name = "functions5"
dir = "03_functions"
hint = """
- Seperate vaules after the return keyword with comma
"""

[exercise_conditionals1]
name = "conditionals1"
dir = "04_conditionals"
hint = """
It is common to confuse `<` and `>`
"""

[exercise_conditionals2]
name = "conditionals2"
dir = "04_conditionals"
hint = """
- It is common to confuse `<` and `>`
- All but one comparsion should be a `>=` or `<=` or `==`
"""

[exercise_conditionals3]
name = "conditionals3"
dir = "04_conditionals"
hint = """
Check number:
- a combination of '>=', '<=', '==' & 'and'

Check user:
- some values are already booleans, true or false
- are you using all arguments to the function?
"""

[exercise_conditionals4]
name = "conditionals4"
dir = "04_conditionals"
hint = """
- Keywords match and case, 
- You are match`ing` on a value, so each case is an accepted value. 
- Use `_` to give a default or unmatched case.
"""

[exercise_loops1]
name = "loops1"
dir = "05_loops"
hint = """
generate_numbers()
- You could use a range(1, var + 1) as the for loop condition
- remember that a list has the extension .append(var)

sum_numbers()
- less than or equal to is a good operator to use here
- you can increment a variable using +=

even_numbers()
- use modulos `%` can be used to determine if a number is divisible
- a conditional check with a `if` is recommended
"""

[exercise_oop1]
name = "oop1"
dir = "06_oop"
hint = """
__init__ method()
- Use `self.attribute_name = value` to set instance variables.
- Set `speed` to 0 when initializing.

accelerate() method
- Use `self.speed += amount` to increase the speed.

brake() method
- Make sure the speed doesn't go below 0; you can use `max(0, value)` to ensure this.
"""

[exercise_oop2]
name = "oop2"
dir = "06_oop"
hint = """
Remember to use self to access members/attributes

__str__ method
- This should return a user-friendly message.
- Use an f-string to format: `f"{} traveling at {} km/h"`.

__repr__ method
- Should return a string that looks like how you'd recreate the object.
- Use: `f"Car('{}', {})"`
"""

[exercise_oop3]
name = "oop3"
dir = "06_oop"
hint = """
ElectricCar class
- Use inheritance by passing the parent class name in parentheses: `class ElectricCar(Car):`
- Call the parent class constructor using `super().__init__(brand)`.

accelerate() method
- Call the parent's accelerate method using `super().accelerate(amount)`
- Then, reduce `battery_level` by 1, do not go below 0.

brake() method
- Call the parent's accelerate method using `super().brake(amount)`
- Then, increase `battery_level` by 1, do above 100.

__str__ method
- Return a string that includes the brand, speed, and battery level.
- Example format: `f"{} traveling at {} km/h with {}% battery"`
"""

[exercise_quiz1]
name = "quiz1"
dir = "07_quiz"
hint = """
Book class
- Initialize attributes: title, author, genre, year, and availability.
- In `borrow()`, use an if-statement to check if the book is available.
- Use `return_book()` to reset availability.
- Format the `__str__` output as: "Title by Author (Genre, Year) - Available/Unavailable"

Library class
- Store books in a list.
- Use a for loop to iterate through the list of books when borrowing or returning.
- Use the `__str__` method of Book to display information for each book in `display_books()`.

General tips
- Use `self.attribute = value` to assign instance attributes.
- Use `append()` to add books to the library's list.
- Use `if` conditions to check book availability when borrowing.

Still stuck? Then refer to previous completed exercises
"""

[exercise_errors1]
name = "errors1"
dir = "08_error_handling"
hint = """
safe_divide()
- Use a try block to divide the numbers.

string_to_int()
- Use int() to attempt conversion inside a try block.

access_list_element()
- Use a try block to access the list at the given index.
- You do not need a for loops
"""

[exercise_errors2]
name = "errors2"
dir = "08_error_handling"
hint = """
- Refer to the url in the comments in the errors2.py

- Or you could use type() like in the example to find the exception type, and then replace it. 

- Instead of returning a string like `"ZeroDivisionError"`, use `type(exception)` to return the actual exception class.
"""

[exercise_errors3]
name = "errors3"
dir = "08_error_handling"
hint = """
- Refer to the url in the comments in the errors2.py

- `raise` <SomeError>("MESSAGE)

- Use a `finally` block to ensure `file.close()` runs even if an error occurs.
"""

[exercise_errors4]
name = "errors4"
dir = "08_error_handling"
hint = """
- Create a custom exception `class NegativeNumberError(Exception):`

validate_positive()
- Use `raise NegativeNumberError("Negative numbers are not allowed.")` if the number is negative.

check_age()
- Define `class InvalidAgeError(Exception):`
- If age is below 0 or above 120, raise `InvalidAgeError("Invalid age.")`

withdraw_money()
- Define `class InsufficientFundsError(Exception):`
- Raise `InsufficientFundsError("Insufficient funds.")` if withdrawal exceeds balance.
"""

[exercise_threading1]
name = "threading1"
dir = "09_threading"
hint = """
worker()
- Define a function that takes `thread_id` as an argument.
- Print `"Thread {thread_id} done"` and sleep for 1 second using `time.sleep(1)`.
- Use `time.time()` to measure the execution time and return it.

main()
- Create an empty list `threads` to store the thread objects.
- Use `threading.Thread(target=lambda i=i: results.append(worker(i)))` to create a thread.
- Start each thread using `.start()`.
- Use `.join()` on each thread to wait for its completion.
- Ensure `results` collects 5 entries, proving all threads finished execution.

Ensuring Threading is Used
- Measure execution time using `time.time()`.
- Ensure total execution time is **less than 2 seconds**.
- If execution takes **5+ seconds**, threading is not used properly.
"""

[exercise_threading2]
name = "threading2"
dir = "09_threading"
hint = """
safe_increment()
- Use `lock.acquire()` before modifying `counter`.
- Use `lock.release()` after modifying `counter`.
- Alternatively, use `with lock:` for cleaner syntax.
- Increment `counter` **1000 times per thread**.

main()
- Create an empty list `threads` to store the thread objects.
- Use `threading.Thread(target=safe_increment)` to create threads.
- Start each thread using `.start()`.
- Use `.join()` on each thread to ensure completion.

Ensuring Synchronisation
- Without `threading.Lock`, the counter may be incorrect due to race conditions.
- The correct final value should be **5000** if threading is used properly.
"""

[exercise_threading3]
name = "threading3"
dir = "09_threading"
hint = """
access_resource()
- Use `semaphore.acquire()` before accessing the resource.
- Print `"Thread {thread_id} accessing resource"` before sleeping.
- Use `time.sleep(2)` to simulate work.
- Print `"Thread {thread_id} done"` after work is done.
- Use `semaphore.release()` to free up a slot.

main()
- Create an empty list `threads` to store the thread objects.
- Use `threading.Thread(target=access_resource, args=(thread_id,))` inside a loop.
- Start each thread using `.start()`.
- Use `.join()` on each thread to ensure completion.

Ensuring Semaphore Works
- If no semaphore is used, all threads will access the resource at the same time.
- With `threading.Semaphore(3)`, only **3 threads should work concurrently**.
"""