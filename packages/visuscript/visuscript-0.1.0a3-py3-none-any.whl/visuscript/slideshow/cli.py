"""A utility for presenting a slideshow generated with Visuscript."""

from argparse import ArgumentParser
from pathlib import Path
from dataclasses import dataclass
import json
import time

try:
    import cv2
except ModuleNotFoundError:
    print(
        "'opencv-python' is a dependency for this utility but is not installed. You can install it with `pip install opencv-python`."
    )
    exit(1)


def main():
    parser = ArgumentParser(__doc__)
    parser.add_argument(
        "video_file",
        type=Path,
        help="The video file that contains the frames for the slideshow.",
    )
    parser.add_argument(
        "--metadata_file",
        type=Path,
        default=None,
        help="The file generated by Visuscript that contains the data necessary for running the slideshow.",
    )

    args = parser.parse_args()

    VIDEO_FILE: Path = args.video_file
    slideshow_metadata: Path | None = args.metadata_file

    if not slideshow_metadata:
        slideshow_metadata = VIDEO_FILE.with_suffix(".slideshow-metadata.json")

    SLIDESHOW_METADATA = slideshow_metadata

    with open(SLIDESHOW_METADATA) as f:
        metadata = json.load(f)
    slide_start_frames: list[int] = list(map(int, metadata["slide_start_frames"]))

    FPS: int = metadata["fps"]
    FRAME_DELAY = 1 / FPS

    cap = cv2.VideoCapture(str(VIDEO_FILE))
    last_frame_id = int(cap.get(cv2.CAP_PROP_FRAME_COUNT)) - 1

    slide_start_frames.append(last_frame_id)

    state: ProgramState = JumpingToStartOfSlide(target_slide=0)

    while cap.isOpened():
        if isinstance(state, Animating):
            if state.last_rendered_frame < slide_start_frames[state.slide + 1] - 1:
                ret, frame = cap.read()
                if not ret:
                    raise RuntimeError(
                        f"Could not render frame {state.last_rendered_frame + 1}"
                    )

                time_ahead = state.frames_animated * FRAME_DELAY - (
                    time.time() - state.start_time
                )
                if time_ahead > 0:
                    time.sleep(time_ahead)
                cv2.imshow("Presentation", frame)
                state.last_rendered_frame += 1
                state.frames_animated += 1
                match get_pressed_key():
                    case Keys.DOWN_ARROW | Keys.RIGHT_ARROW:
                        state = JumpingToStartOfSlide(target_slide=state.slide + 1)
                    case Keys.UP_ARROW | Keys.LEFT_ARROW:
                        state = JumpingToStartOfSlide(target_slide=state.slide)
                    case _:
                        ...
            elif state.last_rendered_frame == slide_start_frames[state.slide + 1] - 1:
                state = EndOfSlide(slide=state.slide)
            else:
                raise RuntimeError(
                    "Internal Error: last rendered frame cannot be greater than the target frame."
                )
        elif isinstance(state, JumpingToStartOfSlide):
            cap.set(cv2.CAP_PROP_POS_FRAMES, slide_start_frames[state.target_slide])
            ret, frame = cap.read()
            if not ret:
                raise RuntimeError(f"Could not jump to slide {state.target_slide}")
            cv2.imshow("Presentation", frame)
            state = StartOfSlide(slide=state.target_slide)
        elif isinstance(state, JumpingToEndOfSlide):
            cap.set(
                cv2.CAP_PROP_POS_FRAMES, slide_start_frames[state.target_slide + 1] - 1
            )
            ret, frame = cap.read()
            if not ret:
                raise RuntimeError(f"Could not jump to slide {state.target_slide}")
            cv2.imshow("Presentation", frame)
            state = StartOfSlide(slide=state.target_slide)
        elif isinstance(state, StartOfSlide):
            match get_pressed_key():
                case Keys.SPACE | Keys.RIGHT_ARROW if (
                    state.slide + 1 < len(slide_start_frames)
                    and slide_start_frames[state.slide + 1]
                    - slide_start_frames[state.slide]
                    > 1
                ):
                    state = Animating(
                        last_rendered_frame=slide_start_frames[state.slide],
                        slide=state.slide,
                        start_time=time.time(),
                    )
                case Keys.SPACE | Keys.RIGHT_ARROW if (
                    state.slide + 1 < len(slide_start_frames)
                    and slide_start_frames[state.slide + 1]
                    - slide_start_frames[state.slide]
                    == 1
                ):
                    state = JumpingToStartOfSlide(target_slide=state.slide + 1)
                case Keys.DOWN_ARROW if state.slide + 1 < len(slide_start_frames):
                    state = JumpingToStartOfSlide(target_slide=state.slide + 1)
                case Keys.UP_ARROW | Keys.LEFT_ARROW if state.slide > 0:
                    state = JumpingToStartOfSlide(target_slide=state.slide - 1)
                case _:
                    ...
        else:  # state is EndOfSlide
            match get_pressed_key():
                case Keys.DOWN_ARROW | Keys.RIGHT_ARROW if state.slide + 1 < len(
                    slide_start_frames
                ):
                    state = JumpingToStartOfSlide(target_slide=state.slide + 1)
                case Keys.UP_ARROW | Keys.LEFT_ARROW if state.slide > 0:
                    state = JumpingToStartOfSlide(target_slide=state.slide - 1)
                case _:
                    ...

    # Release resources
    cap.release()
    cv2.destroyAllWindows()


class ProgramState: ...


@dataclass
class JumpingToStartOfSlide(ProgramState):
    target_slide: int


@dataclass
class JumpingToEndOfSlide(ProgramState):
    target_slide: int


@dataclass
class Animating(ProgramState):
    last_rendered_frame: int
    slide: int
    start_time: float
    frames_animated: int = 0


@dataclass
class StartOfSlide(ProgramState):
    slide: int


@dataclass
class EndOfSlide(ProgramState):
    slide: int


class Keys:
    SPACE = ord(" ")
    UP_ARROW = 0
    DOWN_ARROW = 1
    LEFT_ARROW = 2
    RIGHT_ARROW = 3


def key_pressed(*keys: str):
    return cv2.waitKey(1) & 0xFF in map(ord, keys)


def get_pressed_key():
    return cv2.waitKey(1) & 0xFF


if __name__ == "__main__":
    main()
