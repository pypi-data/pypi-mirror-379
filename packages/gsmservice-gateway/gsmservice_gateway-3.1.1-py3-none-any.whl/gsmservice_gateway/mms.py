"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from gsmservice_gateway import models, utils
from gsmservice_gateway._hooks import HookContext
from gsmservice_gateway.types import BaseModel, OptionalNullable, UNSET
from gsmservice_gateway.utils import get_security_from_env
from gsmservice_gateway.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, List, Mapping, Optional, Union, cast


class Mms(BaseSDK):
    def get_price(
        self,
        *,
        request: Union[
            models.GetMmsPriceRequestBody, models.GetMmsPriceRequestBodyTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetMmsPriceResponse:
        r"""Check the price of MMS Messages

        Check the price of single or multiple MMS messages at the same time before sending them. You can pass as a `request` named parameter a single `MmsMessage` (for single message) or `List[MmsMessage]` (for multiple messages). Each `MmsMessage` object has several properties, describing message parameters such as recipient phone number, content of the message, attachments, etc.
        The method will accept maximum **50** messages in one call.

        As a successful result a `GetMmsPriceResponse` object will be returned with `result` property of type `List[Price]` containing a `Price` objects, one object per each single message. You should check the `error` property of each `Price` object to make sure which messages were priced successfully and which finished with an error. Successfully priced messages will have `null` value of `error` property.

        `GetSmsPriceResponse` object will include also `headers` property with `X-Success-Count` (a count of messages which were processed successfully) and `X-Error-Count` (count of messages which were rejected) elements.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.GetMmsPriceRequestBody)
        request = cast(models.GetMmsPriceRequestBody, request)

        req = self._build_request(
            method="POST",
            path="/messages/mms/price",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.GetMmsPriceRequestBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 60000, 1.5, 3600000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getMmsPrice",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.GetMmsPriceResponse(
                result=unmarshal_json_response(List[models.Price], http_res),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(
            http_res, ["400", "401", "4XX"], "application/problem+json"
        ):
            response_data = unmarshal_json_response(
                models.ErrorResponseErrorData, http_res
            )
            raise models.ErrorResponseError(response_data, http_res)
        if utils.match_response(http_res, "5XX", "application/problem+json"):
            response_data = unmarshal_json_response(
                models.ErrorResponseErrorData, http_res
            )
            raise models.ErrorResponseError(response_data, http_res)

        raise models.SDKError("Unexpected response received", http_res)

    async def get_price_async(
        self,
        *,
        request: Union[
            models.GetMmsPriceRequestBody, models.GetMmsPriceRequestBodyTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetMmsPriceResponse:
        r"""Check the price of MMS Messages

        Check the price of single or multiple MMS messages at the same time before sending them. You can pass as a `request` named parameter a single `MmsMessage` (for single message) or `List[MmsMessage]` (for multiple messages). Each `MmsMessage` object has several properties, describing message parameters such as recipient phone number, content of the message, attachments, etc.
        The method will accept maximum **50** messages in one call.

        As a successful result a `GetMmsPriceResponse` object will be returned with `result` property of type `List[Price]` containing a `Price` objects, one object per each single message. You should check the `error` property of each `Price` object to make sure which messages were priced successfully and which finished with an error. Successfully priced messages will have `null` value of `error` property.

        `GetSmsPriceResponse` object will include also `headers` property with `X-Success-Count` (a count of messages which were processed successfully) and `X-Error-Count` (count of messages which were rejected) elements.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.GetMmsPriceRequestBody)
        request = cast(models.GetMmsPriceRequestBody, request)

        req = self._build_request_async(
            method="POST",
            path="/messages/mms/price",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.GetMmsPriceRequestBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 60000, 1.5, 3600000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getMmsPrice",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.GetMmsPriceResponse(
                result=unmarshal_json_response(List[models.Price], http_res),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(
            http_res, ["400", "401", "4XX"], "application/problem+json"
        ):
            response_data = unmarshal_json_response(
                models.ErrorResponseErrorData, http_res
            )
            raise models.ErrorResponseError(response_data, http_res)
        if utils.match_response(http_res, "5XX", "application/problem+json"):
            response_data = unmarshal_json_response(
                models.ErrorResponseErrorData, http_res
            )
            raise models.ErrorResponseError(response_data, http_res)

        raise models.SDKError("Unexpected response received", http_res)

    def send(
        self,
        *,
        request: Union[models.SendMmsRequestBody, models.SendMmsRequestBodyTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SendMmsResponse:
        r"""Send MMS Messages

        Send single or multiple MMS messages at the same time. You can pass as a `request` named parameter a single `MmsMessage` object (for single message) or `List[MmsMessage]` (for multiple messages). Each `MmsMessage` object has several properties, describing message parameters such recipient phone number, content of the message, attachments or scheduled sending date, etc. This method will accept maximum 50 messages in one call.

        As a successful result a `SendMmsResponse` object will be returned with `result` property of type `List[Message]` containing `Message` objects, one object per each single message. You should check the `status_code` property of each `Message` object to make sure which messages were accepted by gateway (queued) and which were rejected. In case of rejection, `status_description` property will include a reason.

        `SendMmsResponse` will also include `headers` property with `X-Success-Count` (a count of messages which were processed successfully), `X-Error-Count` (count of messages which were rejected) and `X-Sandbox` (if a request was made in Sandbox or Production system) elements.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.SendMmsRequestBody)
        request = cast(models.SendMmsRequestBody, request)

        req = self._build_request(
            method="POST",
            path="/messages/mms",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.SendMmsRequestBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 60000, 1.5, 3600000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="sendMms",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.SendMmsResponse(
                result=unmarshal_json_response(List[models.Message], http_res),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "4XX"], "application/problem+json"
        ):
            response_data = unmarshal_json_response(
                models.ErrorResponseErrorData, http_res
            )
            raise models.ErrorResponseError(response_data, http_res)
        if utils.match_response(http_res, "5XX", "application/problem+json"):
            response_data = unmarshal_json_response(
                models.ErrorResponseErrorData, http_res
            )
            raise models.ErrorResponseError(response_data, http_res)

        raise models.SDKError("Unexpected response received", http_res)

    async def send_async(
        self,
        *,
        request: Union[models.SendMmsRequestBody, models.SendMmsRequestBodyTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SendMmsResponse:
        r"""Send MMS Messages

        Send single or multiple MMS messages at the same time. You can pass as a `request` named parameter a single `MmsMessage` object (for single message) or `List[MmsMessage]` (for multiple messages). Each `MmsMessage` object has several properties, describing message parameters such recipient phone number, content of the message, attachments or scheduled sending date, etc. This method will accept maximum 50 messages in one call.

        As a successful result a `SendMmsResponse` object will be returned with `result` property of type `List[Message]` containing `Message` objects, one object per each single message. You should check the `status_code` property of each `Message` object to make sure which messages were accepted by gateway (queued) and which were rejected. In case of rejection, `status_description` property will include a reason.

        `SendMmsResponse` will also include `headers` property with `X-Success-Count` (a count of messages which were processed successfully), `X-Error-Count` (count of messages which were rejected) and `X-Sandbox` (if a request was made in Sandbox or Production system) elements.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.SendMmsRequestBody)
        request = cast(models.SendMmsRequestBody, request)

        req = self._build_request_async(
            method="POST",
            path="/messages/mms",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.SendMmsRequestBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 60000, 1.5, 3600000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="sendMms",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.SendMmsResponse(
                result=unmarshal_json_response(List[models.Message], http_res),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "4XX"], "application/problem+json"
        ):
            response_data = unmarshal_json_response(
                models.ErrorResponseErrorData, http_res
            )
            raise models.ErrorResponseError(response_data, http_res)
        if utils.match_response(http_res, "5XX", "application/problem+json"):
            response_data = unmarshal_json_response(
                models.ErrorResponseErrorData, http_res
            )
            raise models.ErrorResponseError(response_data, http_res)

        raise models.SDKError("Unexpected response received", http_res)
