# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _phreeqcrm
else:
    import _phreeqcrm

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref


import numpy as np
import phreeqcrm
from enum import Enum, unique

@unique
class State(Enum):
    UNINITIALIZED = 1
    INITIALIZED = 2

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _phreeqcrm.delete_SwigPyIterator

    def value(self):
        return _phreeqcrm.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _phreeqcrm.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _phreeqcrm.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _phreeqcrm.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _phreeqcrm.SwigPyIterator_equal(self, x)

    def copy(self):
        return _phreeqcrm.SwigPyIterator_copy(self)

    def next(self):
        return _phreeqcrm.SwigPyIterator_next(self)

    def __next__(self):
        return _phreeqcrm.SwigPyIterator___next__(self)

    def previous(self):
        return _phreeqcrm.SwigPyIterator_previous(self)

    def advance(self, n):
        return _phreeqcrm.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _phreeqcrm.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _phreeqcrm.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _phreeqcrm.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _phreeqcrm.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _phreeqcrm.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _phreeqcrm.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _phreeqcrm:
_phreeqcrm.SwigPyIterator_swigregister(SwigPyIterator)
class BoolVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _phreeqcrm.BoolVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _phreeqcrm.BoolVector___nonzero__(self)

    def __bool__(self):
        return _phreeqcrm.BoolVector___bool__(self)

    def __len__(self):
        return _phreeqcrm.BoolVector___len__(self)

    def __getslice__(self, i, j):
        return _phreeqcrm.BoolVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _phreeqcrm.BoolVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _phreeqcrm.BoolVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _phreeqcrm.BoolVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _phreeqcrm.BoolVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _phreeqcrm.BoolVector___setitem__(self, *args)

    def pop(self):
        return _phreeqcrm.BoolVector_pop(self)

    def append(self, x):
        return _phreeqcrm.BoolVector_append(self, x)

    def empty(self):
        return _phreeqcrm.BoolVector_empty(self)

    def size(self):
        return _phreeqcrm.BoolVector_size(self)

    def swap(self, v):
        return _phreeqcrm.BoolVector_swap(self, v)

    def begin(self):
        return _phreeqcrm.BoolVector_begin(self)

    def end(self):
        return _phreeqcrm.BoolVector_end(self)

    def rbegin(self):
        return _phreeqcrm.BoolVector_rbegin(self)

    def rend(self):
        return _phreeqcrm.BoolVector_rend(self)

    def clear(self):
        return _phreeqcrm.BoolVector_clear(self)

    def get_allocator(self):
        return _phreeqcrm.BoolVector_get_allocator(self)

    def pop_back(self):
        return _phreeqcrm.BoolVector_pop_back(self)

    def erase(self, *args):
        return _phreeqcrm.BoolVector_erase(self, *args)

    def __init__(self, *args):
        _phreeqcrm.BoolVector_swiginit(self, _phreeqcrm.new_BoolVector(*args))

    def push_back(self, x):
        return _phreeqcrm.BoolVector_push_back(self, x)

    def front(self):
        return _phreeqcrm.BoolVector_front(self)

    def back(self):
        return _phreeqcrm.BoolVector_back(self)

    def assign(self, n, x):
        return _phreeqcrm.BoolVector_assign(self, n, x)

    def resize(self, *args):
        return _phreeqcrm.BoolVector_resize(self, *args)

    def insert(self, *args):
        return _phreeqcrm.BoolVector_insert(self, *args)

    def reserve(self, n):
        return _phreeqcrm.BoolVector_reserve(self, n)

    def capacity(self):
        return _phreeqcrm.BoolVector_capacity(self)
    __swig_destroy__ = _phreeqcrm.delete_BoolVector

# Register BoolVector in _phreeqcrm:
_phreeqcrm.BoolVector_swigregister(BoolVector)
class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _phreeqcrm.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _phreeqcrm.DoubleVector___nonzero__(self)

    def __bool__(self):
        return _phreeqcrm.DoubleVector___bool__(self)

    def __len__(self):
        return _phreeqcrm.DoubleVector___len__(self)

    def __getslice__(self, i, j):
        return _phreeqcrm.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _phreeqcrm.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _phreeqcrm.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _phreeqcrm.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _phreeqcrm.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _phreeqcrm.DoubleVector___setitem__(self, *args)

    def pop(self):
        return _phreeqcrm.DoubleVector_pop(self)

    def append(self, x):
        return _phreeqcrm.DoubleVector_append(self, x)

    def empty(self):
        return _phreeqcrm.DoubleVector_empty(self)

    def size(self):
        return _phreeqcrm.DoubleVector_size(self)

    def swap(self, v):
        return _phreeqcrm.DoubleVector_swap(self, v)

    def begin(self):
        return _phreeqcrm.DoubleVector_begin(self)

    def end(self):
        return _phreeqcrm.DoubleVector_end(self)

    def rbegin(self):
        return _phreeqcrm.DoubleVector_rbegin(self)

    def rend(self):
        return _phreeqcrm.DoubleVector_rend(self)

    def clear(self):
        return _phreeqcrm.DoubleVector_clear(self)

    def get_allocator(self):
        return _phreeqcrm.DoubleVector_get_allocator(self)

    def pop_back(self):
        return _phreeqcrm.DoubleVector_pop_back(self)

    def erase(self, *args):
        return _phreeqcrm.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        _phreeqcrm.DoubleVector_swiginit(self, _phreeqcrm.new_DoubleVector(*args))

    def push_back(self, x):
        return _phreeqcrm.DoubleVector_push_back(self, x)

    def front(self):
        return _phreeqcrm.DoubleVector_front(self)

    def back(self):
        return _phreeqcrm.DoubleVector_back(self)

    def assign(self, n, x):
        return _phreeqcrm.DoubleVector_assign(self, n, x)

    def resize(self, *args):
        return _phreeqcrm.DoubleVector_resize(self, *args)

    def insert(self, *args):
        return _phreeqcrm.DoubleVector_insert(self, *args)

    def reserve(self, n):
        return _phreeqcrm.DoubleVector_reserve(self, n)

    def capacity(self):
        return _phreeqcrm.DoubleVector_capacity(self)
    __swig_destroy__ = _phreeqcrm.delete_DoubleVector

# Register DoubleVector in _phreeqcrm:
_phreeqcrm.DoubleVector_swigregister(DoubleVector)
class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _phreeqcrm.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _phreeqcrm.IntVector___nonzero__(self)

    def __bool__(self):
        return _phreeqcrm.IntVector___bool__(self)

    def __len__(self):
        return _phreeqcrm.IntVector___len__(self)

    def __getslice__(self, i, j):
        return _phreeqcrm.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _phreeqcrm.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _phreeqcrm.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _phreeqcrm.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _phreeqcrm.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _phreeqcrm.IntVector___setitem__(self, *args)

    def pop(self):
        return _phreeqcrm.IntVector_pop(self)

    def append(self, x):
        return _phreeqcrm.IntVector_append(self, x)

    def empty(self):
        return _phreeqcrm.IntVector_empty(self)

    def size(self):
        return _phreeqcrm.IntVector_size(self)

    def swap(self, v):
        return _phreeqcrm.IntVector_swap(self, v)

    def begin(self):
        return _phreeqcrm.IntVector_begin(self)

    def end(self):
        return _phreeqcrm.IntVector_end(self)

    def rbegin(self):
        return _phreeqcrm.IntVector_rbegin(self)

    def rend(self):
        return _phreeqcrm.IntVector_rend(self)

    def clear(self):
        return _phreeqcrm.IntVector_clear(self)

    def get_allocator(self):
        return _phreeqcrm.IntVector_get_allocator(self)

    def pop_back(self):
        return _phreeqcrm.IntVector_pop_back(self)

    def erase(self, *args):
        return _phreeqcrm.IntVector_erase(self, *args)

    def __init__(self, *args):
        _phreeqcrm.IntVector_swiginit(self, _phreeqcrm.new_IntVector(*args))

    def push_back(self, x):
        return _phreeqcrm.IntVector_push_back(self, x)

    def front(self):
        return _phreeqcrm.IntVector_front(self)

    def back(self):
        return _phreeqcrm.IntVector_back(self)

    def assign(self, n, x):
        return _phreeqcrm.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _phreeqcrm.IntVector_resize(self, *args)

    def insert(self, *args):
        return _phreeqcrm.IntVector_insert(self, *args)

    def reserve(self, n):
        return _phreeqcrm.IntVector_reserve(self, n)

    def capacity(self):
        return _phreeqcrm.IntVector_capacity(self)
    __swig_destroy__ = _phreeqcrm.delete_IntVector

# Register IntVector in _phreeqcrm:
_phreeqcrm.IntVector_swigregister(IntVector)
class StringVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _phreeqcrm.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _phreeqcrm.StringVector___nonzero__(self)

    def __bool__(self):
        return _phreeqcrm.StringVector___bool__(self)

    def __len__(self):
        return _phreeqcrm.StringVector___len__(self)

    def __getslice__(self, i, j):
        return _phreeqcrm.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _phreeqcrm.StringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _phreeqcrm.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _phreeqcrm.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _phreeqcrm.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _phreeqcrm.StringVector___setitem__(self, *args)

    def pop(self):
        return _phreeqcrm.StringVector_pop(self)

    def append(self, x):
        return _phreeqcrm.StringVector_append(self, x)

    def empty(self):
        return _phreeqcrm.StringVector_empty(self)

    def size(self):
        return _phreeqcrm.StringVector_size(self)

    def swap(self, v):
        return _phreeqcrm.StringVector_swap(self, v)

    def begin(self):
        return _phreeqcrm.StringVector_begin(self)

    def end(self):
        return _phreeqcrm.StringVector_end(self)

    def rbegin(self):
        return _phreeqcrm.StringVector_rbegin(self)

    def rend(self):
        return _phreeqcrm.StringVector_rend(self)

    def clear(self):
        return _phreeqcrm.StringVector_clear(self)

    def get_allocator(self):
        return _phreeqcrm.StringVector_get_allocator(self)

    def pop_back(self):
        return _phreeqcrm.StringVector_pop_back(self)

    def erase(self, *args):
        return _phreeqcrm.StringVector_erase(self, *args)

    def __init__(self, *args):
        _phreeqcrm.StringVector_swiginit(self, _phreeqcrm.new_StringVector(*args))

    def push_back(self, x):
        return _phreeqcrm.StringVector_push_back(self, x)

    def front(self):
        return _phreeqcrm.StringVector_front(self)

    def back(self):
        return _phreeqcrm.StringVector_back(self)

    def assign(self, n, x):
        return _phreeqcrm.StringVector_assign(self, n, x)

    def resize(self, *args):
        return _phreeqcrm.StringVector_resize(self, *args)

    def insert(self, *args):
        return _phreeqcrm.StringVector_insert(self, *args)

    def reserve(self, n):
        return _phreeqcrm.StringVector_reserve(self, n)

    def capacity(self):
        return _phreeqcrm.StringVector_capacity(self)
    __swig_destroy__ = _phreeqcrm.delete_StringVector

# Register StringVector in _phreeqcrm:
_phreeqcrm.StringVector_swigregister(StringVector)
IRM_OK = _phreeqcrm.IRM_OK
IRM_OUTOFMEMORY = _phreeqcrm.IRM_OUTOFMEMORY
IRM_BADVARTYPE = _phreeqcrm.IRM_BADVARTYPE
IRM_INVALIDARG = _phreeqcrm.IRM_INVALIDARG
IRM_INVALIDROW = _phreeqcrm.IRM_INVALIDROW
IRM_INVALIDCOL = _phreeqcrm.IRM_INVALIDCOL
IRM_BADINSTANCE = _phreeqcrm.IRM_BADINSTANCE
IRM_FAIL = _phreeqcrm.IRM_FAIL
class PhreeqcRMStop(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def what(self):
        return _phreeqcrm.PhreeqcRMStop_what(self)

    def __init__(self):
        _phreeqcrm.PhreeqcRMStop_swiginit(self, _phreeqcrm.new_PhreeqcRMStop())
    __swig_destroy__ = _phreeqcrm.delete_PhreeqcRMStop

# Register PhreeqcRMStop in _phreeqcrm:
_phreeqcrm.PhreeqcRMStop_swigregister(PhreeqcRMStop)
METHOD_CONSTRUCT = _phreeqcrm.METHOD_CONSTRUCT
METHOD_CREATEMAPPING = _phreeqcrm.METHOD_CREATEMAPPING
METHOD_DUMPMODULE = _phreeqcrm.METHOD_DUMPMODULE
METHOD_FINDCOMPONENTS = _phreeqcrm.METHOD_FINDCOMPONENTS
METHOD_GETCONCENTRATIONS = _phreeqcrm.METHOD_GETCONCENTRATIONS
METHOD_GETDENSITYCALCULATED = _phreeqcrm.METHOD_GETDENSITYCALCULATED
METHOD_GETERRORSTRING = _phreeqcrm.METHOD_GETERRORSTRING
METHOD_GETGASCOMPMOLES = _phreeqcrm.METHOD_GETGASCOMPMOLES
METHOD_GETGASCOMPPRESSURES = _phreeqcrm.METHOD_GETGASCOMPPRESSURES
METHOD_GETGASCOMPPHI = _phreeqcrm.METHOD_GETGASCOMPPHI
METHOD_GETGASPHASEVOLUME = _phreeqcrm.METHOD_GETGASPHASEVOLUME
METHOD_GETPRESSURE = _phreeqcrm.METHOD_GETPRESSURE
METHOD_GETSATURATIONCALCULATED = _phreeqcrm.METHOD_GETSATURATIONCALCULATED
METHOD_GETSELECTEDOUTPUT = _phreeqcrm.METHOD_GETSELECTEDOUTPUT
METHOD_GETSOLUTIONVOLUME = _phreeqcrm.METHOD_GETSOLUTIONVOLUME
METHOD_GETSPECIESCONCENTRATIONS = _phreeqcrm.METHOD_GETSPECIESCONCENTRATIONS
METHOD_GETSPECIESLOG10GAMMAS = _phreeqcrm.METHOD_GETSPECIESLOG10GAMMAS
METHOD_GETSPECIESLOG10MOLALITIES = _phreeqcrm.METHOD_GETSPECIESLOG10MOLALITIES
METHOD_GETTEMPERATURE = _phreeqcrm.METHOD_GETTEMPERATURE
METHOD_GETVISCOSITY = _phreeqcrm.METHOD_GETVISCOSITY
METHOD_INITIALPHREEQC2MODULE = _phreeqcrm.METHOD_INITIALPHREEQC2MODULE
METHOD_INITIALPHREEQCCELL2MODULE = _phreeqcrm.METHOD_INITIALPHREEQCCELL2MODULE
METHOD_LOADDATABASE = _phreeqcrm.METHOD_LOADDATABASE
METHOD_MPIWORKERBREAK = _phreeqcrm.METHOD_MPIWORKERBREAK
METHOD_RUNCELLS = _phreeqcrm.METHOD_RUNCELLS
METHOD_RUNFILE = _phreeqcrm.METHOD_RUNFILE
METHOD_RUNSTRING = _phreeqcrm.METHOD_RUNSTRING
METHOD_SETCOMPONENTH2O = _phreeqcrm.METHOD_SETCOMPONENTH2O
METHOD_SETCONCENTRATIONS = _phreeqcrm.METHOD_SETCONCENTRATIONS
METHOD_SETDENSITYUSER = _phreeqcrm.METHOD_SETDENSITYUSER
METHOD_SETERRORHANDLERMODE = _phreeqcrm.METHOD_SETERRORHANDLERMODE
METHOD_SETFILEPREFIX = _phreeqcrm.METHOD_SETFILEPREFIX
METHOD_SETGASCOMPMOLES = _phreeqcrm.METHOD_SETGASCOMPMOLES
METHOD_SETGASPHASEVOLUME = _phreeqcrm.METHOD_SETGASPHASEVOLUME
METHOD_SETPARTITIONUZSOLIDS = _phreeqcrm.METHOD_SETPARTITIONUZSOLIDS
METHOD_SETPOROSITY = _phreeqcrm.METHOD_SETPOROSITY
METHOD_SETPRESSURE = _phreeqcrm.METHOD_SETPRESSURE
METHOD_SETPRINTCHEMISTRYON = _phreeqcrm.METHOD_SETPRINTCHEMISTRYON
METHOD_SETPRINTCHEMISTRYMASK = _phreeqcrm.METHOD_SETPRINTCHEMISTRYMASK
METHOD_SETREBALANCEBYCELL = _phreeqcrm.METHOD_SETREBALANCEBYCELL
METHOD_SETREBALANCEFRACTION = _phreeqcrm.METHOD_SETREBALANCEFRACTION
METHOD_SETREPRESENTATIVEVOLUME = _phreeqcrm.METHOD_SETREPRESENTATIVEVOLUME
METHOD_SETSATURATIONUSER = _phreeqcrm.METHOD_SETSATURATIONUSER
METHOD_SETSELECTEDOUTPUTON = _phreeqcrm.METHOD_SETSELECTEDOUTPUTON
METHOD_SETSPECIESSAVEON = _phreeqcrm.METHOD_SETSPECIESSAVEON
METHOD_SETTEMPERATURE = _phreeqcrm.METHOD_SETTEMPERATURE
METHOD_SETTIME = _phreeqcrm.METHOD_SETTIME
METHOD_SETTIMECONVERSION = _phreeqcrm.METHOD_SETTIMECONVERSION
METHOD_SETTIMESTEP = _phreeqcrm.METHOD_SETTIMESTEP
METHOD_SETUNITSEXCHANGE = _phreeqcrm.METHOD_SETUNITSEXCHANGE
METHOD_SETUNITSGASPHASE = _phreeqcrm.METHOD_SETUNITSGASPHASE
METHOD_SETUNITSKINETICS = _phreeqcrm.METHOD_SETUNITSKINETICS
METHOD_SETUNITSPPASSEMBLAGE = _phreeqcrm.METHOD_SETUNITSPPASSEMBLAGE
METHOD_SETUNITSSOLUTION = _phreeqcrm.METHOD_SETUNITSSOLUTION
METHOD_SETUNITSSSASSEMBLAGE = _phreeqcrm.METHOD_SETUNITSSSASSEMBLAGE
METHOD_SETUNITSSURFACE = _phreeqcrm.METHOD_SETUNITSSURFACE
METHOD_SPECIESCONCENTRATIONS2MODULE = _phreeqcrm.METHOD_SPECIESCONCENTRATIONS2MODULE
METHOD_STATESAVE = _phreeqcrm.METHOD_STATESAVE
METHOD_STATEAPPLY = _phreeqcrm.METHOD_STATEAPPLY
METHOD_STATEDELETE = _phreeqcrm.METHOD_STATEDELETE
METHOD_USESOLUTIONDENSITYVOLUME = _phreeqcrm.METHOD_USESOLUTIONDENSITYVOLUME
class PhreeqcRM(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def CleanupReactionModuleInstances():
        return _phreeqcrm.PhreeqcRM_CleanupReactionModuleInstances()

    @staticmethod
    def CreateReactionModule(nxyz, nthreads):
        return _phreeqcrm.PhreeqcRM_CreateReactionModule(nxyz, nthreads)

    @staticmethod
    def DestroyReactionModule(n):
        return _phreeqcrm.PhreeqcRM_DestroyReactionModule(n)

    @staticmethod
    def GetGridCellCountYAML(YAML_file):
        r"""
        GetGridCellCountYAML will read the YAML file and extract
        the value of GridCellCount, which can be used to construct
        a PhreeqcRM instance.

        One constructor for a PhreeqcRM instance requires a value
        for the number of cells. If a GUI or preprocessor is used
        to write a YAML file to initialize PhreeqcRM, the number of
        cells can be written to the YAML file and extracted with
        this method.

        Args:
        	YAML_file (str): String containing the YAML file name.

        Returns:
        	int: Number of grid cells specified in the YAML file;
        		returns zero if GridCellCount is not defined.
        """
        return _phreeqcrm.PhreeqcRM_GetGridCellCountYAML(YAML_file)

    def __init__(self, nxyz, thread_count_or_communicator, io=None, delay_construct=False):
        r"""
        Constructor for the PhreeqcRM reaction module. 

        PhreeqcRM is a reaction module for reactive-transport
        simulators. Based on IPhreeqc, it allows access to all
        PHREEQC reaction capabilities. It contains methods for
        initial and boundary conditions, running reactions on all
        model cells, transfer of data to and from the module, and
        parallelization by MPI or OpenMP.

        If the code is compiled with the preprocessor directive
        USE_OPENMP, the reaction module use OPENMP and multiple
        threads. If the code is compiled with the preprocessor
        directive USE_MPI, the reaction module will use MPI and
        multiple processes. If neither preprocessor directive is
        used, the reaction module will be serial (unparallelized).

        Args:
        	nxyz (int): The number of grid cells in the users model. 

        	thread_count_or_communicator (int): If multithreaded, the
        		number of threads to use in parallel segments of the code.
        		If thread_count_or_communicator is <= 0, the number of
        		threads is set equal to the number of processors in the
        		computer. If multiprocessor, the MPI communicator to use
        		within the reaction module.

        	io(PHRQ_io): Optionally, a PHRQ_io input/output object can
        		be provided to the constructor. By default a PHRQ_io object
        		is constructed to handle reading and writing files.
        """
        if self.__class__ == PhreeqcRM:
            _self = None
        else:
            _self = self
        _phreeqcrm.PhreeqcRM_swiginit(self, _phreeqcrm.new_PhreeqcRM(_self, nxyz, thread_count_or_communicator, io, delay_construct))
    __swig_destroy__ = _phreeqcrm.delete_PhreeqcRM

    def CloseFiles(self):
        r"""
        Close the output and log files.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See
        		:meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_CloseFiles(self)

    def Concentrations2Utility(self, c, tc, p_atm):
        r"""
        N sets of component concentrations are converted to
        SOLUTIONs numbered 1-n in the Utility IPhreeqc.

        The solutions can be reacted and manipulated with the
        methods of IPhreeqc. If solution concentration units
        (:meth:`SetUnitsSolution`) are per liter, one liter of
        solution is created in the Utility instance; if solution
        concentration units are mass fraction, one kilogram of
        solution is created in the Utility instance. The motivation
        for this method is the mixing of solutions in wells, where
        it may be necessary to calculate solution properties (pH
        for example) or react the mixture to form scale minerals.

        Args:
        	c (float list, numpy.ndarray, or tuple): Array of
        		concentrations to be made SOLUTIONs in Utility IPhreeqc.
        		Array contains n values for each component
        		(:meth:`GetComponentCount`) in sequence.
        	tc (float list, numpy.ndarray, or tuple): Array of
        		temperatures to apply to the SOLUTIONs, in degrees C.
        		Array of size n.
        	p_atm (float list, numpy.ndarray, or tuple): Array of
        		pressures to apply to the SOLUTIONs, in atm. Array of size
        		n.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See
        		:meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_Concentrations2Utility(self, c, tc, p_atm)

    def CreateMappingSWIG(self, grid2chem):
        r"""
        Provides a mapping from grid cells in the user model to
        reaction cells for which chemistry needs to be run.

        The mapping is used to eliminate inactive cells and to use
        symmetry to decrease the number of cells for which
        chemistry must be run. The array grid2chem of size nxyz
        (the number of grid cells, :meth:`GetGridCellCount`) must
        contain the set of all integers 0 <= i < count_chemistry,
        where count_chemistry is a number less than or equal to
        nxyz. Inactive cells are assigned a negative integer. The
        mapping may be many-to-one to account for symmetry. Default
        is a one-to-one mapping--all user grid cells are reaction
        cells (equivalent to grid2chem values of
        0,1,2,3,...,nxyz-1).

        Args:
        	grid2chem (int list, numpy.ndarray, or tuple): An array of
        		integers: Nonnegative is a reaction-cell number (0 based),
        		negative is an inactive cell. Array is of size nxyz (number
        		of grid cells, :meth:`GetGridCellCount`).

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See
        		:meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_CreateMappingSWIG(self, grid2chem)

    def DecodeError(self, result):
        r"""
        If result is negative, this method prints an error message
        corresponding to IRM_RESULT result. If result is
        non-negative, no action is taken.

        Args:
        	result (IRM_RESULT): An IRM_RESULT value returned by one of
        		the reaction- module methods.

        IRM_RESULT definition:
        typedef enum {
        IRM_OK            =  0,  //Success
        IRM_OUTOFMEMORY   = -1,  //Failure, Out of memory
        IRM_BADVARTYPE    = -2,  //Failure, Invalid VAR type
        IRM_INVALIDARG    = -3,  //Failure, Invalid argument
        IRM_INVALIDROW    = -4,  //Failure, Invalid row
        IRM_INVALIDCOL    = -5,  //Failure, Invalid column
        IRM_BADINSTANCE   = -6,  //Failure, Invalid rm instance id
        IRM_FAIL          = -7,  //Failure, Unspecified
        } IRM_RESULT;
        """
        return _phreeqcrm.PhreeqcRM_DecodeError(self, result)

    def DumpModule(self, dump_on, append=False):
        r"""
        Writes the contents of all workers to file in _RAW formats
        (see appendix of PHREEQC version 3 manual), including
        SOLUTIONs and all reactants.

        Args:
        	dump_on (Boolean): Signal for writing the dump file, true
        		or false.
        	append (Boolean): Signal to append to the contents of the
        		dump file, true or false.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See
        		:meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_DumpModule(self, dump_on, append)

    def ErrorHandler(self, result, e_string):
        r"""
        Checks result for an error code. 

        If result is negative, the result is decoded
        (:meth:`DecodeError`), and printed as an error message
        along with the e_string, and an exception is thrown. If the
        result is nonnegative, no action is taken.

        Args:
        	result (IRM_RESULT): IRM_RESULT to be checked for an error.
        	e_string (str): String to be printed if an error is found.
        """
        return _phreeqcrm.PhreeqcRM_ErrorHandler(self, result, e_string)

    def ErrorMessage(self, error_string, prepend=True):
        r"""
        Send an error message to the screen, the output file, and
        the log file.

        Args:
        	error_string (str): String to be printed.
        	prepend (Boolean): True, prepends error_string with 'Error: ';
        		false, error_string is used with no prepended text.
        """
        return _phreeqcrm.PhreeqcRM_ErrorMessage(self, error_string, prepend)

    def FindComponents(self):
        r"""
        This method accumulates a list of elements that have been
        defined in a solution or any other reactant
        (EQUILIBRIUM_PHASE, KINETICS, and others), including charge
        imbalance.

        This method can be called multiple times and the list that
        is created is cummulative.The list is the set of components
        that needs to be transported.By default the list includes
        water, excess H and excess O(the H and O not contained in
        water); alternatively, the list may be set to contain total
        H and total O(:meth:`SetComponentH2O`), which requires
        transport results to be accurate to eight or nine
        significant digits.If multicomponent diffusion(MCD) is to
        be modeled, there is a capability to retrieve aqueous
        species concentrations(:meth:`GetSpeciesConcentrations`)
        and to set new solution concentrations after MCD by using
        individual species concentrations
        (:meth:`SpeciesConcentrations2Module`) .To use these methods the
        save - species property needs to be turned on
        (:meth:`SetSpeciesSaveOn`) .If the save - species property is on,
        FindComponents will generate a list of aqueous species
        (:meth:`GetSpeciesCount`, :meth:`GetSpeciesNames`), their
        diffusion coefficients at 25 C(:meth:`GetSpeciesD25`),
        and their charge(:meth:`GetSpeciesZ`) .

        returns: 
        	int : Number of components currently in the list, or
        		IRM_RESULT error code(negative value, see
        		:meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_FindComponents(self)

    def GetBackwardMapping(self):
        r"""
        Returns a dictionary of numpy arrays, where the reaction cell
        n is mapped to an array of user grid cell numbers that are mapped
        to n.

        Each reaction cell number has an array with one or more grid
        cell numbers.

        Returns: 
        	dict (numpy.ndarray) : Dict of array of ints. For each
        	reaction cell n, n is mapped to an array that contains
        	contains the grid-cell numbers that map to the reaction
        	cell.
        """
        return _phreeqcrm.PhreeqcRM_GetBackwardMapping(self)

    def GetBackwardMappingSWIG(self):
        return _phreeqcrm.PhreeqcRM_GetBackwardMappingSWIG(self)

    def GetChemistryCellCount(self):
        r"""
        Returns the number of reaction cells in the reaction module. 

        The number of reaction cells is defined by the set of
        non-negative integers in the mapping from grid cells 
        (:meth:`CreateMapping`), or, by default, the number of grid
        cells (:meth:`GetGridCellCount`) .The number of reaction
        cells is less than or equal to the number of grid cells in
        the user model.

        Returns: 
        	int: Number of reaction cells.
        """
        return _phreeqcrm.PhreeqcRM_GetChemistryCellCount(self)

    def GetComponentCount(self):
        r"""
        Returns the number of components in the reaction-module
        component list.

        returns: 
        	int : The number of components in the reaction - module
        		component list.The component list is generated by calls to
        		:meth:`FindComponents`.The return value from the last call
        		to :meth:`FindComponents` is equal to the return value from
        		GetComponentCount.
        """
        return _phreeqcrm.PhreeqcRM_GetComponentCount(self)

    def GetComponents(self):
        r"""
        Returns the reaction-module component list that was
        generated by calls to :meth:`FindComponents`.

        returns: 
        	numpy ndarray (str)): Each string is a component name.
        """
        return _phreeqcrm.PhreeqcRM_GetComponents(self)

    def GetConcentrationsSWIG(self):
        r"""
        Return solution concentrations for all model cells. 

        Units of concentration for c are defined by
        :meth:`SetUnitsSolution`. For per liter concentration
        units, solution volume is used to calculate the
        concentrations for c. For mass-fraction concentration
        units, the solution mass is used to calculate
        concentrations for c. Two options are available for the
        volume and mass of solution that are used in converting to
        transport concentrations: (1) the volume and mass of
        solution are calculated by PHREEQC, or (2) the volume of
        solution is the product of saturation
        (:meth:`SetSaturationUser`), porosity (:meth:`SetPorosity`),
        and representative volume
        (:meth:`SetRepresentativeVolume`), and the mass of solution
        is volume times density as defined by :meth:`SetDensityUser`.
        :meth:`UseSolutionDensityVolume` determines which option is
        used. For option 1 , the databases that have partial molar
        volume definitions needed to accurately calculate solution
        volume are phreeqc.dat, Amm.dat, and pitzer.dat.

        Returns:
        	numpy.ndarray: Dimension of the array is ncomps times nxyz,
        		where, ncomps is the result of :meth:` FindComponents` or
        		:meth:`GetComponentCount`, and nxyz is the number of user
        		grid cells (:meth:`GetGridCellCount`). Values for inactive
        		cells are set to 1e30.
        """
        return _phreeqcrm.PhreeqcRM_GetConcentrationsSWIG(self)

    def GetCurrentSelectedOutputUserNumber(self):
        r"""
        Returns the user number of the current selected-output definition.

        :meth:`SetCurrentSelectedOutputUserNumber` or
        :meth:`SetNthSelectedOutput` specifies which of the
        selected-output definitions is used.

        Returns:
        	int: User number of the the current selected-output definition,
        		negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_GetCurrentSelectedOutputUserNumber(self)

    def GetDatabaseFileName(self):
        r"""
        Returns the file name of the database. Should be called
        after :meth:`LoadDatabase`.

        Returns:
        	string: The file name defined by :meth:`LoadDatabase`.
        """
        return _phreeqcrm.PhreeqcRM_GetDatabaseFileName(self)

    def GetDensityCalculatedSWIG(self):
        r"""
        Returns calculated densities from the reaction-module cells. 

        This method always returns the calculated densities;
        :meth:`SetDensityUser` does not affect the result.

        Returns:
        	numpy.darray: Dimension of the array is set to nxyz, where
        		nxyz is the number of user grid cells
        		(:meth:`GetGridCellCount`). Values for inactive cells are
        		set to 1e30. Densities are those calculated by the reaction
        		module. Only the following databases distributed with
        		PhreeqcRM have molar volume information needed to
        		accurately calculate density: phreeqc.dat, Amm.dat, and
        		pitzer.dat.
        """
        return _phreeqcrm.PhreeqcRM_GetDensityCalculatedSWIG(self)

    def GetDensity(self):
        return _phreeqcrm.PhreeqcRM_GetDensity(self)

    def GetEndCellSWIG(self):
        r"""
        Returns an array of integers that contains the largest
        reaction-cell number assigned to each worker.

        Each worker is assigned a range of reaction-cell numbers
        that are run during a call to :meth:`RunCells`. The range
        of reaction cells for a worker may vary as load rebalancing
        occurs. At any point in the calculations, the first cell
        and last cell to be run by a worker can be found in the
        arrays returned by :meth:`GetStartCell` and
        :meth:`GetEndCell`. Each method returns an array of
        integers that has length of the number of threads
        (:meth:`GetThreadCount`), if using OPENMP, or the number of
        processes (:meth:`GetMpiTasks`), if using MPI.

        Returns:
        	numpy.ndarray (int): Array of integers, one for each
        		worker, that gives the last reaction cell to be run by each
        		worker.
        """
        return _phreeqcrm.PhreeqcRM_GetEndCellSWIG(self)

    def GetEquilibriumPhases(self):
        r"""
        Returns a the names of all equilibrium phases defined in the module. 

        The list includes all phases included in any
        EQUILIBRIUM_PHASES definitions in the initial-phreeqc
        module. :meth:`FindComponents` must be called before
        :meth:`GetEquilibriumPhases`. This method may be useful
        when generating selected output definitions related to
        equilibrium phases.

        Returns:
        	tuple (str): each string is a unique equilibrium
        		phases name.
        """
        return _phreeqcrm.PhreeqcRM_GetEquilibriumPhases(self)

    def GetEquilibriumPhasesCount(self):
        r"""
        Returns the number of equilibrium phases found by
        :meth:`FindComonents`.

        :meth:`FindComponents` must be called before
        :meth:`GetEquilibriumPhasesCount`.This method may be useful
        when generating selected output definitions related to
        equilibrium phases.

        returns: 
        	int : The number of equilibrium phases.
        """
        return _phreeqcrm.PhreeqcRM_GetEquilibriumPhasesCount(self)

    def GetErrorHandlerMode(self):
        r"""
        Get the setting for the action to be taken when the reaction module 
        encounters an error.

        Options are 0, return to calling program with an error
        return code(default); 1, throw an exception, which can be
        caught in C++ (for C and Fortran, the program will exit);
        2, attempt to exit gracefully.

        Returns:
        	int: Current setting for the error handling mode: 0, 1, or 2.
        """
        return _phreeqcrm.PhreeqcRM_GetErrorHandlerMode(self)

    def GetErrorString(self):
        r"""
        Returns a standard string containing error messages
        related to the last call to a BMIPhreeqcRM method.

        Returns:
        	string: Error messages related to the last call to a
        		PhreeqcRM method.
        """
        return _phreeqcrm.PhreeqcRM_GetErrorString(self)

    def GetExchangeNames(self):
        r"""
        Returns a tuple of exchange names (such as 'X') that
        correspond with the exchange species names.

        :meth:`FindComponents` must be called before
        :meth:`GetExchangeNames`. The exchange names tuple is the
        same length as the exchange species names tuple and
        provides the corresponding exchange site. This method may
        be useful when generating selected output definitions
        related to exchangers.

        Returns:
        	tuple (str): Each string is an exchange name
        		corresponding to the exchange species names; an exchange
        		name may occur multiple times.
        """
        return _phreeqcrm.PhreeqcRM_GetExchangeNames(self)

    def GetExchangeSpecies(self):
        r"""
        Returns a tuple of exchange species names (such as 'NaX').

        The list of exchange species(such as 'NaX') is derived from
        the list of components(:meth:`FindComponents`) and the
        list of all exchange names(such as 'X') that are included
        in EXCHANGE definitions in the initial phreeqc instance.
        :meth:`FindComponents` must be called before
        :meth:`GetExchangeSpecies`.This method may be useful when
        generating selected output definitions related to
        exchangers.

        Returns: 
        	tuple (str): Each string is a unique exchange species
        		name.
        """
        return _phreeqcrm.PhreeqcRM_GetExchangeSpecies(self)

    def GetExchangeSpeciesCount(self):
        r"""
        Returns the number of exchange species found by
        :meth:`FindComponents`.

        :meth:`FindComponents` must be called before
        :meth:`GetExchangeSpeciesCount`. This method may be useful
        when generating selected output definitions related to
        exchangers.

        Returns:
        	int: The number of exchange species.
        """
        return _phreeqcrm.PhreeqcRM_GetExchangeSpeciesCount(self)

    def GetFilePrefix(self):
        r"""
        Returns the file prefix for the output (.chem.txt) and log
        files (.log.txt).

        Returns:
        	string: The file prefix as set by :meth:`SetFilePrefix`, or
        		'myrun', by default.
        """
        return _phreeqcrm.PhreeqcRM_GetFilePrefix(self)

    def GetForwardMappingSWIG(self):
        r"""
        Returns an array of ints that is a mapping from grid cells
        to reaction cells.

        The mapping is used to eliminate cells that are inactive
        and cells that are unnecessary because of symmetry from the
        list of cells for which reactions must be run. The mapping
        may be many-to-one to account for symmetry. The mapping is
        set by :meth:`CreateMapping`, or, by default, is a
        one-to-one mapping--all grid cells are reaction cells
        (array contains 0,1,2,3,...,nxyz-1).

        Returns:
        	numpy.ndarray (int): An array of integers of size nxyz
        		(number of grid cells, :meth:`GetGridCellCount`).
        		Nonnegative is a reaction-cell number (0 based), negative
        		is an inactive cell.
        """
        return _phreeqcrm.PhreeqcRM_GetForwardMappingSWIG(self)

    def GetGasComponents(self):
        r"""
        Returns a tuple of the names of all gas components found by 
        :meth:`FindComponents`. 

        :meth:`FindComponents` must be called before
        :meth:`GetGasComponents`. This method may be useful when
        generating selected output definitions related to gas
        phases.

        Returns:
        	tuple (str): Each string is a unique gas component
        		name.
        """
        return _phreeqcrm.PhreeqcRM_GetGasComponents(self)

    def GetGasComponentsCount(self):
        r"""
        Returns the number of gas phase components found by 
        :meth:`FindComponents`. 

        :meth:`FindComponents` must be called before
        :meth:`GetGasComponentsCount`. This method may be useful
        when generating selected output definitions related to gas
        phases.

        Returns:
        	int: The number of gas phase components.
        """
        return _phreeqcrm.PhreeqcRM_GetGasComponentsCount(self)

    def GetGasCompMolesSWIG(self):
        r"""
        Return moles of gas components for each model cell.

        Returns:
        	numpy.ndarray (float): Dimension of the array is
        		ngas_comps times nxyz, where, ngas_comps is the result of
        		:meth:`GetGasComponentsCount`, and nxyz is the number of
        		user grid cells (:meth:`GetGridCellCount`). If a gas
        		component is not defined for a cell, the number of moles is
        		set to -1. Values for inactive cells are set to 1e30.
        """
        return _phreeqcrm.PhreeqcRM_GetGasCompMolesSWIG(self)

    def GetGasCompPhiSWIG(self):
        r"""
        Return fugacity coefficients (phi) of each gas component
        for each model cell.

        Fugacity is equal to the gas component pressure times the
        fugacity coefficient.

        Returns: 
        	numpy.ndarray (float): Dimension of the array is ngas_comps
        		times nxyz, where, ngas_comps is the result of
        		:meth:`GetGasComponentsCount`, and nxyz is the number of
        		user grid cells (:meth:`GetGridCellCount`). If a gas
        		component is not defined for a cell, the fugacity
        		coefficient is set to -1. Values for inactive cells are set
        		to 1e30.
        """
        return _phreeqcrm.PhreeqcRM_GetGasCompPhiSWIG(self)

    def GetGasCompPressuresSWIG(self):
        r"""
        Return pressures of gas components for each model cell.

        Returns:
        	numpy.ndarray (float): Dimension of the array is set
        		to ngas_comps times nxyz, where ngas_comps is the result of
        		:meth:`GetGasComponentsCount`, and nxyz is the number of
        		user grid cells (:meth:`GetGridCellCount`). If a gas
        		component is not defined for a cell, the pressure is set to
        		-1. Values for inactive cells are set to 1e30.
        """
        return _phreeqcrm.PhreeqcRM_GetGasCompPressuresSWIG(self)

    def GetGasPhaseVolumeSWIG(self):
        r"""
        Returns volume of gas phase for each model cell.

        Returns:
        	numpy.ndarray (float): Dimension of the array is 
        		nxyz, where, nxyz is the number of user grid cells
        		(:meth:`GetGridCellCount`). If a gas phase is not defined
        		for a cell, the volume is set to -1. Values for inactive
        		cells are set to 1e30.
        """
        return _phreeqcrm.PhreeqcRM_GetGasPhaseVolumeSWIG(self)

    def GetGfwSWIG(self):
        r"""
        Returns an array with the gram-formula weight of each
        component.

        Called after :meth:`FindComponents`. Order of weights
        corresponds to the list of components from
        :meth:`GetComponents`.

        Returns:
        	numpy.ndarray (float): Each value is a component gram-
        		formula weight, g/mol.
        """
        return _phreeqcrm.PhreeqcRM_GetGfwSWIG(self)

    def GetGridCellCount(self):
        r"""
        Returns the number of grid cells in the user model.

        The mapping from grid cells to 
        reaction cells is defined by :meth:`CreateMapping`. The number of reaction cells 
        may be less than the number of grid cells if there are inactive regions or there 
        is symmetry in the model definition.

        Returns:
        	int: Number of grid cells in the user model.
        """
        return _phreeqcrm.PhreeqcRM_GetGridCellCount(self)

    def GetIthConcentrationSWIG(self, i):
        r"""
        Returns an array of concentrations for the Ith component. 

        Called after :meth:`FindComponents`. Order of components
        corresponds to the list of components from
        :meth:`GetComponents`.

        Returns:
        	numpy.ndarray (float): Concentration for each model cell 
        		of the Ith component.
        """
        return _phreeqcrm.PhreeqcRM_GetIthConcentrationSWIG(self, i)

    def GetIthSpeciesConcentrationSWIG(self, i):
        r"""
        Returns an array of concentrations for the Ith aqueous species. 

        Called after :meth:`FindComponents`. Order of species
        corresponds to the list of species from
        :meth:`GetSpeciesNames`. :meth:`SetSpeciesSaveOn` must be set
        to True.

        Returns:
        	numpy.ndarray (float): Concentration for each model cell 
        		of the Ith species.
        """
        return _phreeqcrm.PhreeqcRM_GetIthSpeciesConcentrationSWIG(self, i)

    def GetKineticReactions(self):
        r"""
        Returns a tuple of all kinetic reactions found by
        :meth:`FindComponents`.

        :meth:`FindComponents` must be called before
        :meth:`GetKineticReactions`. This method may be useful when
        generating selected output definitions related to kinetic
        reactions.

        Returns:
        	tuple (str): Each string is a unique
        		kinetic reaction name.
        """
        return _phreeqcrm.PhreeqcRM_GetKineticReactions(self)

    def GetKineticReactionsCount(self):
        r"""
        Returns the number of kinetic reactions found by
        :meth:`FindComponents`.

        :meth:`FindComponents` must be called before
        :meth:`GetKineticReactionsCount`. This method may be useful
        when generating selected output definitions related to
        kinetic reactions.

        Returns:
        	int: The number of kinetic reactions.
        """
        return _phreeqcrm.PhreeqcRM_GetKineticReactionsCount(self)

    def GetMpiMyself(self):
        r"""
        Returns the MPI process (task) number. 

        For the MPI version, the root task number is zero, and all
        other MPI tasks have unique task numbers greater than zero.
        The number of tasks can be obtained with
        :meth:`GetMpiTasks`. The number of tasks and computer hosts
        is determined at run time by the mpiexec command, and the
        number of reaction-module processes is defined by the
        communicator used in constructing the reaction modules
        (:meth:`PhreeqcRM`::PhreeqcRM). For the OPENMP version, the
        task number is always zero, and the result of
        :meth:`GetMpiTasks` is one.

        Returns:
        	int: The MPI task number for a process.
        """
        return _phreeqcrm.PhreeqcRM_GetMpiMyself(self)

    def GetMpiTasks(self):
        r"""
        Returns the number of MPI processes (tasks) assigned to
        the reaction module. 

        For the MPI version, the number of tasks and computer hosts
        is specified at run time by the mpiexec command. The number
        of MPI processes used for reaction calculations is
        determined by the MPI communicator used in constructing the
        reaction modules. The communicator may define as a subset of
        the total number of MPI processes. The root task number is
        zero, and all other MPI tasks have unique task numbers
        greater than zero. For the OPENMP version, the number of
        tasks is one, and the task number returned by
        :meth:`GetMpiMyself` is zero.

        Returns:
        	int: The number of MPI processes assigned to the reaction
        		module.
        """
        return _phreeqcrm.PhreeqcRM_GetMpiTasks(self)

    def GetNthSelectedOutputUserNumber(self, n):
        r"""
        Returns the user number for the nth selected-output
        definition. 

        Definitions are sorted by user number. Phreeqc allows
        multiple selected-output definitions, each of which is
        assigned a nonnegative integer identifier by the user. The
        number of definitions can be obtained by
        :meth:`GetSelectedOutputCount`. To cycle through all of the
        definitions, GetNthSelectedOutputUserNumber can be used to
        identify the user number for each selected-output
        definition in sequence.
        :meth:`SetCurrentSelectedOutputUserNumber` is then used to
        select that user number for selected-output processing.

        Args:
        	n (int): The sequence number of the selected-output
        		definition for which the user number will be returned.
        		Fortran, 1 based; C, 0 based.

        Returns: 
        	int: The user number of the nth selected - output
        		definition, negative is failure(See :meth:`DecodeError`) .
        """
        return _phreeqcrm.PhreeqcRM_GetNthSelectedOutputUserNumber(self, n)

    def GetPartitionUZSolids(self):
        r"""
        Returns the setting for partitioning solids between the
        saturated and unsaturated parts of a partially saturated
        cell.

        The option is intended to be used by saturated-only flow
        codes that allow a variable water table.The value has
        meaning only when saturations less than 1.0 are
        encountered.The partially saturated cells may have a small
        water-to-rock ratio that causes reactions to proceed
        slowly relative to fully saturated cells. By setting
        :meth:`SetPartitionUZSolids` to true, the amounts of solids
        and gases are partioned according to the saturation. If a
        cell has a saturation of 0.5, then the water interacts with
        only half of the solids and gases; the other half is
        unreactive until the water table rises. As the saturation
        in a cell varies, solids and gases are transferred between
        the saturated and unsaturated (unreactive) reservoirs of
        the cell. Unsaturated-zone flow and transport codes will
        probably use the default (false), which assumes all gases
        and solids are reactive regardless of saturation.

        Returns:
        	Boolean: True, the fraction of solids and gases available
        		for reaction is equal to the saturation; False(default),
        		all solids and gases are reactive regardless of
        		saturation.
        """
        return _phreeqcrm.PhreeqcRM_GetPartitionUZSolids(self)

    def GetPorositySWIG(self):
        r"""
        Returns the porosity for each cell. 

        By default, the porosity array is initialized with 0.1,
        unitless.PhreeqcRM does not change the porosity, so the
        values that are retrieved are either the default, or the
        values set by the last call to :meth:`SetPorosity`.

        Returns: 
        	numpy.ndarray (float): The porosities in each cell,
        		unitless. Size of the array is nxyz, the number of grid
        		cells in the user model (:meth:`GetGridCellCount`).
        """
        return _phreeqcrm.PhreeqcRM_GetPorositySWIG(self)

    def GetPressureSWIG(self):
        r"""
        Returns the pressure for each cell. 

        By default, the pressure array is initialized with 1 atm;
        if :meth:`SetPressure` has not been called, worker
        solutions will have pressures as defined the SOLUTION
        definitions at initialization; if :meth:`SetPressure` has
        been called, worker solutions will have the pressures as
        defined by :meth:`SetPressure`. Pressure effects are
        considered by three PHREEQC databases: phreeqc.dat,
        Amm.dat, and pitzer.dat.

        Returns:
        	numpy.ndarray (float): Size of the array is nxyz, the
        		number of grid cells in the user model
        		(:meth:`GetGridCellCount`).
        """
        return _phreeqcrm.PhreeqcRM_GetPressureSWIG(self)

    def GetPrintChemistryMaskSWIG(self):
        r"""
        Return an array of print flags that enable or disable
        detailed output for each cell.

        Printing for a cell will occur only when the printing is
        enabled with :meth:`SetPrintChemistryOn`, and the value in
        the array for the cell is 1 as set by
        :meth:`SetPrintChemistryMask`.

        Returns:
        	numpy.ndarray (int): Size of array is nxyz, where nxyz is
        		the number of grid cells in the user model
        		(:meth:`GetGridCellCount`). A value of 0 for a cell
        		indicates printing is disabled; a value of 1 for a cell
        		indicates printing is enabled.
        """
        return _phreeqcrm.PhreeqcRM_GetPrintChemistryMaskSWIG(self)

    def GetPrintChemistryOn_bool_vector(self):
        r"""
        Returns an array of the current print flags for detailed
        output for the three sets of IPhreeqc instances: the
        workers, the InitialPhreeqc instance, and the Utility
        instance.

        Dimension of the array is 3. Printing of
        detailed output from reaction calculations to the output
        file is enabled when the array value is true, disabled
        when false. The detailed output prints all of the output
        typical of a PHREEQC reaction calculation, which includes
        solution descriptions and the compositions of all other
        reactants. The output can be several hundred lines per
        cell, which can lead to a very large output file
        (prefix.chem.txt, :meth:`OpenFiles`). For the worker
        instances, the output can be limited to a set of cells
        (:meth:`SetPrintChemistryMask`) and, in general, the amount
        of information printed can be limited by use of options in
        the PRINT data block of PHREEQC (applied by using
        :meth:`RunFile` or :meth:`RunString`). Printing the
        detailed output for the workers is generally used only for
        debugging, and PhreeqcRM will run faster when printing
        detailed output for the workers is disabled
        (:meth:`SetPrintChemistryOn`).

        Returns:
        	numpy.ndarray (Boolean): Print flag for the workers, 
        		InitialPhreeqc, and Utility IPhreeqc 
        		instances, respectively.
        """
        return _phreeqcrm.PhreeqcRM_GetPrintChemistryOn_bool_vector(self)

    def GetRebalanceByCell(self):
        r"""
        Returns the load-rebalancing method used for parallel
        processing. 

        PhreeqcRM attempts to rebalance the load of each thread or
        process such that each thread or process takes the same
        amount of time to run its part of a :meth:`RunCells`
        calculation. Two algorithms are available: one accounts for
        cells that were not run because saturation was zero (true),
        and the other uses the average time to run all of the cells
        assigned to a process or thread (false), . The methods are
        similar, but preliminary results indicate the default is
        better in most cases.

        Returns:
        	Boolean: True indicates individual cell run times are used
        		in rebalancing (default); False, indicates average run
        		times are used in rebalancing.
        """
        return _phreeqcrm.PhreeqcRM_GetRebalanceByCell(self)

    def GetRebalanceFraction(self):
        r"""
        Get the fraction used to determine the number of cells to
        transfer among threads or processes.

        PhreeqcRM attempts to rebalance the load of each thread or
        process such that each thread or process takes the same
        amount of time to run its part of a :meth:`RunCells`
        calculation.The rebalancing transfers cell calculations
        among threads or processes to try to achieve an optimum
        balance. :meth:`SetRebalanceFraction` adjusts the
        calculated optimum number of cell transfers by a fraction
        from 0 to 1.0 to determine the number of cell transfers
        that actually are made.A value of zero eliminates load
        rebalancing. A value less than 1.0 is suggested to avoid
        possible oscillations, where too many cells are transferred
        at one iteration, requiring reverse transfers at the next
        iteration.Default is 0.5.

        Returns: 
        	float : Fraction used in rebalance,	0.0 to 1.0. 
        """
        return _phreeqcrm.PhreeqcRM_GetRebalanceFraction(self)

    def GetSaturationCalculatedSWIG(self):
        r"""
        Returns an array of saturations as calculated by the reaction 
        module.

        This method always returns solution_volume / (rv * porosity); 
        the method :meth:`SetSaturationUser` has no effect on the
        values returned. Reactions will change the volume of
        solution in a cell. The transport code must decide whether
        to ignore or account for this change in solution volume due
        to reactions. Following reactions, the cell saturation is
        calculated as solution volume (:meth:`GetSolutionVolume`)
        divided by the product of representative volume
        (:meth:`SetRepresentativeVolume`) and the porosity
        (:meth:`SetPorosity`). The cell saturation returned by
        GetSaturationCalculated may be less than or greater than
        the saturation set by the transport code
        (:meth:`SetSaturationUser`), and may be greater than or less
        than 1.0, even in fully saturated simulations. Only the
        following databases distributed with PhreeqcRM have molar
        volume information needed to accurately calculate solution
        volume and saturation: phreeqc.dat, Amm.dat, and
        pitzer.dat.

        Returns:
        	numpy.ndarray (float): Dimension of the array is set to
        		nxyz, where nxyz is the number of user grid cells
        		(:meth:`GetGridCellCount`). Values for inactive cells are
        		set to 1e30.
        """
        return _phreeqcrm.PhreeqcRM_GetSaturationCalculatedSWIG(self)

    def GetSaturation(self):
        return _phreeqcrm.PhreeqcRM_GetSaturation(self)

    def GetSelectedOutputSWIG(self):
        r"""
        Returns the array of selected-output values for the current 
        selected-output definition. 

        :meth:`SetCurrentSelectedOutputUserNumber` or
        :meth:`SetNthSelectedOutput` specifies which of the
        selected-output definitions is returned.

        Returns:
        	numpy.ndarray (float): Size of the array is col times nxyz,
        		where col is the number of columns in the selected-output
        		definition (:meth:`GetSelectedOutputColumnCount`), and nxyz
        		is the number of grid cells in the user model
        		(:meth:`GetGridCellCount`).
        """
        return _phreeqcrm.PhreeqcRM_GetSelectedOutputSWIG(self)

    def GetSelectedOutputColumnCount(self):
        r"""
        Returns the number of columns in the current
        selected-output definition.

        :meth:`SetCurrentSelectedOutputUserNumber` or
        :meth:`SetNthSelectedOutput`specifies which of the
        selected-output definitions is used.

        Returns:
        	int: Number of columns in the current selected-output definition,
        		negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_GetSelectedOutputColumnCount(self)

    def GetSelectedOutputCount(self):
        r"""
        Returns the number of selected-output definitions. 

        :meth:`SetCurrentSelectedOutputUserNumber` or
        :meth:`SetNthSelectedOutput` specifies which of the
        selected-output definitions is used.

        Returns:
        	int: Number of selected-output definitions, negative is
        		failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_GetSelectedOutputCount(self)

    def GetSelectedOutputHeadingsSWIG(self):
        r"""
        Returns a list of the current selected-output headings. 

        The number of headings is determined by
        :meth:`GetSelectedOutputColumnCount`.
        :meth:`SetCurrentSelectedOutputUserNumber` or
        :meth:`SetNthSelectedOutput` are used to
        specify which of the selected-output definitions is used.

        Returns:
        	numpy.ndarray (str): Array of the headings for the 
        		current selected output.
        """
        return _phreeqcrm.PhreeqcRM_GetSelectedOutputHeadingsSWIG(self)

    def GetSelectedOutputOn(self):
        r"""
        Returns the current value of the selected-output-on property. 

        A value of true for this property indicates that selected
        output data is requested this time step. A value of
        false indicates that selected output will not be retrieved
        for this time step; processing the selected output is
        avoided with some time savings.

        Returns: 
        	Boolean: True, selected output will be requested; false,
        		selected output will not be retrieved.
        """
        return _phreeqcrm.PhreeqcRM_GetSelectedOutputOn(self)

    def GetSelectedOutputRowCount(self):
        r"""
        Returns the number of rows in the current selected-output
        definition. 

        The method is included only for convenience; the number of
        rows is always equal to the number of grid cells in the
        user model (:meth:`GetGridCellCount`).

        Returns:
        	int: Number of rows in the current selected-output
        		definition, negative is failure.
        """
        return _phreeqcrm.PhreeqcRM_GetSelectedOutputRowCount(self)

    def GetSICount(self):
        r"""
        Returns the number of phases found by the method
        :meth:`FindComponents` for which saturation indices 
        could be calculated.

        :meth:`FindComponents` must be called before
        :meth:`GetSICount`. This method may be useful when
        generating selected output definitions related to
        saturation indices.

        Returns:
        	int: The number of phases in for which 
        		saturation indices could be calculated.
        """
        return _phreeqcrm.PhreeqcRM_GetSICount(self)

    def GetSINames(self):
        r"""
        Returns a tuple of the names of all
        phases for which saturation indices (SIs) could be
        calculated.

        The list includes all phases that contain only elements
        found by the method :meth:`FindComponents`. The list
        assumes that all components are present to be able to
        calculate the entire list of SIs; it may be that one or
        more components are missing in any specific cell.
        :meth:`FindComponents` must be called before
        :meth:`GetSINames`.This method may be useful when
        generating selected output definitions related to
        saturation indices.

        Returns: 
        	tuple (str): Each string is a unique phase name.
        """
        return _phreeqcrm.PhreeqcRM_GetSINames(self)

    def GetSolidSolutionComponents(self):
        r"""
        Returns a tuple of the names of solid solution components.

        The list of solid solution components includes all
        components in any SOLID_SOLUTION definitions found by the
        method :meth:`FindComponents`. :meth:`FindComponents` must
        be called before :meth:`GetSolidSolutionComponents`. This
        method may be useful when generating selected output
        definitions related to solid solutions.

        Returns:
        	tuple (str): Each string is a unique solid solution
        		component.
        """
        return _phreeqcrm.PhreeqcRM_GetSolidSolutionComponents(self)

    def GetSolidSolutionComponentsCount(self):
        r"""
        Returns the number of solid solution components found by
        the method :meth:`FindComponents`.

        :meth:`FindComponents` must be called before
        :meth:`GetSolidSolutionComponentsCount`. This method may be
        useful when generating selected output definitions related
        to solid solutions.

        Returns: 
        	int: The number of solid solution components in the
        		initial - phreeqc module.
        """
        return _phreeqcrm.PhreeqcRM_GetSolidSolutionComponentsCount(self)

    def GetSolidSolutionNames(self):
        r"""
        Returns a tuple of solid solution names that correspond
        with the solid solution components.

        :meth:`FindComponents` must be called before
        :meth:`GetSolidSolutionNames`.The solid solution names
        tuple is the same length as the solid solution components
        tuple and provides the corresponding name of the solid
        solution containing the component. This method may be
        useful when generating selected output definitions related
        to solid solutions.

        Returns: 
        	tuple (str): Each string is a solid solution name
        		corresponding to the solid solution components tuple; a
        		solid solution name may occur multiple times.
        """
        return _phreeqcrm.PhreeqcRM_GetSolidSolutionNames(self)

    def GetSolutionVolumeSWIG(self):
        r"""
        Return an array of the current solution volumes as
        calculated by the reaction module.

        Dimension of the array will be nxyz, where nxyz is the
        number of user grid cells. Values for inactive cells are
        set to 1e30. Only the following databases distributed with
        PhreeqcRM have molar volume information needed to
        accurately calculate solution volume: phreeqc.dat, Amm.dat,
        and pitzer.dat.

        Returns:
        	numpy.ndarray (float): Current solution volumes.
        """
        return _phreeqcrm.PhreeqcRM_GetSolutionVolumeSWIG(self)

    def GetSpeciesConcentrationsSWIG(self):
        r"""
        Returns an array of aqueous species concentrations.

        This method is intended for use with
        multicomponent-diffusion transport calculations, and
        :meth:`SetSpeciesSaveOn` must be set to true. The list of
        aqueous species is determined by :meth:`FindComponents` and
        includes all aqueous species that can be made from the set
        of components. Solution volumes used to calculate mol/L are
        calculated by the reaction module. Only the following
        databases distributed with PhreeqcRM have molar volume
        information needed to accurately calculate solution volume:
        phreeqc.dat, Amm.dat, and pitzer.dat.

        Returns:
        	numpy.ndarray (float): Dimension of the array is nspecies
        		times nxyz, where nspecies is the number of aqueous species
        		(:meth:`GetSpeciesCount`), and nxyz is the number of grid
        		cells (:meth:`GetGridCellCount`). Concentrations are moles
        		per liter. Values for inactive cells are set to 1e30.
        """
        return _phreeqcrm.PhreeqcRM_GetSpeciesConcentrationsSWIG(self)

    def GetSpeciesCount(self):
        r"""
        Returns the number of aqueous species found by the method
        :meth:`FindComponents`.

        This method is intended for use with
        multicomponent-diffusion transport calculations, and
        :meth:`SetSpeciesSaveOn` must be set to true. The method
        :meth:`FindComponents` must be called before
        GetSpeciesCount. 

        Returns:
        	int: The number of aqueous species.
        """
        return _phreeqcrm.PhreeqcRM_GetSpeciesCount(self)

    def GetSpeciesD25SWIG(self):
        r"""
        Returns an array of diffusion coefficients at 25C for the
        set of aqueous species.

        This method is intended for use with
        multicomponent-diffusion transport calculations, and
        :meth:`SetSpeciesSaveOn` must be set to true. Diffusion
        coefficients are defined in SOLUTION_SPECIES data blocks,
        normally in the database file. Databases distributed with
        the reaction module that have diffusion coefficients
        defined are phreeqc.dat, Amm.dat, and pitzer.dat.

        Returns:
        	numpy.ndarray (float): Diffusion coefficients at 25 C,
        		m^2/s. Dimension of the array is nspecies, where nspecies
        		is the number of aqueous species
        		(:meth:`GetSpeciesCount`).
        """
        return _phreeqcrm.PhreeqcRM_GetSpeciesD25SWIG(self)

    def GetSpeciesLog10GammasSWIG(self):
        r"""
        Returns an array of log10 aqueous species activity
        coefficients.

        This method is intended for use with
        multicomponent-diffusion transport calculations, and
        :meth:`SetSpeciesSaveOn` must be set to true. The list of
        aqueous species is determined by :meth:`FindComponents` and
        includes all aqueous species that can be made from the set
        of components.

        Returns:
        	numpy.ndarray (float): Log10 aqueous species activity
        		coefficients. Dimension of the array is nspecies times
        		nxyz, where nspecies is the number of aqueous species
        		(:meth:` GetSpeciesCount`), and nxyz is the number of grid
        		cells (:meth:` GetGridCellCount`). Values for inactive
        		cells are set to 1e30.
        """
        return _phreeqcrm.PhreeqcRM_GetSpeciesLog10GammasSWIG(self)

    def GetSpeciesLog10MolalitiesSWIG(self):
        r"""
        Returns an array of log10 aqueous species molalities.

        To use this method :meth:`SetSpeciesSaveOn` must be set to
        true. The list of aqueous species is determined by
        :meth:`FindComponents` and includes all aqueous species
        that can be made from the set of components.

        Returns:
        	numpy.ndarray (float): Log10 aqueous species molalites.
        		Dimension of the array is nspecies times nxyz, where
        		nspecies is the number of aqueous species
        		(:meth:`GetSpeciesCount`), and nxyz is the number of grid
        		cells (:meth:`GetGridCellCount`). Values for inactive cells
        		are set to 1e30.
        """
        return _phreeqcrm.PhreeqcRM_GetSpeciesLog10MolalitiesSWIG(self)

    def GetSpeciesNames(self):
        r"""
        Returns a tuple of the names of the aqueous species.

        This method is intended for use with
        multicomponent-diffusion transport calculations, and
        :meth:`SetSpeciesSaveOn` must be set to true. The list of
        aqueous species is determined by :meth:`FindComponents` and
        includes all aqueous species that can be made from the set
        of components.

        Returns:
        	tuple (str): The names of the aqueous species. Dimension of
        		the tuple is nspecies, where nspecies is the number of
        		aqueous species (:meth:`GetSpeciesCount`).
        """
        return _phreeqcrm.PhreeqcRM_GetSpeciesNames(self)

    def GetSpeciesSaveOn(self):
        r"""
        Returns the value of the species-save property. 

        By default, concentrations of aqueous species are not
        saved. Setting the species-save property to true allows
        aqueous species concentrations to be retrieved with
        :meth:`GetSpeciesConcentrations`, and solution compositions
        to be set with :meth:`SpeciesConcentrations2Module`.

        Returns:
        	Boolean: True indicates solution species concentrations are
        		saved and can be used for multicomponent-diffusion
        		calculations; False indicates that solution species
        		concentrations are not saved.
        """
        return _phreeqcrm.PhreeqcRM_GetSpeciesSaveOn(self)

    def GetSpeciesStoichiometry(self):
        r"""
        Returns a dictionary with the stoichiometry of each
        aqueous species.

        This method is intended for use with
        multicomponent-diffusion transport calculations, and
        :meth:`SetSpeciesSaveOn` must be set to true. Each species
        name is mapped to a dictionary that maps elements in the
        species to stoichiometry of the element in the species.

        Returns:
        	dict (dict):Component names and associated stoichiometric
        		coefficients for each aqueous species. Dimension of the
        		dict is nspecies, where nspecies is the number of aqueous
        		species (:meth:`GetSpeciesCount`).
        """
        return _phreeqcrm.PhreeqcRM_GetSpeciesStoichiometry(self)

    def GetSpeciesStoichiometrySWIG(self):
        return _phreeqcrm.PhreeqcRM_GetSpeciesStoichiometrySWIG(self)

    def GetSpeciesZSWIG(self):
        r"""
        Returns an array of the charge on each aqueous species.

        This method is intended for use with
        multicomponent-diffusion transport calculations, and
        :meth:`SetSpeciesSaveOn` must be set to true.

        Returns:
        	numpy.ndarray (float): The charge on each aqueous species.
        		Dimension of the array is nspecies, where nspecies is the
        		number of aqueous species (:meth:`GetSpeciesCount`).
        """
        return _phreeqcrm.PhreeqcRM_GetSpeciesZSWIG(self)

    def GetStartCellSWIG(self):
        r"""
        Returns an array of integers that contains the smallest
        reaction-cell number assigned to each worker.

        Each worker is assigned a range of reaction-cell numbers
        that are run during a call to :meth:`RunCells`. The range
        of reaction cell numbers for a worker may vary as load
        rebalancing occurs. At any point in the calculations, the
        first cell and last cell to be run by a worker can be found
        in the arrays returned by GetStartCell and
        :meth:`GetEndCell`. Each method returns an array of
        integers that has size of the number of threads
        (:meth:`GetThreadCount`), if using OPENMP, or the number of
        processes (:meth:`GetMpiTasks`), if using MPI.

        Returns:
        	numpy.ndarray (int): One integer for each worker, that
        		gives the first reaction cell to be run by the worker.
        """
        return _phreeqcrm.PhreeqcRM_GetStartCellSWIG(self)

    def GetSurfaceNames(self):
        r"""
        Returns a tuple of surface names (such as 'Hfo') that
        correspond with the surface species names.

        The tuples referenced by :meth:`GetSurfaceSpecies` and
        :meth:`GetSurfaceNames` are the same length.
        :meth:`FindComponents` must be called before
        :meth:`GetSurfaceNames`. This method may be useful when
        generating selected output definitions related to surfaces.

        Returns:
        	tuple (str)): Each string is a surface name corresponding
        		to the corresponding element of thesurface species tuple; a
        		surface name may occur multiple times.
        """
        return _phreeqcrm.PhreeqcRM_GetSurfaceNames(self)

    def GetSurfaceSpecies(self):
        r"""
        Returns a tuple of surface species names (such as
        'Hfo_wOH').

        The list of surface species is derived from the list of
        components (:meth:`FindComponents`) and the list of all
        surface site types (such as 'Hfo_w') that are found by the
        method :meth:`FindComponents`. :meth:`FindComponents` must
        be called before :meth:`GetSurfaceSpecies`. This method may
        be useful when generating selected output definitions
        related to surfaces.

        Returns:
        	tuple (str): Each string is a unique surface species name.
        """
        return _phreeqcrm.PhreeqcRM_GetSurfaceSpecies(self)

    def GetSurfaceSpeciesCount(self):
        r"""
        Returns the number of surface species (such as 'Hfo_wOH')
        found by the method :meth:`FindComponents`.

        :meth:`FindComponents` must be called before
        :meth:`GetSurfaceSpeciesCount`. This method may be useful
        when generating selected output definitions related to
        surfaces.

        Returns:
        	int: The number of surface species in the initial-phreeqc
        		module.
        """
        return _phreeqcrm.PhreeqcRM_GetSurfaceSpeciesCount(self)

    def GetSurfaceTypes(self):
        r"""
        Returns a tuple of surface site types (such as 'Hfo_w')
        that correspond with the surface species names (such as
        'Hfo_wOH').

        The tuples referenced by :meth:`GetSurfaceSpecies` and
        :meth:`GetSurfaceTypes` are the same length.
        :meth:`FindComponents` must be called before
        :meth:`GetSurfaceTypes`. This method may be useful when
        generating selected output definitions related to surfaces.

        Returns:
        	tuple (str)): Each string is a surface site type for the
        		corresponding species in the surface species tuple; a
        		surface site type may occur multiple times.
        """
        return _phreeqcrm.PhreeqcRM_GetSurfaceTypes(self)

    def GetTemperatureSWIG(self):
        r"""
        Returns an array of the current temperatures of the cells.

        By default, the temperature array is initialized to 25 C;
        if :meth:`SetTemperature` has not been called, worker
        solutions will have temperatures as defined by the SOLUTION
        definitions used to initialize the module; if
        :meth:`SetTemperature` has been called, worker solutions
        will have the temperatures as defined by
        :meth:`SetTemperature`.

        Returns:
        	numpy.ndarray (float): Temperatures, in degrees C. Size of
        		the array is nxyz, where nxyz is the number of grid cells
        		in the user model (:meth:` GetGridCellCount`).
        """
        return _phreeqcrm.PhreeqcRM_GetTemperatureSWIG(self)

    def GetThreadCount(self):
        r"""
        Returns the number of threads, which is equal to the
        number of workers used to run in parallel with OPENMP. 

        For the OPENMP version, the number of threads is set
        implicitly or explicitly with the constructor
        (:meth:`PhreeqcRM`::PhreeqcRM). For the MPI version, the
        number of threads is always one for each process.

        Returns:
        	int: The number of threads used for OPENMP parallel
        		processing.
        """
        return _phreeqcrm.PhreeqcRM_GetThreadCount(self)

    def GetTime(self):
        r"""
        Returns the current simulation time in seconds. 

        Returns:
        	float: The current simulation time, in seconds.
        """
        return _phreeqcrm.PhreeqcRM_GetTime(self)

    def GetTimeConversion(self):
        r"""
        Returns a multiplier to convert time from seconds to
        another unit, as specified by the user. 

        The reaction module uses seconds as the time unit. The user
        can set a conversion factor (:meth:`SetTimeConversion`) and
        retrieve it with GetTimeConversion. The reaction module
        only uses the conversion factor when printing the long
        version of cell chemistry (:meth:`SetPrintChemistryOn`),
        which is rare. Default conversion factor is 1.0.

        Returns:
        	float: Multiplier to convert seconds to another 
        		time unit.
        """
        return _phreeqcrm.PhreeqcRM_GetTimeConversion(self)

    def GetTimeStep(self):
        r"""
        Returns the current simulation time step in seconds. 

        This is the time over which kinetic reactions are
        integrated in a call to :meth:`RunCells`.

        Returns:
        	float: The current simulation time step, in seconds.
        """
        return _phreeqcrm.PhreeqcRM_GetTimeStep(self)

    def GetUnitsExchange(self):
        r"""
        Returns the input units for exchangers. 

        In PHREEQC input, exchangers are defined by moles of
        exchange sites (Mp). :meth:`SetUnitsExchange` specifies how
        the number of moles of exchange sites in a reaction cell
        (Mc) is calculated from the input value (Mp).

        Options are 0, Mp is mol/L of RV (default), Mc = Mp*RV,
        where RV is the representative volume
        (:meth:`SetRepresentativeVolume`); 1, Mp is mol / L of
        water in the RV, Mc = Mp * P * RV, where P is porosity 
        (:meth:`SetPorosity`); or 2, Mp is mol/L of rock in the RV,
        Mc = Mp*(1-P)*RV.

        Returns:
        	int: Input units for exchangers.
        """
        return _phreeqcrm.PhreeqcRM_GetUnitsExchange(self)

    def GetUnitsGasPhase(self):
        r"""
        Returns the input units for gas phases. 

        In PHREEQC input, gas phases are defined by moles of
        component gases (Mp). :meth:`SetUnitsGasPhase` specifies
        how the number of moles of component gases in a reaction
        cell (Mc) is calculated from the input value(Mp).

        Options are 0, Mp is mol / L of RV(default), Mc = Mp * RV,
        where RV is the representative volume
        (:meth:`SetRepresentativeVolume`); 1, Mp is mol / L of
        water in the RV, Mc = Mp * P * RV, where P is porosity
        (:meth:`SetPorosity`); or 2, Mp is mol/L of rock in the RV,
        Mc = Mp*(1-P)*RV.

        Returns:
        	int: Input units for gas phases (0, 1, or 2).
        """
        return _phreeqcrm.PhreeqcRM_GetUnitsGasPhase(self)

    def GetUnitsKinetics(self):
        r"""
        Returns the input units for kinetic reactants. 

        In PHREEQC input, kinetics are defined by moles of kinetic
        reactants (Mp). :meth:`SetUnitsKinetics` specifies how the
        number of moles of kinetic reactants in a reaction cell
        (Mc) is calculated from the input value(Mp).

        Options are 0, Mp is mol / L of RV(default), Mc = Mp * RV,
        where RV is the representative volume
        (:meth:`SetRepresentativeVolume`); 1, Mp is mol / L of
        water in the RV, Mc = Mp * P * RV, where P is porosity
        (:meth:`SetPorosity`); or 2, Mp is mol/L of rock in the RV,
        Mc = Mp*(1-P)*RV.

        Returns:
        	int: Input units for kinetic reactants (0, 1, or 2).
        """
        return _phreeqcrm.PhreeqcRM_GetUnitsKinetics(self)

    def GetUnitsPPassemblage(self):
        r"""
        Returns the input units for pure phase assemblages (equilibrium phases). 

        In PHREEQC input, equilibrium phases are defined by moles
        of each phase (Mp). :meth:`SetUnitsPPassemblage` specifies
        how the number of moles of phases in a reaction cell (Mc)
        is calculated from the input value(Mp).

        Options are 0, Mp is mol / L of RV(default), Mc = Mp * RV,
        where RV is the representative volume
        (:meth:`SetRepresentativeVolume`); 1, Mp is mol / L of
        water in the RV, Mc = Mp * P * RV, where P is porosity
        (:meth:`SetPorosity`); or 2, Mp is mol/L of rock in the RV,
        Mc = Mp*(1-P)*RV.

        Returns:
        	int: Input units for equilibrium phases (0, 1, or 2).
        """
        return _phreeqcrm.PhreeqcRM_GetUnitsPPassemblage(self)

    def GetUnitsSolution(self):
        r"""
        Returns the units of concentration used by the transport
        model. Options are 1, mg/L; 2 mol / L; or 3, mass fraction,
        kg/kgs.

        In PHREEQC, solutions are defined by the number of moles of
        each element in the solution. The units of transport
        concentration are used when transport concentrations are
        converted to solution moles by :meth:`SetConcentrations`
        and :meth:`Concentrations2Utility`. The units of solution
        concentration also are used when solution moles are
        converted to transport concentrations by
        :meth:`GetConcentrations`.

        To convert from mg/L to moles of element in the
        representative volume of a reaction cell, mg/L is converted
        to mol/L and multiplied by the solution volume, which is
        the product of porosity (:meth:`SetPorosity`), saturation
        (:meth:` SetSaturation`), and representative volume
        (:meth:` SetRepresentativeVolume`). To convert from mol/L
        to moles of element in a cell , mol/L is multiplied by the
        solution volume. To convert from mass fraction to moles of
        element in a cell, kg /kgs is converted to mol/kgs,
        multiplied by density (:meth:`SetDensityUser`) and
        multiplied by the solution volume.

        To convert from moles of element in the representative
        volume of a reaction cell to mg/L, the number of moles of
        an element is divided by the solution volume resulting in
        mol/L, and then converted to mg/L. To convert from moles of
        element in the representative volume of a reaction cell to
        mol/L, the number of moles of an element is divided by the
        solution volume resulting in mol/L. To convert from moles
        of element in the representative volume of a reaction cell
        to mass fraction, the number of moles of an element is
        converted to kg and divided by the total mass of the
        solution. Two options are available for the volume and mass
        of solution that are used in converting to transport
        concentrations: (1) the volume and mass of solution are
        calculated by PHREEQC, or (2) the volume of solution is the
        product of porosity, saturation, and representative volume,
        and the mass of solution is volume times density as defined
        by :meth:`SetDensityUser`. Which option is used is
        determined by :meth:`UseSolutionDensityVolume`.

        Returns:
        	int: Units for solute concentrations in transport model.
        """
        return _phreeqcrm.PhreeqcRM_GetUnitsSolution(self)

    def GetUnitsSSassemblage(self):
        r"""
        Returns the input units for solid-solution assemblages. 

        In PHREEQC input, solid solutions are defined by moles of
        each component (Mp). :meth:`SetUnitsSSassemblage` specifies
        how the number of moles in a reaction cell (Mc) is
        calculated from the input value(Mp).

        Options are 0, Mp is mol / L of RV(default), Mc = Mp * RV,
        where RV is the representative volume
        (:meth:`SetRepresentativeVolume`); 1, Mp is mol / L of
        water in the RV, Mc = Mp * P * RV, where P is porosity
        (:meth:`SetPorosity`); or 2, Mp is mol/L of rock in the RV,
        Mc = Mp*(1-P)*RV.

        Returns:
        	int: Input units for solid solutions (0, 1, or 2).
        """
        return _phreeqcrm.PhreeqcRM_GetUnitsSSassemblage(self)

    def GetUnitsSurface(self):
        r"""
        Returns the input units for surfaces. 

        In PHREEQC input, surfaces are defined by moles of surface
        sites (Mp). :meth:`SetUnitsSurface` specifies how the
        number of moles of surface sites in a reaction cell (Mc) is
        calculated from the input value(Mp) .

        Options are 0, Mp is mol / L of RV(default), Mc = Mp * RV,
        where RV is the representative volume
        (:meth:`SetRepresentativeVolume`); 1, Mp is mol / L of
        water in the RV, Mc = Mp * P * RV, where P is porosity
        (:meth:`SetPorosity`); or 2, Mp is mol/L of rock in the RV,
        Mc = Mp*(1-P)*RV.

        Returns:
        	int: Input units for surfaces (0, 1, or 2).
        """
        return _phreeqcrm.PhreeqcRM_GetUnitsSurface(self)

    def GetViscositySWIG(self):
        return _phreeqcrm.PhreeqcRM_GetViscositySWIG(self)

    def InitializeYAML(self, yamlfile):
        r"""
        A YAML file can be used to initialize an instance of PhreeqcRM. 

        Args:
        	YAML_file: String containing the YAML file name.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See
        		:meth:`DecodeError`).

        The file contains a YAML sequence of PhreeqcRM methods
        and the arguments corresponding to the methods. 

        For example,

        - key: LoadDatabase
          database: phreeqc.dat
        - key: RunFile
          workers: true
          initial_phreeqc: true
          utility: true
          chemistry_name: advect.pqi

        :meth:`InitializeYAML` will read the YAML file and execute
        the specified methods with the specified arguments. Using
        YAML terminology, the argument(s) for a method may be a
        scalar, a sequence, or a map, depending if the argument is
        a single item, a single array, or there are multiple
        arguments. In the case of a map, the names associated with
        each argument (for example 'chemistry_name' above) is
        arbitrary. The names of the map keys for map arguments are
        not used in parsing the YAML file; only the order of the
        arguments is important.

        The class YAMLPhreeqcRM can be used to write a YAML file.
        The methods defined in the YAMLPhreeqcRM class include the
        following list; all but SetGridCellCount and ThreadCount
        correspond to PhreeqcRM methods.

        CloseFiles(void);
        CreateMapping(float list, numpy.ndarray, or tuple: grid2chem);
        DumpModule();
        FindComponents();
        InitialEquilibriumPhases2Module(int list, numpy.ndarray, or tuple: ic);
        InitialExchanges2Module(int list, numpy.ndarray, or tuple: ic);
        InitialGasPhases2Module(int list, numpy.ndarray, or tuple: ic);
        InitialKinetics2Module(int list, numpy.ndarray, or tuple: ic);
        InitialPhreeqc2Module(int list, numpy.ndarray, or tuple: initial_conditions1);
        InitialPhreeqc2Module_mix(int list, numpy.ndarray, or tuple: initial_conditions1,
        	int list, numpy.ndarray, or tuple: initial_conditions2,
        	float list, numpy.ndarray, or tuple: fraction1);
        InitialPhreeqcCell2Module(int n, 
        	int list, numpy.ndarray, or tuple: cell_numbers);
        InitialSolidSolutions2Module(int list, numpy.ndarray, or tuple: ic);
        InitialSolutions2Module(int list, numpy.ndarray, or tuple: ic);
        InitialSurfaces2Module(int list, numpy.ndarray, or tuple: ic);
        LoadDatabase(string database);
        OpenFiles(void);
        OutputMessage(string str);
        RunCells(void);
        RunFile(Boolean workers, 
        	Boolean initial_phreeqc, 
        	Boolean utility, 
        	string chemistry_name);
        RunString(Boolean workers, 
        	Boolean initial_phreeqc, 
        	Boolean utility, 
        	string input_string);
        ScreenMessage(string str);
        SetComponentH2O(Boolean tf);
        SetConcentrations(float list, numpy.ndarray, or tuple: c);
        SetCurrentSelectedOutputUserNumber(int n_user);
        SetDensityUser(float list, numpy.ndarray, or tuple: density);
        SetDumpFileName(string dump_name);
        SetErrorHandlerMode(int mode);
        SetErrorOn(Boolean tf);
        SetFilePrefix(string prefix);
        SetGasCompMoles(float list, numpy.ndarray, or tuple: gas_moles);
        SetGasPhaseVolume(float list, numpy.ndarray, or tuple: gas_volume);
        SetGridCellCount(int nxyz);
        SetPartitionUZSolids(Boolean tf);
        SetPorosity(float list, numpy.ndarray, or tuple: por);
        SetPressure(float list, numpy.ndarray, or tuple: p);
        SetPrintChemistryMask(int list, numpy.ndarray, or tuple: cell_mask);
        SetPrintChemistryOn(Boolean workers, 
        	Boolean initial_phreeqc, 
        	Boolean utility);
        SetRebalanceByCell(Boolean tf);
        SetRebalanceFraction(float f);
        SetRepresentativeVolume(float list, numpy.ndarray, or tuple: rv);
        SetSaturationUser(float list, numpy.ndarray, or tuple: sat);
        SetScreenOn(Boolean tf);
        SetSelectedOutputOn(Boolean tf);
        SetSpeciesSaveOn(Boolean save_on);
        SetTemperature(float list, numpy.ndarray, or tuple: t);
        SetTime(float time);
        SetTimeConversion(float conv_factor);
        SetTimeStep(float time_step);
        SetUnitsExchange(int option);
        SetUnitsGasPhase(int option);
        SetUnitsKinetics(int option);
        SetUnitsPPassemblage(int option);
        SetUnitsSolution(int option);
        SetUnitsSSassemblage(int option);
        SetUnitsSurface(int option);
        SpeciesConcentrations2Module(float list, numpy.ndarray, or tuple: species_conc);
        StateSave(int istate);
        StateApply(int istate);
        StateDelete(int istate);
        UseSolutionDensityVolume(Boolean tf);
        WarningMessage(string warnstr);

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_InitializeYAML(self, yamlfile)

    def InitialPhreeqc2ConcentrationsSWIG(self, boundary_solution1):
        r"""
        Returns an array of component concentrations from
        solutions in the InitialPhreeqc instance. 

        The method is used to obtain concentrations for boundary
        conditions. If a negative value is used for a cell in
        boundary_solution1, then the highest numbered solution in
        the InitialPhreeqc instance will be used for that cell.

        Args:
        	boundary_solution1(float list, numpy.ndarray, or tuple):
        		Array of solution index numbers that refer to solutions in
        		the InitialPhreeqc instance. Size is n_boundary.

        Returns:
        	numpy.ndarray (float): The dimension of the array is
        		ncomps times n_boundary, where ncomps is the number
        		of components returned from :meth:`FindComponents` or
        		:meth:`GetComponentCount`, and n_boundary is the dimension
        		of the argument boundary_solution1.
        """
        return _phreeqcrm.PhreeqcRM_InitialPhreeqc2ConcentrationsSWIG(self, boundary_solution1)

    def InitialPhreeqc2ConcentrationsSWIG_mix(self, boundary_solution1, boundary_solution2, fraction1):
        r"""
        Returns an array of component concentrations from
        solutions in the InitialPhreeqc instance. 

        The method is used to obtain concentrations for boundary
        conditions. If a negative value is used for a cell in
        boundary_solution1, then the highest numbered solution in
        the InitialPhreeqc instance will be used for that cell.

        Args:
        	boundary_solution1(float list, numpy.ndarray, or tuple):
        		Array of solution index numbers that refer to solutions in
        		the InitialPhreeqc instance. Size is n_boundary.

        Returns:
        	numpy.ndarray (float): The dimension of the array is
        		ncomps times n_boundary, where ncomps is the number
        		of components returned from :meth:`FindComponents` or
        		:meth:`GetComponentCount`, and n_boundary is the dimension
        		of the argument boundary_solution1.
        """
        return _phreeqcrm.PhreeqcRM_InitialPhreeqc2ConcentrationsSWIG_mix(self, boundary_solution1, boundary_solution2, fraction1)

    def InitialEquilibriumPhases2ModuleSWIG(self, equilibrium_phases):
        r"""
        Transfer equilibrium phases definitions from the
        InitialPhreeqc instance to the reaction-module workers.

        Initial_conditions1 is used to select equilibrium phases
        for each cell of the model. Initial_conditions1 is
        dimensioned nxyz, where nxyz is the number of grid cells in
        the user model (:meth:`GetGridCellCount`).

        Args:
        	initial_conditions1 (int list, numpy.ndarray, or tuple):
        		Array of EQUILIBRIUM_PHASES index numbers that refer to
        		definitions in the InitialPhreeqc instance. Size is nxyz.
        		Negative values are ignored, resulting in no transfer of
        		equilibrium phases for that cell.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See
        		:meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_InitialEquilibriumPhases2ModuleSWIG(self, equilibrium_phases)

    def InitialExchanges2ModuleSWIG(self, exchanges):
        r"""
        Transfer exchange definitions from the InitialPhreeqc
        instance to the reaction-module workers.

        Initial_conditions1 is used to select exchange definitions
        for each cell of the model. Initial_conditions1 is
        dimensioned nxyz, where nxyz is the number of grid cells in
        the user model (:meth:`GetGridCellCount`).

        Args:
        	initial_conditions1 (int list, numpy.ndarray, or tuple):
        		Array of EXCHANGE index numbers that refer to
        		definitions in the InitialPhreeqc instance. Size is nxyz.
        		Negative values are ignored, resulting in no transfer of
        		an exchange definition for that cell.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See
        		:meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_InitialExchanges2ModuleSWIG(self, exchanges)

    def InitialGasPhases2ModuleSWIG(self, gas_phases):
        r"""
        Transfer gas phase definitions from the InitialPhreeqc
        instance to the reaction-module workers.

        Initial_conditions1 is used to select gas phase definitions
        for each cell of the model. Initial_conditions1 is
        dimensioned nxyz, where nxyz is the number of grid cells in
        the user model (:meth:`GetGridCellCount`).

        Args:
        	initial_conditions1 (int list, numpy.ndarray, or tuple):
        		Array of GAS_PHASE index numbers that refer to
        		definitions in the InitialPhreeqc instance. Size is nxyz.
        		Negative values are ignored, resulting in no transfer of
        		a gas phase definition for that cell.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See
        		:meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_InitialGasPhases2ModuleSWIG(self, gas_phases)

    def InitialKinetics2ModuleSWIG(self, kinetics):
        r"""
        Transfer kinetics definitions from the InitialPhreeqc
        instance to the reaction-module workers.

        Initial_conditions1 is used to select kinetics definitions
        for each cell of the model. Initial_conditions1 is
        dimensioned nxyz, where nxyz is the number of grid cells in
        the user model (:meth:`GetGridCellCount`).

        Args:
        	initial_conditions1 (int list, numpy.ndarray, or tuple):
        		Array of KINETICS index numbers that refer to
        		definitions in the InitialPhreeqc instance. Size is nxyz.
        		Negative values are ignored, resulting in no transfer of
        		a kinetics definition for that cell.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See
        		:meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_InitialKinetics2ModuleSWIG(self, kinetics)

    def InitialPhreeqc2ModuleSWIG(self, initial_conditions1):
        r"""
        Transfer solutions and reactants from the InitialPhreeqc
        instance to the reaction-module workers.

        Initial_conditions1 is used to select initial conditions,
        including solutions and reactants, for each cell of the
        model, without mixing. Initial_conditions1 is dimensioned 7
        times nxyz, where nxyz is the number of grid cells in the
        user model (:meth:`GetGridCellCount`). The dimension of 7
        refers to solutions and reactants in the following order:
        (0) SOLUTIONS, (1) EQUILIBRIUM_PHASES, (2) EXCHANGE, (3)
        SURFACE, (4) GAS_PHASE, (5) SOLID_SOLUTIONS, and (6)
        KINETICS. The definition initial_solution1[3*nxyz + 99] =
        2, indicates that cell 99 (0 based) contains the SURFACE
        definition (index 3) defined by SURFACE 2 in the
        InitialPhreeqc instance (created in the InitialPhreeqc
        instance either by :meth:`RunFile` or :meth:`RunString`).

        Args:
        	initial_conditions1 (int list, numpy.ndarray, or tuple):
        		Array of solution and reactant index numbers that refer to
        		definitions in the InitialPhreeqc instance. Size is 7 times
        		nxyz. The order of definitions is given above. Negative
        		values are ignored, resulting in no definition of that
        		entity for that cell.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See
        		:meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_InitialPhreeqc2ModuleSWIG(self, initial_conditions1)

    def InitialPhreeqc2ModuleSWIG_mix(self, initial_conditions1, initial_conditions2, fraction1):
        r"""
        Transfer solutions and reactants from the InitialPhreeqc
        instance to the reaction-module workers.

        Initial_conditions1 is used to select initial conditions,
        including solutions and reactants, for each cell of the
        model, without mixing. Initial_conditions1 is dimensioned 7
        times nxyz, where nxyz is the number of grid cells in the
        user model (:meth:`GetGridCellCount`). The dimension of 7
        refers to solutions and reactants in the following order:
        (0) SOLUTIONS, (1) EQUILIBRIUM_PHASES, (2) EXCHANGE, (3)
        SURFACE, (4) GAS_PHASE, (5) SOLID_SOLUTIONS, and (6)
        KINETICS. The definition initial_solution1[3*nxyz + 99] =
        2, indicates that cell 99 (0 based) contains the SURFACE
        definition (index 3) defined by SURFACE 2 in the
        InitialPhreeqc instance (created in the InitialPhreeqc
        instance either by :meth:`RunFile` or :meth:`RunString`).

        Args:
        	initial_conditions1 (int list, numpy.ndarray, or tuple):
        		Array of solution and reactant index numbers that refer to
        		definitions in the InitialPhreeqc instance. Size is 7 times
        		nxyz. The order of definitions is given above. Negative
        		values are ignored, resulting in no definition of that
        		entity for that cell.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See
        		:meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_InitialPhreeqc2ModuleSWIG_mix(self, initial_conditions1, initial_conditions2, fraction1)

    def InitialPhreeqc2SpeciesConcentrationsSWIG(self, boundary_solution1):
        r"""
        Returns an array of aqueous species concentrations from
        solutions in the InitialPhreeqc instance.

        This method is intended for use with
        multicomponent-diffusion transport calculations, and
        :meth:`SetSpeciesSaveOn` must be set to true. The method is
        used to obtain aqueous species concentrations for boundary
        conditions. If a negative value is used for a cell in
        boundary_solution1, then the highest numbered solution in
        the InitialPhreeqc instance will be used for that cell.

        Args:
        	boundary_solution1 (int list, numpy.ndarray, or tuple):
        	Array of solution index numbers that refer to solutions in
        	the InitialPhreeqc instance.

        Returns:
        	numpy.ndarray (float): Array of aqueous concentrations
        		extracted from the InitialPhreeqc instance. The dimension
        		of the array is nspecies times n_boundary, where nspecies
        		is the number of aqueous species returned from
        		:meth:`GetSpeciesCount`, and n_boundary is the dimension of
        		boundary_solution1.
        """
        return _phreeqcrm.PhreeqcRM_InitialPhreeqc2SpeciesConcentrationsSWIG(self, boundary_solution1)

    def InitialPhreeqc2SpeciesConcentrationsSWIG_mix(self, boundary_solution1, boundary_solution2, fraction1):
        r"""
        Returns an array of aqueous species concentrations from
        solutions in the InitialPhreeqc instance.

        This method is intended for use with
        multicomponent-diffusion transport calculations, and
        :meth:`SetSpeciesSaveOn` must be set to true. The method is
        used to obtain aqueous species concentrations for boundary
        conditions. If a negative value is used for a cell in
        boundary_solution1, then the highest numbered solution in
        the InitialPhreeqc instance will be used for that cell.

        Args:
        	boundary_solution1 (int list, numpy.ndarray, or tuple):
        	Array of solution index numbers that refer to solutions in
        	the InitialPhreeqc instance.

        Returns:
        	numpy.ndarray (float): Array of aqueous concentrations
        		extracted from the InitialPhreeqc instance. The dimension
        		of the array is nspecies times n_boundary, where nspecies
        		is the number of aqueous species returned from
        		:meth:`GetSpeciesCount`, and n_boundary is the dimension of
        		boundary_solution1.
        """
        return _phreeqcrm.PhreeqcRM_InitialPhreeqc2SpeciesConcentrationsSWIG_mix(self, boundary_solution1, boundary_solution2, fraction1)

    def InitialPhreeqcCell2ModuleSWIG(self, n, cell_numbers):
        r"""
        A cell numbered n in the InitialPhreeqc instance is
        selected to populate a series of transport cells. 

        All reactants with the number n are transferred along with
        the solution. If MIX n exists, it is used for the
        definition of the solution. If n is negative, n is
        redefined to be the largest solution or MIX number in the
        InitialPhreeqc instance. All reactants for each cell in the
        list cell_numbers are removed before the cell definition is
        copied from the InitialPhreeqc instance to the workers.

        Args:
        	n (int): Number that refers to a solution or MIX and
        		associated reactants in the InitialPhreeqc instance.

        	cell_numbers (numpy.ndarray (int)): An array of grid-cell
        		numbers (user grid-cell numbering system) that will be
        		populated with cell n from the InitialPhreeqc instance.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_InitialPhreeqcCell2ModuleSWIG(self, n, cell_numbers)

    def InitialSolidSolutions2ModuleSWIG(self, solid_solutions):
        r"""
        Transfer solid solution definitions from the InitialPhreeqc
        instance to the reaction-module workers.

        Initial_conditions1 is used to select solid solution
        definitions for each cell of the model. Initial_conditions1
        is dimensioned nxyz, where nxyz is the number of grid cells
        in the user model (:meth:`GetGridCellCount`).

        Args:
        	initial_conditions1 (int list, numpy.ndarray, or tuple):
        		Array of SOLID_SOLUTIONS index numbers that refer to
        		definitions in the InitialPhreeqc instance. Size is nxyz.
        		Negative values are ignored, resulting in no transfer of
        		a kinetics definition for that cell.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See
        		:meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_InitialSolidSolutions2ModuleSWIG(self, solid_solutions)

    def InitialSolutions2ModuleSWIG(self, solutions):
        r"""
        Transfer solution definitions from the InitialPhreeqc
        instance to the reaction-module workers.

        Initial_conditions1 is used to select solution definitions
        for each cell of the model. Initial_conditions1 is
        dimensioned nxyz, where nxyz is the number of grid cells in
        the user model (:meth:`GetGridCellCount`).

        Args:
        	initial_conditions1 (int list, numpy.ndarray, or tuple):
        		Array of SOLUTIONS index numbers that refer to
        		definitions in the InitialPhreeqc instance. Size is nxyz.
        		Negative values are ignored, resulting in no transfer of
        		a solution definition for that cell.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See
        		:meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_InitialSolutions2ModuleSWIG(self, solutions)

    def InitialSurfaces2ModuleSWIG(self, surfaces):
        return _phreeqcrm.PhreeqcRM_InitialSurfaces2ModuleSWIG(self, surfaces)

    def LoadDatabase(self, database):
        r"""
        Load a database for all IPhreeqc instances--workers,
        InitialPhreeqc, and Utility. 

        All definitions of the reaction module are cleared
        (SOLUTION_SPECIES, PHASES, SOLUTIONs, etc.), and the
        database is read.

        Args:
        	database (str): String containing the database name.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_LoadDatabase(self, database)

    def LogMessage(self, str):
        r"""
        Print a message to the log file.

        Args:
        	string (str): String to be printed.
        """
        return _phreeqcrm.PhreeqcRM_LogMessage(self, str)

    def MpiWorker(self):
        r"""
        MPI only. Nonroot processes (processes with
        :meth:`GetMpiMyself` > 0) must call MpiWorker to be able to
        respond to messages from the root.

        Once MpiWorker has been called, the non-root process can
        accept data, perform calculations, and (or) return data
        within the reaction module. MpiWorker contains a loop that
        reads a message from root, performs a task, and waits for
        another message from root. :meth:`SetConcentrations`,
        :meth:`RunCells`, and :meth:`GetConcentrations` are
        examples of methods that send a message from root to get
        the workers to perform a task. The workers will respond to
        all methods that are designated 'workers must be in the
        loop of MpiWorker' in the MPI section of the method
        documentation. The workers will continue to respond to
        messages from root until root calls :meth:`MpiWorkerBreak`.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See
        		:meth:`DecodeError`). MpiWorker returns a value only when
        		:meth:`MpiWorkerBreak` is called by root.
        """
        return _phreeqcrm.PhreeqcRM_MpiWorker(self)

    def MpiWorkerBreak(self):
        r"""
        MPI only. This method is called by root to force nonroot
        processes to return from a call to :meth:`MpiWorker`.

        :meth:`MpiWorker` contains a loop that reads a message from
        root, performs a task, and waits for another message from
        root. The workers respond to all methods that are
        designated 'workers must be in the loop of MpiWorker' in
        the MPI section of the method documentation. The workers
        will continue to respond to messages from root until root
        calls MpiWorkerBreak.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_MpiWorkerBreak(self)

    def OpenFiles(self):
        r"""
        Opens the output and log files. Files are named
        prefix.chem.txt and prefix.log.txt based on the prefix
        defined by :meth:`SetFilePrefix`.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_OpenFiles(self)

    def OutputMessage(self, str):
        r"""
        Print a message to the output file.

        Args:
        	string (str) String to be printed.
        """
        return _phreeqcrm.PhreeqcRM_OutputMessage(self, str)

    def ReturnHandler(self, result, e_string):
        r"""
        Process an IRM_RESULT return code. 

        If the return code is nonnegative, no action is taken. If
        the return code is negative, the return code is decoded and
        printed as an error message along with the second argument
        (std::string). On an error, the method will return the same
        return code, throw an exception, or exit the program
        depending on the setting for :meth:`SetErrorHandlerMode`.

        Args:
        	result (IRM_RESULT): Return code to be processed.
        	e_string (str): Error message to be printed in case of an error.

        Returns:
        	IRM_RESULT : The first argument to the method is returned.
        """
        return _phreeqcrm.PhreeqcRM_ReturnHandler(self, result, e_string)

    def RunCells(self):
        r"""
        Runs a reaction step for all reaction cells in the
        reaction module. 

        Normally, tranport concentrations are transferred to the
        reaction cells (:meth:`SetConcentrations`) before reaction
        calculations are run. The length of time over which kinetic
        reactions are integrated is set by :meth:`SetTimeStep`.
        Other properties that may need to be updated as a result of
        the transport calculations include porosity
        (:meth:`SetPorosity`), saturation
        (:meth:`SetSaturationUser`), temperature
        (:meth:`SetTemperature`), and pressure
        (:meth:`SetPressure`).

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_RunCells(self)

    def RunFile(self, workers, initial_phreeqc, utility, chemistry_name):
        r"""
        Run a PHREEQC input file. 

        The first three arguments determine which IPhreeqc
        instances will run the file-- the workers, the
        InitialPhreeqc instance, and(or) the Utility instance.
        Input files that modify the thermodynamic database should
        be run by all three sets of instances. Files with
        SELECTED_OUTPUT definitions that will be used during the
        time-stepping loop need to be run by the workers. Files
        that contain initial conditions or boundary conditions
        should be run by the InitialPhreeqc instance.

        Args: 
        	workers (Boolean): True, the workers will run the file;
        		False, the workers will not run the file.

        	initial_phreeqc (Boolean): True, the InitialPhreeqc
        		instance will run the file; False, the InitialPhreeqc will
        		not run the file.

        	utility(Boolean): True, the Utility instance will run the file;
        		False, the Utility instance will not run the file.

        	chemistry_name (str): Name of the file to run.

        Returns: 
        	IRM_RESULT : 0 is success, negative is failure(See
        		:meth:`DecodeError`) .
        """
        return _phreeqcrm.PhreeqcRM_RunFile(self, workers, initial_phreeqc, utility, chemistry_name)

    def RunString(self, workers, initial_phreeqc, utility, input_string):
        r"""
        Run a PHREEQC input string. 

        The first three arguments determine which IPhreeqc
        instances will run the string-- the workers, the
        InitialPhreeqc instance, and(or) the Utility instance. Input
        strings that modify the thermodynamic database should be
        run by all three sets of instances. Strings with
        SELECTED_OUTPUT definitions that will be used during the
        time-stepping loop need to be run by the workers.Strings
        that contain initial conditions or boundary conditions
        should be run by the InitialPhreeqc instance.

        Args: 
        	workers(Boolean) : True, the workers will run the string;
        		False, the workers will not run the string.
        	initial_phreeqc(Boolean) : True, the InitialPhreeqc
        		instance will run the string; False, the InitialPhreeqc
        		will not run the string.
        	utility(Boolean) : True, the Utility instance will run the
        		string; False, the Utility instance will not run the
        		string. input_string (str): String containing PHREEQC
        		input.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_RunString(self, workers, initial_phreeqc, utility, input_string)

    def ScreenMessage(self, str):
        r"""
        Print message to the screen.

        Args:
        	string (str): String to be printed.
        """
        return _phreeqcrm.PhreeqcRM_ScreenMessage(self, str)

    def SetComponentH2O(self, tf):
        r"""
        Select whether to include H2O in the component list. 

        The concentrations of H and O must be known accurately (8
        to 10 significant digits) for the numerical method of
        PHREEQC to produce accurate pH and pe values. Because most
        of the H and O are in the water species, it may be more
        robust (require less accuracy in transport) to transport
        the excess H and O (the H and O not in water) and water.
        The default setting (true) is to include water, excess H,
        and excess O as components. A setting of false will include
        total H and total O as components. SetComponentH2O must be
        called before :meth:`FindComponents`.

        Args:
        	tf (Boolean): True (default), excess H, excess O, and water
        		are included in the component list; False, total H and O
        		are included in the component list.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetComponentH2O(self, tf)

    def SetConcentrations(self, c):
        r"""
        Use the array of concentrations (c) to set the moles of
        components in each reaction cell. 

        The volume of water in a cell is the product of porosity
        (:meth:`SetPorosity`), saturation
        (:meth:`SetSaturationUser`), and reference volume
        (:meth:`SetRepresentativeVolume`). The moles of each
        component are determined by the volume of water and per
        liter concentrations. If concentration units
        (:meth:`SetUnitsSolution`) are mass fraction, the density
        (as specified by :meth:`SetDensityUser`) is used to convert
        from mass fraction to per mass per liter.

        Args:
        	c (double list, numpy.ndarray, or tuple): Component
        		concentrations. Size of array is ncomps times nxyz, where
        		ncomps is the number of components as determined by
        		:meth:`FindComponents` or :meth:`GetComponentCount` and
        		nxyz is the number of grid cells in the user model
        		(:meth:`GetGridCellCount`).

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetConcentrations(self, c)

    def SetCurrentSelectedOutputUserNumber(self, n_user):
        r"""
        Select the current selected output by user number. 

        The user may define multiple SELECTED_OUTPUT data blocks
        for the workers. A user number is specified for each data
        block. The value of the argument n_user selects which of
        the SELECTED_OUTPUT definitions will be used for
        selected-output operations.

        Args:
        	n_user (int): User number of the SELECTED_OUTPUT data
        		block that is to be used.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetCurrentSelectedOutputUserNumber(self, n_user)

    def SetDensityUser(self, density):
        r"""
        Set the density for each reaction cell. 

        These density values are used when converting from
        transported mass-fraction concentrations
        (:meth:`SetUnitsSolution`) to produce per liter
        concentrations during a call to :meth:`SetConcentrations`.
        They are also used when converting from reaction-cell
        concentrations to transport concentrations
        (:meth:`GetConcentrations`), if
        :meth:`UseSolutionDensityVolume` is set to false.

        Args:
        	density (float list, numpy.ndarray, or tuple): Densities.
        		Size of array is nxyz, where nxyz is the number of grid
        		cells in the user model (:meth:` GetGridCellCount`).

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetDensityUser(self, density)

    def SetDensity(self, density):
        return _phreeqcrm.PhreeqcRM_SetDensity(self, density)

    def SetDumpFileName(self, dump_name):
        r"""
        Set the name of the dump file. It is the name used by
        :meth:`DumpModule`.

        Args:
        	dump_name (str): Name of dump file.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetDumpFileName(self, dump_name)

    def SetErrorHandlerMode(self, mode):
        r"""
        Set the action to be taken when the reaction module encounters an error. 

        Options are 0, return to calling program with an error
        return code (default); 1, throw an exception, in C++, the
        exception can be caught, for C and Fortran, the program
        will exit; or 2, attempt to exit gracefully.

        Args: 
        	mode (int): Error handling mode : 0, 1, or 2.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure(See
        		:meth:`DecodeError`) .
        """
        return _phreeqcrm.PhreeqcRM_SetErrorHandlerMode(self, mode)

    def SetErrorOn(self, tf):
        r"""
        Set the property that controls whether error messages are
        generated and displayed.

        Messages include PHREEQC 'ERROR' messages, and any messages
        written with :meth:`ErrorMessage`.

        Args: 
        	tf(Boolean) : True, enable error messages; False, disable
        		error messages. Default is true.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetErrorOn(self, tf)

    def SetFilePrefix(self, prefix):
        r"""
        Set the prefix for the output (prefix.chem.txt) and log
        (prefix.log.txt) files. 

        These files are opened by :meth:`OpenFiles`.

        Args:
        	prefix (str): Prefix used when opening the output and log
        		files.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetFilePrefix(self, prefix)

    def SetGasCompMoles(self, gas_moles):
        r"""
        Transfer moles of gas components from the array given in
        the argument list (gas_moles) to each reaction cell.

        Args:
        	gas_moles (float list, numpy.ndarray, or tuple): Moles of
        		gas components. Dimension of the array is set to
        		ngas_comps times nxyz, where, ngas_comps is the result of
        		:meth:`GetGasComponentsCount`, and nxyz is the number of
        		user grid cells (:meth:`GetGridCellCount`). If the number
        		of moles is set to a negative number, the gas component
        		will not be defined for the GAS_PHASE of the reaction cell.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetGasCompMoles(self, gas_moles)

    def SetGasPhaseVolume(self, gas_volume):
        r"""
        Transfer volumes of gas phases from the array given in
        the argument list (gas_volume) to each reaction cell.

        The gas-phase volume affects the gas-component pressures
        calculated for fixed-volume gas phases. If a gas-phase
        volume is defined with this methood for a GAS_PHASE in a
        cell, the gas phase is forced to be a fixed-volume gas
        phase.

        Args:
        	gas_volume (float list, numpy.ndarray, or tuple): Volumes
        		for each gas phase. Dimension of the array is nxyz, where
        		nxyz is the number of user grid cells
        		(:meth:`GetGridCellCount`). If the volume is set to a
        		negative number for a cell, the gas-phase volume for that
        		cell is not changed.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetGasPhaseVolume(self, gas_volume)

    def SetIthConcentrationSWIG(self, i, c):
        return _phreeqcrm.PhreeqcRM_SetIthConcentrationSWIG(self, i, c)

    def SetIthSpeciesConcentrationSWIG(self, i, c):
        return _phreeqcrm.PhreeqcRM_SetIthSpeciesConcentrationSWIG(self, i, c)

    def SetMpiWorkerCallbackFortran(self, fcn):
        return _phreeqcrm.PhreeqcRM_SetMpiWorkerCallbackFortran(self, fcn)

    def SetNthSelectedOutput(self, n):
        r"""
        Specify the current selected output by sequence number. The user may define 
        multiple SELECTED_OUTPUT data blocks for the workers. A user number is 
        specified for each data block, and the blocks are stored in user-number order. 
        The value of the argument n selects the sequence number of the SELECTED_OUTPUT 
        definition that will be used for selected-output operations.

        Args:
        	n (int): Sequence number of the SELECTED_OUTPUT data block that is to be 
        		used.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetNthSelectedOutput(self, n)

    def SetPartitionUZSolids(self, tf):
        r"""
        Sets the property for partitioning solids between the
        saturated and unsaturated parts of a partially saturated
        cell.

        The option is intended to be used by saturated-only flow
        codes that allow a variable water table. The value has
        meaning only when saturations less than 1.0 are
        encountered. The partially saturated cells may have a small
        water-to-rock ratio that causes reactions to proceed
        differently relative to fully saturated cells. By setting
        SetPartitionUZSolids to true, the amounts of solids and
        gases are partioned according to the saturation. If a cell
        has a saturation of 0.5, then the water interacts with only
        half of the solids and gases; the other half is unreactive
        until the water table rises. As the saturation in a cell
        varies, solids and gases are transferred between the
        saturated and unsaturated ( unreactive) reservoirs of the
        cell. Unsaturated-zone flow and transport codes will
        probably use the default (false), which assumes all gases
        and solids are reactive regardless of saturation.

        Args:
        	tf (Boolean): True, the fraction of solids and gases
        		available for reaction is equal to the saturation; False
        		(default), all solids and gases are reactive regardless of
        		saturation.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetPartitionUZSolids(self, tf)

    def SetPorosity(self, por):
        r"""
        Set the porosity for each reaction cell. 

        The volume of water in a reaction cell is the product of
        porosity, saturation (:meth:`SetSaturationUser`), and
        representative volume (:meth:`SetRepresentativeVolume`).

        Args:
        	por (float list, numpy.ndarray, or tuple): Porosities,
        		unitless. Default is 0.1. Size of array is nxyz, where
        		nxyz is the number of grid cells in the user model
        		(:meth:`GetGridCellCount`).

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetPorosity(self, por)

    def SetPressure(self, p):
        r"""
        Set the pressure for each reaction cell. 

        Pressure effects are considered only in three of the
        databases distributed with PhreeqcRM: phreeqc.dat, Amm.dat,
        and pitzer.dat. 

        Args:
        	p (float list, numpy.ndarray, or tuple): Pressures, in atm.
        		Size of array is nxyz, where nxyz is the number of grid
        		cells in the user model (:meth:` GetGridCellCount`).

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetPressure(self, p)

    def SetPrintChemistryMaskSWIG(self, cell_mask):
        r"""
        Enable or disable detailed output for each reaction cell.

        Printing for a reaction cell will occur only when the
        printing is enabled with :meth:`SetPrintChemistryOn` and
        the cell_mask value is 1.

        Args:

        	cell_mask (Intfloat list, numpy.ndarray, or tuple): Array
        		of integers. Size of vector is nxyz, where nxyz is the
        		number of grid cells in the user model
        		(:meth:`GetGridCellCount`). A value of 0 will disable
        		printing detailed output for the cell; a value of 1 will
        		enable printing detailed output for a cell.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetPrintChemistryMaskSWIG(self, cell_mask)

    def SetPrintChemistryOn(self, workers, initial_phreeqc, utility):
        r"""
        Set property that enables or disables printing detailed
        output from reaction calculations to the output file.

        Detailed output will occur for a set of cells defined by
        :meth:`SetPrintChemistryMask`. The detailed output prints
        all of the output typical of a PHREEQC reaction
        calculation, which includes solution descriptions and the
        compositions of all other reactants. The output can be
        several hundred lines per cell, which can lead to a very
        large output file (prefix.chem.txt, :meth:`OpenFiles`). For
        the worker instances, the output can be limited to a set of
        cells (:meth:`SetPrintChemistryMask`) and, in general, the
        amount of information printed can be limited by use of
        options in the PRINT data block of PHREEQC (applied by
        using :meth:`RunFile` or :meth:`RunString`). Printing the
        detailed output for the workers is generally used only for
        debugging, and PhreeqcRM will run significantly faster when
        printing detailed output for the workers is disabled.

        Args:
        	workers (Boolean): True, enable detailed printing in the
        		worker instances; False, disable detailed printing in the
        		worker instances.
        	initial_phreeqc(Boolean) : True, enable detailed printing
        		in the InitialPhreeqc instance; False, disable detailed
        		printing in the InitialPhreeqc instance.
        	utility(Boolean) : True, enable detailed printing in the
        		Utility instance; False, disable detailed printing in the
        		Utility instance.

        Returns: 
        	IRM_RESULT : 0 is success, negative is failure(See
        		:meth:`DecodeError`) .
        """
        return _phreeqcrm.PhreeqcRM_SetPrintChemistryOn(self, workers, initial_phreeqc, utility)

    def SetRebalanceByCell(self, tf):
        r"""
        Set the load-balancing algorithm. 

        PhreeqcRM attempts to rebalance the load of each thread or
        process such that each thread or process takes the same
        amount of time to run its part of a :meth:`RunCells`
        calculation. Two algorithms are available; one uses
        individual times for each cell and accounts for cells that
        were not run because saturation was zero (default), and the
        other assigns an average time to all cells. The methods are
        similar, but limited testing indicates the default method
        performs better.

        Args:
        	tf (Boolean): True, indicates individual cell times are
        		used in rebalancing (default); False, indicates average
        		times are used in rebalancing.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetRebalanceByCell(self, tf)

    def SetRebalanceFraction(self, f):
        r"""
        Sets the fraction of cells that are transferred among
        threads or processes when rebalancing. 

        PhreeqcRM attempts to rebalance the load of each thread or
        process such that each thread or process takes the same
        amount of time to run its part of a :meth:`RunCells`
        calculation. The rebalancing transfers cell calculations
        among threads or processes to try to achieve an optimum
        balance. SetRebalanceFraction adjusts the calculated
        optimum number of cell transfers by a fraction from 0 to
        1.0 to determine the actual number of cell transfers. A
        value of zero eliminates load rebalancing. A value less
        than 1.0 is suggested to slow the approach to the optimum
        cell distribution and avoid possible oscillations when too
        many cells are transferred at one iteration, requiring
        reverse transfers at the next iteration. Default is 0.5.

        Args:
        	f (float): Fraction from 0.0 to 1.0.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetRebalanceFraction(self, f)

    def SetRepresentativeVolume(self, rv):
        r"""
        Set the representative volume of each reaction cell. 

        By default the representative volume of each reaction cell
        is 1 liter. The volume of water in a reaction cell is
        determined by the product of the representative volume, the
        porosity (:meth:`SetPorosity`), and the saturation
        (:meth:`SetSaturationUser`). The numerical method of
        PHREEQC is more robust if the water volume for a reaction
        cell is within a couple orders of magnitude of 1.0. Small
        water volumes caused by small porosities and (or) small
        saturations (and (or) small representative volumes) may
        cause non-convergence of the numerical method. In these
        cases, a larger representative volume may help. Note that
        increasing the representative volume also increases the
        number of moles of the reactants in the reaction cell
        (minerals, surfaces, exchangers, and others).

        Args:
        	rv (float list, numpy.ndarray, or tuple): Representative
        		volumes, in liters. Default is 1.0 liter. Size of array is
        		nxyz, where nxyz is the number of grid cells in the user
        		model (:meth:`GetGridCellCount`).

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetRepresentativeVolume(self, rv)

    def SetSaturationUser(self, sat):
        r"""
        Set the saturation of each reaction cell. 

        Saturation is a fraction ranging from 0 to 1. The volume of
        water in a cell is the product of porosity
        (:meth:`SetPorosity`), saturation (SetSaturationUser), and
        representative volume (:meth:`SetRepresentativeVolume`). As
        a result of a reaction calculation, solution properties
        (density and volume) will change; the databases
        phreeqc.dat, Amm.dat, and pitzer.dat have the molar volume
        data to calculate these changes. The methods
        :meth:`GetDensityCalculated`, :meth:`GetSolutionVolume`,
        and :meth:`GetSaturationCalculated` can be used to account
        for these changes in the succeeding transport calculation.
        SetRepresentativeVolume should be called before initial
        conditions are defined for the reaction cells.

        Args:
        	sat (float list, numpy.ndarray, or tuple): Saturations,
        		unitless. Default 1.0. Size of vector is nxyz, where nxyz
        		is the number of grid cells in the user model
        		(:meth:`GetGridCellCount`).

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetSaturationUser(self, sat)

    def SetSaturation(self, sat):
        return _phreeqcrm.PhreeqcRM_SetSaturation(self, sat)

    def SetScreenOn(self, tf):
        r"""
        Set the property that controls whether messages are
        written to the screen.

        Messages include information about rebalancing during
        :meth:`RunCells`, and any messages written with
        :meth:`ScreenMessage`.

        Args:
        	tf (Boolean): True, enable screen messages; False, disable
        		screen messages.Default is true.

        Returns: 
        	IRM_RESULT : 0 is success, negative is failure(See
        		:meth:`DecodeError`) .
        """
        return _phreeqcrm.PhreeqcRM_SetScreenOn(self, tf)

    def SetSelectedOutputOn(self, tf):
        r"""
        Set the property that controls whether selected-output
        results are available to be retrieved

        If the property is set to True, selected-output results are
        accumulated during :meth:`RunCells` and can be retrieved
        with :meth:`GetSelectedOutput`.

        Args: 
        	tf(Boolean) : True, enable selected output; False, disable
        		selected output.

        Returns: 
        	IRM_RESULT : 0 is success, negative is failure(See
        		:meth:`DecodeError`) .
        """
        return _phreeqcrm.PhreeqcRM_SetSelectedOutputOn(self, tf)

    def SetSpeciesSaveOn(self, save_on):
        r"""
        Sets the value of the species-save property. 

        This method enables or disables saving individual aqueous
        species concentrations. By default, concentrations of
        aqueous species are not saved. Setting the species save
        property to true allows aqueous species concentrations to
        be retrieved with :meth:`GetSpeciesConcentrations`, and
        solution compositions to be set with
        :meth:`SpeciesConcentrations2Module`.SetSpeciesSaveOn must
        be called before calls to :meth:`FindComponents`.
        Individual species concentrations are required for
        multicomponent diffusion calculations.

        Args: 
        	save_on (Boolean): True indicates species concentrations are saved;
        		False indicates species concentrations are not saved.

        Returns: 
        	IRM_RESULT : 0 is success, negative is failure(See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetSpeciesSaveOn(self, save_on)

    def SetTemperature(self, t):
        r"""
        Set the temperature for each reaction cell. 

        If SetTemperature is not called, worker solutions will have
        temperatures as defined by initial conditions(
        :meth:`InitialPhreeqc2Module`,
        :meth:`InitialPhreeqcCell2Module`, or
        :meth:`InitialSoluti
        ons2Module`).

        Args: 
        	t (float list, numpy.ndarray, or tuple): Temperatures, in
        		degrees C. Size of vector is nxyz, where nxyz is the number
        		of grid cells in the user model( :meth:`GetGridCellCount`).

        Returns: 
        	IRM_RESULT : 0 is success, negative is failure(See
        		:meth:`DecodeError`) .
        """
        return _phreeqcrm.PhreeqcRM_SetTemperature(self, t)

    def SetTime(self, time):
        r"""
        Set current simulation time for the reaction module.

        Args: 
        	time(float) : Current simulation time, in seconds.

        Returns: 
        	IRM_RESULT : 0 is success, negative is failure(See
        		:meth:`DecodeError`) .
        """
        return _phreeqcrm.PhreeqcRM_SetTime(self, time)

    def SetTimeConversion(self, conv_factor):
        r"""
        Set a factor to convert from seconds to user time units.
        Factor times seconds produces user time units.

        args: 
        	conv_factor (float): Factor to convert seconds to user time units.

        returns: 
        	IRM_RESULT : 0 is success, negative is failure(See
        		:meth:`DecodeError`) .
        """
        return _phreeqcrm.PhreeqcRM_SetTimeConversion(self, conv_factor)

    def SetTimeStep(self, time_step):
        r"""
        Set current time step for the reaction module. This is the
        length of time over which kinetic reactions are integrated.

        args: 
        	time_step (float): Time step, in seconds.

        returns: 
        	IRM_RESULT : 0 is success, negative is failure(See
        		:meth:`DecodeError`) .
        """
        return _phreeqcrm.PhreeqcRM_SetTimeStep(self, time_step)

    def SetUnitsExchange(self, option):
        r"""
        Sets input units for exchangers. 

        In PHREEQC input, exchangers are defined by moles of
        exchange sites(Mp) .SetUnitsExchange specifies how the
        number of moles of exchange sites in a reaction cell(Mc) is
        calculated from the input value(Mp).

        Options are 0, Mp is mol / L of RV(default), Mc = Mp * RV,
        where RV is the representative volume
        (:meth:`SetRepresentativeVolume`); 1, Mp is mol / L of
        water in the RV, Mc = Mp * P * RV, where P is porosity
        (:meth:`SetPorosity`); or 2, Mp is mol/L of rock in the RV,
        Mc = Mp*(1-P)*RV.

        If a single EXCHANGE definition is used for cells with
        different initial porosity, the three options scale quite
        differently. For option 0, the number of moles of
        exchangers will be the same regardless of porosity. For
        option 1, the number of moles of exchangers will be vary
        directly with porosity and inversely with rock volume. For
        option 2, the number of moles of exchangers will vary
        directly with rock volume and inversely with porosity.

        Args:
        	option (int): Units option for exchangers: 0, 1, or 2.

        Returns:

        	IRM_RESULT: 0 is success, negative is failure (See
        		:meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetUnitsExchange(self, option)

    def SetUnitsGasPhase(self, option):
        r"""
        Set input units for gas phases. 

        In PHREEQC input, gas phases are defined by moles of
        component gases (Mp). SetUnitsGasPhase specifies how the
        number of moles of component gases in a reaction cell (Mc)
        is calculated from the input value(Mp) .

        Options are 0, Mp is mol / L of RV(default), Mc = Mp * RV,
        where RV is the representative volume
        (:meth:`SetRepresentativeVolume`); 1, Mp is mol / L of
        water in the RV, Mc = Mp * P * RV, where P is porosity
        (:meth:`SetPorosity`); or 2, Mp is mol/L of rock in the RV,
        Mc = Mp*(1-P)*RV.

        If a single GAS_PHASE definition is used for cells with
        different initial porosity, the three options scale quite
        differently. For option 0, the number of moles of a gas
        component will be the same regardless of porosity. For
        option 1, the number of moles of a gas component will be
        vary directly with porosity and inversely with rock volume.
        For option 2, the number of moles of a gas component will
        vary directly with rock volume and inversely with porosity.

        Args:
        	option (int): Units option for gas phases: 0, 1, or 2.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetUnitsGasPhase(self, option)

    def SetUnitsKinetics(self, option):
        r"""
        Set input units for kinetic reactants.

        In PHREEQC input, kinetics are defined by moles of kinetic
        reactants (Mp). SetUnitsKinetics specifies how the number
        of moles of kinetic reactants in a reaction cell (Mc) is
        calculated from the input value(Mp).

        Options are 0, Mp is mol / L of RV(default), Mc = Mp * RV,
        where RV is the representative volume
        (:meth:`SetRepresentativeVolume`); 1, Mp is mol / L of
        water in the RV, Mc = Mp * P * RV, where P is porosity
        (:meth:`SetPorosity`); or 2, Mp is mol/L of rock in the RV,
        Mc = Mp*(1-P)*RV.

        If a single KINETICS definition is used for cells with
        different initial porosity, the three options scale quite
        differently. For option 0, the number of moles of kinetic
        reactants will be the same regardless of porosity. For
        option 1, the number of moles of kinetic reactants will be
        vary directly with porosity and inversely with rock volume.
        For option 2, the number of moles of kinetic reactants will
        vary directly with rock volume and inversely with porosity.

        Note that the volume of water in a cell in the reaction
        module is equal to the product of porosity
        (:meth:`SetPorosity`), the saturation
        (:meth:`SetSaturationUser`), and representative volume
        (:meth: `SetRepresentativeVolume`), which is usually less
        than 1 liter. It is important to write the RATES
        definitions for homogeneous (aqueous) kinetic reactions to
        account for the current volume of water, often by
        calculating the rate of reaction per liter of water and
        multiplying by the volume of water (Basic function
        SOLN_VOL).

        Rates that depend on surface area of solids, are not
        dependent on the volume of water. However, it is important
        to get the correct surface area for the kinetic reaction.
        To scale the surface area with the number of moles, the
        specific area (m^2 per mole of reactant) can be defined as
        a parameter (KINETICS; -parm), which is multiplied by the
        number of moles of reactant (Basic function M) in RATES to
        obtain the surface area.

        Args:
        o	ption (int): Units option for kinetic reactants: 0, 1, or 2.

        Returns:
        I	RM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetUnitsKinetics(self, option)

    def SetUnitsPPassemblage(self, option):
        r"""
        Set input units for pure phase assemblages (equilibrium phases). 

        In PHREEQC input, equilibrium phases are defined by moles
        of each phase (Mp). SetUnitsPPassemblage specifies how the
        number of moles of phases in a reaction cell (Mc) is
        calculated from the input value(Mp).

        Options are 0, Mp is mol / L of RV(default), Mc = Mp * RV,
        where RV is the representative volume
        (:meth:`SetRepresentativeVolume`); 1, Mp is mol / L of
        water in the RV, Mc = Mp * P * RV, where P is porosity
        (:meth:`SetPorosity`); or 2, Mp is mol/L of rock in the RV,
        Mc = Mp*(1-P)*RV.

        If a single EQUILIBRIUM_PHASES definition is used for cells
        with different initial porosity, the three options scale
        quite differently. For option 0, the number of moles of a
        mineral will be the same regardless of porosity. For option
        1, the number of moles of a mineral will be vary directly
        with porosity and inversely with rock volume. For option 2,
        the number of moles of a mineral will vary directly with
        rock volume and inversely with porosity.

        Args:
        	option (int): Units option for equilibrium phases: 0, 1, or 2.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetUnitsPPassemblage(self, option)

    def SetUnitsSolution(self, option):
        r"""
        Solution concentration units used by the transport model. 

        Options are 1, mg/L; 2 mol/L; or 3, mass fraction, kg/kgs.
        PHREEQC defines solutions by the number of moles of each
        element in the solution.

        To convert from mg/L to moles of element in the
        representative volume of a reaction cell, mg/L is converted
        to mol/L and multiplied by the solution volume, which is
        the product of porosity (:meth:`SetPorosity`), saturation
        (:meth:` SetSaturationUser`), and representative volume
        (:meth:`SetRepresentativeVolume`). To convert from mol/L to
        moles of element in the representative volume of a reaction
        cell, mol/L is multiplied by the solution volume. To
        convert from mass fraction to moles of element in the
        representative volume of a reaction cell, kg /kgs is
        converted to mol/kgs, multiplied by density
        (:meth:`SetDensityUser`) and multiplied by the solution
        volume.

        To convert from moles of element in the representative
        volume of a reaction cell to mg/L, the number of moles of
        an element is divided by the solution volume resulting in
        mol/L, and then converted to mg/L. To convert from moles of
        element in a cell to mol/L, the number of moles of an
        element is divided by the solution volume resulting in
        mol/L. To convert from moles of element in a cell to mass
        fraction, the number of moles of an element is converted to
        kg and divided by the total mass of the solution. Two
        options are available for the volume and mass of solution
        that are used in converting to transport concentrations:
        (1) the volume and mass of solution are calculated by
        PHREEQC, or (2) the volume of solution is the product of
        porosity (:meth:`SetPorosity`), saturation
        (:meth:`SetSaturationUser`), and representative volume
        (:meth:`SetRepresentativeVolume`), and the mass of solution
        is volume times density as defined by
        :meth:`SetDensityUser`. Which option is used is determined
        by :meth:`UseSolutionDensityVolume`.

        Args:
        	option (int): Units option for solutions: 1, 2, or 3, default is 1, mg/L.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetUnitsSolution(self, option)

    def SetUnitsSSassemblage(self, option):
        r"""
        Set input units for solid-solution assemblages. 

        In PHREEQC, solid solutions are defined by moles of each
        component (Mp). SetUnitsSSassemblage specifies how the
        number of moles of solid-solution components in a reaction
        cell (Mc) is calculated from the input value(Mp).

        Options are 0, Mp is mol / L of RV(default), Mc = Mp * RV,
        where RV is the representative volume
        (:meth:`SetRepresentativeVolume`); 1, Mp is mol / L of
        water in the RV, Mc = Mp * P * RV, where P is porosity
        (:meth:`SetPorosity`); or 2, Mp is mol/L of rock in the RV,
        Mc = Mp*(1-P)*RV.

        If a single SOLID_SOLUTION definition is used for cells
        with different initial porosity, the three options scale
        quite differently. For option 0, the number of moles of a
        solid-solution component will be the same regardless of
        porosity. For option 1, the number of moles of a
        solid-solution component will be vary directly with
        porosity and inversely with rock volume. For option 2, the
        number of moles of a solid-solution component will vary
        directly with rock volume and inversely with porosity.

        Args:
        	option (int): Units option for solid solutions: 0, 1, or 2.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetUnitsSSassemblage(self, option)

    def SetUnitsSurface(self, option):
        r"""
        Set input units for surfaces. 

        In PHREEQC input, surfaces are defined by moles of surface
        sites (Mp). SetUnitsSurface specifies how the number of
        moles of surface sites in a reaction cell (Mc) is
        calculated from the input value(Mp).

        Options are 0, Mp is mol / L of RV(default), Mc = Mp * RV,
        where RV is the representative volume
        (:meth:`SetRepresentativeVolume`); 1, Mp is mol / L of
        water in the RV, Mc = Mp * P * RV, where P is porosity
        (:meth:`SetPorosity`); or 2, Mp is mol/L of rock in the RV,
        Mc = Mp*(1-P)*RV.

        If a single SURFACE definition is used for cells with
        different initial porosity, the three options scale quite
        differently. For option 0, the number of moles of surface
        sites will be the same regardless of porosity. For option
        1, the number of moles of surface sites will be vary
        directly with porosity and inversely with rock volume. For
        option 2, the number of moles of surface sites will vary
        directly with rock volume and inversely with porosity.

        Args:
        	option (int): Units option for surfaces: 0, 1, or 2.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SetUnitsSurface(self, option)

    def SpeciesConcentrations2Module(self, species_conc):
        r"""
        Set solution concentrations in the reaction module based on
        the array of aqueous species concentrations
        (species_conc). 

        This method is intended for use with
        multicomponent-diffusion transport calculations, and
        :meth:`SetSpeciesSaveOn` must be set to true. The list of
        aqueous species is determined by :meth:`FindComponents` and
        includes all aqueous species that can be made from the set
        of components. The method determines the total
        concentration of a component by summing the molarities of
        the individual species times the stoichiometric coefficient
        of the elements in each species. Solution compositions in
        the reaction cells are updated with these component
        concentrations.

        Args:
        	species_conc (float list, numpy.ndarray, or tuple): Aqueous
        		species concentrations. Dimension of the array is nspecies
        		times nxyz, where nspecies is the number of aqueous species
        		(:meth:`GetSpeciesCount`), and nxyz is the number of user
        		grid cells (:meth:`GetGridCellCount`). Concentrations are
        		moles per liter.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_SpeciesConcentrations2Module(self, species_conc)

    def StateSave(self, istate):
        r"""
        Save the state of the chemistry in all model cells,
        including SOLUTIONs, EQUILIBRIUM_PHASES, EXCHANGEs,
        GAS_PHASEs, KINETICS, SOLID_SOLUTIONs, and SURFACEs.


        Although not generally used, MIXes, REACTIONs,
        REACTION_PRESSUREs, and REACTION_TEMPERATUREs will be saved
        for each cell, if they have been defined in the worker
        IPhreeqc instances. The distribution of cells among the
        workers and the chemistry of fully or partially unsaturated
        cells are also saved. The state is saved in memory; use
        :meth:`DumpModule` to save the state to file. PhreeqcRM can
        be reset to this state by using :meth:`StateApply`. A state
        is identified by an integer, and multiple states can be
        saved.

        Args:
        	istate (int): Integer identifying the state that is saved. 

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_StateSave(self, istate)

    def StateApply(self, istate):
        r"""
        Reset the state of the module to a state previously saved
        with :meth:`StateSave`.

        The chemistry of all model cells are reset, including
        SOLUTIONs, EQUILIBRIUM_PHASES, EXCHANGEs, GAS_PHASEs,
        KINETICS, SOLID_SOLUTIONs, and SURFACEs. MIXes, REACTIONs,
        REACTION_PRESSUREs, and REACTION_TEMPERATUREs will be reset
        for each cell, if they were defined in the worker IPhreeqc
        instances at the time the state was saved. The distribution
        of cells among the workers and the chemistry of fully or
        partially unsaturated cells are also reset to the saved
        state. The state to be applied is identified by an integer.

        Args:
        	istate (int): Integer identifying the state that 
        		is to be applied.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure 
        		(See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_StateApply(self, istate)

    def StateDelete(self, istate):
        r"""
        Delete a state previously saved with :meth:`StateSave`.

        Args:
        	istate (int): Integer identifying the state that is to be deleted.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """
        return _phreeqcrm.PhreeqcRM_StateDelete(self, istate)

    def UseSolutionDensityVolume(self, tf):
        r"""
        Determines the volume and density to use when converting
        from the reaction-cell concentrations to transport
        concentrations (:meth:`GetConcentrations`). 

        Two options are available to convert concentration units:
        (1) the density and solution volume calculated by PHREEQC
        are used, or (2) the specified density
        (:meth:`SetDensityUser`) and solution volume are determined
        by the product of saturation (:meth:`SetSaturationUser`),
        porosity (:meth:`SetPorosity`), and representative volume
        (:meth:`SetRepresentativeVolume`). Transport models that
        consider density-dependent flow will probably use the
        PHREEQC-calculated density and solution volume (default),
        whereas transport models that assume constant-density flow
        will probably use specified values of density and solution
        volume. Only the following databases distributed with
        PhreeqcRM have molar-volume information needed to
        accurately calculate density and solution volume:
        phreeqc.dat, Amm.dat, and pitzer.dat. Density is only used
        when converting to or from transport units of mass
        fraction.

        Args:
        	tf (Boolean): True indicates that the solution density and
        		volume as calculated by PHREEQC will be used to calculate
        		concentrations. False indicates that the solution density
        		set by :meth:`SetDensityUser` and the volume determined by
        		the product of :meth:`SetSaturationUser`,
        		:meth:`SetPorosity`, and :meth:`SetRepresentativeVolume`,
        		will be used to calculate concentrations retrieved by
        		:meth:`GetConcentrations`.
        """
        return _phreeqcrm.PhreeqcRM_UseSolutionDensityVolume(self, tf)

    def WarningMessage(self, warnstr):
        r"""
        Print a warning message to the screen and the log file.

        Args:
        	warnstr (str): String to be printed.
        """
        return _phreeqcrm.PhreeqcRM_WarningMessage(self, warnstr)

    @staticmethod
    def Char2TrimString(str, l=0):
        return _phreeqcrm.PhreeqcRM_Char2TrimString(str, l)

    @staticmethod
    def FileExists(name):
        return _phreeqcrm.PhreeqcRM_FileExists(name)

    @staticmethod
    def FileRename(temp_name, name, backup_name):
        return _phreeqcrm.PhreeqcRM_FileRename(temp_name, name, backup_name)

    @staticmethod
    def Int2IrmResult(r, positive_ok):
        return _phreeqcrm.PhreeqcRM_Int2IrmResult(r, positive_ok)

    def Construct(self):
        return _phreeqcrm.PhreeqcRM_Construct(self)

    def GetSpeciesStoichiometry(self):
    	v = self.GetSpeciesStoichiometrySWIG()
    	species = v[0]
    	nelt_in_species = v[1]
    	elts = v[2]
    	coefs = v[3]
    	all_stoich = dict()
    	j_tot = 0
    	for i in range(len(species)):
    		n = nelt_in_species[i]
    		s_stoich = dict()
    		for j in range(n):
    			s_stoich[elts[j_tot]] = coefs[j_tot]
    			j_tot += 1
    		all_stoich[species[i]] = s_stoich
    	return all_stoich	
    def GetBackwardMapping(self):
    	v = self.GetBackwardMappingSWIG()
    	count = v[0]
    	allcells = v[1]
    	backward_mapping = dict()
    	j_tot = 0
    	for i in range(len(count)):
    		n = count[i]
    		back = []
    		for j in range(n):
    			back.append(allcells[j_tot]);
    			j_tot += 1
    		backward_mapping[i] = back
    	return backward_mapping	
    def InitialPhreeqc2Concentrations(self, bc1):
    	if not isinstance(bc1, phreeqcrm.IntVector):
    		bc1 = self.GetIntVector(bc1)
    	return np.array(self.InitialPhreeqc2ConcentrationsSWIG(bc1)[1])
    def InitialPhreeqc2Module(self, ic1):
    	if not isinstance(ic1, phreeqcrm.IntVector):
    		ic1 = self.GetIntVector(ic1)
    	return self.InitialPhreeqc2ModuleSWIG(ic1)
    def InitialPhreeqc2Module_mix(self, ic1, ic2, f1):
    	if not isinstance(ic1, phreeqcrm.IntVector):
    		ic1 = self.GetIntVector(ic1)
    	if not isinstance(ic2, phreeqcrm.IntVector):
    		ic2 = self.GetIntVector(ic2)
    	return self.InitialPhreeqc2ModuleSWIG_mix(ic1,ic2,f1)
    def InitialPhreeqc2Concentrations_mix(self, bc1, bc2, f1):
    	if not isinstance(bc1, phreeqcrm.IntVector):
    		bc1 = self.GetIntVector(bc1)
    	if not isinstance(bc2, phreeqcrm.IntVector):
    		bc2 = self.GetIntVector(bc2)
    	return np.array(self.InitialPhreeqc2ConcentrationsSWIG_mix(bc1,bc2,f1)[1])
    def InitialPhreeqc2SpeciesConcentrations(self, bc1):
    	if not isinstance(bc1, phreeqcrm.IntVector):
    		bc1 = self.GetIntVector(bc1)
    	return np.array(self.InitialPhreeqc2SpeciesConcentrationsSWIG(bc1)[1])
    def InitialPhreeqc2SpeciesConcentrations_mix(self, bc1, bc2, f1):
    	if not isinstance(bc1, phreeqcrm.IntVector):
    		bc1 = self.GetIntVector(bc1)
    	if not isinstance(bc2, phreeqcrm.IntVector):
    		bc2 = self.GetIntVector(bc2)
    	return np.array(self.InitialPhreeqc2SpeciesConcentrationsSWIG_mix(bc1,bc2,f1)[1])
    def InitialPhreeqcCell2Module(self, n, v):
    	if not isinstance(v, phreeqcrm.IntVector):
    		v = self.GetIntVector(v)
    	return self.InitialPhreeqcCell2ModuleSWIG(n, v)
    def CreateMapping(self, v):
    	if not isinstance(v, phreeqcrm.IntVector):
    		v = self.GetIntVector(v)
    	return self.CreateMappingSWIG(v)
    def GetConcentrations(self):
    	return np.array(self.GetConcentrationsSWIG()[1])
    def GetDensityCalculated(self): 
    	return np.array(self.GetDensityCalculatedSWIG()[1])     
    def GetEndCell(self):
    	return np.array(self.GetEndCellSWIG())    
    def GetForwardMapping(self):
    	return np.array(self.GetForwardMappingSWIG())  
    def GetGasCompMoles(self):                 
    	return np.array(self.GetGasCompMolesSWIG()[1])             
    def GetGasCompPhi(self):                
    	return np.array(self.GetGasCompPhiSWIG()[1])  
    def GetGasCompPressures(self):      
    	return np.array(self.GetGasCompPressuresSWIG()[1])           
    def GetGasPhaseVolume(self):           
    	return np.array(self.GetGasPhaseVolumeSWIG()[1])    
    def GetGfw(self):
    	return np.array(self.GetGfwSWIG())  
    def GetIthConcentration(self, n):
    	return np.array(self.GetIthConcentrationSWIG(n)[1])   
    def GetIthSpeciesConcentration(self, n):
    	return np.array(self.GetIthSpeciesConcentrationSWIG(n)[1])  
    def GetPrintChemistryOn(self):
    	return np.array(self.GetPrintChemistryOn_bool_vector())  
    def GetPorosity(self):
    	return np.array(self.GetPorositySWIG())
    def GetPressure(self):
    	return np.array(self.GetPressureSWIG())
    def GetPrintChemistryMask(self):
    	return np.array(self.GetPrintChemistryMaskSWIG())
    def GetPrintChemistryOn(self):
    	return np.array(self.GetPrintChemistryOn_bool_vector())
    def GetSaturationCalculated(self):      
    	return np.array(self.GetSaturationCalculatedSWIG()[1])   
    def GetSelectedOutput(self):    
    	return np.array(self.GetSelectedOutputSWIG()[1])     
    def GetSelectedOutputHeadings(self):             
    	return np.array(self.GetSelectedOutputHeadingsSWIG()[1])  
    def GetSpeciesConcentrations(self):
    	return np.array(self.GetSpeciesConcentrationsSWIG()[1])  
    def GetSpeciesD25(self):
    	return np.array(self.GetSpeciesD25SWIG())    
    def GetSpeciesLog10Gammas(self):   
    	return np.array(self.GetSpeciesLog10GammasSWIG()[1])     
    def GetSpeciesLog10Molalities(self):        
    	return np.array(self.GetSpeciesLog10MolalitiesSWIG()[1]) 
    def GetSpeciesZ(self):
    	return np.array(self.GetSpeciesZSWIG())
    def GetSolutionVolume(self):
    	return np.array(self.GetSolutionVolumeSWIG())
    def GetStartCell(self):
    	return np.array(self.GetStartCellSWIG())
    def GetTemperature(self):
    	return np.array(self.GetTemperatureSWIG())
    def GetViscosity(self):
    	return np.array(self.GetViscositySWIG())
    def InitialEquilibriumPhases2Module(self, v):
    	if not isinstance(v, phreeqcrm.IntVector):
    		v = self.GetIntVector(v)
    	return self.InitialEquilibriumPhases2ModuleSWIG(v)
    def InitialExchanges2Module(self, v):
    	if not isinstance(v, phreeqcrm.IntVector):
    		v = self.GetIntVector(v)
    	return self.InitialExchanges2ModuleSWIG(v)
    def InitialGasPhases2Module(self, v):
    	if not isinstance(v, phreeqcrm.IntVector):
    		v = self.GetIntVector(v)
    	return self.InitialGasPhases2ModuleSWIG(v)
    def InitialKinetics2Module(self, v):
    	if not isinstance(v, phreeqcrm.IntVector):
    		v = self.GetIntVector(v)
    	return self.InitialKinetics2ModuleSWIG(v)
    def InitialSolutions2Module(self, v):
    	if not isinstance(v, phreeqcrm.IntVector):
    		v = self.GetIntVector(v)
    	return self.InitialSolutions2ModuleSWIG(v)
    def InitialSolidSolutions2Module(self, v):
    	if not isinstance(v, phreeqcrm.IntVector):
    		v = self.GetIntVector(v)
    	return self.InitialSolidSolutions2ModuleSWIG(v)
    def InitialSurfaces2Module(self, v):
    	if not isinstance(v, phreeqcrm.IntVector):
    		v = self.GetIntVector(v)
    	return self.InitialSurfaces2ModuleSWIG(v)
    def SetIthConcentration(self, i, c):
    	if not isinstance(c, phreeqcrm.DoubleVector):
    		c = self.GetDoubleVector(c)
    	return self.SetIthConcentrationSWIG(i, c)
    def SetIthSpeciesConcentration(self, i, c):
    	if not isinstance(c, phreeqcrm.DoubleVector):
    		c = self.GetDoubleVector(c)
    	return self.SetIthSpeciesConcentrationSWIG(i, c)
    def SetPrintChemistryMask(self, cell_mask):
    	if not isinstance(cell_mask, phreeqcrm.IntVector):
    		cell_mask = self.GetIntVector(cell_mask)
    	return self.SetPrintChemistryMaskSWIG(cell_mask)
    def GetIntVector(self, v):
    	if isinstance(v, np.ndarray) and isinstance(v[0].item(), int):
    		vv = phreeqcrm.IntVector()
    		for i in range(len(v)):
    			vv.push_back(v[i].item())
    		return vv
    	if (isinstance(v, tuple) or isinstance(v, list)) and isinstance(v[0], int):
    		vv = phreeqcrm.IntVector()
    		for i in range(len(v)):
    			vv.push_back(v[i])
    		return vv
    	return v
    def GetDoubleVector(self, v):
    	if isinstance(v, np.ndarray) and isinstance(v[0].item(), float):
    		vv = phreeqcrm.DoubleVector()
    		for i in range(len(v)):
    			vv.push_back(v[i].item())
    		return vv
    	if (isinstance(v, tuple) or isinstance(v, list)) and isinstance(v[0], float):
    		vv = phreeqcrm.DoubleVector()
    		for i in range(len(v)):
    			vv.push_back(v[i])
    		return vv
    	return v


    def __disown__(self):
        self.this.disown()
        _phreeqcrm.disown_PhreeqcRM(self)
        return weakref.proxy(self)

# Register PhreeqcRM in _phreeqcrm:
_phreeqcrm.PhreeqcRM_swigregister(PhreeqcRM)
class NotImplemented(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _phreeqcrm.NotImplemented_swiginit(self, _phreeqcrm.new_NotImplemented())
    __swig_destroy__ = _phreeqcrm.delete_NotImplemented

# Register NotImplemented in _phreeqcrm:
_phreeqcrm.NotImplemented_swigregister(NotImplemented)
class BMIPhreeqcRM(PhreeqcRM):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def CleanupBMIModuleInstances():
        return _phreeqcrm.BMIPhreeqcRM_CleanupBMIModuleInstances()

    @staticmethod
    def CreateBMIModule(*args):
        return _phreeqcrm.BMIPhreeqcRM_CreateBMIModule(*args)

    @staticmethod
    def DestroyBMIModule(n):
        return _phreeqcrm.BMIPhreeqcRM_DestroyBMIModule(n)

    @staticmethod
    def GetInstance(n):
        return _phreeqcrm.BMIPhreeqcRM_GetInstance(n)

    def __init__(self):
        r"""
        Default constructor for the BMIPhreeqcRM subclass of PhreeqcRM.

        Definition of the number of cells and threads (or MPI communicator) 
        is deferred to the method :meth:`initialize`.

        Returns:
        	 A BMIPhreeqcRM instance.
        """

        self._state = State.UNINITIALIZED
        self._values = {}
        self._pointables = {}
        self._readonlys = {}


        if self.__class__ == BMIPhreeqcRM:
            _self = None
        else:
            _self = self
        _phreeqcrm.BMIPhreeqcRM_swiginit(self, _phreeqcrm.new_BMIPhreeqcRM(_self, ))
    __swig_destroy__ = _phreeqcrm.delete_BMIPhreeqcRM

    def initialize(self, *args):
        r"""
        Basic Model Interface method that can be used to
        initialize a PhreeqcRM instance. 

        This method is equivalent to :meth:`InitializeYAML`. A YAML
        file is used to initialize the instance. The file contains
        a YAML map of PhreeqcRM methods and the arguments
        corresponding to the method. 

        For example,

        - key: LoadDatabase
          database: phreeqc.dat
        - key: RunFile
          workers: true
          initial_phreeqc: true
          utility: true
          chemistry_name: advect.pqi

        :meth:`initialize` will read the YAML file and execute the
        specified methods with the specified arguments. Using YAML
        terminology, the argument(s) for a method may be a scalar,
        a sequence, or a map, depending if the argument is a single
        item, a single vector, or there are multiple arguments. In
        the case of a map, the name associated with each argument
        (for example 'chemistry_name' above) is arbitrary. The
        names of the map keys for map arguments are not used in
        parsing the YAML file; only the order of the arguments is
        important.

        The PhreeqcRM methods that can be specified in a YAML file
        include:

        CloseFiles(void);
        CreateMapping(int list, numpy.ndarray, or tuple: grid2chem);
        DumpModule();
        FindComponents();
        InitialPhreeqc2Module(int list, numpy.ndarray, or tuple: initial_conditions1);
        InitialPhreeqc2Module(int list, numpy.ndarray, or tuple: initial_conditions1,
        int list, numpy.ndarray, or tuple: initial_conditions2,
        float list, numpy.ndarray, or tuple: fraction1);
        InitialPhreeqcCell2Module(int n, int list, numpy.ndarray, or tuple: cell_numbers);
        LoadDatabase(string database);
        OpenFiles(void);
        OutputMessage(string str);
        RunCells(void);
        RunFile(Boolean workers, Boolean initial_phreeqc, Boolean utility, string chemistry_name);
        RunString(Boolean workers, Boolean initial_phreeqc, Boolean utility, string input_string);
        ScreenMessage(string str);
        SetComponentH2O(Boolean tf);
        SetConcentrations(float list, numpy.ndarray, or tuple: c);
        SetCurrentSelectedOutputUserNumber(int n_user);
        SetDensityUser(float list, numpy.ndarray, or tuple: density);
        SetDumpFileName(string dump_name);
        SetErrorHandlerMode(int mode);
        SetErrorOn(Boolean tf);
        SetFilePrefix(string prefix);
        SetGasCompMoles(float list, numpy.ndarray, or tuple: gas_moles);
        SetGasPhaseVolume(float list, numpy.ndarray, or tuple: gas_volume);
        SetPartitionUZSolids(Boolean tf);
        SetPorosity(float list, numpy.ndarray, or tuple: por);
        SetPressure(float list, numpy.ndarray, or tuple: p);
        SetPrintChemistryMask(int list, numpy.ndarray, or tuple: cell_mask);
        SetPrintChemistryOn(Boolean workers, Boolean initial_phreeqc, Boolean utility);
        SetRebalanceByCell(Boolean tf);
        SetRebalanceFraction(float f);
        SetRepresentativeVolume(float list, numpy.ndarray, or tuple: rv);
        SetSaturationUser(float list, numpy.ndarray, or tuple: sat);
        SetScreenOn(Boolean tf);
        SetSelectedOutputOn(Boolean tf);
        SetSpeciesSaveOn(Boolean save_on);
        SetTemperature(float list, numpy.ndarray, or tuple: t);
        SetTime(float time);
        SetTimeConversion(float conv_factor);
        SetTimeStep(float time_step);
        SetUnitsExchange(int option);
        SetUnitsGasPhase(int option);
        SetUnitsKinetics(int option);
        SetUnitsPPassemblage(int option);
        SetUnitsSolution(int option);
        SetUnitsSSassemblage(int option);
        SetUnitsSurface(int option);
        SpeciesConcentrations2Module(float list, numpy.ndarray, or tuple: species_conc);
        StateSave(int istate);
        StateApply(int istate);
        StateDelete(int istate);
        UseSolutionDensityVolume(Boolean tf);
        WarningMessage(string warnstr);

        Args:
        	config_file (str): File with YAML definitions for PhreeqcRM 
        		initialization.
        """
        val = _phreeqcrm.BMIPhreeqcRM_initialize(self, *args)

        self._pointables = {var.lower() for var in self.get_pointable_var_names()}
        self._readonlys = {var.lower() for var in self.get_readonly_var_names()}
        self._state = State.INITIALIZED


        return val


    def update(self):
        r"""
        Basic Model Interface method that runs PhreeqcRM for one time step. 

        PhreeqcRM will equilibrate the solutions with all
        equilibrium reactants (EQUILIBRIUM_PHASES, EXCHANGE,
        GAS_PHASE, SOLID_SOLUTIONS, and SURFACE) and integrate
        KINETICS reactions for the specified time step
        (:meth:`SetTimeStep`). The time will be updated, and all
        pointer variables will be updated.
        """

        if self._state != State.INITIALIZED:
            raise RuntimeError("must call initialize first")


        return _phreeqcrm.BMIPhreeqcRM_update(self)


    def update_until(self, end_time):
        r"""
        Runs chemistry for a time step calculated
        as end_time minus the current time.

        Current time is found with :meth:`get_current_time`.

        Args:
        	end_time (float): Time at the end of the simulation
        		period.
        """

        if self._state != State.INITIALIZED:
            raise RuntimeError("must call initialize first")


        return _phreeqcrm.BMIPhreeqcRM_update_until(self, end_time)


    def finalize(self):
        r"""Finalize closes any files open in the BMIPhreeqcRM instance."""
        val = _phreeqcrm.BMIPhreeqcRM_finalize(self)

        self._state = State.UNINITIALIZED
        self._values = {}
        self._pointables = {}
        self._readonlys = {}


        return val


    def get_component_name(self):
        r"""
        Basic Model Interface method that returns the component
        name--PhreeqcRM.

        The BMI interface to PhreeqcRM provides most of the
        functions necessary to couple a flow and transport model
        with chemistry. The native PhreeqcRM methods
        provide additional methods to complete the interface. 

        Returns:
        	str: The string 'PhreeqcRM'.
        """
        return _phreeqcrm.BMIPhreeqcRM_get_component_name(self)

    def get_input_item_count(self):
        r"""
        Basic Model Interface method that returns count of input
        variables that can be set with :meth:`set_value`.

        Returns:
        	int: Count of input variables that can be set with
        		:meth:`set_value`.
        """

        if self._state != State.INITIALIZED:
            raise RuntimeError("must call initialize first")


        return _phreeqcrm.BMIPhreeqcRM_get_input_item_count(self)


    def get_output_item_count(self):
        r"""
        Basic Model Interface method that returns count of output
        variables that can be retrieved with :meth:`get_value`.

        Returns:
        	int: Count of output variables that can be retrieved with 
        		:meth:`get_value`.
        """

        if self._state != State.INITIALIZED:
            raise RuntimeError("must call initialize first")


        return _phreeqcrm.BMIPhreeqcRM_get_output_item_count(self)


    def get_pointable_item_count(self):
        r"""
        Basic Model Interface method that returns count of 
        variables that can be reference with :meth:`get_value_ptr`.

        Returns:
        	int: Count of output variables that can be referenced with 
        		:meth:`get_value_ptr`.
        """
        return _phreeqcrm.BMIPhreeqcRM_get_pointable_item_count(self)

    def get_input_var_names(self):
        r"""
        Basic Model Interface method that returns a list of the
        variable names that can be set with :meth:`set_value`.

        Returns:
        	tuple (str): A list of the variable names that can be set with 
        		:meth:`set_value`.
        """

        if self._state != State.INITIALIZED:
            raise RuntimeError("must call initialize first")


        return _phreeqcrm.BMIPhreeqcRM_get_input_var_names(self)


    def get_output_var_names(self):
        r"""
        Basic Model Interface method that returns a list of the
        variable names that can be retrieved with
        :meth:`get_value`.

        Returns:
        	tuple (str): A list of the variable names that can be retrieved with
        		:meth:`get_value`.
        """

        if self._state != State.INITIALIZED:
            raise RuntimeError("must call initialize first")


        return _phreeqcrm.BMIPhreeqcRM_get_output_var_names(self)


    def get_pointable_var_names(self):
        r"""
        Basic Model Interface method that returns a list of the
        variable names that can be referenced by
        :meth:`get_value_ptr`.

        Returns:
        	tuple (str): A list of the variable names that can be
        		referenced with :meth:`get_value_ptr`.
        """
        return _phreeqcrm.BMIPhreeqcRM_get_pointable_var_names(self)

    def get_readonly_var_names(self):
        return _phreeqcrm.BMIPhreeqcRM_get_readonly_var_names(self)

    def get_var_grid(self, name):
        return _phreeqcrm.BMIPhreeqcRM_get_var_grid(self, name)

    def get_var_type(self, name):
        r"""
        Basic Model Interface method that retrieves the type of a
        variable that can be set or retrieved.

        Types are 'int', 'float', or 'str'.

        Args:
        	name (str): Name of the variable to retrieve type.

        Returns:
        	str: Character string of variable type.
        """

        if self._state != State.INITIALIZED:
            raise RuntimeError("must call initialize first")


        return _phreeqcrm.BMIPhreeqcRM_get_var_type(self, name)


    def get_var_units(self, name):
        r"""
        Basic Model Interface method that retrieves the units of a
        variable that can be set or retrieved.

        Args:
        	name (str): Name of the variable to retrieve type.

        Returns:
        	str: Character string of units for variable.
        """

        if self._state != State.INITIALIZED:
            raise RuntimeError("must call initialize first")


        return _phreeqcrm.BMIPhreeqcRM_get_var_units(self, name)


    def get_var_itemsize(self, name):
        r"""
        Basic Model Interface method that retrieves size of an
        individual item that can be set or retrived. 

        Sizes may be sizeof(int), sizeof(float), or a character
        length for string variables. Only variables in the list
        provided by :meth:`get_input_var_names` can be set. Only
        variables in the list provided by
        :meth:`get_output_var_names` can be retrieved.

        Args:
        	name (str): Name of the variable to retrieve item size.

        Returns:
        	int: Size of one element of variable.
        """

        if self._state != State.INITIALIZED:
            raise RuntimeError("must call initialize first")


        return _phreeqcrm.BMIPhreeqcRM_get_var_itemsize(self, name)


    def get_var_nbytes(self, name):
        r"""
        Basic Model Interface method that retrieves the total
        number of bytes that are set or retrieved.

        Variables are set with :meth:`set_value` and retrieved with
        :meth:`get_value`. Only variables in the list provided by
        :meth:`get_input_var_names` can be set. Only variables in
        the list provided by :meth:`get_output_var_names` can be
        retrieved.

        Args:
        	name (str): Name of the variable to retrieve total bytes.

        Returns:
        	int: Total number of bytes set or retrieved for variable.
        """

        if self._state != State.INITIALIZED:
            raise RuntimeError("must call initialize first")


        return _phreeqcrm.BMIPhreeqcRM_get_var_nbytes(self, name)


    def get_var_location(self, name):
        return _phreeqcrm.BMIPhreeqcRM_get_var_location(self, name)

    def get_current_time(self):
        r"""
        Basic Model Interface method that returns the current simulation time.

        The method :meth:`GetTime` also returns the current
        simulation time. The current time can be set by the methods
        :meth:`set_value`('Time') or :meth:`SetTime`.

        Returns:
        	float: The current simulation time, in seconds.
        """
        return _phreeqcrm.BMIPhreeqcRM_get_current_time(self)

    def get_start_time(self):
        return _phreeqcrm.BMIPhreeqcRM_get_start_time(self)

    def get_end_time(self):
        r"""
        Basic Model Interface method that returns
        :meth:`get_current_time` plus :meth:`get_time_step`.

        Returns:
        	float: The end of the time step, in seconds.
        """
        return _phreeqcrm.BMIPhreeqcRM_get_end_time(self)

    def get_time_units(self):
        r"""
        Basic Model Interface method that returns the time units
        of PhreeqcRM. 

        All time units are seconds for PhreeqcRM.

        Returns:
        	string: Returns the string 'seconds'.
        """
        return _phreeqcrm.BMIPhreeqcRM_get_time_units(self)

    def get_time_step(self):
        r"""
        Basic Model Interface method that returns the current
        simulation time step. (Same as :meth:`GetTimeStep`.) 

        The time step can be set by :meth:`set_value`('TimeStep')
        or :meth:`SetTimeStep`.

        Returns:
        	float: The current simulation time step, in seconds.
        """
        return _phreeqcrm.BMIPhreeqcRM_get_time_step(self)

    def GetValue(self, name, dest):
        return _phreeqcrm.BMIPhreeqcRM_GetValue(self, name, dest)

    def GetValue_bool(self, name):
        return _phreeqcrm.BMIPhreeqcRM_GetValue_bool(self, name)

    def GetValue_double(self, name):
        return _phreeqcrm.BMIPhreeqcRM_GetValue_double(self, name)

    def GetValue_int(self, name):
        return _phreeqcrm.BMIPhreeqcRM_GetValue_int(self, name)

    def GetValue_string(self, name):
        return _phreeqcrm.BMIPhreeqcRM_GetValue_string(self, name)

    def GetValue_double_vector(self, name):
        return _phreeqcrm.BMIPhreeqcRM_GetValue_double_vector(self, name)

    def GetValue_int_vector(self, name):
        return _phreeqcrm.BMIPhreeqcRM_GetValue_int_vector(self, name)

    def GetValue_string_vector(self, name):
        return _phreeqcrm.BMIPhreeqcRM_GetValue_string_vector(self, name)

    def GetValuePtr(self, name):
        return _phreeqcrm.BMIPhreeqcRM_GetValuePtr(self, name)

    def GetValueAtIndices(self, name, dest, inds, count):
        return _phreeqcrm.BMIPhreeqcRM_GetValueAtIndices(self, name, dest, inds, count)

    def SetValue_bool(self, name, src):
        return _phreeqcrm.BMIPhreeqcRM_SetValue_bool(self, name, src)

    def SetValue(self, *args):
        return _phreeqcrm.BMIPhreeqcRM_SetValue(self, *args)

    def SetValue_double(self, name, src):
        return _phreeqcrm.BMIPhreeqcRM_SetValue_double(self, name, src)

    def SetValue_int(self, name, src):
        return _phreeqcrm.BMIPhreeqcRM_SetValue_int(self, name, src)

    def SetValue_string(self, name, src):
        return _phreeqcrm.BMIPhreeqcRM_SetValue_string(self, name, src)

    def SetValue_double_vector(self, name, src):
        return _phreeqcrm.BMIPhreeqcRM_SetValue_double_vector(self, name, src)

    def SetValue_int_vector(self, name, src):
        return _phreeqcrm.BMIPhreeqcRM_SetValue_int_vector(self, name, src)

    def SetValue_string_vector(self, name, src):
        return _phreeqcrm.BMIPhreeqcRM_SetValue_string_vector(self, name, src)

    def SetValueAtIndices(self, name, inds, count, src):
        return _phreeqcrm.BMIPhreeqcRM_SetValueAtIndices(self, name, inds, count, src)

    def get_grid_rank(self, grid):
        r"""
        Returns a rank of 1 for grid 0. 

        BMIPhreeqcRM only has a 1D series of
        cells; any grid or spatial information must
        be found in the user's model.

        Args:
        	grid (int): Grid number, only grid 0 is considered.
        Returns:
        	(int) Rank of 1 is returned for grid 0; 0 for all other values of 
        		grid.
        """
        return _phreeqcrm.BMIPhreeqcRM_get_grid_rank(self, grid)

    def get_grid_size(self, grid):
        r"""
        Returns the number of cells specified
        at initialization of the BMIPhreeqcRM instance. 

        Args:
        	grid (int): Grid number, only grid 0 is considered.

        Returns:
        	(int) Number of cells in the user's modle (same value as
        		:meth:`GetGridCellCount` is returned for grid 0; 0 for all other
        		values of grid.
        """

        if self._state != State.INITIALIZED:
            raise RuntimeError("must call initialize first")


        return _phreeqcrm.BMIPhreeqcRM_get_grid_size(self, grid)


    def get_grid_type(self, grid):
        r"""
        Grid type is points. 

        No grid information is available in BMIPhreeqcRM; all grid
        information must be found in the user's model. 

        Args:
        	grid (int): Grid number, only grid 0 is considered. 

        Returns:
        	(str) 'Points' is returned for grid 0; 'Undefined grid
        		identifier' is returned for all other values of @a grid.
        """
        return _phreeqcrm.BMIPhreeqcRM_get_grid_type(self, grid)

    def get_grid_shape(self, grid, shape):
        return _phreeqcrm.BMIPhreeqcRM_get_grid_shape(self, grid, shape)

    def get_grid_spacing(self, grid, spacing):
        return _phreeqcrm.BMIPhreeqcRM_get_grid_spacing(self, grid, spacing)

    def get_grid_origin(self, grid, origin):
        return _phreeqcrm.BMIPhreeqcRM_get_grid_origin(self, grid, origin)

    def get_grid_x(self, grid, x):
        return _phreeqcrm.BMIPhreeqcRM_get_grid_x(self, grid, x)

    def get_grid_y(self, grid, y):
        return _phreeqcrm.BMIPhreeqcRM_get_grid_y(self, grid, y)

    def get_grid_z(self, grid, z):
        return _phreeqcrm.BMIPhreeqcRM_get_grid_z(self, grid, z)

    def get_grid_node_count(self, grid):
        return _phreeqcrm.BMIPhreeqcRM_get_grid_node_count(self, grid)

    def get_grid_edge_count(self, grid):
        return _phreeqcrm.BMIPhreeqcRM_get_grid_edge_count(self, grid)

    def get_grid_face_count(self, grid):
        return _phreeqcrm.BMIPhreeqcRM_get_grid_face_count(self, grid)

    def get_grid_edge_nodes(self, grid, edge_nodes):
        return _phreeqcrm.BMIPhreeqcRM_get_grid_edge_nodes(self, grid, edge_nodes)

    def get_grid_face_edges(self, grid, face_edges):
        return _phreeqcrm.BMIPhreeqcRM_get_grid_face_edges(self, grid, face_edges)

    def get_grid_face_nodes(self, grid, face_nodes):
        return _phreeqcrm.BMIPhreeqcRM_get_grid_face_nodes(self, grid, face_nodes)

    def get_grid_nodes_per_face(self, grid, nodes_per_face):
        return _phreeqcrm.BMIPhreeqcRM_get_grid_nodes_per_face(self, grid, nodes_per_face)

    def add_output_vars(self, option, _def):
        r"""
        Method that defines additional output variables that can be
        retrieved by the BMI method :meth:`get_value`. 

        add_output_vars selects sets of variables that can be
        retieved by the :meth:`get_value` method. Sets of variables
        can be included or excluded with multiple calls to this
        method. All calls must precede the final call to
        FindComponents. FindComponents generates SELECTED_OUTPUT
        333 and USER_PUNCH 333 data blocks that make the selected
        variables accessible. Variables will only be accessible if
        the system includes the given reactant; for example, no gas
        variables will be created if there are no GAS_PHASEs in the
        model.

        Args:
        	option (str): A string value, among those listed below,
        		that includes or excludes variables from
        		get_output_var_names, get_value, get_var_itemsize, and
        		other BMI methods.

        	def (str): A string value that can be 'false', 'true', or a
        		list of items to be included as accessible variables. A
        		value of 'false', excludes all variables of the given type;
        		a value of 'true' includes all variables of the given type
        		for the current system; a list specifies a subset of items
        		of the given type.

        Values for the the parameter option include:

        'AddOutputVars': False excludes all variables; True causes
        	the settings for each variable group to determine the
        	variables that will be defined. Default True;

        'SolutionProperties': False excludes all solution property
        	variables; True includes variables pH, pe, alkalinity,
        	ionic strength, water mass, charge balance, percent error,
        	and specific conductance. Default True.

        'SolutionTotalMolalities': False excludes all total element
        	and element redox state variables; True includes all
        	elements and element redox state variables for the system
        	defined for the calculation; list restricts variables to
        	the specified elements and redox states. Default True.

        'ExchangeMolalities': False excludes all variables related
        	to exchange; True includes all variables related to
        	exchange; list includes variables for the specified
        	exchange species. Default True.

        'SurfaceMolalities': False excludes all variables related
        	to surfaces; True includes all variables related to
        	surfaces; list includes variables for the specified surface
        	species. Default True.

        'EquilibriumPhases': False excludes all variables related
        	to equilibrium phases; True includes all variables related
        	to equilibrium phases; list includes variables for the
        	specified equilibiurm phases. Default True.

        'Gases': False excludes all variables related to gases;
        	True includes all variables related to gases; list includes
        	variables for the specified gas components. Default True.

        'KineticReactants': False excludes all variables related to
        	kinetic reactants; True includes all variables related to
        	kinetic reactants; list includes variables for the
        	specified kinetic reactants. Default True.

        'SolidSolutions': False excludes all variables related to
        	solid solutions; True includes all variables related to
        	solid solutions; list includes variables for the specified
        	solid solutions components. Default True.

        'CalculateValues': False excludes all calculate values;
        	True includes all calculate values; list includes the
        	specified calculate values. CALCLUATE_VALUES can be used to
        	calculate geochemical quantities not available in the other
        	sets of variables. Default True.

        'SolutionActivities': False excludes all aqueous species;
        	True includes all aqueous species; list includes only the
        	specified aqueous species. Default False.

        'SolutionMolalities': False excludes all aqueous species;
        	True includes all aqueous species; list includes only the
        	specified aqueous species. Default False.

        'SaturationIndices': False excludes all saturation indices;
        	True includes all saturation indices; list includes only
        	the specified saturation indices. Default False.
        """
        return _phreeqcrm.BMIPhreeqcRM_add_output_vars(self, option, _def)

    def SetLanguage(self, string):
        return _phreeqcrm.BMIPhreeqcRM_SetLanguage(self, string)
    language = property(_phreeqcrm.BMIPhreeqcRM_language_get, _phreeqcrm.BMIPhreeqcRM_language_set)

    def LoadDatabase(self, database):
        r"""
        Load a database for all IPhreeqc instances--workers,
        InitialPhreeqc, and Utility. 

        All definitions of the reaction module are cleared
        (SOLUTION_SPECIES, PHASES, SOLUTIONs, etc.), and the
        database is read.

        Args:
        	database (str): String containing the database name.

        Returns:
        	IRM_RESULT: 0 is success, negative is failure (See :meth:`DecodeError`).
        """

        if self._state != State.INITIALIZED:
            raise RuntimeError("must call initialize first")


        return _phreeqcrm.BMIPhreeqcRM_LoadDatabase(self, database)


    def get_value_ptr_double(self, var):
        return _phreeqcrm.BMIPhreeqcRM_get_value_ptr_double(self, var)

    def get_value_ptr_int(self, var):
        return _phreeqcrm.BMIPhreeqcRM_get_value_ptr_int(self, var)

    def get_value_ptr_vector_strings(self, var):
        return _phreeqcrm.BMIPhreeqcRM_get_value_ptr_vector_strings(self, var)

    def Construct(self):
        return _phreeqcrm.BMIPhreeqcRM_Construct(self)

    def get_value_ptr(self, var_name):

        if self._state != State.INITIALIZED:
          raise RuntimeError("must call initialize first")

        var_name_lower = var_name.lower()
        if var_name_lower in self._values:
            return self._values[var_name_lower]

        Nbytes = self.get_var_nbytes(var_name_lower)
        Itemsize = self.get_var_itemsize(var_name_lower)
        dim = 0
        if Itemsize != 0:
            dim = Nbytes / Itemsize
        vtype = self.get_var_type(var_name_lower)

        if vtype=="float64":
            if dim>=1:
                arry = self.get_value_ptr_double(var_name_lower)
                self._values[var_name_lower] = arry
                if var_name_lower in self._readonlys:
                    arry.flags.writeable = False
                return arry
        if vtype=="int32":
            if dim>=1:
                arry = self.get_value_ptr_int(var_name_lower)
                self._values[var_name_lower] = arry
                if var_name_lower in self._readonlys:
                    arry.flags.writeable = False
                return arry
        if vtype.startswith("<U"):
            arry = np.array(self.get_value_ptr_vector_strings(var_name_lower))
            self._values[var_name_lower] = arry
    # strings are always readonly
            arry.flags.writeable = False
            return arry
        return None

    def get_value(self, var_name, dest):

        if self._state != State.INITIALIZED:
          raise RuntimeError("must call initialize first")

        var_name_lower = var_name.lower()
        if var_name_lower in self._pointables:
            dest[:] = self.get_value_ptr(var_name_lower).flatten()
            return dest

        Nbytes = self.get_var_nbytes(var_name_lower)
        Itemsize = self.get_var_itemsize(var_name_lower)
        dim = 0
        if Itemsize != 0:
            dim = Nbytes / Itemsize
        vtype = self.get_var_type(var_name_lower)

        if vtype=="float64":
            if dim==1:
                dest[:] = np.array(self.GetValue_double(var_name_lower)).flatten()
            if dim>1:
                dest[:] = np.array(self.GetValue_double_vector(var_name_lower)).flatten()
        if vtype=="int32":
            if dim==1:
                dest[:] = np.array(self.GetValue_int(var_name_lower)).flatten()
            if dim>1:
                dest[:] = np.array(self.GetValue_int_vector(var_name_lower)).flatten()
        if vtype.startswith("<U"):
            if dim==1:
                dest[:] = np.array([self.GetValue_string(var_name_lower)]).flatten()
            if dim>1:
                dest[:] = np.array(self.GetValue_string_vector(var_name_lower)).flatten()
        if vtype=="bool":
            dest[:] = np.array([self.GetValue_bool(var_name_lower)]).flatten()
        return dest

    def get_value_at_indices(self, var_name, dest, indices):
        """Get values at particular indices.

        Parameters
        ----------
        var_name : str
            Name of variable as CSDMS Standard Name.
        dest : ndarray
            A numpy array into which to place the values.
        indices : array_like
            Array of indices.

        Returns
        -------
        array_like
            Values at indices.
        """
        if self._state != State.INITIALIZED:
            raise RuntimeError("must call initialize first")

        dest[:] = self.get_value_ptr(var_name).take(indices)
        return dest

    def set_value_at_indices(self, var_name, inds, src):
        """Set model values at particular indices.

        Parameters
        ----------
        var_name : str
            Name of variable as CSDMS Standard Name.
        src : array_like
            Array of new values.
        indices : array_like
            Array of indices.
        """
        if self._state != State.INITIALIZED:
            raise RuntimeError("must call initialize first")

        val = self.get_value_ptr(var_name)
        val.flat[inds] = src

    def set_value(self, var_name, value):
        '''@todo
        '''
        if self._state != State.INITIALIZED:
          raise RuntimeError("must call initialize first")

        Nbytes = self.get_var_nbytes(var_name)
        Itemsize = self.get_var_itemsize(var_name)
        dim = Nbytes / Itemsize
        vtype = self.get_var_type(var_name)
        if vtype=="float64":
            if dim==1:
                self.SetValue_double(var_name, value[0])
            if dim>1:
                self.SetValue_double_vector(var_name, value)
        if vtype=="int32":
            if dim==1:
                self.SetValue_int(var_name, value[0])
            if dim>1:
    # this needs testing
                self.SetValue_int_vector(var_name, value)
        if vtype.startswith("<U"):
            if dim==1:
                self.SetValue_string(var_name, value[0])
            if dim>1:
                self.SetValue_string_vector(var_name, value)

    def __disown__(self):
        self.this.disown()
        _phreeqcrm.disown_BMIPhreeqcRM(self)
        return weakref.proxy(self)

# Register BMIPhreeqcRM in _phreeqcrm:
_phreeqcrm.BMIPhreeqcRM_swigregister(BMIPhreeqcRM)

