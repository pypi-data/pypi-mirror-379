#################################################################################
# WaterTAP Copyright (c) 2020-2025, The Regents of the University of California,
# through Lawrence Berkeley National Laboratory, Oak Ridge National Laboratory,
# National Renewable Energy Laboratory, and National Energy Technology
# Laboratory (subject to receipt of any required approvals from the U.S. Dept.
# of Energy). All rights reserved.
#
# Please see the files COPYRIGHT.md and LICENSE.md for full copyright and license
# information, respectively. These files are also available online at the URL
# "https://github.com/watertap-org/watertap/"
#################################################################################

import pandas as pd

from pyomo.environ import (
    Var,
    Param,
    value,
    Expression,
    Constraint,
    units as pyunits,
    check_optimal_termination,
)

from idaes.core import declare_process_block_class
import idaes.core.util.scaling as iscale
from idaes.core.util.exceptions import InitializationError
import idaes.logger as idaeslog

from watertap.core.solvers import get_solver
from watertap_contrib.reflo.core import SolarEnergyBaseData
from watertap_contrib.reflo.costing.solar.trough_surrogate import cost_trough_surrogate

__author__ = "Mukta Hardikar, Kurban Sitterley"


@declare_process_block_class("TroughSurrogate")
class TroughSurrogateData(SolarEnergyBaseData):
    """
    Surrogate model for trough collector system
    for industrial process heat (IPH) applications.
    """

    def build(self):
        super().build()
        self._tech_type = "trough"

        self.row_spacing = Param(
            initialize=15,
            units=pyunits.m,
            mutable=True,
            doc="Spacing between rows of collectors",
        )

        self.maximum_sca_width = Param(
            initialize=8.2,
            units=pyunits.m,
            mutable=True,
            doc="Width of solar collector assembly (sca) aperture",
        )

        self.land_area = Var(
            initialize=0, units=pyunits.acre, bounds=(0, None), doc="Land area in acres"
        )

        if "hours_storage" not in self.input_labels:

            if "hours_storage" in self.data.columns:
                self.hours_storage = Param(
                    initialize=self.data["hours_storage"].mean(),
                    units=pyunits.hour,
                    mutable=True,
                    doc="Hours of storage",
                )

            else:
                self.hours_storage = Param(
                    initialize=24,
                    units=pyunits.hour,
                    mutable=True,
                    doc="Hours of storage",
                )

        if "temperature_loop" not in self.input_labels:

            if "temperature_loop" in self.data.columns:
                self.temperature_loop = Param(
                    initialize=self.data["temperature_loop"].mean(),
                    units=pyunits.degK,
                    mutable=True,
                    doc="Target loop outlet temperature",
                )

            else:
                self.temperature_loop = Param(
                    initialize=300,
                    units=pyunits.degK,
                    mutable=True,
                    doc="Target loop outlet temperature",
                )

        if self.config.scale_training_data:

            self.heat_annual = Expression(
                expr=self.heat_annual_scaled / self.heat_annual_scaling,
                doc="Annual heat generated by trough in kWh/year",
            )

            self.electricity_annual = Expression(
                expr=self.electricity_annual_scaled / self.electricity_annual_scaling,
                doc="Annual electricity consumed by trough in kWh/year",
            )

            self.total_aperture_area = Expression(
                expr=self.total_aperture_area_scaled / self.total_aperture_area_scaling,
                doc="Total aperture area of trough in m²",
            )

        if self.config.surrogate_model_file is not None:
            self.load_surrogate()
        else:
            self.create_rbf_surrogate()

        self.heat_constraint = Constraint(
            expr=self.heat == pyunits.convert(self.heat_annual, to_units=pyunits.kW)
        )

        self.electricity_constraint = Constraint(
            expr=self.electricity
            == pyunits.convert(self.electricity_annual, to_units=pyunits.kW)
        )

        # Solar Field Area (acres) = Actual Aperture (m²) × Row Spacing (m) / Maximum SCA Width (m) × 0.0002471 (acres/m²)

        self.land_area_constraint = Constraint(
            expr=self.land_area
            == pyunits.convert(
                self.total_aperture_area * self.row_spacing / self.maximum_sca_width,
                to_units=pyunits.acre,
            )
        )

    def calculate_scaling_factors(self):

        if iscale.get_scaling_factor(self.system_capacity) is None:
            iscale.set_scaling_factor(self.system_capacity, 1)

        if iscale.get_scaling_factor(self.hours_storage) is None:
            iscale.set_scaling_factor(self.hours_storage, 1)

        if iscale.get_scaling_factor(self.temperature_loop) is None:
            iscale.set_scaling_factor(self.temperature_loop, 1)

        if iscale.get_scaling_factor(self.heat) is None:
            iscale.set_scaling_factor(self.heat, 1e-4)

        if iscale.get_scaling_factor(self.electricity) is None:
            iscale.set_scaling_factor(self.electricity, 1e-3)

        if iscale.get_scaling_factor(self.total_aperture_area) is None:
            iscale.set_scaling_factor(self.total_aperture_area, 1e-6)

        if iscale.get_scaling_factor(self.land_area) is None:
            iscale.set_scaling_factor(self.land_area, 0.1)

        if self.config.scale_training_data:
            if iscale.get_scaling_factor(self.heat_annual_scaled) is None:
                iscale.set_scaling_factor(self.heat_annual_scaled, 1)

            if iscale.get_scaling_factor(self.electricity_annual_scaled) is None:
                iscale.set_scaling_factor(self.electricity_annual_scaled, 1)

            if iscale.get_scaling_factor(self.total_aperture_area_scaled) is None:
                iscale.set_scaling_factor(self.total_aperture_area_scaled, 1)

        else:
            if iscale.get_scaling_factor(self.heat_annual) is None:
                iscale.set_scaling_factor(self.heat_annual, 1e-5)

            if iscale.get_scaling_factor(self.electricity_annual) is None:
                iscale.set_scaling_factor(self.electricity_annual, 1e-5)

            if iscale.get_scaling_factor(self.total_aperture_area) is None:
                iscale.set_scaling_factor(self.total_aperture_area, 1e-3)

    def initialize_build(
        self,
        outlvl=idaeslog.NOTSET,
        solver=None,
        optarg=None,
    ):
        """
        General wrapper for initialization routines

        Keyword Arguments:
            outlvl : sets output level of initialization routine
            optarg : solver options dictionary object (default=None)
            solver : str indicating which solver to use during
                     initialization (default = None)

        Returns: None
        """
        init_log = idaeslog.getInitLogger(self.name, outlvl, tag="unit")
        solve_log = idaeslog.getSolveLogger(self.name, outlvl, tag="unit")

        # Initialize surrogate
        self.init_data = pd.DataFrame(
            {
                "system_capacity": [value(self.system_capacity)],
                "hours_storage": [value(self.hours_storage)],
                "temperature_loop": [value(self.temperature_loop)],
            }
        )
        self.init_output = self.surrogate.evaluate_surrogate(self.init_data)
        self.heat_annual_scaled.set_value(self.init_output.heat_annual_scaled.values[0])
        self.electricity_annual_scaled.set_value(
            self.init_output.electricity_annual_scaled.values[0]
        )
        self.heat.set_value(value(self.heat_annual) / 8766)
        self.electricity.set_value(value(self.electricity_annual) / 8766)

        # Solve unit
        opt = get_solver(solver, optarg)
        with idaeslog.solver_log(solve_log, idaeslog.DEBUG) as slc:
            res = opt.solve(self, tee=slc.tee)

        init_log.info_high(f"Initialization Step 2 {idaeslog.condition(res)}")

        if not check_optimal_termination(res):
            raise InitializationError(f"Unit model {self.name} failed to initialize")

        init_log.info("Initialization Complete: {}".format(idaeslog.condition(res)))

    @property
    def default_costing_method(self):
        return cost_trough_surrogate
