import asyncio
import json
import logging
import os
import pathlib
import random
import time
from collections import Counter, defaultdict
from datetime import datetime, timedelta, timezone
from datetime import time as dt_time
from typing import (
    BinaryIO,
    Generic,
    List,
    Optional,
    Type,
    TypeVar,
    Union,
)
from urllib import parse

import httpx
from croniter import CroniterBadCronError, croniter
from pydantic import BaseModel, ConfigDict, ValidationError
from pyrogram import Client as BaseClient
from pyrogram import errors, filters
from pyrogram.enums import ChatMembersFilter, ChatType
from pyrogram.handlers import MessageHandler
from pyrogram.methods.utilities.idle import idle
from pyrogram.session import Session
from pyrogram.storage import MemoryStorage
from pyrogram.types import (
    Chat,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    Message,
    Object,
    User,
)

from tg_signer.config import (
    ActionT,
    BaseJSONConfig,
    ChooseOptionByImageAction,
    ClickKeyboardByTextAction,
    HttpCallback,
    MatchConfig,
    MonitorConfig,
    ReplyByCalculationProblemAction,
    SendDiceAction,
    SendTextAction,
    SignChatV3,
    SignConfigV3,
    SupportAction,
    UDPForward,
)

from .ai_tools import (
    calculate_problem,
    choose_option_by_image,
    get_openai_client,
    get_reply,
)
from .notification.server_chan import sc_send
from .utils import NumberingLangT, numbering

logger = logging.getLogger("tg-signer")

print_to_user = print

DICE_EMOJIS = ("üé≤", "üéØ", "üèÄ", "‚öΩ", "üé≥", "üé∞")

Session.START_TIMEOUT = 5  # ÂéüÂßãË∂ÖÊó∂Êó∂Èó¥‰∏∫2ÁßíÔºå‰ΩÜ‰∏Ä‰∫õ‰ª£ÁêÜËÆøÈóÆ‰ºöË∂ÖÊó∂ÔºåÊâÄ‰ª•ËøôÈáåË∞ÉÂ§ß‰∏ÄÁÇπ


class UserInput:
    def __init__(self, index: int = 1, numbering_lang: NumberingLangT = "arabic"):
        self.index = index
        self.numbering_lang = numbering_lang

    def incr(self, n: int = 1):
        self.index += n

    def decr(self, n: int = 1):
        self.index -= n

    @property
    def index_str(self):
        return f"{numbering(self.index, self.numbering_lang)}. "

    def __call__(self, prompt: str = None):
        r = input(f"{self.index_str}{prompt}")
        self.incr(1)
        return r


def indent(
    s: str,
    level=0,
    indentation: str = "\t",
    sep: str = "\n",
):
    r = ""
    for line in s.split(sep):
        r += indentation * level + line + sep
    return r


def readable_message(message: Message):
    s = "\nMessage: "
    s += f"\n  text: {message.text or ''}"
    if message.photo:
        s += f"\n  ÂõæÁâá: [({message.photo.width}x{message.photo.height}) {message.caption}]"
    if message.reply_markup:
        if isinstance(message.reply_markup, InlineKeyboardMarkup):
            s += "\n  InlineKeyboard: "
            for row in message.reply_markup.inline_keyboard:
                s += "\n   "
                for button in row:
                    s += f"{button.text} | "
    return s


def readable_chat(chat: Chat):
    if chat.type == ChatType.BOT:
        type_ = "BOT"
    elif chat.type == ChatType.GROUP:
        type_ = "Áæ§ÁªÑ"
    elif chat.type == ChatType.SUPERGROUP:
        type_ = "Ë∂ÖÁ∫ßÁæ§ÁªÑ"
    elif chat.type == ChatType.CHANNEL:
        type_ = "È¢ëÈÅì"
    else:
        type_ = "‰∏™‰∫∫"

    none_or_dash = lambda x: x or "-"  # noqa: E731

    return f"id: {chat.id}, username: {none_or_dash(chat.username)}, title: {none_or_dash(chat.title)}, type: {type_}, name: {none_or_dash(chat.first_name)}"


_CLIENT_INSTANCES: dict[str, "Client"] = {}

# reference counts and async locks for shared client lifecycle management
# Keyed by account name. Use asyncio locks to serialize start/stop operations
# so multiple coroutines in the same process can safely share one Client.
_CLIENT_REFS: defaultdict[str, int] = defaultdict(int)
_CLIENT_ASYNC_LOCKS: dict[str, asyncio.Lock] = {}


class Client(BaseClient):
    def __init__(self, name: str, *args, **kwargs):
        key = kwargs.pop("key", None)
        super().__init__(name, *args, **kwargs)
        self.key = key or str(self.session_string_file.resolve())
        if self.in_memory and not self.session_string:
            self.load_session_string()
            self.storage = MemoryStorage(self.name, self.session_string)

    async def __aenter__(self):
        lock = _CLIENT_ASYNC_LOCKS.get(self.key)
        if lock is None:
            lock = asyncio.Lock()
            _CLIENT_ASYNC_LOCKS[self.key] = lock
        async with lock:
            _CLIENT_REFS[self.key] += 1
            if _CLIENT_REFS[self.key] == 1:
                try:
                    await self.start()
                except ConnectionError:
                    pass
            return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        lock = _CLIENT_ASYNC_LOCKS.get(self.key)
        if lock is None:
            return
        async with lock:
            _CLIENT_REFS[self.key] -= 1
            if _CLIENT_REFS[self.key] == 0:
                try:
                    await self.stop()
                except ConnectionError:
                    pass
                _CLIENT_INSTANCES.pop(self.key, None)

    @property
    def session_string_file(self):
        return self.workdir / (self.name + ".session_string")

    async def save_session_string(self):
        with open(self.session_string_file, "w") as fp:
            fp.write(await self.export_session_string())

    def load_session_string(self):
        logger.info("Loading session_string from local file.")
        if self.session_string_file.is_file():
            with open(self.session_string_file, "r") as fp:
                self.session_string = fp.read()
                logger.info("The session_string has been loaded.")
        return self.session_string

    async def log_out(
        self,
    ):
        await super().log_out()
        if self.session_string_file.is_file():
            os.remove(self.session_string_file)


def get_api_config():
    api_id = int(os.environ.get("TG_API_ID", 611335))
    api_hash = os.environ.get("TG_API_HASH", "d524b414d21f4d37f08684c1df41ac9c")
    return api_id, api_hash


def get_proxy(proxy: str = None):
    proxy = proxy or os.environ.get("TG_PROXY")
    if proxy:
        r = parse.urlparse(proxy)
        return {
            "scheme": r.scheme,
            "hostname": r.hostname,
            "port": r.port,
            "username": r.username,
            "password": r.password,
        }
    return None


def get_client(
    name: str = "my_account",
    proxy: dict = None,
    workdir: Union[str, pathlib.Path] = ".",
    session_string: str = None,
    in_memory: bool = False,
    **kwargs,
):
    proxy = proxy or get_proxy()
    api_id, api_hash = get_api_config()
    key = str(pathlib.Path(workdir).joinpath(name).resolve())
    if key in _CLIENT_INSTANCES:
        return _CLIENT_INSTANCES[key]
    client = Client(
        name,
        api_id=api_id,
        api_hash=api_hash,
        proxy=proxy,
        workdir=workdir,
        session_string=session_string,
        in_memory=in_memory,
        **kwargs,
    )
    _CLIENT_INSTANCES[key] = client
    return client


def get_now():
    return datetime.now(tz=timezone(timedelta(hours=8)))


def make_dirs(path: pathlib.Path, exist_ok=True):
    path = pathlib.Path(path)
    if not path.is_dir():
        os.makedirs(path, exist_ok=exist_ok)
    return path


ConfigT = TypeVar("ConfigT", bound=BaseJSONConfig)


class BaseUserWorker(Generic[ConfigT]):
    _workdir = "."
    _tasks_dir = "tasks"
    cfg_cls: Type["ConfigT"] = BaseJSONConfig

    def __init__(
        self,
        task_name: str = None,
        session_dir: str = ".",
        account: str = "my_account",
        proxy=None,
        workdir=None,
        session_string: str = None,
        in_memory: bool = False,
        *,
        loop: Optional[asyncio.AbstractEventLoop] = None,
    ):
        self.task_name = task_name or "my_task"
        self._session_dir = pathlib.Path(session_dir)
        self._account = account
        self._proxy = proxy
        if workdir:
            self._workdir = pathlib.Path(workdir)
        self.app = get_client(
            account,
            proxy,
            workdir=self._session_dir,
            session_string=session_string,
            in_memory=in_memory,
            loop=loop,
        )
        self.loop = self.app.loop
        self.user: Optional[User] = None
        self._config = None
        self.context = self.ensure_ctx()

    def ensure_ctx(self):
        return {}

    def app_run(self, coroutine=None):
        if coroutine is not None:
            run = self.loop.run_until_complete
            run(coroutine)
        else:
            self.app.run()

    @property
    def workdir(self) -> pathlib.Path:
        workdir = self._workdir
        make_dirs(workdir)
        return pathlib.Path(workdir)

    @property
    def tasks_dir(self):
        tasks_dir = self.workdir / self._tasks_dir
        make_dirs(tasks_dir)
        return pathlib.Path(tasks_dir)

    @property
    def task_dir(self):
        task_dir = self.tasks_dir / self.task_name
        make_dirs(task_dir)
        return task_dir

    def get_user_dir(self, user: User):
        user_dir = self.workdir / "users" / str(user.id)
        make_dirs(user_dir)
        return user_dir

    @property
    def config_file(self):
        return self.task_dir.joinpath("config.json")

    @property
    def config(self) -> ConfigT:
        return self._config or self.load_config()

    @config.setter
    def config(self, value):
        self._config = value

    def log(self, msg, level: str = "INFO", **kwargs):
        msg = f"Ë¥¶Êà∑„Äå{self._account}„Äç- ‰ªªÂä°„Äå{self.task_name}„Äç: {msg}"
        if level.upper() == "INFO":
            logger.info(msg, **kwargs)
        elif level.upper() == "WARNING":
            logger.warning(msg, **kwargs)
        elif level.upper() == "ERROR":
            logger.error(msg, **kwargs)
        elif level.upper() == "CRITICAL":
            logger.critical(msg, **kwargs)
        else:
            logger.debug(msg, **kwargs)

    def ask_for_config(self):
        raise NotImplementedError

    def write_config(self, config: BaseJSONConfig):
        with open(self.config_file, "w", encoding="utf-8") as fp:
            json.dump(config.to_jsonable(), fp, ensure_ascii=False)

    def reconfig(self):
        config = self.ask_for_config()
        self.write_config(config)
        return config

    def load_config(self, cfg_cls: Type[ConfigT] = None) -> ConfigT:
        cfg_cls = cfg_cls or self.cfg_cls
        if not self.config_file.exists():
            config = self.reconfig()
        else:
            with open(self.config_file, "r", encoding="utf-8") as fp:
                config, from_old = cfg_cls.load(json.load(fp))
                if from_old:
                    self.write_config(config)
        self.config = config
        return config

    def get_task_list(self):
        signs = []
        for d in os.listdir(self.tasks_dir):
            if self.tasks_dir.joinpath(d).is_dir():
                signs.append(d)
        return signs

    def list_(self):
        print_to_user("Â∑≤ÈÖçÁΩÆÁöÑ‰ªªÂä°Ôºö")
        for d in self.get_task_list():
            print_to_user(d)

    def set_me(self, user: User):
        self.user = user
        with open(
            self.get_user_dir(user).joinpath("me.json"), "w", encoding="utf-8"
        ) as fp:
            fp.write(str(user))

    async def login(self, num_of_dialogs=20, print_chat=True):
        app = self.app
        async with app:
            me = await app.get_me()
            self.set_me(me)
            latest_chats = []
            async for dialog in app.get_dialogs(num_of_dialogs):
                chat = dialog.chat
                latest_chats.append(
                    {
                        "id": chat.id,
                        "title": chat.title,
                        "type": chat.type,
                        "username": chat.username,
                        "first_name": chat.first_name,
                        "last_name": chat.last_name,
                    }
                )
                if print_chat:
                    print_to_user(readable_chat(chat))

            with open(
                self.get_user_dir(me).joinpath("latest_chats.json"),
                "w",
                encoding="utf-8",
            ) as fp:
                json.dump(
                    latest_chats,
                    fp,
                    indent=4,
                    default=Object.default,
                    ensure_ascii=False,
                )
            await self.app.save_session_string()

    async def logout(self):
        is_authorized = await self.app.connect()
        if not is_authorized:
            await self.app.storage.delete()
            return None
        return await self.app.log_out()

    async def send_message(
        self, chat_id: Union[int, str], text: str, delete_after: int = None, **kwargs
    ):
        """
        ÂèëÈÄÅÊñáÊú¨Ê∂àÊÅØ
        :param chat_id:
        :param text:
        :param delete_after: Áßí, ÂèëÈÄÅÊ∂àÊÅØÂêéËøõË°åÂà†Èô§Ôºå``None`` Ë°®Á§∫‰∏çÂà†Èô§, ``0`` Ë°®Á§∫Á´ãÂç≥Âà†Èô§.
        :param kwargs:
        :return:
        """
        message = await self.app.send_message(chat_id, text, **kwargs)
        if delete_after is not None:
            self.log(
                f"Message„Äå{text}„Äç to {chat_id} will be deleted after {delete_after} seconds."
            )
            self.log("Waiting...")
            await asyncio.sleep(delete_after)
            await message.delete()
            self.log(f"Message„Äå{text}„Äç to {chat_id} deleted!")
        return message

    async def send_dice(
        self,
        chat_id: Union[int, str],
        emoji: str = "üé≤",
        delete_after: int = None,
        **kwargs,
    ):
        """
        ÂèëÈÄÅDICEÁ±ªÂûãÊ∂àÊÅØ
        :param chat_id:
        :param emoji: Should be one of "üé≤", "üéØ", "üèÄ", "‚öΩ", "üé≥", or "üé∞".
        :param delete_after:
        :param kwargs:
        :return:
        """
        emoji = emoji.strip()
        if emoji not in DICE_EMOJIS:
            self.log(
                f"Warning, emoji should be one of {', '.join(DICE_EMOJIS)}",
                level="WARNING",
            )
        message = await self.app.send_dice(chat_id, emoji, **kwargs)
        if message and delete_after is not None:
            self.log(
                f"Dice„Äå{emoji}„Äç to {chat_id} will be deleted after {delete_after} seconds."
            )
            self.log("Waiting...")
            await asyncio.sleep(delete_after)
            await message.delete()
            self.log(f"Dice„Äå{emoji}„Äç to {chat_id} deleted!")
        return message

    async def search_members(
        self, chat_id: Union[int, str], query: str, admin=False, limit=10
    ):
        filter_ = ChatMembersFilter.SEARCH
        if admin:
            filter_ = ChatMembersFilter.ADMINISTRATORS
            query = ""
        async for member in self.app.get_chat_members(
            chat_id, query, limit=limit, filter=filter_
        ):
            yield member

    async def list_members(
        self, chat_id: Union[int, str], query: str = "", admin=False, limit=10
    ):
        async with self.app:
            async for member in self.search_members(chat_id, query, admin, limit):
                print_to_user(
                    User(
                        id=member.user.id,
                        username=member.user.username,
                        first_name=member.user.first_name,
                        last_name=member.user.last_name,
                        is_bot=member.user.is_bot,
                    )
                )

    def export(self):
        with open(self.config_file, "r", encoding="utf-8") as fp:
            data = fp.read()
        return data

    def import_(self, config_str: str):
        with open(self.config_file, "w", encoding="utf-8") as fp:
            fp.write(config_str)

    def ask_one(self):
        raise NotImplementedError


class Waiter:
    def __init__(self):
        self.waiting_ids = set()
        self.waiting_counter = Counter()

    def add(self, elm):
        self.waiting_ids.add(elm)
        self.waiting_counter[elm] += 1

    def discard(self, elm):
        self.waiting_ids.discard(elm)
        self.waiting_counter.pop(elm, None)

    def sub(self, elm):
        self.waiting_counter[elm] -= 1
        if self.waiting_counter[elm] <= 0:
            self.discard(elm)

    def clear(self):
        self.waiting_ids.clear()
        self.waiting_counter.clear()

    def __bool__(self):
        return bool(self.waiting_ids)

    def __repr__(self):
        return f"<{self.__class__.__name__}: {self.waiting_counter}>"


class UserSignerWorkerContext(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True)

    waiter: Waiter
    sign_chats: defaultdict[int, List[SignChatV3]]
    chat_messages: defaultdict[int, List[Message]]


OPENAI_USE_PROMPT = 'Âú®ËøêË°åÂâçËØ∑ÈÄöËøáÁéØÂ¢ÉÂèòÈáèÊ≠£Á°ÆËÆæÁΩÆ`OPENAI_API_KEY`, `OPENAI_BASE_URL`„ÄÇÈªòËÆ§Ê®°Âûã‰∏∫"gpt-4o", ÂèØÈÄöËøáÁéØÂ¢ÉÂèòÈáè`OPENAI_MODEL`Êõ¥Êîπ„ÄÇ'


class UserSigner(BaseUserWorker[SignConfigV3]):
    _workdir = ".signer"
    _tasks_dir = "signs"
    cfg_cls = SignConfigV3
    context: UserSignerWorkerContext

    def ensure_ctx(self) -> UserSignerWorkerContext:
        return UserSignerWorkerContext(
            waiter=Waiter(),
            sign_chats=defaultdict(list),
            chat_messages=defaultdict(list),
        )

    @property
    def sign_record_file(self):
        sign_record_dir = self.task_dir / str(self.user.id)
        make_dirs(sign_record_dir)
        return sign_record_dir / "sign_record.json"

    def _ask_actions(
        self, input_: UserInput, available_actions: List[SupportAction] = None
    ) -> List[ActionT]:
        print_to_user(f"{input_.index_str}ÂºÄÂßãÈÖçÁΩÆ<Âä®‰Ωú>ÔºåËØ∑ÊåâÁÖßÂÆûÈôÖÁ≠æÂà∞È°∫Â∫èÈÖçÁΩÆ„ÄÇ")
        available_actions = available_actions or list(SupportAction)
        for action in available_actions:
            print_to_user(f"  {action.value}: {action.desc}")
        print_to_user()
        actions = []
        print_openai_prompt = False
        while True:
            try:
                local_input_ = UserInput()
                print_to_user(f"Á¨¨{len(actions) + 1}‰∏™Âä®‰Ωú: ")
                action_str = local_input_("ËæìÂÖ•ÂØπÂ∫îÁöÑÊï∞Â≠óÈÄâÊã©Âä®‰Ωú: ").strip()
                action = SupportAction(int(action_str))
                if action not in available_actions:
                    raise ValueError(f"‰∏çÊîØÊåÅÁöÑÂä®‰Ωú: {action}")
                if len(actions) == 0 and action not in [
                    SupportAction.SEND_TEXT,
                    SupportAction.SEND_DICE,
                ]:
                    raise ValueError(
                        f"Á¨¨‰∏Ä‰∏™Âä®‰ΩúÂøÖÈ°ª‰∏∫„Äå{SupportAction.SEND_TEXT.desc}„ÄçÊàñ„Äå{SupportAction.SEND_DICE.desc}„Äç"
                    )
                if action == SupportAction.SEND_TEXT:
                    text = local_input_("ËæìÂÖ•Ë¶ÅÂèëÈÄÅÁöÑÊñáÊú¨: ")
                    actions.append(SendTextAction(text=text))
                elif action == SupportAction.SEND_DICE:
                    dice = local_input_("ËæìÂÖ•Ë¶ÅÂèëÈÄÅÁöÑÈ™∞Â≠êÔºàÂ¶Ç üé≤, üéØÔºâ: ")
                    actions.append(SendDiceAction(dice=dice))
                elif action == SupportAction.CLICK_KEYBOARD_BY_TEXT:
                    text_of_btn_to_click = local_input_("ÈîÆÁõò‰∏≠ÈúÄË¶ÅÁÇπÂáªÁöÑÊåâÈíÆÊñáÊú¨: ")
                    actions.append(ClickKeyboardByTextAction(text=text_of_btn_to_click))
                elif action == SupportAction.CHOOSE_OPTION_BY_IMAGE:
                    print_to_user(
                        "ÂõæÁâáËØÜÂà´Â∞Ü‰ΩøÁî®Â§ßÊ®°ÂûãÂõûÁ≠îÔºåËØ∑Á°Æ‰øùÂ§ßÊ®°ÂûãÊîØÊåÅÂõæÁâáËØÜÂà´„ÄÇ"
                    )
                    print_openai_prompt = True
                    actions.append(ChooseOptionByImageAction())
                elif action == SupportAction.REPLY_BY_CALCULATION_PROBLEM:
                    print_to_user("ËÆ°ÁÆóÈ¢òÂ∞Ü‰ΩøÁî®Â§ßÊ®°ÂûãÂõûÁ≠î„ÄÇ")
                    print_openai_prompt = True
                    actions.append(ReplyByCalculationProblemAction())
                else:
                    raise ValueError(f"‰∏çÊîØÊåÅÁöÑÂä®‰Ωú: {action}")
                if local_input_("ÊòØÂê¶ÁªßÁª≠Ê∑ªÂä†Âä®‰ΩúÔºü(y/N)Ôºö").strip().lower() != "y":
                    break
            except (ValueError, ValidationError) as e:
                print_to_user("ÈîôËØØ: ")
                print_to_user(e)
        if print_openai_prompt:
            print_to_user(OPENAI_USE_PROMPT)
        input_.incr()
        return actions

    def ask_one(self) -> SignChatV3:
        input_ = UserInput(numbering_lang="chinese_simple")
        chat_id = int(input_("Chat IDÔºàÁôªÂΩïÊó∂ÊúÄËøëÂØπËØùËæìÂá∫‰∏≠ÁöÑIDÔºâ: "))
        name = input_("ChatÂêçÁß∞ÔºàÂèØÈÄâÔºâ: ")
        actions = self._ask_actions(input_)
        delete_after = (
            input_(
                "Á≠âÂæÖNÁßíÂêéÂà†Èô§Ê∂àÊÅØÔºàÂèëÈÄÅÊ∂àÊÅØÂêéÁ≠âÂæÖËøõË°åÂà†Èô§, '0'Ë°®Á§∫Á´ãÂç≥Âà†Èô§, ‰∏çÈúÄË¶ÅÂà†Èô§Áõ¥Êé•ÂõûËΩ¶Ôºâ, N: "
            )
            or None
        )
        if delete_after:
            delete_after = int(delete_after)
        cfgs = {
            "chat_id": chat_id,
            "name": name,
            "delete_after": delete_after,
            "actions": actions,
        }
        return SignChatV3.model_validate(cfgs)

    def ask_for_config(self) -> "SignConfigV3":
        chats = []
        i = 1
        print_to_user(f"ÂºÄÂßãÈÖçÁΩÆ‰ªªÂä°<{self.task_name}>\n")
        while True:
            print_to_user(f"Á¨¨{i}‰∏™‰ªªÂä°: ")
            try:
                chat = self.ask_one()
                print_to_user(chat)
                print_to_user(f"Á¨¨{i}‰∏™‰ªªÂä°ÈÖçÁΩÆÊàêÂäü\n")
                chats.append(chat)
            except Exception as e:
                print_to_user(e)
                print_to_user("ÈÖçÁΩÆÂ§±Ë¥•")
                i -= 1
            continue_ = input("ÁªßÁª≠ÈÖçÁΩÆ‰ªªÂä°Ôºü(y/N)Ôºö")
            if continue_.strip().lower() != "y":
                break
            i += 1
        sign_at_prompt = "Á≠æÂà∞Êó∂Èó¥ÔºàtimeÊàñcrontabË°®ËææÂºèÔºåÂ¶Ç'06:00:00'Êàñ'0 6 * * *'Ôºâ: "
        sign_at_str = input(sign_at_prompt) or "06:00:00"
        while not (sign_at := self._validate_sign_at(sign_at_str)):
            print_to_user("ËØ∑ËæìÂÖ•Ê≠£Á°ÆÁöÑÊó∂Èó¥Ê†ºÂºè")
            sign_at_str = input(sign_at_prompt) or "06:00:00"

        random_seconds_str = input("Á≠æÂà∞Êó∂Èó¥ËØØÂ∑ÆÈöèÊú∫ÁßíÊï∞ÔºàÈªòËÆ§‰∏∫0Ôºâ: ") or "0"
        random_seconds = int(float(random_seconds_str))
        config = SignConfigV3.model_validate(
            {
                "chats": chats,
                "sign_at": sign_at,
                "random_seconds": random_seconds,
            }
        )
        return config

    @classmethod
    def _validate_sign_at(cls, sign_at_str: str) -> Optional[str]:
        sign_at_str = sign_at_str.replace("Ôºö", ":").strip()

        try:
            sign_at = dt_time.fromisoformat(sign_at_str)
            crontab_expr = cls._time_to_crontab(sign_at)
        except ValueError:
            try:
                croniter(sign_at_str)
                crontab_expr = sign_at_str
            except CroniterBadCronError:
                return None
        return crontab_expr

    @staticmethod
    def _time_to_crontab(sign_at: time) -> str:
        return f"{sign_at.minute} {sign_at.hour} * * *"

    def load_sign_record(self):
        sign_record = {}
        if not self.sign_record_file.is_file():
            with open(self.sign_record_file, "w", encoding="utf-8") as fp:
                json.dump(sign_record, fp)
        else:
            with open(self.sign_record_file, "r", encoding="utf-8") as fp:
                sign_record = json.load(fp)
        return sign_record

    async def sign(
        self,
        chat: SignChatV3,
    ):
        self.log(f"ÂºÄÂßãÊâßË°å: \n{chat}")
        for action in chat.actions:
            await self.wait_for(chat, action)
            await asyncio.sleep(chat.action_interval)

    async def run(
        self, num_of_dialogs=20, only_once: bool = False, force_rerun: bool = False
    ):
        if self.user is None:
            await self.login(num_of_dialogs, print_chat=True)

        config = self.load_config(self.cfg_cls)
        sign_record = self.load_sign_record()
        chat_ids = [c.chat_id for c in config.chats]

        async def sign_once():
            for chat in config.chats:
                self.context.sign_chats[chat.chat_id].append(chat)
                try:
                    await self.sign(chat)
                except errors.RPCError as _e:
                    self.log(f"Á≠æÂà∞Â§±Ë¥•: {_e} \nchat: \n{chat}")
                    logger.warning(_e, exc_info=True)
                    continue

                self.context.chat_messages[chat.chat_id].clear()
                await asyncio.sleep(config.sign_interval)
            sign_record[str(now.date())] = now.isoformat()
            with open(self.sign_record_file, "w", encoding="utf-8") as fp:
                json.dump(sign_record, fp)

        def need_sign(last_date_str):
            if force_rerun:
                return True
            if last_date_str not in sign_record:
                return True
            _last_sign_at = datetime.fromisoformat(sign_record[last_date_str])
            self.log(f"‰∏äÊ¨°ÊâßË°åÊó∂Èó¥: {_last_sign_at}")
            _cron_it = croniter(self._validate_sign_at(config.sign_at), _last_sign_at)
            _next_run: datetime = _cron_it.next(datetime)
            if _next_run > now:
                self.log("ÂΩìÂâçÊú™Âà∞‰∏ãÊ¨°ÊâßË°åÊó∂Èó¥ÔºåÊó†ÈúÄÊâßË°å")
                return False
            return True

        while True:
            self.log(f"‰∏∫‰ª•‰∏ãChatÊ∑ªÂä†Ê∂àÊÅØÂõûË∞ÉÂ§ÑÁêÜÂáΩÊï∞Ôºö{chat_ids}")
            self.app.add_handler(
                MessageHandler(self.on_message, filters.chat(chat_ids))
            )
            try:
                async with self.app:
                    now = get_now()
                    self.log(f"ÂΩìÂâçÊó∂Èó¥: {now}")
                    now_date_str = str(now.date())
                    self.context = self.ensure_ctx()
                    if need_sign(now_date_str):
                        await sign_once()

            except (OSError, errors.Unauthorized) as e:
                logger.exception(e)
                await asyncio.sleep(30)
                continue

            if only_once:
                break
            cron_it = croniter(self._validate_sign_at(config.sign_at), now)
            next_run: datetime = cron_it.next(datetime) + timedelta(
                seconds=random.randint(0, int(config.random_seconds))
            )
            self.log(f"‰∏ãÊ¨°ËøêË°åÊó∂Èó¥: {next_run}")
            await asyncio.sleep((next_run - now).total_seconds())

    async def run_once(self, num_of_dialogs):
        return await self.run(num_of_dialogs, only_once=True, force_rerun=True)

    async def send_text(
        self, chat_id: int, text: str, delete_after: int = None, **kwargs
    ):
        if self.user is None:
            await self.login(print_chat=False)
        async with self.app:
            await self.send_message(chat_id, text, delete_after, **kwargs)

    async def send_dice_cli(
        self,
        chat_id: Union[str, int],
        emoji: str = "üé≤",
        delete_after: int = None,
        **kwargs,
    ):
        if self.user is None:
            await self.login(print_chat=False)
        async with self.app:
            await self.send_dice(chat_id, emoji, delete_after, **kwargs)

    async def on_message(self, client, message: Message):
        try:
            await self._on_message(client, message)
        except Exception as e:
            logger.exception(e)

    async def _on_message(self, client: Client, message: Message):
        self.log(
            f"Êî∂Âà∞Êù•Ëá™„Äå{message.from_user.username or message.from_user.id}„ÄçÁöÑÊ∂àÊÅØ: {readable_message(message)}"
        )
        chats = self.context.sign_chats.get(message.chat.id)
        if not chats:
            self.log("ÂøΩÁï•ÊÑèÊñô‰πãÂ§ñÁöÑËÅäÂ§©", level="WARNING")
            return
        self.context.chat_messages[message.chat.id].append(message)

    async def _click_keyboard_by_text(
        self, action: ClickKeyboardByTextAction, message: Message
    ):
        if reply_markup := message.reply_markup:
            if isinstance(reply_markup, InlineKeyboardMarkup):
                flat_buttons = (b for row in reply_markup.inline_keyboard for b in row)
                option_to_btn: dict[str, InlineKeyboardButton] = {}
                for btn in flat_buttons:
                    option_to_btn[btn.text] = btn
                    if action.text in btn.text:
                        self.log(f"ÁÇπÂáªÊåâÈíÆ: {btn.text}")
                        await self.request_callback_answer(
                            self.app,
                            message.chat.id,
                            message.id,
                            btn.callback_data,
                        )
                        return True
        return False

    async def _reply_by_calculation_problem(
        self, action: ReplyByCalculationProblemAction, message
    ):
        if message.text:
            self.log("Ê£ÄÊµãÂà∞ÊñáÊú¨ÂõûÂ§çÔºåÂ∞ùËØïË∞ÉÁî®Â§ßÊ®°ÂûãËøõË°åËÆ°ÁÆóÈ¢òÂõûÁ≠î")
            ai_client = get_openai_client()
            if not ai_client:
                self.log("Êú™ÈÖçÁΩÆOpenAI API KeyÔºåÊó†Ê≥ï‰ΩøÁî®AIÊúçÂä°", level="WARNING")
                return False
            self.log(f"ÈóÆÈ¢ò: \n{message.text}")
            answer = await calculate_problem(message.text, client=ai_client)
            self.log(f"ÂõûÁ≠î‰∏∫: {answer}")
            await self.send_message(message.chat.id, answer)
            return True
        return False

    async def _choose_option_by_image(self, action: ChooseOptionByImageAction, message):
        if reply_markup := message.reply_markup:
            if isinstance(reply_markup, InlineKeyboardMarkup) and message.photo:
                flat_buttons = (b for row in reply_markup.inline_keyboard for b in row)
                option_to_btn = {btn.text: btn for btn in flat_buttons if btn.text}
                self.log("Ê£ÄÊµãÂà∞ÂõæÁâáÔºåÂ∞ùËØïË∞ÉÁî®Â§ßÊ®°ÂûãËøõË°åÂõæÁâáËØÜÂà´Âπ∂ÈÄâÊã©ÈÄâÈ°π")
                ai_client = get_openai_client()
                if not ai_client:
                    self.log(
                        "Êú™ÈÖçÁΩÆOpenAI API KeyÔºåÊó†Ê≥ï‰ΩøÁî®AIÊúçÂä°",
                        level="WARNING",
                    )
                    return False
                image_buffer: BinaryIO = await self.app.download_media(
                    message.photo.file_id, in_memory=True
                )
                image_buffer.seek(0)
                image_bytes = image_buffer.read()
                options = list(option_to_btn)
                result_index = await choose_option_by_image(
                    image_bytes,
                    "ÈÄâÊã©Ê≠£Á°ÆÁöÑÈÄâÈ°π",
                    list(enumerate(options)),
                    client=ai_client,
                )
                result = options[result_index]
                self.log(f"ÈÄâÊã©ÁªìÊûú‰∏∫: {result}")
                target_btn = option_to_btn.get(result.strip())
                if not target_btn:
                    self.log("Êú™ÊâæÂà∞ÂåπÈÖçÁöÑÊåâÈíÆ", level="WARNING")
                    return False
                await self.request_callback_answer(
                    self.app,
                    message.chat.id,
                    message.id,
                    target_btn.callback_data,
                )
                return True
        return False

    async def wait_for(self, chat: SignChatV3, action: ActionT, timeout=10):
        self.log(f"Â§ÑÁêÜÂä®‰Ωú: {action}")
        if isinstance(action, SendTextAction):
            return await self.send_message(chat.chat_id, action.text, chat.delete_after)
        elif isinstance(action, SendDiceAction):
            return await self.send_dice(chat.chat_id, action.dice, chat.delete_after)
        self.context.waiter.add(chat.chat_id)
        start = time.perf_counter()
        self.log(f"Á≠âÂæÖÂ§ÑÁêÜÂä®‰Ωú: {action}")
        last_message = None
        while time.perf_counter() - start < timeout:
            await asyncio.sleep(0.3)
            messages = self.context.chat_messages.get(chat.chat_id)
            if not messages:
                continue
            # ÊöÇÊó†Êñ∞Ê∂àÊÅØ
            if messages[-1] == last_message:
                continue
            last_message = messages[-1]
            for message in messages:
                ok = False
                if isinstance(action, ClickKeyboardByTextAction):
                    ok = await self._click_keyboard_by_text(action, message)
                elif isinstance(action, ReplyByCalculationProblemAction):
                    ok = await self._reply_by_calculation_problem(action, message)
                elif isinstance(action, ChooseOptionByImageAction):
                    ok = await self._choose_option_by_image(action, message)
                if ok:
                    self.context.waiter.sub(message.chat.id)
                    # ËøôÈáåÁßªÈô§‰∫ÜËØ•Ê∂àÊÅØÔºåÊ∂àÊÅØÂàóË°®‰∏çÂèØÂÜçËø≠‰ª£
                    self.context.chat_messages[chat.chat_id].remove(message)
                    return None
                self.log(f"ÂøΩÁï•Ê∂àÊÅØ: {readable_message(message)}")
        self.log(f"Á≠âÂæÖË∂ÖÊó∂: \nchat: \n{chat} \naction: {action}", level="WARNING")
        return None

    async def request_callback_answer(
        self,
        client: Client,
        chat_id: Union[int, str],
        message_id: int,
        callback_data: Union[str, bytes],
        **kwargs,
    ):
        try:
            await client.request_callback_answer(
                chat_id, message_id, callback_data=callback_data, **kwargs
            )
            self.log("ÁÇπÂáªÂÆåÊàê")
        except (errors.BadRequest, TimeoutError) as e:
            self.log(e, level="ERROR")

    async def schedule_messages(
        self,
        chat_id: Union[int, str],
        text: str,
        crontab: str = None,
        next_times: int = 1,
        random_seconds: int = 0,
    ):
        now = get_now()
        it = croniter(crontab, start_time=now)
        if self.user is None:
            await self.login(print_chat=False)
        results = []
        async with self.app:
            for n in range(next_times):
                next_dt: datetime = it.next(ret_type=datetime) + timedelta(
                    seconds=random.randint(0, random_seconds)
                )
                results.append({"at": next_dt.isoformat(), "text": text})
                await self.app.send_message(
                    chat_id,
                    text,
                    schedule_date=next_dt,
                )
                await asyncio.sleep(0.1)
                print_to_user(f"Â∑≤ÈÖçÁΩÆÊ¨°Êï∞Ôºö{n + 1}")
        self.log(f"Â∑≤ÈÖçÁΩÆÂÆöÊó∂ÂèëÈÄÅÊ∂àÊÅØÔºåÊ¨°Êï∞{next_times}")
        return results

    async def get_schedule_messages(self, chat_id):
        if self.user is None:
            await self.login(print_chat=False)
        async with self.app:
            messages = await self.app.get_scheduled_messages(chat_id)
            for message in messages:
                print_to_user(f"{message.date}: {message.text}")


class UserMonitor(BaseUserWorker[MonitorConfig]):
    _workdir = ".monitor"
    _tasks_dir = "monitors"
    cfg_cls = MonitorConfig
    config: MonitorConfig

    def ask_one(self):
        input_ = UserInput()
        chat_id = (input_("Chat IDÔºàÁôªÂΩïÊó∂ÊúÄËøëÂØπËØùËæìÂá∫‰∏≠ÁöÑIDÔºâ: ")).strip()
        if not chat_id.startswith("@"):
            chat_id = int(chat_id)
        rules = ["exact", "contains", "regex", "all"]
        while rule := (input_(f"ÂåπÈÖçËßÑÂàô({', '.join(rules)}): ") or "exact"):
            if rule in rules:
                break
            print_to_user("‰∏çÂ≠òÂú®ÁöÑËßÑÂàô, ËØ∑ÈáçÊñ∞ËæìÂÖ•!")
        rule_value = None
        if rule != "all":
            while not (rule_value := input_("ËßÑÂàôÂÄºÔºà‰∏çÂèØ‰∏∫Á©∫Ôºâ: ")):
                print_to_user("‰∏çÂèØ‰∏∫Á©∫ÔºÅ")
                continue
        from_user_ids = (
            input_(
                "Âè™ÂåπÈÖçÊù•Ëá™ÁâπÂÆöÁî®Êà∑IDÁöÑÊ∂àÊÅØÔºàÂ§ö‰∏™Áî®ÈÄóÂè∑ÈöîÂºÄ, ÂåπÈÖçÊâÄÊúâÁî®Êà∑Áõ¥Êé•ÂõûËΩ¶Ôºâ: "
            )
            or None
        )
        always_ignore_me = input_("ÊÄªÊòØÂøΩÁï•Ëá™Â∑±ÂèëÈÄÅÁöÑÊ∂àÊÅØÔºày/NÔºâ: ").lower() == "y"
        if from_user_ids:
            from_user_ids = [
                i if i.startswith("@") else int(i) for i in from_user_ids.split(",")
            ]
        default_send_text = input_("ÈªòËÆ§ÂèëÈÄÅÊñáÊú¨Ôºà‰∏çÈúÄË¶ÅÂàôÂõûËΩ¶Ôºâ: ") or None
        ai_reply = False
        ai_prompt = None
        use_ai_reply = input_("ÊòØÂê¶‰ΩøÁî®AIËøõË°åÂõûÂ§ç(y/N): ") or "n"
        if use_ai_reply.lower() == "y":
            ai_reply = True
            while not (ai_prompt := input_("ËæìÂÖ•‰Ω†ÁöÑÊèêÁ§∫ËØçÔºà‰Ωú‰∏∫`system prompt`Ôºâ: ")):
                print_to_user("‰∏çÂèØ‰∏∫Á©∫ÔºÅ")
                continue
            print_to_user(OPENAI_USE_PROMPT)

        send_text_search_regex = None
        if not ai_reply:
            send_text_search_regex = (
                input_("‰ªéÊ∂àÊÅØ‰∏≠ÊèêÂèñÂèëÈÄÅÊñáÊú¨ÁöÑÊ≠£ÂàôË°®ËææÂºèÔºà‰∏çÈúÄË¶ÅÂàôÁõ¥Êé•ÂõûËΩ¶Ôºâ: ") or None
            )

        if default_send_text or ai_reply or send_text_search_regex:
            delete_after = (
                input_(
                    "ÂèëÈÄÅÊ∂àÊÅØÂêéÁ≠âÂæÖNÁßíËøõË°åÂà†Èô§Ôºà'0'Ë°®Á§∫Á´ãÂç≥Âà†Èô§, ‰∏çÈúÄË¶ÅÂà†Èô§Áõ¥Êé•ÂõûËΩ¶ÔºâÔºå N: "
                )
                or None
            )
            if delete_after:
                delete_after = int(delete_after)
            forward_to_chat_id = (
                input_("ËΩ¨ÂèëÊ∂àÊÅØÂà∞ËØ•ËÅäÂ§©IDÔºåÈªòËÆ§‰∏∫Ê∂àÊÅØÊù•Ê∫êÔºö")
            ).strip()
            if forward_to_chat_id and not forward_to_chat_id.startswith("@"):
                forward_to_chat_id = int(forward_to_chat_id)
        else:
            delete_after = None
            forward_to_chat_id = None

        push_via_server_chan = (
            input_("ÊòØÂê¶ÈÄöËøáServerÈÖ±Êé®ÈÄÅÊ∂àÊÅØ(y/N): ") or "n"
        ).lower() == "y"
        server_chan_send_key = None
        if push_via_server_chan:
            server_chan_send_key = (
                input_(
                    "ServerÈÖ±ÁöÑSendKeyÔºà‰∏çÂ°´Â∞Ü‰ªéÁéØÂ¢ÉÂèòÈáè`SERVER_CHAN_SEND_KEY`ËØªÂèñÔºâ: "
                )
                or None
            )

        forward_to_external = (
            input_("ÊòØÂê¶ÈúÄË¶ÅËΩ¨ÂèëÂà∞Â§ñÈÉ®ÔºàUDP, HttpÔºâ(y/N): ").lower() == "y"
        )
        external_forwards = None
        if forward_to_external:
            external_forwards = []
            if input_("ÊòØÂê¶ÈúÄË¶ÅËΩ¨ÂèëÂà∞UDP(y/N): ").lower() == "y":
                addr = input_("ËØ∑ËæìÂÖ•UDPÊúçÂä°Âô®Âú∞ÂùÄÂíåÁ´ØÂè£ÔºàÂΩ¢Â¶Ç`127.0.0.1:1234`Ôºâ: ")
                host, port = addr.split(":")
                external_forwards.append(
                    {
                        "host": host,
                        "port": int(port),
                    }
                )

            if input_("ÊòØÂê¶ÈúÄË¶ÅËΩ¨ÂèëÂà∞Http(y/N): ").lower() == "y":
                url = input_("ËØ∑ËæìÂÖ•HttpÂú∞ÂùÄÔºàÂΩ¢Â¶Ç`http://127.0.0.1:1234`Ôºâ: ")
                external_forwards.append(
                    {
                        "url": url,
                    }
                )

        return MatchConfig.model_validate(
            {
                "chat_id": chat_id,
                "rule": rule,
                "rule_value": rule_value,
                "from_user_ids": from_user_ids,
                "always_ignore_me": always_ignore_me,
                "default_send_text": default_send_text,
                "ai_reply": ai_reply,
                "ai_prompt": ai_prompt,
                "send_text_search_regex": send_text_search_regex,
                "delete_after": delete_after,
                "forward_to_chat_id": forward_to_chat_id,
                "push_via_server_chan": push_via_server_chan,
                "server_chan_send_key": server_chan_send_key,
                "external_forwards": external_forwards,
            }
        )

    def ask_for_config(self) -> "MonitorConfig":
        i = 1
        print_to_user(f"ÂºÄÂßãÈÖçÁΩÆ‰ªªÂä°<{self.task_name}>")
        print_to_user(
            "ËÅäÂ§©chat idÂíåÁî®Êà∑user idÂùáÂêåÊó∂ÊîØÊåÅÊï¥Êï∞idÂíåÂ≠óÁ¨¶‰∏≤username, usernameÂøÖÈ°ª‰ª•@ÂºÄÂ§¥ÔºåÂ¶Ç@neo"
        )
        match_cfgs = []
        while True:
            print_to_user(f"\nÈÖçÁΩÆÁ¨¨{i}‰∏™ÁõëÊéßÈ°π")
            try:
                match_cfgs.append(self.ask_one())
            except Exception as e:
                print_to_user(e)
                print_to_user("ÈÖçÁΩÆÂ§±Ë¥•")
                i -= 1
            continue_ = input("ÁªßÁª≠ÈÖçÁΩÆÔºü(y/N)Ôºö")
            if continue_.strip().lower() != "y":
                break
            i += 1
        return MonitorConfig(match_cfgs=match_cfgs)

    @classmethod
    async def udp_forward(cls, f: UDPForward, message: Message):
        data = str(message).encode("utf-8")
        loop = asyncio.get_running_loop()
        transport, protocol = await loop.create_datagram_endpoint(
            lambda: _UDPProtocol(), remote_addr=(f.host, f.port)
        )
        try:
            transport.sendto(data)
        finally:
            transport.close()

    @classmethod
    async def http_api_callback(cls, f: HttpCallback, message: Message):
        headers = f.headers or {}
        headers.update({"Content-Type": "application/json"})
        content = str(message).encode("utf-8")
        async with httpx.AsyncClient() as client:
            await client.post(
                str(f.url),
                content=content,
                headers=headers,
                timeout=10,
            )

    async def forward_to_external(self, match_cfg: MatchConfig, message: Message):
        if not match_cfg.external_forwards:
            return
        for forward in match_cfg.external_forwards:
            self.log(f"ËΩ¨ÂèëÊ∂àÊÅØËá≥{forward}")
            if isinstance(forward, UDPForward):
                asyncio.create_task(
                    self.udp_forward(
                        forward,
                        message,
                    )
                )
            elif isinstance(forward, HttpCallback):
                asyncio.create_task(
                    self.http_api_callback(
                        forward,
                        message,
                    )
                )

    async def on_message(self, client, message: Message):
        for match_cfg in self.config.match_cfgs:
            if not match_cfg.match(message):
                continue
            self.log(f"ÂåπÈÖçÂà∞ÁõëÊéßÈ°πÔºö{match_cfg}")
            await self.forward_to_external(match_cfg, message)
            try:
                send_text = await self.get_send_text(match_cfg, message)
                if not send_text:
                    self.log("ÂèëÈÄÅÂÜÖÂÆπ‰∏∫Á©∫", level="WARNING")
                else:
                    forward_to_chat_id = match_cfg.forward_to_chat_id or message.chat.id
                    self.log(f"ÂèëÈÄÅÊñáÊú¨Ôºö{send_text}Ëá≥{forward_to_chat_id}")
                    await self.send_message(
                        forward_to_chat_id,
                        send_text,
                        delete_after=match_cfg.delete_after,
                    )

                if match_cfg.push_via_server_chan:
                    server_chan_send_key = (
                        match_cfg.server_chan_send_key
                        or os.environ.get("SERVER_CHAN_SEND_KEY")
                    )
                    if not server_chan_send_key:
                        self.log("Êú™ÈÖçÁΩÆServerÈÖ±ÁöÑSendKey", level="WARNING")
                    else:
                        await sc_send(
                            server_chan_send_key,
                            f"ÂåπÈÖçÂà∞ÁõëÊéßÈ°πÔºö{match_cfg.chat_id}",
                            f"Ê∂àÊÅØÂÜÖÂÆπ‰∏∫:\n\n{message.text}",
                        )
            except IndexError as e:
                logger.exception(e)

    async def get_send_text(self, match_cfg: MatchConfig, message: Message) -> str:
        send_text = match_cfg.get_send_text(message.text)
        if match_cfg.ai_reply and match_cfg.ai_prompt:
            ai_client = get_openai_client()
            if not ai_client:
                self.log("Êú™ÈÖçÁΩÆOpenAI API KeyÔºåÊó†Ê≥ï‰ΩøÁî®AIÊúçÂä°", level="WARNING")
                return send_text
            send_text = await get_reply(
                match_cfg.ai_prompt, message.text, client=ai_client
            )
        return send_text

    async def run(self, num_of_dialogs=20):
        if self.user is None:
            await self.login(num_of_dialogs, print_chat=True)

        cfg = self.load_config(self.cfg_cls)
        self.app.add_handler(
            MessageHandler(self.on_message, filters.text & filters.chat(cfg.chat_ids)),
        )
        async with self.app:
            self.log("ÂºÄÂßãÁõëÊéß...")
            await idle()


class _UDPProtocol(asyncio.DatagramProtocol):
    """ÂÜÖÈÉ®‰ΩøÁî®ÁöÑUDPÂçèËÆÆÂ§ÑÁêÜÁ±ª"""

    def __init__(self):
        self.transport = None

    def connection_made(self, transport):
        self.transport = transport

    def datagram_received(self, data, addr):
        pass  # ‰∏çÈúÄË¶ÅÂ§ÑÁêÜÊé•Êî∂ÁöÑÊï∞ÊçÆ

    def error_received(self, exc):
        print(f"UDP error received: {exc}")
