{
  "issue_title": "输入验证：自输入型XSS",
  "issue_level": "High",
  "issue_count": "2",
  "issue_desc": "对于 Self-XSS，恶意内容通常采用 JavaScript 代码片段的形式，或者其他任意一种可以被浏览器执行的代码的形式。由于 Self-XSS 主要是对自身进行攻击，因此往往被认为不重要，但在以下情况下，应将其与标准 XSS 缺陷同等对待：\n在您的网站上识别到 Cross-Site Request Forgery 漏洞。社会工程攻击可能诱使用户攻击他们自己的帐户，从而破坏其会话。\n**例如**：考虑使用 HTML 表单。\n```&lt;div id=\"myDiv\"&gt;\n  Employee ID: &lt;input type=\"text\" id=\"eid\"&gt;&lt;br&gt;\n  ...\n  &lt;button&gt;Show results&lt;/button&gt;\n&lt;/div&gt;\n&lt;div id=\"resultsDiv\"&gt;\n  ...\n&lt;/div&gt;\n;\n```\n该段脚本解析URL，读取msg参数的值，并将其写入页面。如果攻击者设计一个恶意的URL，并以JavaScript代码作为msg参数，那么Web浏览器就会像显示HTTP响应那样执行该代码，应用程序将受到基于DOM的XSS攻击。",
  "fix_advice": "这里是对原始文本的整理，主要是对段落进行了分隔，同时对其中的特殊字符进行了处理，以便更好地阐明观点：\n\n---\n\n防止 XSS 漏洞的解决方法是确保在适当位置进行验证，并设置相关属性以防止漏洞。\n\n由于 XSS 漏洞在应用程序的输出中包含恶意数据时出现，因此，合乎逻辑的方法是在数据流出应用程序的前一刻（或在呈现之前（如果基于 DOM））对其进行验证。然而，由于 Web 应用程序常常会包含复杂而难以理解的代码，用以生成动态内容，因此，这一方法容易产生遗漏错误（遗漏验证）。降低这一风险的有效途径是对 XSS 也执行输入验证。\n\n由于 Web 应用程序必须验证所有输入信息以避免其他漏洞（如 SQL Injection），因此，一种相对简单的解决方法是，加强应用程序的现有输入验证机制，将 XSS 检测包括其中。尽管有一定的价值，但 XSS 输入验证并不能取代严格的输出验证。应用程序可能通过共享的数据存储器或其他可信赖的数据源接受输入，而该数据存储器所接受的输入源可能并未执行适当的输入验证。因此，应用程序不能间接地依赖于该数据或其他任意数据的安全性。这就意味着，避免 XSS 漏洞的最佳方法是验证所有进入应用程序以及由应用程序传送至用户端的数据。\n\n针对 XSS 漏洞进行验证最安全的方式是，创建一份安全字符允许列表，允许其中的字符出现在 HTTP 内容中，并且只接受完全由这些经认可的字符组成的输入。例如，有效的用户名可能仅包含字母数字字符，电话号码可能仅包含 0-9 的数字。然而，这种解决方法在 Web 应用程序中通常是行不通的，因为许多字符对浏览器来说都具有特殊的含义，编码时这些字符必须被视为合法输入，例如，一个 Web 设计电子公告栏就必须接受其用户提供的 HTML 片段。\n\n更灵活的方法是采用拒绝列表，但其安全性较差，这种方法在使用输入之前就有选择地拒绝或转义了潜在的危险字符。为了创建这样一个列表，首先需要了解对于 Web 浏览器具有特殊含义的字符集。虽然 HTML 标准定义了哪些字符具有特殊含义，许多 Web 浏览器仍会设法更正 HTML 中的常见错误，并可能在特定的上下文中认为其他字符具有特殊含义。这就是为何我们不鼓励使用拒绝列表作为阻止 XSS 的方法。卡耐基梅隆大学 (Carnegie Mellon University) 软件工程学院 (Software Engineering Institute) 下属的 CERT(R) (CERT(R) Coordination Center) 合作中心提供了有关各种上下文中认定的特殊字符的具体信息：\n\n在有关块级别元素的内容中（位于一段文本的中间）：\n\n- “&amp;lt;”是一个特殊字符，因为它可以引入一个标签。\n- “&amp;amp;”是一个特殊字符，因为它可以引入一个字符实体。\n- “&amp;gt;”是一个特殊字符，之所以某些浏览器将其视为特殊字符，是基于一种假设，即页面创建者本想在前面添加一个“&amp;lt;”，却错误地将其遗漏了。\n\n下面的这些原则适用于属性值：\n\n- 对于外加双引号的属性值，双引号是特殊字符，因为它们标记了该属性值的结束。\n- 对于外加单引号的属性值，单引号是特殊字符，因为它们标记了该属性值的结束。\n- 对于不带任何引号的属性值，空格字符（如空格符和制表符）是特殊字符。\n- “&amp;amp;”与某些特定属性一起使用时是特殊字符，因为它可以引入一个字符实体。\n\n例如，在 URL 中，搜索引擎可能会在结果页面内提供一个链接，用户可以单击该链接来重新运行搜索。可以将这一方法运用于编写 URL 中的搜索查询语句，这将引入更多特殊字符：\n\n- 空格符、制表符和换行符是特殊字符，因为它们标记了 URL 的结束。\n- “&amp;amp;”是特殊字符，因为它可以引入一个字符实体或分隔 CGI 参数。\n- 非 ASCII 字符（即 ISO-8859-1 编码表中所有大于 127 的字符）不允许出现在 URL 中，因此这些字符在此环境下被视为特殊字符。\n- 在服务器端对在 HTTP 转义序列中编码的参数进行解码时，必须过滤掉输入中的 \"%\" 符号。例如，当输入中出现“%68%65%6C%6C%6F”时，只有从输入的内容中过滤掉“%”，上述字符串才能在网页上显示为“hello”。\n\n在 &amp;lt;SCRIPT&amp;gt; &amp;lt;/SCRIPT&amp;gt; 正文中：\n\n- 如果可以将文本直接插入到已有的脚本标签中，则必须过滤\n\n掉分号、圆括号、花括号和换行符。\n\n服务器端脚本：\n\n- 如果服务器端脚本会将输入中的感叹号 (!) 转换成输出中的双引号 (\")，则可能需要对此进行更多过滤。\n\n其他可能出现的情况：\n\n- 如果攻击者以 UTF-7 格式提交了请求，则特殊字符“&amp;lt;”可能会显示为“+ADw-”，并可能会绕过过滤。如果输出包含在没有确切指定编码格式的网页中，某些浏览器就会设法根据内容自动识别编码（此处采用 UTF-7 格式）。\n\n在应用程序中确定针对 XSS 攻击执行验证的正确要点，以及验证过程中要考虑的特殊字符之后，下一个难点就是确定验证过程中处理各种特殊字符的方式。如果应用程序认定某些特殊字符为无效输入，那么您可以拒绝任何带有这些无效特殊字符的输入。第二种选择就是采用过滤手段来删除这些特殊字符。然而，过滤的负面作用在于，过滤内容的显示将发生改变。在需要完整显示输入内容的情况下，过滤的这种负面作用可能是无法接受的。\n\n如果必须接受带有特殊字符的输入，并将其准确地显示出来，验证机制一定要对所有特殊字符进行编码，以便删除其具有的含义。官方的 HTML 规范  提供了特殊字符对应的 ISO 8859-1 编码值的完整列表。\n\n许多应用程序服务器都试图避免应用程序出现 Cross-Site Scripting 漏洞，具体做法是为负责设置特定 HTTP 响应内容的函数提供各种实现方式，以检验是否存在进行 Cross-Site Scripting 攻击必需的字符。不要依赖运行应用程序的服务器，以此确保该应用程序的安全。对于任何已开发的应用程序，并不能保证在其生命周期中它会在哪些应用程序服务器中运行。由于标准和已知盗取方式的演变，我们不能保证应用程序服务器将继续保持同步。",
  "code_sample": "",
  "code_list": [
    {
      "code_location": "src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js",
      "code_line_num": "17",
      "code_details": "跟踪路径:跟踪路径1:\n\n1 src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js;12行读取来自于http请求的数据value\n\n2 src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js;12行不可信的数据从ajaxFunction()方法第1个参数进入\n\n3 src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js;17行不可信的数据从get()方法第1个参数进入"
    },
    {
      "code_location": "src/main/resources/lessons/clientsidefiltering/js/clientSideFilteringFree.js",
      "code_line_num": "41",
      "code_details": "跟踪路径:跟踪路径1:\n\n1 src/main/resources/lessons/clientsidefiltering/js/clientSideFilteringFree.js;40行来自于http请求的数据从val()方法返回值返回\n\n2 src/main/resources/lessons/clientsidefiltering/js/clientSideFilteringFree.js;40行赋值不可信的数据给变量checkoutCode\n\n3 src/main/resources/lessons/clientsidefiltering/js/clientSideFilteringFree.js;41行不可信的数据从get()方法第1个参数进入"
    }
  ],
  "next_block_start": 14
}