# This file was auto-generated by Fern from our API Definition.

import typing
from .....core.client_wrapper import SyncClientWrapper
from .types.items_list_items_request_sort_by import ItemsListItemsRequestSortBy
from .types.items_list_items_request_sort_order import ItemsListItemsRequestSortOrder
from .....core.request_options import RequestOptions
from .....types.collection_item_list import CollectionItemList
from .....core.jsonable_encoder import jsonable_encoder
from .....core.pydantic_utilities import parse_obj_as
from .....errors.bad_request_error import BadRequestError
from .....errors.unauthorized_error import UnauthorizedError
from .....types.error import Error
from .....errors.not_found_error import NotFoundError
from .....errors.too_many_requests_error import TooManyRequestsError
from .....errors.internal_server_error import InternalServerError
from json.decoder import JSONDecodeError
from .....core.api_error import ApiError
from .types.items_create_item_request import ItemsCreateItemRequest
from .....types.collection_item import CollectionItem
from .....core.serialization import convert_and_respect_annotation_metadata
from .types.items_delete_items_request_items_item import ItemsDeleteItemsRequestItemsItem
from .....errors.conflict_error import ConflictError
from .....types.collection_item_with_id_input import CollectionItemWithIdInput
from .types.items_list_items_live_request_sort_by import ItemsListItemsLiveRequestSortBy
from .types.items_list_items_live_request_sort_order import ItemsListItemsLiveRequestSortOrder
from .types.items_create_item_live_request import ItemsCreateItemLiveRequest
from .types.items_delete_items_live_request_items_item import ItemsDeleteItemsLiveRequestItemsItem
from .....types.collection_item_list_no_pagination import CollectionItemListNoPagination
from .types.create_bulk_collection_item_request_body_field_data import CreateBulkCollectionItemRequestBodyFieldData
from .....types.bulk_collection_item import BulkCollectionItem
from .....types.collection_item_patch_single_field_data import CollectionItemPatchSingleFieldData
from .types.items_publish_item_response import ItemsPublishItemResponse
from .....core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ItemsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list_items(
        self,
        collection_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        offset: typing.Optional[float] = None,
        limit: typing.Optional[float] = None,
        name: typing.Optional[str] = None,
        slug: typing.Optional[str] = None,
        sort_by: typing.Optional[ItemsListItemsRequestSortBy] = None,
        sort_order: typing.Optional[ItemsListItemsRequestSortOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItemList:
        """
        List of all Items within a Collection.

        Required scope | `CMS:read`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        offset : typing.Optional[float]
            Offset used for pagination if the results have more than limit records

        limit : typing.Optional[float]
            Maximum number of records to be returned (max limit: 100)

        name : typing.Optional[str]
            The name of the item(s)

        slug : typing.Optional[str]
            The slug of the item

        sort_by : typing.Optional[ItemsListItemsRequestSortBy]
            Sort results by the provided value

        sort_order : typing.Optional[ItemsListItemsRequestSortOrder]
            Sorts the results by asc or desc

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItemList
            Request was successful

        Examples
        --------
        from webflow import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.list_items(
            collection_id="580e63fc8c9a982ac9b8b745",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items",
            method="GET",
            params={
                "cmsLocaleId": cms_locale_id,
                "offset": offset,
                "limit": limit,
                "name": name,
                "slug": slug,
                "sortBy": sort_by,
                "sortOrder": sort_order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItemList,
                    parse_obj_as(
                        type_=CollectionItemList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_item(
        self,
        collection_id: str,
        *,
        request: ItemsCreateItemRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Create Item(s) in a Collection.


        To create items across multiple locales, please use [this endpoint.](/v2.0.0/data/reference/cms/collection-items/staged-items/create-items)

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        request : ItemsCreateItemRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        from webflow import (
            CollectionItemPostSingle,
            CollectionItemPostSingleFieldData,
            Webflow,
        )

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.create_item(
            collection_id="580e63fc8c9a982ac9b8b745",
            request=CollectionItemPostSingle(
                is_archived=False,
                is_draft=False,
                field_data=CollectionItemPostSingleFieldData(
                    name="Pan Galactic Gargle Blaster Recipe",
                    slug="pan-galactic-gargle-blaster",
                ),
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=ItemsCreateItemRequest, direction="write"
            ),
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItem,
                    parse_obj_as(
                        type_=CollectionItem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_items(
        self,
        collection_id: str,
        *,
        items: typing.Optional[typing.Sequence[ItemsDeleteItemsRequestItemsItem]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete Items from a Collection.

        **Note:** If the `cmsLocaleId` parameter is undefined or empty and the items are localized, items will be deleted only in the primary locale.

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        items : typing.Optional[typing.Sequence[ItemsDeleteItemsRequestItemsItem]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from webflow import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.delete_items(
            collection_id="580e63fc8c9a982ac9b8b745",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items",
            method="DELETE",
            json={
                "items": convert_and_respect_annotation_metadata(
                    object_=items, annotation=typing.Sequence[ItemsDeleteItemsRequestItemsItem], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_items(
        self,
        collection_id: str,
        *,
        items: typing.Optional[typing.Sequence[CollectionItemWithIdInput]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Update a single item or multiple items (up to 100) in a Collection.

        **Note:** If the `cmsLocaleId` parameter is undefined or empty and the items are localized, items will be updated only in the primary locale.

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        items : typing.Optional[typing.Sequence[CollectionItemWithIdInput]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        from webflow import (
            CollectionItemWithIdInput,
            CollectionItemWithIdInputFieldData,
            Webflow,
        )

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.update_items(
            collection_id="580e63fc8c9a982ac9b8b745",
            items=[
                CollectionItemWithIdInput(
                    id="66f6ed9576ddacf3149d5ea6",
                    cms_locale_id="66f6e966c9e1dc700a857ca5",
                    field_data=CollectionItemWithIdInputFieldData(
                        name="Ne Paniquez Pas",
                        slug="ne-paniquez-pas",
                    ),
                ),
                CollectionItemWithIdInput(
                    id="66f6ed9576ddacf3149d5ea6",
                    cms_locale_id="66f6e966c9e1dc700a857ca4",
                    field_data=CollectionItemWithIdInputFieldData(
                        name="No Entrar en Pánico",
                        slug="no-entrar-en-panico",
                    ),
                ),
                CollectionItemWithIdInput(
                    id="66f6ed9576ddacf3149d5eaa",
                    cms_locale_id="66f6e966c9e1dc700a857ca5",
                    field_data=CollectionItemWithIdInputFieldData(
                        name="Au Revoir et Merci pour Tous les Poissons",
                        slug="au-revoir-et-merci",
                    ),
                ),
                CollectionItemWithIdInput(
                    id="66f6ed9576ddacf3149d5eaa",
                    cms_locale_id="66f6e966c9e1dc700a857ca4",
                    field_data=CollectionItemWithIdInputFieldData(
                        name="Hasta Luego y Gracias por Todo el Pescado",
                        slug="hasta-luego-y-gracias",
                    ),
                ),
            ],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items",
            method="PATCH",
            json={
                "items": convert_and_respect_annotation_metadata(
                    object_=items, annotation=typing.Sequence[CollectionItemWithIdInput], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItem,
                    parse_obj_as(
                        type_=CollectionItem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_items_live(
        self,
        collection_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        offset: typing.Optional[float] = None,
        limit: typing.Optional[float] = None,
        name: typing.Optional[str] = None,
        slug: typing.Optional[str] = None,
        sort_by: typing.Optional[ItemsListItemsLiveRequestSortBy] = None,
        sort_order: typing.Optional[ItemsListItemsLiveRequestSortOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItemList:
        """
        List of all live Items within a Collection.

        Required scope | `CMS:read`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        offset : typing.Optional[float]
            Offset used for pagination if the results have more than limit records

        limit : typing.Optional[float]
            Maximum number of records to be returned (max limit: 100)

        name : typing.Optional[str]
            The name of the item(s)

        slug : typing.Optional[str]
            The slug of the item

        sort_by : typing.Optional[ItemsListItemsLiveRequestSortBy]
            Sort results by the provided value

        sort_order : typing.Optional[ItemsListItemsLiveRequestSortOrder]
            Sorts the results by asc or desc

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItemList
            Request was successful

        Examples
        --------
        from webflow import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.list_items_live(
            collection_id="580e63fc8c9a982ac9b8b745",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/live",
            method="GET",
            params={
                "cmsLocaleId": cms_locale_id,
                "offset": offset,
                "limit": limit,
                "name": name,
                "slug": slug,
                "sortBy": sort_by,
                "sortOrder": sort_order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItemList,
                    parse_obj_as(
                        type_=CollectionItemList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_item_live(
        self,
        collection_id: str,
        *,
        request: ItemsCreateItemLiveRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Create live Item(s) in a Collection. The Item(s) will be published to the live site.


        To create items across multiple locales, [please use this endpoint.](/v2.0.0/data/reference/cms/collection-items/staged-items/create-items)


        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        request : ItemsCreateItemLiveRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        from webflow import CollectionItem, CollectionItemFieldData, Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.create_item_live(
            collection_id="580e63fc8c9a982ac9b8b745",
            request=CollectionItem(
                is_archived=False,
                is_draft=False,
                field_data=CollectionItemFieldData(
                    name="Pan Galactic Gargle Blaster Recipe",
                    slug="pan-galactic-gargle-blaster",
                ),
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/live",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=ItemsCreateItemLiveRequest, direction="write"
            ),
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItem,
                    parse_obj_as(
                        type_=CollectionItem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_items_live(
        self,
        collection_id: str,
        *,
        items: typing.Optional[typing.Sequence[ItemsDeleteItemsLiveRequestItemsItem]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Remove an item or multiple items (up to 100 items) from the live site. Deleting published items will unpublish the items from the live site and set them to draft.

        **Note:** If the `cmsLocaleId` parameter is undefined or empty and the items are localized, items will be unpublished only in the primary locale.

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        items : typing.Optional[typing.Sequence[ItemsDeleteItemsLiveRequestItemsItem]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from webflow import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.delete_items_live(
            collection_id="580e63fc8c9a982ac9b8b745",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/live",
            method="DELETE",
            json={
                "items": convert_and_respect_annotation_metadata(
                    object_=items, annotation=typing.Sequence[ItemsDeleteItemsLiveRequestItemsItem], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_items_live(
        self,
        collection_id: str,
        *,
        items: typing.Optional[typing.Sequence[CollectionItemWithIdInput]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItemListNoPagination:
        """
        Update a single live item or multiple live items (up to 100) in a Collection

        **Note:** If the `cmsLocaleId` parameter is undefined or empty and the items are localized, items will be updated only in the primary locale.

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        items : typing.Optional[typing.Sequence[CollectionItemWithIdInput]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItemListNoPagination
            Request was successful

        Examples
        --------
        from webflow import (
            CollectionItemWithIdInput,
            CollectionItemWithIdInputFieldData,
            Webflow,
        )

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.update_items_live(
            collection_id="580e63fc8c9a982ac9b8b745",
            items=[
                CollectionItemWithIdInput(
                    id="66f6ed9576ddacf3149d5ea6",
                    cms_locale_id="66f6e966c9e1dc700a857ca5",
                    field_data=CollectionItemWithIdInputFieldData(
                        name="Ne Paniquez Pas",
                        slug="ne-paniquez-pas",
                    ),
                ),
                CollectionItemWithIdInput(
                    id="66f6ed9576ddacf3149d5ea6",
                    cms_locale_id="66f6e966c9e1dc700a857ca4",
                    field_data=CollectionItemWithIdInputFieldData(
                        name="No Entrar en Pánico",
                        slug="no-entrar-en-panico",
                    ),
                ),
                CollectionItemWithIdInput(
                    id="66f6ed9576ddacf3149d5eaa",
                    cms_locale_id="66f6e966c9e1dc700a857ca5",
                    field_data=CollectionItemWithIdInputFieldData(
                        name="Au Revoir et Merci pour Tous les Poissons",
                        slug="au-revoir-et-merci",
                    ),
                ),
                CollectionItemWithIdInput(
                    id="66f6ed9576ddacf3149d5eaa",
                    cms_locale_id="66f6e966c9e1dc700a857ca4",
                    field_data=CollectionItemWithIdInputFieldData(
                        name="Hasta Luego y Gracias por Todo el Pescado",
                        slug="hasta-luego-y-gracias",
                    ),
                ),
            ],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/live",
            method="PATCH",
            json={
                "items": convert_and_respect_annotation_metadata(
                    object_=items, annotation=typing.Sequence[CollectionItemWithIdInput], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItemListNoPagination,
                    parse_obj_as(
                        type_=CollectionItemListNoPagination,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_items(
        self,
        collection_id: str,
        *,
        field_data: CreateBulkCollectionItemRequestBodyFieldData,
        cms_locale_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BulkCollectionItem:
        """
        Create an item or multiple items in a CMS Collection across multiple corresponding locales.

        **Notes:**
          - This endpoint can create up to 100 items in a request.
          - If the `cmsLocaleIds` parameter is undefined or empty and localization is enabled, items will only be created in the primary locale.

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        field_data : CreateBulkCollectionItemRequestBodyFieldData

        cms_locale_ids : typing.Optional[typing.Sequence[str]]
            Array of identifiers for the locales where the item will be created

        is_archived : typing.Optional[bool]
            Indicates whether the item is archived.

        is_draft : typing.Optional[bool]
            Indicates whether the item is in draft state.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BulkCollectionItem
            Request was successful

        Examples
        --------
        from webflow import Webflow
        from webflow.resources.collections.resources.items import SingleCmsItem

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.create_items(
            collection_id="580e63fc8c9a982ac9b8b745",
            cms_locale_ids=[
                "66f6e966c9e1dc700a857ca3",
                "66f6e966c9e1dc700a857ca4",
                "66f6e966c9e1dc700a857ca5",
            ],
            is_archived=False,
            is_draft=False,
            field_data=SingleCmsItem(
                name="Don’t Panic",
                slug="dont-panic",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/bulk",
            method="POST",
            json={
                "cmsLocaleIds": cms_locale_ids,
                "isArchived": is_archived,
                "isDraft": is_draft,
                "fieldData": convert_and_respect_annotation_metadata(
                    object_=field_data, annotation=CreateBulkCollectionItemRequestBodyFieldData, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BulkCollectionItem,
                    parse_obj_as(
                        type_=BulkCollectionItem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_item(
        self,
        collection_id: str,
        item_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Get details of a selected Collection Item.

        Required scope | `CMS:read`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        from webflow import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.get_item(
            collection_id="580e63fc8c9a982ac9b8b745",
            item_id="580e64008c9a982ac9b8b754",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}",
            method="GET",
            params={
                "cmsLocaleId": cms_locale_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItem,
                    parse_obj_as(
                        type_=CollectionItem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_item(
        self,
        collection_id: str,
        item_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete an Item from a Collection. This endpoint does not currently support bulk deletion.

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from webflow import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.delete_item(
            collection_id="580e63fc8c9a982ac9b8b745",
            item_id="580e64008c9a982ac9b8b754",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}",
            method="DELETE",
            params={
                "cmsLocaleId": cms_locale_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_item(
        self,
        collection_id: str,
        item_id: str,
        *,
        id: typing.Optional[str] = OMIT,
        cms_locale_id: typing.Optional[str] = OMIT,
        last_published: typing.Optional[str] = OMIT,
        last_updated: typing.Optional[str] = OMIT,
        created_on: typing.Optional[str] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        field_data: typing.Optional[CollectionItemPatchSingleFieldData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Update a selected Item in a Collection.

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        id : typing.Optional[str]
            Unique identifier for the Item

        cms_locale_id : typing.Optional[str]
            Identifier for the locale of the CMS item

        last_published : typing.Optional[str]
            The date the item was last published

        last_updated : typing.Optional[str]
            The date the item was last updated

        created_on : typing.Optional[str]
            The date the item was created

        is_archived : typing.Optional[bool]
            Boolean determining if the Item is set to archived

        is_draft : typing.Optional[bool]
            Boolean determining if the Item is set to draft

        field_data : typing.Optional[CollectionItemPatchSingleFieldData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        from webflow import CollectionItemPatchSingleFieldData, Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.update_item(
            collection_id="580e63fc8c9a982ac9b8b745",
            item_id="580e64008c9a982ac9b8b754",
            is_archived=False,
            is_draft=False,
            field_data=CollectionItemPatchSingleFieldData(
                name="Pan Galactic Gargle Blaster Recipe",
                slug="pan-galactic-gargle-blaster",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}",
            method="PATCH",
            json={
                "id": id,
                "cmsLocaleId": cms_locale_id,
                "lastPublished": last_published,
                "lastUpdated": last_updated,
                "createdOn": created_on,
                "isArchived": is_archived,
                "isDraft": is_draft,
                "fieldData": convert_and_respect_annotation_metadata(
                    object_=field_data, annotation=CollectionItemPatchSingleFieldData, direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItem,
                    parse_obj_as(
                        type_=CollectionItem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_item_live(
        self,
        collection_id: str,
        item_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Get details of a selected Collection live Item.

        Required scope | `CMS:read`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        from webflow import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.get_item_live(
            collection_id="580e63fc8c9a982ac9b8b745",
            item_id="580e64008c9a982ac9b8b754",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}/live",
            method="GET",
            params={
                "cmsLocaleId": cms_locale_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItem,
                    parse_obj_as(
                        type_=CollectionItem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_item_live(
        self,
        collection_id: str,
        item_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Remove a live item from the site. Removing a published item will unpublish the item from the live site and set it to draft.

        This endpoint does not currently support bulk deletion.

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from webflow import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.delete_item_live(
            collection_id="580e63fc8c9a982ac9b8b745",
            item_id="580e64008c9a982ac9b8b754",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}/live",
            method="DELETE",
            params={
                "cmsLocaleId": cms_locale_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_item_live(
        self,
        collection_id: str,
        item_id: str,
        *,
        id: typing.Optional[str] = OMIT,
        cms_locale_id: typing.Optional[str] = OMIT,
        last_published: typing.Optional[str] = OMIT,
        last_updated: typing.Optional[str] = OMIT,
        created_on: typing.Optional[str] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        field_data: typing.Optional[CollectionItemPatchSingleFieldData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Update a selected live Item in a Collection. The updates for this Item will be published to the live site.

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        id : typing.Optional[str]
            Unique identifier for the Item

        cms_locale_id : typing.Optional[str]
            Identifier for the locale of the CMS item

        last_published : typing.Optional[str]
            The date the item was last published

        last_updated : typing.Optional[str]
            The date the item was last updated

        created_on : typing.Optional[str]
            The date the item was created

        is_archived : typing.Optional[bool]
            Boolean determining if the Item is set to archived

        is_draft : typing.Optional[bool]
            Boolean determining if the Item is set to draft

        field_data : typing.Optional[CollectionItemPatchSingleFieldData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        from webflow import CollectionItemPatchSingleFieldData, Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.update_item_live(
            collection_id="580e63fc8c9a982ac9b8b745",
            item_id="580e64008c9a982ac9b8b754",
            is_archived=False,
            is_draft=False,
            field_data=CollectionItemPatchSingleFieldData(
                name="Pan Galactic Gargle Blaster Recipe",
                slug="pan-galactic-gargle-blaster",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}/live",
            method="PATCH",
            json={
                "id": id,
                "cmsLocaleId": cms_locale_id,
                "lastPublished": last_published,
                "lastUpdated": last_updated,
                "createdOn": created_on,
                "isArchived": is_archived,
                "isDraft": is_draft,
                "fieldData": convert_and_respect_annotation_metadata(
                    object_=field_data, annotation=CollectionItemPatchSingleFieldData, direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItem,
                    parse_obj_as(
                        type_=CollectionItem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def publish_item(
        self,
        collection_id: str,
        *,
        item_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ItemsPublishItemResponse:
        """
        Publish an item or multiple items.

        Required scope | `cms:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ItemsPublishItemResponse
            Request was successful

        Examples
        --------
        from webflow import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.collections.items.publish_item(
            collection_id="580e63fc8c9a982ac9b8b745",
            item_ids=["itemIds"],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/publish",
            method="POST",
            json={
                "itemIds": item_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ItemsPublishItemResponse,
                    parse_obj_as(
                        type_=ItemsPublishItemResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncItemsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list_items(
        self,
        collection_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        offset: typing.Optional[float] = None,
        limit: typing.Optional[float] = None,
        name: typing.Optional[str] = None,
        slug: typing.Optional[str] = None,
        sort_by: typing.Optional[ItemsListItemsRequestSortBy] = None,
        sort_order: typing.Optional[ItemsListItemsRequestSortOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItemList:
        """
        List of all Items within a Collection.

        Required scope | `CMS:read`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        offset : typing.Optional[float]
            Offset used for pagination if the results have more than limit records

        limit : typing.Optional[float]
            Maximum number of records to be returned (max limit: 100)

        name : typing.Optional[str]
            The name of the item(s)

        slug : typing.Optional[str]
            The slug of the item

        sort_by : typing.Optional[ItemsListItemsRequestSortBy]
            Sort results by the provided value

        sort_order : typing.Optional[ItemsListItemsRequestSortOrder]
            Sorts the results by asc or desc

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItemList
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.collections.items.list_items(
                collection_id="580e63fc8c9a982ac9b8b745",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items",
            method="GET",
            params={
                "cmsLocaleId": cms_locale_id,
                "offset": offset,
                "limit": limit,
                "name": name,
                "slug": slug,
                "sortBy": sort_by,
                "sortOrder": sort_order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItemList,
                    parse_obj_as(
                        type_=CollectionItemList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_item(
        self,
        collection_id: str,
        *,
        request: ItemsCreateItemRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Create Item(s) in a Collection.


        To create items across multiple locales, please use [this endpoint.](/v2.0.0/data/reference/cms/collection-items/staged-items/create-items)

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        request : ItemsCreateItemRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import (
            AsyncWebflow,
            CollectionItemPostSingle,
            CollectionItemPostSingleFieldData,
        )

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.collections.items.create_item(
                collection_id="580e63fc8c9a982ac9b8b745",
                request=CollectionItemPostSingle(
                    is_archived=False,
                    is_draft=False,
                    field_data=CollectionItemPostSingleFieldData(
                        name="Pan Galactic Gargle Blaster Recipe",
                        slug="pan-galactic-gargle-blaster",
                    ),
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=ItemsCreateItemRequest, direction="write"
            ),
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItem,
                    parse_obj_as(
                        type_=CollectionItem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_items(
        self,
        collection_id: str,
        *,
        items: typing.Optional[typing.Sequence[ItemsDeleteItemsRequestItemsItem]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete Items from a Collection.

        **Note:** If the `cmsLocaleId` parameter is undefined or empty and the items are localized, items will be deleted only in the primary locale.

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        items : typing.Optional[typing.Sequence[ItemsDeleteItemsRequestItemsItem]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.collections.items.delete_items(
                collection_id="580e63fc8c9a982ac9b8b745",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items",
            method="DELETE",
            json={
                "items": convert_and_respect_annotation_metadata(
                    object_=items, annotation=typing.Sequence[ItemsDeleteItemsRequestItemsItem], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_items(
        self,
        collection_id: str,
        *,
        items: typing.Optional[typing.Sequence[CollectionItemWithIdInput]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Update a single item or multiple items (up to 100) in a Collection.

        **Note:** If the `cmsLocaleId` parameter is undefined or empty and the items are localized, items will be updated only in the primary locale.

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        items : typing.Optional[typing.Sequence[CollectionItemWithIdInput]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import (
            AsyncWebflow,
            CollectionItemWithIdInput,
            CollectionItemWithIdInputFieldData,
        )

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.collections.items.update_items(
                collection_id="580e63fc8c9a982ac9b8b745",
                items=[
                    CollectionItemWithIdInput(
                        id="66f6ed9576ddacf3149d5ea6",
                        cms_locale_id="66f6e966c9e1dc700a857ca5",
                        field_data=CollectionItemWithIdInputFieldData(
                            name="Ne Paniquez Pas",
                            slug="ne-paniquez-pas",
                        ),
                    ),
                    CollectionItemWithIdInput(
                        id="66f6ed9576ddacf3149d5ea6",
                        cms_locale_id="66f6e966c9e1dc700a857ca4",
                        field_data=CollectionItemWithIdInputFieldData(
                            name="No Entrar en Pánico",
                            slug="no-entrar-en-panico",
                        ),
                    ),
                    CollectionItemWithIdInput(
                        id="66f6ed9576ddacf3149d5eaa",
                        cms_locale_id="66f6e966c9e1dc700a857ca5",
                        field_data=CollectionItemWithIdInputFieldData(
                            name="Au Revoir et Merci pour Tous les Poissons",
                            slug="au-revoir-et-merci",
                        ),
                    ),
                    CollectionItemWithIdInput(
                        id="66f6ed9576ddacf3149d5eaa",
                        cms_locale_id="66f6e966c9e1dc700a857ca4",
                        field_data=CollectionItemWithIdInputFieldData(
                            name="Hasta Luego y Gracias por Todo el Pescado",
                            slug="hasta-luego-y-gracias",
                        ),
                    ),
                ],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items",
            method="PATCH",
            json={
                "items": convert_and_respect_annotation_metadata(
                    object_=items, annotation=typing.Sequence[CollectionItemWithIdInput], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItem,
                    parse_obj_as(
                        type_=CollectionItem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_items_live(
        self,
        collection_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        offset: typing.Optional[float] = None,
        limit: typing.Optional[float] = None,
        name: typing.Optional[str] = None,
        slug: typing.Optional[str] = None,
        sort_by: typing.Optional[ItemsListItemsLiveRequestSortBy] = None,
        sort_order: typing.Optional[ItemsListItemsLiveRequestSortOrder] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItemList:
        """
        List of all live Items within a Collection.

        Required scope | `CMS:read`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        offset : typing.Optional[float]
            Offset used for pagination if the results have more than limit records

        limit : typing.Optional[float]
            Maximum number of records to be returned (max limit: 100)

        name : typing.Optional[str]
            The name of the item(s)

        slug : typing.Optional[str]
            The slug of the item

        sort_by : typing.Optional[ItemsListItemsLiveRequestSortBy]
            Sort results by the provided value

        sort_order : typing.Optional[ItemsListItemsLiveRequestSortOrder]
            Sorts the results by asc or desc

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItemList
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.collections.items.list_items_live(
                collection_id="580e63fc8c9a982ac9b8b745",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/live",
            method="GET",
            params={
                "cmsLocaleId": cms_locale_id,
                "offset": offset,
                "limit": limit,
                "name": name,
                "slug": slug,
                "sortBy": sort_by,
                "sortOrder": sort_order,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItemList,
                    parse_obj_as(
                        type_=CollectionItemList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_item_live(
        self,
        collection_id: str,
        *,
        request: ItemsCreateItemLiveRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Create live Item(s) in a Collection. The Item(s) will be published to the live site.


        To create items across multiple locales, [please use this endpoint.](/v2.0.0/data/reference/cms/collection-items/staged-items/create-items)


        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        request : ItemsCreateItemLiveRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow, CollectionItem, CollectionItemFieldData

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.collections.items.create_item_live(
                collection_id="580e63fc8c9a982ac9b8b745",
                request=CollectionItem(
                    is_archived=False,
                    is_draft=False,
                    field_data=CollectionItemFieldData(
                        name="Pan Galactic Gargle Blaster Recipe",
                        slug="pan-galactic-gargle-blaster",
                    ),
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/live",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=ItemsCreateItemLiveRequest, direction="write"
            ),
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItem,
                    parse_obj_as(
                        type_=CollectionItem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_items_live(
        self,
        collection_id: str,
        *,
        items: typing.Optional[typing.Sequence[ItemsDeleteItemsLiveRequestItemsItem]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Remove an item or multiple items (up to 100 items) from the live site. Deleting published items will unpublish the items from the live site and set them to draft.

        **Note:** If the `cmsLocaleId` parameter is undefined or empty and the items are localized, items will be unpublished only in the primary locale.

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        items : typing.Optional[typing.Sequence[ItemsDeleteItemsLiveRequestItemsItem]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.collections.items.delete_items_live(
                collection_id="580e63fc8c9a982ac9b8b745",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/live",
            method="DELETE",
            json={
                "items": convert_and_respect_annotation_metadata(
                    object_=items, annotation=typing.Sequence[ItemsDeleteItemsLiveRequestItemsItem], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_items_live(
        self,
        collection_id: str,
        *,
        items: typing.Optional[typing.Sequence[CollectionItemWithIdInput]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItemListNoPagination:
        """
        Update a single live item or multiple live items (up to 100) in a Collection

        **Note:** If the `cmsLocaleId` parameter is undefined or empty and the items are localized, items will be updated only in the primary locale.

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        items : typing.Optional[typing.Sequence[CollectionItemWithIdInput]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItemListNoPagination
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import (
            AsyncWebflow,
            CollectionItemWithIdInput,
            CollectionItemWithIdInputFieldData,
        )

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.collections.items.update_items_live(
                collection_id="580e63fc8c9a982ac9b8b745",
                items=[
                    CollectionItemWithIdInput(
                        id="66f6ed9576ddacf3149d5ea6",
                        cms_locale_id="66f6e966c9e1dc700a857ca5",
                        field_data=CollectionItemWithIdInputFieldData(
                            name="Ne Paniquez Pas",
                            slug="ne-paniquez-pas",
                        ),
                    ),
                    CollectionItemWithIdInput(
                        id="66f6ed9576ddacf3149d5ea6",
                        cms_locale_id="66f6e966c9e1dc700a857ca4",
                        field_data=CollectionItemWithIdInputFieldData(
                            name="No Entrar en Pánico",
                            slug="no-entrar-en-panico",
                        ),
                    ),
                    CollectionItemWithIdInput(
                        id="66f6ed9576ddacf3149d5eaa",
                        cms_locale_id="66f6e966c9e1dc700a857ca5",
                        field_data=CollectionItemWithIdInputFieldData(
                            name="Au Revoir et Merci pour Tous les Poissons",
                            slug="au-revoir-et-merci",
                        ),
                    ),
                    CollectionItemWithIdInput(
                        id="66f6ed9576ddacf3149d5eaa",
                        cms_locale_id="66f6e966c9e1dc700a857ca4",
                        field_data=CollectionItemWithIdInputFieldData(
                            name="Hasta Luego y Gracias por Todo el Pescado",
                            slug="hasta-luego-y-gracias",
                        ),
                    ),
                ],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/live",
            method="PATCH",
            json={
                "items": convert_and_respect_annotation_metadata(
                    object_=items, annotation=typing.Sequence[CollectionItemWithIdInput], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItemListNoPagination,
                    parse_obj_as(
                        type_=CollectionItemListNoPagination,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_items(
        self,
        collection_id: str,
        *,
        field_data: CreateBulkCollectionItemRequestBodyFieldData,
        cms_locale_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BulkCollectionItem:
        """
        Create an item or multiple items in a CMS Collection across multiple corresponding locales.

        **Notes:**
          - This endpoint can create up to 100 items in a request.
          - If the `cmsLocaleIds` parameter is undefined or empty and localization is enabled, items will only be created in the primary locale.

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        field_data : CreateBulkCollectionItemRequestBodyFieldData

        cms_locale_ids : typing.Optional[typing.Sequence[str]]
            Array of identifiers for the locales where the item will be created

        is_archived : typing.Optional[bool]
            Indicates whether the item is archived.

        is_draft : typing.Optional[bool]
            Indicates whether the item is in draft state.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BulkCollectionItem
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow
        from webflow.resources.collections.resources.items import SingleCmsItem

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.collections.items.create_items(
                collection_id="580e63fc8c9a982ac9b8b745",
                cms_locale_ids=[
                    "66f6e966c9e1dc700a857ca3",
                    "66f6e966c9e1dc700a857ca4",
                    "66f6e966c9e1dc700a857ca5",
                ],
                is_archived=False,
                is_draft=False,
                field_data=SingleCmsItem(
                    name="Don’t Panic",
                    slug="dont-panic",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/bulk",
            method="POST",
            json={
                "cmsLocaleIds": cms_locale_ids,
                "isArchived": is_archived,
                "isDraft": is_draft,
                "fieldData": convert_and_respect_annotation_metadata(
                    object_=field_data, annotation=CreateBulkCollectionItemRequestBodyFieldData, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BulkCollectionItem,
                    parse_obj_as(
                        type_=BulkCollectionItem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_item(
        self,
        collection_id: str,
        item_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Get details of a selected Collection Item.

        Required scope | `CMS:read`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.collections.items.get_item(
                collection_id="580e63fc8c9a982ac9b8b745",
                item_id="580e64008c9a982ac9b8b754",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}",
            method="GET",
            params={
                "cmsLocaleId": cms_locale_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItem,
                    parse_obj_as(
                        type_=CollectionItem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_item(
        self,
        collection_id: str,
        item_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete an Item from a Collection. This endpoint does not currently support bulk deletion.

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.collections.items.delete_item(
                collection_id="580e63fc8c9a982ac9b8b745",
                item_id="580e64008c9a982ac9b8b754",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}",
            method="DELETE",
            params={
                "cmsLocaleId": cms_locale_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_item(
        self,
        collection_id: str,
        item_id: str,
        *,
        id: typing.Optional[str] = OMIT,
        cms_locale_id: typing.Optional[str] = OMIT,
        last_published: typing.Optional[str] = OMIT,
        last_updated: typing.Optional[str] = OMIT,
        created_on: typing.Optional[str] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        field_data: typing.Optional[CollectionItemPatchSingleFieldData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Update a selected Item in a Collection.

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        id : typing.Optional[str]
            Unique identifier for the Item

        cms_locale_id : typing.Optional[str]
            Identifier for the locale of the CMS item

        last_published : typing.Optional[str]
            The date the item was last published

        last_updated : typing.Optional[str]
            The date the item was last updated

        created_on : typing.Optional[str]
            The date the item was created

        is_archived : typing.Optional[bool]
            Boolean determining if the Item is set to archived

        is_draft : typing.Optional[bool]
            Boolean determining if the Item is set to draft

        field_data : typing.Optional[CollectionItemPatchSingleFieldData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow, CollectionItemPatchSingleFieldData

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.collections.items.update_item(
                collection_id="580e63fc8c9a982ac9b8b745",
                item_id="580e64008c9a982ac9b8b754",
                is_archived=False,
                is_draft=False,
                field_data=CollectionItemPatchSingleFieldData(
                    name="Pan Galactic Gargle Blaster Recipe",
                    slug="pan-galactic-gargle-blaster",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}",
            method="PATCH",
            json={
                "id": id,
                "cmsLocaleId": cms_locale_id,
                "lastPublished": last_published,
                "lastUpdated": last_updated,
                "createdOn": created_on,
                "isArchived": is_archived,
                "isDraft": is_draft,
                "fieldData": convert_and_respect_annotation_metadata(
                    object_=field_data, annotation=CollectionItemPatchSingleFieldData, direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItem,
                    parse_obj_as(
                        type_=CollectionItem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_item_live(
        self,
        collection_id: str,
        item_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Get details of a selected Collection live Item.

        Required scope | `CMS:read`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.collections.items.get_item_live(
                collection_id="580e63fc8c9a982ac9b8b745",
                item_id="580e64008c9a982ac9b8b754",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}/live",
            method="GET",
            params={
                "cmsLocaleId": cms_locale_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItem,
                    parse_obj_as(
                        type_=CollectionItem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_item_live(
        self,
        collection_id: str,
        item_id: str,
        *,
        cms_locale_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Remove a live item from the site. Removing a published item will unpublish the item from the live site and set it to draft.

        This endpoint does not currently support bulk deletion.

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        cms_locale_id : typing.Optional[str]
            Unique identifier for a CMS Locale. This UID is different from the Site locale identifier and is listed as `cmsLocaleId` in the Sites response. To query multiple locales, input a comma separated string.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.collections.items.delete_item_live(
                collection_id="580e63fc8c9a982ac9b8b745",
                item_id="580e64008c9a982ac9b8b754",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}/live",
            method="DELETE",
            params={
                "cmsLocaleId": cms_locale_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_item_live(
        self,
        collection_id: str,
        item_id: str,
        *,
        id: typing.Optional[str] = OMIT,
        cms_locale_id: typing.Optional[str] = OMIT,
        last_published: typing.Optional[str] = OMIT,
        last_updated: typing.Optional[str] = OMIT,
        created_on: typing.Optional[str] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        field_data: typing.Optional[CollectionItemPatchSingleFieldData] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CollectionItem:
        """
        Update a selected live Item in a Collection. The updates for this Item will be published to the live site.

        Required scope | `CMS:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_id : str
            Unique identifier for an Item

        id : typing.Optional[str]
            Unique identifier for the Item

        cms_locale_id : typing.Optional[str]
            Identifier for the locale of the CMS item

        last_published : typing.Optional[str]
            The date the item was last published

        last_updated : typing.Optional[str]
            The date the item was last updated

        created_on : typing.Optional[str]
            The date the item was created

        is_archived : typing.Optional[bool]
            Boolean determining if the Item is set to archived

        is_draft : typing.Optional[bool]
            Boolean determining if the Item is set to draft

        field_data : typing.Optional[CollectionItemPatchSingleFieldData]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CollectionItem
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow, CollectionItemPatchSingleFieldData

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.collections.items.update_item_live(
                collection_id="580e63fc8c9a982ac9b8b745",
                item_id="580e64008c9a982ac9b8b754",
                is_archived=False,
                is_draft=False,
                field_data=CollectionItemPatchSingleFieldData(
                    name="Pan Galactic Gargle Blaster Recipe",
                    slug="pan-galactic-gargle-blaster",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/{jsonable_encoder(item_id)}/live",
            method="PATCH",
            json={
                "id": id,
                "cmsLocaleId": cms_locale_id,
                "lastPublished": last_published,
                "lastUpdated": last_updated,
                "createdOn": created_on,
                "isArchived": is_archived,
                "isDraft": is_draft,
                "fieldData": convert_and_respect_annotation_metadata(
                    object_=field_data, annotation=CollectionItemPatchSingleFieldData, direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CollectionItem,
                    parse_obj_as(
                        type_=CollectionItem,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def publish_item(
        self,
        collection_id: str,
        *,
        item_ids: typing.Sequence[str],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ItemsPublishItemResponse:
        """
        Publish an item or multiple items.

        Required scope | `cms:write`

        Parameters
        ----------
        collection_id : str
            Unique identifier for a Collection

        item_ids : typing.Sequence[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ItemsPublishItemResponse
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.collections.items.publish_item(
                collection_id="580e63fc8c9a982ac9b8b745",
                item_ids=["itemIds"],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"collections/{jsonable_encoder(collection_id)}/items/publish",
            method="POST",
            json={
                "itemIds": item_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ItemsPublishItemResponse,
                    parse_obj_as(
                        type_=ItemsPublishItemResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
