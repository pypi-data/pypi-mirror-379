# This file was auto-generated by Fern from our API Definition.

import typing
from ...core.client_wrapper import SyncClientWrapper
from .resources.scripts.client import ScriptsClient
from ...core.request_options import RequestOptions
from ...types.page_list import PageList
from ...core.jsonable_encoder import jsonable_encoder
from ...core.pydantic_utilities import parse_obj_as
from ...errors.bad_request_error import BadRequestError
from ...errors.unauthorized_error import UnauthorizedError
from ...types.error import Error
from ...errors.not_found_error import NotFoundError
from ...errors.too_many_requests_error import TooManyRequestsError
from ...errors.internal_server_error import InternalServerError
from json.decoder import JSONDecodeError
from ...core.api_error import ApiError
from ...types.page import Page
import datetime as dt
from ...types.page_seo import PageSeo
from ...types.page_open_graph import PageOpenGraph
from ...core.serialization import convert_and_respect_annotation_metadata
from ...types.dom import Dom
from ...errors.forbidden_error import ForbiddenError
from .types.page_dom_write_nodes_item import PageDomWriteNodesItem
from .types.update_static_content_response import UpdateStaticContentResponse
from ...core.client_wrapper import AsyncClientWrapper
from .resources.scripts.client import AsyncScriptsClient

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class PagesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper
        self.scripts = ScriptsClient(client_wrapper=self._client_wrapper)

    def list(
        self,
        site_id: str,
        *,
        locale_id: typing.Optional[str] = None,
        limit: typing.Optional[float] = None,
        offset: typing.Optional[float] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PageList:
        """
        List of all pages for a site.

        Required scope | `pages:read`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        locale_id : typing.Optional[str]
            Unique identifier for a specific locale. Applicable, when using localization.

        limit : typing.Optional[float]
            Maximum number of records to be returned (max limit: 100)

        offset : typing.Optional[float]
            Offset used for pagination if the results have more than limit records

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PageList
            Request was successful

        Examples
        --------
        from webflow import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.pages.list(
            site_id="580e63e98c9a982ac9b8b741",
            locale_id="65427cf400e02b306eaa04a0",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/pages",
            method="GET",
            params={
                "localeId": locale_id,
                "limit": limit,
                "offset": offset,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PageList,
                    parse_obj_as(
                        type_=PageList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_metadata(
        self,
        page_id: str,
        *,
        locale_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Page:
        """
        Get metadata information for a single page.

        Required scope | `pages:read`

        Parameters
        ----------
        page_id : str
            Unique identifier for a Page

        locale_id : typing.Optional[str]
            Unique identifier for a specific locale. Applicable, when using localization.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Page
            Request was successful

        Examples
        --------
        from webflow import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.pages.get_metadata(
            page_id="63c720f9347c2139b248e552",
            locale_id="65427cf400e02b306eaa04a0",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"pages/{jsonable_encoder(page_id)}",
            method="GET",
            params={
                "localeId": locale_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Page,
                    parse_obj_as(
                        type_=Page,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_page_settings(
        self,
        page_id: str,
        *,
        id: str,
        locale_id: typing.Optional[str] = None,
        site_id: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        slug: typing.Optional[str] = OMIT,
        parent_id: typing.Optional[str] = OMIT,
        collection_id: typing.Optional[str] = OMIT,
        created_on: typing.Optional[dt.datetime] = OMIT,
        last_updated: typing.Optional[dt.datetime] = OMIT,
        archived: typing.Optional[bool] = OMIT,
        draft: typing.Optional[bool] = OMIT,
        can_branch: typing.Optional[bool] = OMIT,
        is_branch: typing.Optional[bool] = OMIT,
        is_members_only: typing.Optional[bool] = OMIT,
        seo: typing.Optional[PageSeo] = OMIT,
        open_graph: typing.Optional[PageOpenGraph] = OMIT,
        page_locale_id: typing.Optional[str] = OMIT,
        published_path: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Page:
        """
        Update Page-level metadata, including SEO and Open Graph fields.

        Required scope | `pages:write`

        Parameters
        ----------
        page_id : str
            Unique identifier for a Page

        id : str
            Unique identifier for the Page

        locale_id : typing.Optional[str]
            Unique identifier for a specific locale. Applicable, when using localization.

        site_id : typing.Optional[str]
            Unique identifier for the Site

        title : typing.Optional[str]
            Title of the Page

        slug : typing.Optional[str]
            slug of the Page (derived from title)

        parent_id : typing.Optional[str]
            Identifier of the parent folder

        collection_id : typing.Optional[str]
            Unique identifier for a linked Collection, value will be null if the Page is not part of a Collection.

        created_on : typing.Optional[dt.datetime]
            The date the Page was created

        last_updated : typing.Optional[dt.datetime]
            The date the Page was most recently updated

        archived : typing.Optional[bool]
            Whether the Page has been archived

        draft : typing.Optional[bool]
            Whether the Page is a draft

        can_branch : typing.Optional[bool]
            Indicates whether the Page supports [Page Branching](https://university.webflow.com/lesson/page-branching)

        is_branch : typing.Optional[bool]
            Indicates whether the Page is a Branch of another Page [Page Branching](https://university.webflow.com/lesson/page-branching)

        is_members_only : typing.Optional[bool]
            Indicates whether the Page is restricted by [Memberships Controls](https://university.webflow.com/lesson/webflow-memberships-overview#how-to-manage-page-restrictions)

        seo : typing.Optional[PageSeo]
            SEO-related fields for the Page

        open_graph : typing.Optional[PageOpenGraph]
            Open Graph fields for the Page

        page_locale_id : typing.Optional[str]
            Unique ID of the page locale

        published_path : typing.Optional[str]
            Relative path of the published page URL

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Page
            Request was successful

        Examples
        --------
        import datetime

        from webflow import PageOpenGraph, PageSeo, Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.pages.update_page_settings(
            page_id="63c720f9347c2139b248e552",
            locale_id="65427cf400e02b306eaa04a0",
            id="6596da6045e56dee495bcbba",
            site_id="6258612d1ee792848f805dcf",
            title="Guide to the Galaxy",
            slug="guide-to-the-galaxy",
            created_on=datetime.datetime.fromisoformat(
                "2024-03-11 10:42:00+00:00",
            ),
            last_updated=datetime.datetime.fromisoformat(
                "2024-03-11 10:42:42+00:00",
            ),
            archived=False,
            draft=False,
            can_branch=True,
            is_branch=False,
            seo=PageSeo(
                title="The Ultimate Hitchhiker's Guide to the Galaxy",
                description="Everything you need to know about the galaxy, from avoiding Vogon poetry to the importance of towels.",
            ),
            open_graph=PageOpenGraph(
                title="Explore the Cosmos with The Ultimate Guide",
                title_copied=False,
                description="Dive deep into the mysteries of the universe with your guide to everything galactic.",
                description_copied=False,
            ),
            page_locale_id="653fd9af6a07fc9cfd7a5e57",
            published_path="/en-us/guide-to-the-galaxy",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"pages/{jsonable_encoder(page_id)}",
            method="PUT",
            params={
                "localeId": locale_id,
            },
            json={
                "id": id,
                "siteId": site_id,
                "title": title,
                "slug": slug,
                "parentId": parent_id,
                "collectionId": collection_id,
                "createdOn": created_on,
                "lastUpdated": last_updated,
                "archived": archived,
                "draft": draft,
                "canBranch": can_branch,
                "isBranch": is_branch,
                "isMembersOnly": is_members_only,
                "seo": convert_and_respect_annotation_metadata(object_=seo, annotation=PageSeo, direction="write"),
                "openGraph": convert_and_respect_annotation_metadata(
                    object_=open_graph, annotation=PageOpenGraph, direction="write"
                ),
                "localeId": locale_id,
                "publishedPath": published_path,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Page,
                    parse_obj_as(
                        type_=Page,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_content(
        self,
        page_id: str,
        *,
        locale_id: typing.Optional[str] = None,
        limit: typing.Optional[float] = None,
        offset: typing.Optional[float] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Dom:
        """
        Get static content from a static page. This includes text nodes, image nodes and component instances.
        To retrieve the contents of components in the page use the [get component content](/data/reference/pages-and-components/components/get-content) endpoint.

        <Note>If you do not provide a Locale ID in your request, the response will return any content that can be localized from the Primary locale.</Note>

        Required scope | `pages:read`

        Parameters
        ----------
        page_id : str
            Unique identifier for a Page

        locale_id : typing.Optional[str]
            Unique identifier for a specific locale. Applicable, when using localization.

        limit : typing.Optional[float]
            Maximum number of records to be returned (max limit: 100)

        offset : typing.Optional[float]
            Offset used for pagination if the results have more than limit records

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Dom
            Request was successful

        Examples
        --------
        from webflow import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.pages.get_content(
            page_id="63c720f9347c2139b248e552",
            locale_id="65427cf400e02b306eaa04a0",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"pages/{jsonable_encoder(page_id)}/dom",
            method="GET",
            params={
                "localeId": locale_id,
                "limit": limit,
                "offset": offset,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Dom,
                    parse_obj_as(
                        type_=Dom,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_static_content(
        self,
        page_id: str,
        *,
        locale_id: str,
        nodes: typing.Sequence[PageDomWriteNodesItem],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UpdateStaticContentResponse:
        """
        This endpoint updates content on a static page in **secondary locales**. It supports updating up to 1000 nodes in a single request.

        Before making updates:
        1. Use the [get page content](/data/reference/pages-and-components/pages/get-content) endpoint to identify available content nodes and their types
        2. If the page has component instances, retrieve the component's properties that you'll override using the [get component properties](/data/reference/pages-and-components/components/get-properties) endpoint

        <Note>
          This endpoint is specifically for localized pages. Ensure that the specified `localeId` is a valid **secondary locale** for the site otherwise the request will fail.
        </Note>

        Required scope | `pages:write`

        Parameters
        ----------
        page_id : str
            Unique identifier for a Page

        locale_id : str
            The locale identifier.

        nodes : typing.Sequence[PageDomWriteNodesItem]
            List of DOM Nodes with the new content that will be updated in each node.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UpdateStaticContentResponse
            Request was successful

        Examples
        --------
        from webflow import (
            ComponentInstanceNodePropertyOverridesWrite,
            ComponentInstanceNodePropertyOverridesWritePropertyOverridesItem,
            TextNodeWrite,
            Webflow,
        )

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.pages.update_static_content(
            page_id="63c720f9347c2139b248e552",
            locale_id="localeId",
            nodes=[
                TextNodeWrite(
                    node_id="a245c12d-995b-55ee-5ec7-aa36a6cad623",
                    text="<h1>The Hitchhiker's Guide to the Galaxy</h1>",
                ),
                TextNodeWrite(
                    node_id="a245c12d-995b-55ee-5ec7-aa36a6cad627",
                    text="<div><h3>Don't Panic!</h3><p>Always know where your towel is.</p></div>",
                ),
                ComponentInstanceNodePropertyOverridesWrite(
                    node_id="a245c12d-995b-55ee-5ec7-aa36a6cad629",
                    property_overrides=[
                        ComponentInstanceNodePropertyOverridesWritePropertyOverridesItem(
                            property_id="7dd14c08-2e96-8d3d-2b19-b5c03642a0f0",
                            text="<div><h1>Time is an <em>illusion</em></h1></div>",
                        ),
                        ComponentInstanceNodePropertyOverridesWritePropertyOverridesItem(
                            property_id="7dd14c08-2e96-8d3d-2b19-b5c03642a0f1",
                            text="Life, the Universe and Everything",
                        ),
                    ],
                ),
            ],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"pages/{jsonable_encoder(page_id)}/dom",
            method="POST",
            params={
                "localeId": locale_id,
            },
            json={
                "nodes": convert_and_respect_annotation_metadata(
                    object_=nodes, annotation=typing.Sequence[PageDomWriteNodesItem], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    UpdateStaticContentResponse,
                    parse_obj_as(
                        type_=UpdateStaticContentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncPagesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper
        self.scripts = AsyncScriptsClient(client_wrapper=self._client_wrapper)

    async def list(
        self,
        site_id: str,
        *,
        locale_id: typing.Optional[str] = None,
        limit: typing.Optional[float] = None,
        offset: typing.Optional[float] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PageList:
        """
        List of all pages for a site.

        Required scope | `pages:read`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        locale_id : typing.Optional[str]
            Unique identifier for a specific locale. Applicable, when using localization.

        limit : typing.Optional[float]
            Maximum number of records to be returned (max limit: 100)

        offset : typing.Optional[float]
            Offset used for pagination if the results have more than limit records

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PageList
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.pages.list(
                site_id="580e63e98c9a982ac9b8b741",
                locale_id="65427cf400e02b306eaa04a0",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/pages",
            method="GET",
            params={
                "localeId": locale_id,
                "limit": limit,
                "offset": offset,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PageList,
                    parse_obj_as(
                        type_=PageList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_metadata(
        self,
        page_id: str,
        *,
        locale_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Page:
        """
        Get metadata information for a single page.

        Required scope | `pages:read`

        Parameters
        ----------
        page_id : str
            Unique identifier for a Page

        locale_id : typing.Optional[str]
            Unique identifier for a specific locale. Applicable, when using localization.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Page
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.pages.get_metadata(
                page_id="63c720f9347c2139b248e552",
                locale_id="65427cf400e02b306eaa04a0",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"pages/{jsonable_encoder(page_id)}",
            method="GET",
            params={
                "localeId": locale_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Page,
                    parse_obj_as(
                        type_=Page,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_page_settings(
        self,
        page_id: str,
        *,
        id: str,
        locale_id: typing.Optional[str] = None,
        site_id: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        slug: typing.Optional[str] = OMIT,
        parent_id: typing.Optional[str] = OMIT,
        collection_id: typing.Optional[str] = OMIT,
        created_on: typing.Optional[dt.datetime] = OMIT,
        last_updated: typing.Optional[dt.datetime] = OMIT,
        archived: typing.Optional[bool] = OMIT,
        draft: typing.Optional[bool] = OMIT,
        can_branch: typing.Optional[bool] = OMIT,
        is_branch: typing.Optional[bool] = OMIT,
        is_members_only: typing.Optional[bool] = OMIT,
        seo: typing.Optional[PageSeo] = OMIT,
        open_graph: typing.Optional[PageOpenGraph] = OMIT,
        page_locale_id: typing.Optional[str] = OMIT,
        published_path: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Page:
        """
        Update Page-level metadata, including SEO and Open Graph fields.

        Required scope | `pages:write`

        Parameters
        ----------
        page_id : str
            Unique identifier for a Page

        id : str
            Unique identifier for the Page

        locale_id : typing.Optional[str]
            Unique identifier for a specific locale. Applicable, when using localization.

        site_id : typing.Optional[str]
            Unique identifier for the Site

        title : typing.Optional[str]
            Title of the Page

        slug : typing.Optional[str]
            slug of the Page (derived from title)

        parent_id : typing.Optional[str]
            Identifier of the parent folder

        collection_id : typing.Optional[str]
            Unique identifier for a linked Collection, value will be null if the Page is not part of a Collection.

        created_on : typing.Optional[dt.datetime]
            The date the Page was created

        last_updated : typing.Optional[dt.datetime]
            The date the Page was most recently updated

        archived : typing.Optional[bool]
            Whether the Page has been archived

        draft : typing.Optional[bool]
            Whether the Page is a draft

        can_branch : typing.Optional[bool]
            Indicates whether the Page supports [Page Branching](https://university.webflow.com/lesson/page-branching)

        is_branch : typing.Optional[bool]
            Indicates whether the Page is a Branch of another Page [Page Branching](https://university.webflow.com/lesson/page-branching)

        is_members_only : typing.Optional[bool]
            Indicates whether the Page is restricted by [Memberships Controls](https://university.webflow.com/lesson/webflow-memberships-overview#how-to-manage-page-restrictions)

        seo : typing.Optional[PageSeo]
            SEO-related fields for the Page

        open_graph : typing.Optional[PageOpenGraph]
            Open Graph fields for the Page

        page_locale_id : typing.Optional[str]
            Unique ID of the page locale

        published_path : typing.Optional[str]
            Relative path of the published page URL

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Page
            Request was successful

        Examples
        --------
        import asyncio
        import datetime

        from webflow import AsyncWebflow, PageOpenGraph, PageSeo

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.pages.update_page_settings(
                page_id="63c720f9347c2139b248e552",
                locale_id="65427cf400e02b306eaa04a0",
                id="6596da6045e56dee495bcbba",
                site_id="6258612d1ee792848f805dcf",
                title="Guide to the Galaxy",
                slug="guide-to-the-galaxy",
                created_on=datetime.datetime.fromisoformat(
                    "2024-03-11 10:42:00+00:00",
                ),
                last_updated=datetime.datetime.fromisoformat(
                    "2024-03-11 10:42:42+00:00",
                ),
                archived=False,
                draft=False,
                can_branch=True,
                is_branch=False,
                seo=PageSeo(
                    title="The Ultimate Hitchhiker's Guide to the Galaxy",
                    description="Everything you need to know about the galaxy, from avoiding Vogon poetry to the importance of towels.",
                ),
                open_graph=PageOpenGraph(
                    title="Explore the Cosmos with The Ultimate Guide",
                    title_copied=False,
                    description="Dive deep into the mysteries of the universe with your guide to everything galactic.",
                    description_copied=False,
                ),
                page_locale_id="653fd9af6a07fc9cfd7a5e57",
                published_path="/en-us/guide-to-the-galaxy",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"pages/{jsonable_encoder(page_id)}",
            method="PUT",
            params={
                "localeId": locale_id,
            },
            json={
                "id": id,
                "siteId": site_id,
                "title": title,
                "slug": slug,
                "parentId": parent_id,
                "collectionId": collection_id,
                "createdOn": created_on,
                "lastUpdated": last_updated,
                "archived": archived,
                "draft": draft,
                "canBranch": can_branch,
                "isBranch": is_branch,
                "isMembersOnly": is_members_only,
                "seo": convert_and_respect_annotation_metadata(object_=seo, annotation=PageSeo, direction="write"),
                "openGraph": convert_and_respect_annotation_metadata(
                    object_=open_graph, annotation=PageOpenGraph, direction="write"
                ),
                "localeId": locale_id,
                "publishedPath": published_path,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Page,
                    parse_obj_as(
                        type_=Page,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_content(
        self,
        page_id: str,
        *,
        locale_id: typing.Optional[str] = None,
        limit: typing.Optional[float] = None,
        offset: typing.Optional[float] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Dom:
        """
        Get static content from a static page. This includes text nodes, image nodes and component instances.
        To retrieve the contents of components in the page use the [get component content](/data/reference/pages-and-components/components/get-content) endpoint.

        <Note>If you do not provide a Locale ID in your request, the response will return any content that can be localized from the Primary locale.</Note>

        Required scope | `pages:read`

        Parameters
        ----------
        page_id : str
            Unique identifier for a Page

        locale_id : typing.Optional[str]
            Unique identifier for a specific locale. Applicable, when using localization.

        limit : typing.Optional[float]
            Maximum number of records to be returned (max limit: 100)

        offset : typing.Optional[float]
            Offset used for pagination if the results have more than limit records

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Dom
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.pages.get_content(
                page_id="63c720f9347c2139b248e552",
                locale_id="65427cf400e02b306eaa04a0",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"pages/{jsonable_encoder(page_id)}/dom",
            method="GET",
            params={
                "localeId": locale_id,
                "limit": limit,
                "offset": offset,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Dom,
                    parse_obj_as(
                        type_=Dom,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_static_content(
        self,
        page_id: str,
        *,
        locale_id: str,
        nodes: typing.Sequence[PageDomWriteNodesItem],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UpdateStaticContentResponse:
        """
        This endpoint updates content on a static page in **secondary locales**. It supports updating up to 1000 nodes in a single request.

        Before making updates:
        1. Use the [get page content](/data/reference/pages-and-components/pages/get-content) endpoint to identify available content nodes and their types
        2. If the page has component instances, retrieve the component's properties that you'll override using the [get component properties](/data/reference/pages-and-components/components/get-properties) endpoint

        <Note>
          This endpoint is specifically for localized pages. Ensure that the specified `localeId` is a valid **secondary locale** for the site otherwise the request will fail.
        </Note>

        Required scope | `pages:write`

        Parameters
        ----------
        page_id : str
            Unique identifier for a Page

        locale_id : str
            The locale identifier.

        nodes : typing.Sequence[PageDomWriteNodesItem]
            List of DOM Nodes with the new content that will be updated in each node.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UpdateStaticContentResponse
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import (
            AsyncWebflow,
            ComponentInstanceNodePropertyOverridesWrite,
            ComponentInstanceNodePropertyOverridesWritePropertyOverridesItem,
            TextNodeWrite,
        )

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.pages.update_static_content(
                page_id="63c720f9347c2139b248e552",
                locale_id="localeId",
                nodes=[
                    TextNodeWrite(
                        node_id="a245c12d-995b-55ee-5ec7-aa36a6cad623",
                        text="<h1>The Hitchhiker's Guide to the Galaxy</h1>",
                    ),
                    TextNodeWrite(
                        node_id="a245c12d-995b-55ee-5ec7-aa36a6cad627",
                        text="<div><h3>Don't Panic!</h3><p>Always know where your towel is.</p></div>",
                    ),
                    ComponentInstanceNodePropertyOverridesWrite(
                        node_id="a245c12d-995b-55ee-5ec7-aa36a6cad629",
                        property_overrides=[
                            ComponentInstanceNodePropertyOverridesWritePropertyOverridesItem(
                                property_id="7dd14c08-2e96-8d3d-2b19-b5c03642a0f0",
                                text="<div><h1>Time is an <em>illusion</em></h1></div>",
                            ),
                            ComponentInstanceNodePropertyOverridesWritePropertyOverridesItem(
                                property_id="7dd14c08-2e96-8d3d-2b19-b5c03642a0f1",
                                text="Life, the Universe and Everything",
                            ),
                        ],
                    ),
                ],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"pages/{jsonable_encoder(page_id)}/dom",
            method="POST",
            params={
                "localeId": locale_id,
            },
            json={
                "nodes": convert_and_respect_annotation_metadata(
                    object_=nodes, annotation=typing.Sequence[PageDomWriteNodesItem], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    UpdateStaticContentResponse,
                    parse_obj_as(
                        type_=UpdateStaticContentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
