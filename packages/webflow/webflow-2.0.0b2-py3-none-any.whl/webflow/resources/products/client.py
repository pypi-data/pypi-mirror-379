# This file was auto-generated by Fern from our API Definition.

import typing
from ...core.client_wrapper import SyncClientWrapper
from ...core.request_options import RequestOptions
from ...types.product_and_sk_us_list import ProductAndSkUsList
from ...core.jsonable_encoder import jsonable_encoder
from ...core.pydantic_utilities import parse_obj_as
from ...errors.bad_request_error import BadRequestError
from ...errors.unauthorized_error import UnauthorizedError
from ...types.error import Error
from ...errors.forbidden_error import ForbiddenError
from ...errors.not_found_error import NotFoundError
from ...errors.conflict_error import ConflictError
from ...errors.too_many_requests_error import TooManyRequestsError
from ...errors.internal_server_error import InternalServerError
from json.decoder import JSONDecodeError
from ...core.api_error import ApiError
from ...types.publish_status import PublishStatus
from ...types.product import Product
from ...types.sku import Sku
from ...types.product_and_sk_us import ProductAndSkUs
from ...core.serialization import convert_and_respect_annotation_metadata
from .types.products_create_sku_response import ProductsCreateSkuResponse
from ...core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ProductsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        site_id: str,
        *,
        offset: typing.Optional[float] = None,
        limit: typing.Optional[float] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProductAndSkUsList:
        """
        Retrieve all products for a site.

        Use `limit` and `offset` to page through all products with subsequent requests. All SKUs for each product
        will also be fetched and returned. The `limit`, `offset` and `total` values represent Products only and do not include any SKUs.

        Required scope | `ecommerce:read`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        offset : typing.Optional[float]
            Offset used for pagination if the results have more than limit records

        limit : typing.Optional[float]
            Maximum number of records to be returned (max limit: 100)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProductAndSkUsList
            Request was successful

        Examples
        --------
        from webflow import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.list(
            site_id="580e63e98c9a982ac9b8b741",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products",
            method="GET",
            params={
                "offset": offset,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ProductAndSkUsList,
                    parse_obj_as(
                        type_=ProductAndSkUsList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        site_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        product: typing.Optional[Product] = OMIT,
        sku: typing.Optional[Sku] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProductAndSkUs:
        """
        Create a new product and SKU.

        When you create a product, you will always create a SKU, since a Product Item must have, at minimum, a single SKU.

        To create a Product with multiple SKUs - for example a T-shirt in sizes small, medium and large:
          - Create parameters in `sku-properties`, also known as [product options and variants.](https://help.webflow.com/hc/en-us/articles/33961334531347-Create-product-options-and-variants).
          - A single `sku-property` would be `color`. Within the `color` property, list the various colors of T-shirts as an array of `enum` values: `royal-blue`, `crimson-red`, and `forrest-green`.
          - Once, you've created a Product and its `sku-properties` with `enum` values, Webflow will create a **default SKU**, which will automatically be a combination of the first `sku-properties` you've created.
          - In our example, the default SKU will be a Royal Blue T-Shirt, because our first `enum` of our Color `sku-property` is Royal Blue.
          - After you've created your product, you can create additional SKUs using the [Create SKU endpoint.](/data/reference/ecommerce/products/create-sku)

        Upon creation, the default product type will be `Advanced`, which ensures all Product and SKU fields will be shown to users in the Designer.

        Required scope | `ecommerce:write`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        publish_status : typing.Optional[PublishStatus]

        product : typing.Optional[Product]

        sku : typing.Optional[Sku]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProductAndSkUs
            Request was successful

        Examples
        --------
        from webflow import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.create(
            site_id="580e63e98c9a982ac9b8b741",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products",
            method="POST",
            json={
                "publishStatus": publish_status,
                "product": convert_and_respect_annotation_metadata(
                    object_=product, annotation=Product, direction="write"
                ),
                "sku": convert_and_respect_annotation_metadata(object_=sku, annotation=Sku, direction="write"),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ProductAndSkUs,
                    parse_obj_as(
                        type_=ProductAndSkUs,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(
        self, site_id: str, product_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ProductAndSkUs:
        """
        Retrieve a single product by its ID. All of its SKUs will also be
        retrieved.

        Required scope | `ecommerce:read`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        product_id : str
            Unique identifier for a Product

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProductAndSkUs
            Request was successful

        Examples
        --------
        from webflow import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.get(
            site_id="580e63e98c9a982ac9b8b741",
            product_id="580e63fc8c9a982ac9b8b745",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ProductAndSkUs,
                    parse_obj_as(
                        type_=ProductAndSkUs,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        site_id: str,
        product_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        product: typing.Optional[Product] = OMIT,
        sku: typing.Optional[Sku] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Product:
        """
        Update an existing Product.

        Updating an existing Product will set the product type to `Advanced`, which ensures all Product and SKU fields will be shown to users in the Designer.

        Required scope | `ecommerce:write`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        product_id : str
            Unique identifier for a Product

        publish_status : typing.Optional[PublishStatus]

        product : typing.Optional[Product]

        sku : typing.Optional[Sku]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Product
            Request was successful

        Examples
        --------
        from webflow import Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.update(
            site_id="580e63e98c9a982ac9b8b741",
            product_id="580e63fc8c9a982ac9b8b745",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}",
            method="PATCH",
            json={
                "publishStatus": publish_status,
                "product": convert_and_respect_annotation_metadata(
                    object_=product, annotation=Product, direction="write"
                ),
                "sku": convert_and_respect_annotation_metadata(object_=sku, annotation=Sku, direction="write"),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Product,
                    parse_obj_as(
                        type_=Product,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_sku(
        self,
        site_id: str,
        product_id: str,
        *,
        skus: typing.Sequence[Sku],
        publish_status: typing.Optional[PublishStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProductsCreateSkuResponse:
        """
        Create additional SKUs to manage every [option and variant of your Product.](https://help.webflow.com/hc/en-us/articles/33961334531347-Create-product-options-and-variants)

        Creating SKUs through the API will set the product type to `Advanced`, which ensures all Product and SKU fields will be shown to users in the Designer.

        Required scope | `ecommerce:write`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        product_id : str
            Unique identifier for a Product

        skus : typing.Sequence[Sku]
            An array of the SKU data your are adding

        publish_status : typing.Optional[PublishStatus]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProductsCreateSkuResponse
            Request was successful

        Examples
        --------
        from webflow import Sku, Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.create_sku(
            site_id="580e63e98c9a982ac9b8b741",
            product_id="580e63fc8c9a982ac9b8b745",
            skus=[Sku()],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}/skus",
            method="POST",
            json={
                "publishStatus": publish_status,
                "skus": convert_and_respect_annotation_metadata(
                    object_=skus, annotation=typing.Sequence[Sku], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ProductsCreateSkuResponse,
                    parse_obj_as(
                        type_=ProductsCreateSkuResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_sku(
        self,
        site_id: str,
        product_id: str,
        sku_id: str,
        *,
        sku: Sku,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Sku:
        """
        Update a specified SKU.

        Updating an existing SKU will set the Product type to `Advanced`, which ensures all Product and SKU fields will be shown to users in the Designer.

        Required scope | `ecommerce:write`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        product_id : str
            Unique identifier for a Product

        sku_id : str
            Unique identifier for a SKU

        sku : Sku

        publish_status : typing.Optional[PublishStatus]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Sku
            Request was successful

        Examples
        --------
        from webflow import Sku, Webflow

        client = Webflow(
            access_token="YOUR_ACCESS_TOKEN",
        )
        client.products.update_sku(
            site_id="580e63e98c9a982ac9b8b741",
            product_id="580e63fc8c9a982ac9b8b745",
            sku_id="5e8518516e147040726cc415",
            sku=Sku(),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}/skus/{jsonable_encoder(sku_id)}",
            method="PATCH",
            json={
                "publishStatus": publish_status,
                "sku": convert_and_respect_annotation_metadata(object_=sku, annotation=Sku, direction="write"),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Sku,
                    parse_obj_as(
                        type_=Sku,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncProductsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        site_id: str,
        *,
        offset: typing.Optional[float] = None,
        limit: typing.Optional[float] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProductAndSkUsList:
        """
        Retrieve all products for a site.

        Use `limit` and `offset` to page through all products with subsequent requests. All SKUs for each product
        will also be fetched and returned. The `limit`, `offset` and `total` values represent Products only and do not include any SKUs.

        Required scope | `ecommerce:read`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        offset : typing.Optional[float]
            Offset used for pagination if the results have more than limit records

        limit : typing.Optional[float]
            Maximum number of records to be returned (max limit: 100)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProductAndSkUsList
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.products.list(
                site_id="580e63e98c9a982ac9b8b741",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products",
            method="GET",
            params={
                "offset": offset,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ProductAndSkUsList,
                    parse_obj_as(
                        type_=ProductAndSkUsList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        site_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        product: typing.Optional[Product] = OMIT,
        sku: typing.Optional[Sku] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProductAndSkUs:
        """
        Create a new product and SKU.

        When you create a product, you will always create a SKU, since a Product Item must have, at minimum, a single SKU.

        To create a Product with multiple SKUs - for example a T-shirt in sizes small, medium and large:
          - Create parameters in `sku-properties`, also known as [product options and variants.](https://help.webflow.com/hc/en-us/articles/33961334531347-Create-product-options-and-variants).
          - A single `sku-property` would be `color`. Within the `color` property, list the various colors of T-shirts as an array of `enum` values: `royal-blue`, `crimson-red`, and `forrest-green`.
          - Once, you've created a Product and its `sku-properties` with `enum` values, Webflow will create a **default SKU**, which will automatically be a combination of the first `sku-properties` you've created.
          - In our example, the default SKU will be a Royal Blue T-Shirt, because our first `enum` of our Color `sku-property` is Royal Blue.
          - After you've created your product, you can create additional SKUs using the [Create SKU endpoint.](/data/reference/ecommerce/products/create-sku)

        Upon creation, the default product type will be `Advanced`, which ensures all Product and SKU fields will be shown to users in the Designer.

        Required scope | `ecommerce:write`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        publish_status : typing.Optional[PublishStatus]

        product : typing.Optional[Product]

        sku : typing.Optional[Sku]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProductAndSkUs
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.products.create(
                site_id="580e63e98c9a982ac9b8b741",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products",
            method="POST",
            json={
                "publishStatus": publish_status,
                "product": convert_and_respect_annotation_metadata(
                    object_=product, annotation=Product, direction="write"
                ),
                "sku": convert_and_respect_annotation_metadata(object_=sku, annotation=Sku, direction="write"),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ProductAndSkUs,
                    parse_obj_as(
                        type_=ProductAndSkUs,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self, site_id: str, product_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ProductAndSkUs:
        """
        Retrieve a single product by its ID. All of its SKUs will also be
        retrieved.

        Required scope | `ecommerce:read`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        product_id : str
            Unique identifier for a Product

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProductAndSkUs
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.products.get(
                site_id="580e63e98c9a982ac9b8b741",
                product_id="580e63fc8c9a982ac9b8b745",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ProductAndSkUs,
                    parse_obj_as(
                        type_=ProductAndSkUs,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        site_id: str,
        product_id: str,
        *,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        product: typing.Optional[Product] = OMIT,
        sku: typing.Optional[Sku] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Product:
        """
        Update an existing Product.

        Updating an existing Product will set the product type to `Advanced`, which ensures all Product and SKU fields will be shown to users in the Designer.

        Required scope | `ecommerce:write`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        product_id : str
            Unique identifier for a Product

        publish_status : typing.Optional[PublishStatus]

        product : typing.Optional[Product]

        sku : typing.Optional[Sku]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Product
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.products.update(
                site_id="580e63e98c9a982ac9b8b741",
                product_id="580e63fc8c9a982ac9b8b745",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}",
            method="PATCH",
            json={
                "publishStatus": publish_status,
                "product": convert_and_respect_annotation_metadata(
                    object_=product, annotation=Product, direction="write"
                ),
                "sku": convert_and_respect_annotation_metadata(object_=sku, annotation=Sku, direction="write"),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Product,
                    parse_obj_as(
                        type_=Product,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_sku(
        self,
        site_id: str,
        product_id: str,
        *,
        skus: typing.Sequence[Sku],
        publish_status: typing.Optional[PublishStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProductsCreateSkuResponse:
        """
        Create additional SKUs to manage every [option and variant of your Product.](https://help.webflow.com/hc/en-us/articles/33961334531347-Create-product-options-and-variants)

        Creating SKUs through the API will set the product type to `Advanced`, which ensures all Product and SKU fields will be shown to users in the Designer.

        Required scope | `ecommerce:write`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        product_id : str
            Unique identifier for a Product

        skus : typing.Sequence[Sku]
            An array of the SKU data your are adding

        publish_status : typing.Optional[PublishStatus]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProductsCreateSkuResponse
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow, Sku

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.products.create_sku(
                site_id="580e63e98c9a982ac9b8b741",
                product_id="580e63fc8c9a982ac9b8b745",
                skus=[Sku()],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}/skus",
            method="POST",
            json={
                "publishStatus": publish_status,
                "skus": convert_and_respect_annotation_metadata(
                    object_=skus, annotation=typing.Sequence[Sku], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ProductsCreateSkuResponse,
                    parse_obj_as(
                        type_=ProductsCreateSkuResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_sku(
        self,
        site_id: str,
        product_id: str,
        sku_id: str,
        *,
        sku: Sku,
        publish_status: typing.Optional[PublishStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Sku:
        """
        Update a specified SKU.

        Updating an existing SKU will set the Product type to `Advanced`, which ensures all Product and SKU fields will be shown to users in the Designer.

        Required scope | `ecommerce:write`

        Parameters
        ----------
        site_id : str
            Unique identifier for a Site

        product_id : str
            Unique identifier for a Product

        sku_id : str
            Unique identifier for a SKU

        sku : Sku

        publish_status : typing.Optional[PublishStatus]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Sku
            Request was successful

        Examples
        --------
        import asyncio

        from webflow import AsyncWebflow, Sku

        client = AsyncWebflow(
            access_token="YOUR_ACCESS_TOKEN",
        )


        async def main() -> None:
            await client.products.update_sku(
                site_id="580e63e98c9a982ac9b8b741",
                product_id="580e63fc8c9a982ac9b8b745",
                sku_id="5e8518516e147040726cc415",
                sku=Sku(),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sites/{jsonable_encoder(site_id)}/products/{jsonable_encoder(product_id)}/skus/{jsonable_encoder(sku_id)}",
            method="PATCH",
            json={
                "publishStatus": publish_status,
                "sku": convert_and_respect_annotation_metadata(object_=sku, annotation=Sku, direction="write"),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Sku,
                    parse_obj_as(
                        type_=Sku,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
