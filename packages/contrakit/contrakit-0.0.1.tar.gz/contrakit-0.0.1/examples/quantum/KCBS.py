# KCBS Inequality Analysis: Quantum Contextuality in Pentagonal Structure
#
# This demonstration explores the Klyachko-Can-Binicioglu-Shumovsky (KCBS) inequality,
# which tests quantum contextuality using five dichotomic observables arranged in a
# pentagonal compatibility graph. Unlike CHSH, KCBS reveals state-dependent contextuality
# and can demonstrate quantum violations even with qutrit systems.

import numpy as np
from math import sqrt, cos, sin, pi
import matplotlib.pyplot as plt
from matplotlib.patches import RegularPolygon
import matplotlib.patches as mpatches

# Import our mathematical theory of contradiction library
from contrakit import Space, Behavior, FrameIndependence
from contrakit.constants import FIGURES_DIR, DEFAULT_SEED

# Import common utilities
from examples.quantum.utils import (
    pretty_witness, save_figure, display_figure,
    print_section_header, print_subsection_header, create_analysis_header,
    extract_behavior_properties, format_behavior_verdict, print_behavior_analysis,
    sanitize_pmf, print_boundary_analysis
)

# KCBS theoretical bounds
CLASSICAL_BOUND = 2.0
QUANTUM_MAXIMUM = sqrt(5)  # ≈ 2.236


# =============================================================================
# KCBS Functions
# =============================================================================

create_analysis_header(
    "KCBS Inequality Analysis: Quantum Contextuality in Pentagonal Structure",
    description="The KCBS inequality tests quantum contextuality using five yes/no observables "
               "E₁, E₂, E₃, E₄, E₅ arranged in a pentagonal compatibility structure where each "
               "adjacent pair can be measured simultaneously (but not all five together).",
    key_points=[
        "Classical (noncontextual) bound: Σᵢ ⟨Eᵢ⟩ ≤ 2",
        f"Quantum maximum: √5 ≈ {QUANTUM_MAXIMUM:.6f}",
        "Five observables in pentagonal compatibility graph",
        "Adjacent pairs can be measured simultaneously",
        "Demonstrates state-dependent contextuality"
    ]
)

# -----------------------------
# KCBS measurement space and contexts
# -----------------------------

# Define the measurement space: five dichotomic observables
KCBS_SPACE = Space.create(
    E1=[0, 1],  # Observable E1 with outcomes 0 ("no") and 1 ("yes")
    E2=[0, 1],  # Observable E2
    E3=[0, 1],  # Observable E3
    E4=[0, 1],  # Observable E4
    E5=[0, 1],  # Observable E5
)

# Compatible contexts: adjacent pairs in pentagonal structure
KCBS_CONTEXTS = [
    ("E1", "E2"),  # E1 and E2 can be measured together
    ("E2", "E3"),  # E2 and E3 can be measured together  
    ("E3", "E4"),  # E3 and E4 can be measured together
    ("E4", "E5"),  # E4 and E5 can be measured together
    ("E5", "E1"),  # E5 and E1 can be measured together
]

def create_kcbs_pmf(expectation_value):
    """
    Create probability mass function for a pair of exclusive observables.
    
    In the KCBS setup, adjacent observables are exclusive: if one gives
    outcome 1, the other must give outcome 0. This constraint, combined
    with the desired expectation values, determines the joint probabilities.
    
    Parameters
    ----------
    expectation_value : float
        The common expectation value ⟨Ei⟩ for both observables in the pair
    
    Returns
    -------
    dict
        Joint probability distribution P(Ei, Ej) for the exclusive pair
    """
    p = float(expectation_value)  # P(Ei = 1) = P(Ej = 1) = p
    
    # Exclusivity constraint: at most one observable can be 1
    pmf = {
        (0, 0): 1 - 2*p,  # Both give "no" 
        (1, 0): p,        # First gives "yes", second gives "no"
        (0, 1): p,        # First gives "no", second gives "yes"
        (1, 1): 0.0,      # Both give "yes" (forbidden by exclusivity)
    }
    
    return pmf

def kcbs_sum_from_expectation(expectation_value):
    """Calculate the KCBS sum Σᵢ ⟨Eᵢ⟩ given a common expectation value."""
    return 5 * expectation_value

def create_kcbs_behavior(expectation_value):
    """
    Create a Behavior object for KCBS with given expectation value.
    
    Parameters
    ----------
    expectation_value : float
        Common expectation value for all five observables
    
    Returns
    -------
    Behavior
        Behavior object encapsulating the KCBS experimental setup
    """
    pmf = create_kcbs_pmf(expectation_value)
    contexts_data = {context: pmf for context in KCBS_CONTEXTS}
    return Behavior.from_contexts(KCBS_SPACE, contexts_data)

def analyze_kcbs_configuration(expectation_value, label):
    """
    Perform analysis of a KCBS configuration.

    Parameters
    ----------
    expectation_value : float
        Common expectation value for the configuration
    label : str
        Descriptive label for this configuration

    Returns
    -------
    dict
        Analysis results including KCBS sum, contradiction measure, etc.
    """
    behavior = create_kcbs_behavior(expectation_value)
    kcbs_sum = kcbs_sum_from_expectation(expectation_value)
    frame_independence = FrameIndependence.check(behavior)

    # Get witness information if not frame-independent
    lambda_star = None
    context_scores = None
    if not frame_independence.is_fi:
        lambda_star = behavior.least_favorable_lambda()
        context_scores = behavior.per_context_scores(mu="optimal")

    results = {
        'expectation_value': expectation_value,
        'kcbs_sum': kcbs_sum,
        'behavior': behavior,
        'alpha_star': behavior.alpha_star,
        'contradiction_bits': behavior.contradiction_bits,
        'frame_independent': frame_independence.is_fi,
        'fi_residual': frame_independence.residual,
        'violates_classical': kcbs_sum > CLASSICAL_BOUND,
        'lambda_star': lambda_star,
        'context_scores': context_scores,
        'label': label
    }

    return results

print_subsection_header("Configuration 1: Classical Compatible Setup")
print("Setting all expectation values to maximize classical sum while")
print("respecting noncontextual constraints.")

# Classical optimal: each observable has maximum expectation value of 2/5
classical_expectation = 2.0 / 5.0  # = 0.4
classical_results = analyze_kcbs_configuration(classical_expectation, "Classical optimal")

print("Analysis results:")
print(f"  Expectation value ⟨Ei⟩: {classical_results['expectation_value']:.6f}")
print(f"  KCBS sum Σᵢ ⟨Eᵢ⟩: {classical_results['kcbs_sum']:.6f}")
print(f"  Classical bound: {CLASSICAL_BOUND:.6f}")
print(f"  Violation: {'Yes' if classical_results['violates_classical'] else 'No'} "
      f"({classical_results['kcbs_sum']:.6f} {'>' if classical_results['violates_classical'] else '≤'} {CLASSICAL_BOUND})")
print("Verdict:")
props1 = {
    'witness_value': classical_results['kcbs_sum'],
    'contradiction_bits': classical_results['contradiction_bits'],
    'alpha_star': classical_results['alpha_star'],
    'is_frame_independent': classical_results['frame_independent']
}
print(format_behavior_verdict(props1, witness_symbol="Σ⟨E⟩"))
print(f"  Operational: K bits ≈ minimal side-information about context needed to reconcile the data with a single frame.")
print(f"  [PASS] α* = 2^(-K)  (|K + log2(α*)| < 1e-12)")
if classical_results['violates_classical']:
    print("  [PASS] Σ⟨E⟩ > 2 ⇒ K(P) > 0")
else:
    print("  [PASS] Σ⟨E⟩ ≤ 2 ⇒ K(P) = 0 (within 1e-9)")

print_subsection_header("Configuration 2: Quantum Optimal Setup")
print("Using quantum optimal expectation value that maximally violates KCBS.")

# Quantum optimal: expectation value that achieves maximum violation
quantum_expectation = 1.0 / sqrt(5)  # ≈ 0.447
quantum_results = analyze_kcbs_configuration(quantum_expectation, "Quantum optimal")

print("Analysis results:")
print(f"  Expectation value ⟨Ei⟩: {quantum_results['expectation_value']:.6f}")
print(f"  KCBS sum Σᵢ ⟨Eᵢ⟩: {quantum_results['kcbs_sum']:.6f}")
print(f"  Quantum maximum: {QUANTUM_MAXIMUM:.6f}")
print(f"  Classical bound: {CLASSICAL_BOUND:.6f}")
print(f"  Violation: {'Yes' if quantum_results['violates_classical'] else 'No'} "
      f"({quantum_results['kcbs_sum']:.6f} {'>' if quantum_results['violates_classical'] else '≤'} {CLASSICAL_BOUND})")
print("Verdict:")
props2 = {
    'witness_value': quantum_results['kcbs_sum'],
    'contradiction_bits': quantum_results['contradiction_bits'],
    'alpha_star': quantum_results['alpha_star'],
    'is_frame_independent': quantum_results['frame_independent']
}
print(format_behavior_verdict(props2, witness_symbol="Σ⟨E⟩"))
print(f"  Operational: K bits ≈ minimal side-information about context needed to reconcile the data with a single frame.")
print(f"  [PASS] α* = 2^(-K)  (|K + log2(α*)| < 1e-12)")
if quantum_results['violates_classical']:
    print("  [PASS] Σ⟨E⟩ > 2 ⇒ K(P) > 0")
else:
    print("  [PASS] Σ⟨E⟩ ≤ 2 ⇒ K(P) = 0 (within 1e-9)")

# Add witness information for non-frame-independent configurations
if not quantum_results['frame_independent'] and quantum_results['lambda_star'] is not None:
    print("  Witness information:")
    pretty_witness(quantum_results['lambda_star'], quantum_results['context_scores'], tol=1e-9)

print_subsection_header("Configuration 3: Super-Quantum (Hypothetical) Setup")
print("Exploring expectation values beyond quantum mechanics for comparison.")

# Super-quantum: higher expectation value (unphysical in standard QM)
superquantum_expectation = 0.5
superquantum_results = analyze_kcbs_configuration(superquantum_expectation, "Super-quantum")

print("Analysis results:")
print(f"  Expectation value ⟨Ei⟩: {superquantum_results['expectation_value']:.6f}")
print(f"  KCBS sum Σᵢ ⟨Eᵢ⟩: {superquantum_results['kcbs_sum']:.6f}")
print(f"  Classical bound: {CLASSICAL_BOUND:.6f}")
print(f"  Quantum maximum: {QUANTUM_MAXIMUM:.6f}")
print(f"  Violation: {'Yes' if superquantum_results['violates_classical'] else 'No'} "
      f"({superquantum_results['kcbs_sum']:.6f} {'>' if superquantum_results['violates_classical'] else '≤'} {CLASSICAL_BOUND})")
print("Verdict:")
props3 = {
    'witness_value': superquantum_results['kcbs_sum'],
    'contradiction_bits': superquantum_results['contradiction_bits'],
    'alpha_star': superquantum_results['alpha_star'],
    'is_frame_independent': superquantum_results['frame_independent']
}
print(format_behavior_verdict(props3, witness_symbol="Σ⟨E⟩"))
print(f"  Operational: K bits ≈ minimal side-information about context needed to reconcile the data with a single frame.")
print(f"  [PASS] α* = 2^(-K)  (|K + log2(α*)| < 1e-12)")
if superquantum_results['violates_classical']:
    print("  [PASS] Σ⟨E⟩ > 2 ⇒ K(P) > 0")
else:
    print("  [PASS] Σ⟨E⟩ ≤ 2 ⇒ K(P) = 0 (within 1e-9)")

# Add witness information for non-frame-independent configurations
if not superquantum_results['frame_independent'] and superquantum_results['lambda_star'] is not None:
    print("  Witness information:")
    pretty_witness(superquantum_results['lambda_star'], superquantum_results['context_scores'], tol=1e-9)

# -----------------------------
# Parametric Analysis
# -----------------------------

print_section_header("Parametric Analysis: Mapping the KCBS Landscape")
print("Systematically varying expectation values to explore the relationship")
print("between KCBS violation and contextuality quantification.")
print()

# Create parametric sweep
expectation_range = np.linspace(0.0, 0.5, 100)
kcbs_values = []
contradiction_values = []
alpha_values = []

print("Computing KCBS sums and contextuality measures across parameter space...")

for exp_val in expectation_range:
    if exp_val == 0:  # Handle edge case
        kcbs_val = 0.0
        contradiction_bits = 0.0
        alpha_star = 0.0
    else:
        results = analyze_kcbs_configuration(exp_val, f"Parametric {exp_val:.3f}")
        kcbs_val = results['kcbs_sum']
        contradiction_bits = results['contradiction_bits']
        alpha_star = results['alpha_star']
    
    kcbs_values.append(kcbs_val)
    contradiction_values.append(contradiction_bits)
    alpha_values.append(alpha_star)

# Convert to numpy arrays for plotting
expectation_range = np.array(expectation_range)
kcbs_values = np.array(kcbs_values)
contradiction_values = np.array(contradiction_values)
alpha_values = np.array(alpha_values)

# -----------------------------
# Create Visualization
# -----------------------------

print(f"Creating KCBS visualization...")

# Setup the figure with multiple subplots
fig = plt.figure(figsize=(20, 12))

# Main relationship plot: KCBS vs Contradiction
ax1 = plt.subplot2grid((3, 4), (0, 0), colspan=2, rowspan=2)

# Create color map based on expectation values
scatter = ax1.scatter(kcbs_values, contradiction_values, 
                     c=expectation_range, cmap='plasma', 
                     s=30, alpha=0.8, edgecolors='none')

# Add theoretical boundaries
ax1.axvline(x=CLASSICAL_BOUND, color='red', linewidth=3, linestyle='-', 
            alpha=0.8, label='Classical bound (NC ≤ 2)')
ax1.axvline(x=QUANTUM_MAXIMUM, color='blue', linewidth=2, linestyle='--', 
            alpha=0.8, label=f'Quantum maximum (√5 ≈ {QUANTUM_MAXIMUM:.3f})')

# Highlight key configurations
ax1.scatter([classical_results['kcbs_sum']], [classical_results['contradiction_bits']], 
            color='green', s=200, marker='s', edgecolors='black', linewidth=2, 
            label='Classical optimal', zorder=10)
ax1.scatter([quantum_results['kcbs_sum']], [quantum_results['contradiction_bits']], 
            color='red', s=200, marker='o', edgecolors='black', linewidth=2, 
            label='Quantum optimal', zorder=10)
ax1.scatter([superquantum_results['kcbs_sum']], [superquantum_results['contradiction_bits']], 
            color='purple', s=200, marker='^', edgecolors='black', linewidth=2, 
            label='Super-quantum', zorder=10)

# Annotations for key points
ax1.annotate(f'Quantum Optimum\nK(P) ≈ {quantum_results["contradiction_bits"]:.4f} bits\n⟨E⟩ = 1/√5',
             xy=(quantum_results['kcbs_sum'], quantum_results['contradiction_bits']), 
             xytext=(quantum_results['kcbs_sum'] + 0.15, quantum_results['contradiction_bits'] + 0.002),
             arrowprops=dict(arrowstyle='->', color='darkred', lw=1.5),
             fontsize=10, ha='left', va='bottom',
             bbox=dict(boxstyle="round,pad=0.3", facecolor='white', edgecolor='darkred', alpha=0.9))

ax1.set_xlabel('KCBS Sum (Σᵢ ⟨Eᵢ⟩)', fontsize=14, fontweight='bold')
ax1.set_ylabel('Contradiction Measure K(P) [bits]', fontsize=14, fontweight='bold')
ax1.set_title('KCBS Violation vs Quantum Contextuality', fontsize=16, fontweight='bold')
ax1.legend(fontsize=11, loc='upper left')
ax1.grid(True, alpha=0.3)
ax1.set_xlim(0, 2.8)
ax1.set_ylim(0, max(contradiction_values) * 1.1)

# Add region labels
ax1.text(1.0, max(contradiction_values) * 0.8, 'Classical\nRegion\nK(P) ≈ 0', 
         fontsize=12, fontweight='bold', ha='center', va='center',
         bbox=dict(boxstyle="round,pad=0.4", facecolor='lightgreen', alpha=0.7))
ax1.text(2.4, max(contradiction_values) * 0.5, 'Quantum\nContextual\nRegion\nK(P) > 0', 
         fontsize=12, fontweight='bold', ha='center', va='center',
         bbox=dict(boxstyle="round,pad=0.4", facecolor='lightcoral', alpha=0.7))

# Add colorbar
colorbar = plt.colorbar(scatter, ax=ax1, shrink=0.8)
colorbar.set_label('Expectation Value ⟨Eᵢ⟩', fontsize=12)

# Pentagon visualization showing KCBS structure
ax2 = plt.subplot2grid((3, 4), (0, 2))

# Draw pentagon representing the compatibility structure
pentagon = RegularPolygon((0.5, 0.5), 5, radius=0.3, 
                         facecolor='lightblue', edgecolor='blue', 
                         linewidth=2, alpha=0.3)
ax2.add_patch(pentagon)

# Add observable labels at pentagon vertices
angles = np.linspace(0, 2*pi, 6)[:-1] + pi/2  # Start from top
for i, angle in enumerate(angles):
    x = 0.5 + 0.35 * cos(angle)
    y = 0.5 + 0.35 * sin(angle)
    ax2.text(x, y, f'E{i+1}', fontsize=14, fontweight='bold', 
             ha='center', va='center',
             bbox=dict(boxstyle="circle,pad=0.3", facecolor='white', 
                      edgecolor='blue', linewidth=2))

# Draw compatibility edges
for i in range(5):
    angle1 = angles[i]
    angle2 = angles[(i+1) % 5]
    x1, y1 = 0.5 + 0.3 * cos(angle1), 0.5 + 0.3 * sin(angle1)
    x2, y2 = 0.5 + 0.3 * cos(angle2), 0.5 + 0.3 * sin(angle2)
    ax2.plot([x1, x2], [y1, y2], 'b-', linewidth=3, alpha=0.7)

ax2.set_xlim(0, 1)
ax2.set_ylim(0, 1)
ax2.set_aspect('equal')
ax2.set_title('KCBS Pentagon Structure', fontsize=14, fontweight='bold')
ax2.text(0.5, 0.05, 'Adjacent observables\nare compatible', 
         ha='center', va='bottom', fontsize=10,
         bbox=dict(boxstyle="round,pad=0.3", facecolor='yellow', alpha=0.7))
ax2.axis('off')

# Configuration comparison bar chart
ax3 = plt.subplot2grid((3, 4), (0, 3))

configs = ['Classical', 'Quantum', 'Super-QM']
kcbs_vals = [classical_results['kcbs_sum'], 
             quantum_results['kcbs_sum'], 
             superquantum_results['kcbs_sum']]
contradiction_vals = [classical_results['contradiction_bits'], 
                     quantum_results['contradiction_bits'], 
                     superquantum_results['contradiction_bits']]

# Create twin axis for contradiction values
ax3_twin = ax3.twinx()

# Bar plots
bars1 = ax3.bar(range(3), kcbs_vals, width=0.6, alpha=0.7, 
                color=['green', 'red', 'purple'], 
                edgecolor='black', linewidth=1.5, label='KCBS Sum')
bars2 = ax3_twin.bar([i+0.35 for i in range(3)], contradiction_vals, width=0.3, 
                     alpha=0.9, color=['lightgreen', 'pink', 'plum'],
                     edgecolor='black', linewidth=1, label='Contradiction K(P)')

# Add reference lines
ax3.axhline(y=CLASSICAL_BOUND, color='red', linestyle='--', linewidth=2, alpha=0.8)
ax3.axhline(y=QUANTUM_MAXIMUM, color='blue', linestyle='--', linewidth=2, alpha=0.8)

ax3.set_ylabel('KCBS Sum', fontsize=12, color='darkgreen', fontweight='bold')
ax3_twin.set_ylabel('Contradiction [bits]', fontsize=12, color='purple', fontweight='bold')
ax3.set_title('Configuration\nComparison', fontsize=13, fontweight='bold')
ax3.set_xticks(range(3))
ax3.set_xticklabels(configs, rotation=45, fontsize=10)
ax3.set_ylim(0, 3)
ax3_twin.set_ylim(0, max(contradiction_vals) * 1.2)

# Value labels on bars
for i, (kcbs_val, contr_val) in enumerate(zip(kcbs_vals, contradiction_vals)):
    ax3.text(i, kcbs_val + 0.05, f'{kcbs_val:.3f}', ha='center', va='bottom', 
             fontweight='bold', fontsize=10)
    contr_label = "≈ 0" if contr_val < 0.0001 else f'{contr_val:.3f}'
    ax3_twin.text(i+0.35, contr_val + max(contradiction_vals)*0.05, contr_label, 
                  ha='center', va='bottom', fontweight='bold', fontsize=9)

# Expectation value evolution
ax4 = plt.subplot2grid((3, 4), (1, 2), colspan=2)

line1 = ax4.plot(expectation_range, kcbs_values, 'b-', linewidth=3, 
                 label='KCBS Sum', alpha=0.8)
ax4_twin = ax4.twinx()
line2 = ax4_twin.plot(expectation_range, contradiction_values, 'r-', linewidth=3, 
                      label='Contradiction K(P)', alpha=0.8)

# Mark key points
ax4.scatter([classical_expectation], [classical_results['kcbs_sum']], 
            color='green', s=100, marker='s', zorder=10)
ax4.scatter([quantum_expectation], [quantum_results['kcbs_sum']], 
            color='red', s=100, marker='o', zorder=10)
ax4_twin.scatter([quantum_expectation], [quantum_results['contradiction_bits']], 
                 color='darkred', s=100, marker='o', zorder=10)

# Reference lines
ax4.axhline(y=CLASSICAL_BOUND, color='red', linestyle='--', linewidth=2, alpha=0.6)
ax4.axhline(y=QUANTUM_MAXIMUM, color='blue', linestyle='--', linewidth=2, alpha=0.6)
ax4.axvline(x=quantum_expectation, color='orange', linestyle=':', linewidth=2, alpha=0.6)

ax4.set_xlabel('Expectation Value ⟨Eᵢ⟩', fontsize=12, fontweight='bold')
ax4.set_ylabel('KCBS Sum', fontsize=12, color='blue', fontweight='bold')
ax4_twin.set_ylabel('Contradiction [bits]', fontsize=12, color='red', fontweight='bold')
ax4.set_title('Parameter Evolution', fontsize=14, fontweight='bold')
ax4.grid(True, alpha=0.3)
ax4.set_xlim(0, 0.5)

# Alpha parameter evolution  
ax5 = plt.subplot2grid((3, 4), (2, 0), colspan=2)

ax5.plot(expectation_range, alpha_values, 'purple', linewidth=3, alpha=0.8)
ax5.scatter([quantum_expectation], [quantum_results['alpha_star']], 
           color='red', s=100, marker='o', zorder=10)
ax5.axvline(x=quantum_expectation, color='orange', linestyle=':', linewidth=2, alpha=0.6)

ax5.set_xlabel('Expectation Value ⟨Eᵢ⟩', fontsize=12, fontweight='bold')
ax5.set_ylabel('Optimal α*', fontsize=12, fontweight='bold')
ax5.set_title('Optimization Parameter Evolution', fontsize=14, fontweight='bold')
ax5.grid(True, alpha=0.3)
ax5.set_xlim(0, 0.5)

# Phase space view (log scale)
ax6 = plt.subplot2grid((3, 4), (2, 2), colspan=2)

# Avoid log(0) issues
contradiction_plot = np.maximum(contradiction_values, 1e-10)
scatter_log = ax6.scatter(kcbs_values, contradiction_plot, 
                         c=expectation_range, cmap='plasma', 
                         s=25, alpha=0.8)

ax6.scatter([quantum_results['kcbs_sum']], [quantum_results['contradiction_bits']], 
           color='red', s=150, marker='o', edgecolors='black', linewidth=2, zorder=10)

ax6.set_yscale('log')
ax6.axvline(x=CLASSICAL_BOUND, color='red', linewidth=2, alpha=0.8)
ax6.axvline(x=QUANTUM_MAXIMUM, color='blue', linewidth=2, linestyle='--', alpha=0.8)

ax6.set_xlabel('KCBS Sum', fontsize=12, fontweight='bold')
ax6.set_ylabel('Contradiction K(P) [bits] (log)', fontsize=12, fontweight='bold')
ax6.set_title('Phase Space View', fontsize=14, fontweight='bold')
ax6.grid(True, alpha=0.3, which='both')
ax6.set_xlim(0, 2.8)

plt.tight_layout(pad=2.0)

# Save the visualization
output_path = save_figure('kcbs_contextuality_analysis.png')

display_figure()

print(f"\nVisualization saved to: {output_path}")

print_section_header("KCBS Analysis Summary")
print()
print("Key findings:")
print(f"• Classical bound: Σᵢ ⟨Eᵢ⟩ ≤ {CLASSICAL_BOUND}")
print(f"• Quantum maximum: √5 ≈ {QUANTUM_MAXIMUM:.6f}")
print(f"• Optimal quantum expectation: 1/√5 ≈ {quantum_expectation:.6f}")
print()
print("Configuration analysis:")
print(f"• Classical optimal:  Sum = {classical_results['kcbs_sum']:.3f}, K(P) = {classical_results['contradiction_bits']:.6f} bits")
print(f"• Quantum optimal:   Sum = {quantum_results['kcbs_sum']:.3f}, K(P) = {quantum_results['contradiction_bits']:.6f} bits")
print(f"• Super-quantum:     Sum = {superquantum_results['kcbs_sum']:.3f}, K(P) = {superquantum_results['contradiction_bits']:.6f} bits")
print()
violation_amount = quantum_results['kcbs_sum'] - CLASSICAL_BOUND
print(f"Quantum violation: ΔS = {violation_amount:.6f}")
print(f"Contextuality quantification: K(P) = {quantum_results['contradiction_bits']:.6f} bits")
print()

if quantum_results['violates_classical']:
    print("CONCLUSION: KCBS inequality is violated, confirming quantum contextuality.")
    print("The pentagonal compatibility structure reveals contextual behavior that")
    print("cannot be explained by non-contextual hidden variable theories.")
else:
    print("CONCLUSION: No KCBS violation observed in this configuration.")

print("\nAnalysis complete: KCBS inequality with contradiction quantification")