// --- Drag utilities ---
        function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }

        function restorePosition(el, storageKey) {
            try {
                const raw = localStorage.getItem(storageKey);
                if (!raw) return;
                const pos = JSON.parse(raw);
                if (typeof pos.left === 'number' && typeof pos.top === 'number') {
                    el.style.left = pos.left + 'px';
                    el.style.top = pos.top + 'px';
                    el.style.right = 'auto';
                    el.style.bottom = 'auto';
                }
            } catch (_) {}
        }

        function savePosition(el, storageKey) {
            try {
                const left = parseFloat(el.style.left || 'NaN');
                const top = parseFloat(el.style.top || 'NaN');
                if (!Number.isNaN(left) && !Number.isNaN(top)) {
                    localStorage.setItem(storageKey, JSON.stringify({ left, top }));
                }
            } catch (_) {}
        }


        function makeDraggable(el, storageKey, handleEl) {
            let dragging = false;
            let startX = 0, startY = 0; // cursor
            let origLeft = 0, origTop = 0; // element

            const onMove = (e) => {
                if (!dragging) return;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const dx = clientX - startX;
                const dy = clientY - startY;
                const w = el.offsetWidth;
                const h = el.offsetHeight;
                const maxX = window.innerWidth - w;
                const maxY = window.innerHeight - h;
                const newLeft = clamp(origLeft + dx, 0, maxX);
                const newTop = clamp(origTop + dy, 0, maxY);
                el.style.left = newLeft + 'px';
                el.style.top = newTop + 'px';
                el.style.right = 'auto';
                el.style.bottom = 'auto';
            };

            const endDrag = () => {
                if (!dragging) return;
                dragging = false;
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchmove', onMove);
                document.removeEventListener('touchend', endDrag);
                handleEl && (handleEl.style.cursor = 'grab');
                savePosition(el, storageKey);
                // ensure no-overlap constraint after a drag
                try { layoutWidgetsStackedBottomRight(); } catch (_) {}
            };

            const startDrag = (e) => {
                // Start from element's current on-screen rect
                const elRect = el.getBoundingClientRect();
                el.style.left = elRect.left + 'px';
                el.style.top = elRect.top + 'px';
                el.style.right = 'auto';
                el.style.bottom = 'auto';

                dragging = true;
                startX = e.touches ? e.touches[0].clientX : e.clientX;
                startY = e.touches ? e.touches[0].clientY : e.clientY;
                origLeft = elRect.left;
                origTop = elRect.top;

                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchmove', onMove, { passive: false });
                document.addEventListener('touchend', endDrag);
                handleEl && (handleEl.style.cursor = 'grabbing');
                e.preventDefault();
            };

            (handleEl || el).addEventListener('mousedown', startDrag);
            (handleEl || el).addEventListener('touchstart', startDrag, { passive: false });

            // Apply any saved position on init
            restorePosition(el, storageKey);
        }
        function toggleCell(cellId) {
            const codeElement = document.getElementById('code-' + cellId);
            const outputElement = document.getElementById('output-' + cellId);
            
            if (codeElement) {
                codeElement.classList.toggle('collapsed');
            }
            if (outputElement) {
                outputElement.classList.toggle('collapsed');
            }
            
            updateIndicators(cellId);
            encodeToolStateToUrl();
        }
        
        function toggleCode(cellId) {
            const codeElement = document.getElementById('code-' + cellId);
            if (codeElement) {
                codeElement.classList.toggle('collapsed');
                updateIndicators(cellId);
                encodeToolStateToUrl();
            }
        }
        
        function toggleOutput(cellId) {
            const outputElement = document.getElementById('output-' + cellId);
            if (outputElement) {
                outputElement.classList.toggle('collapsed');
                updateIndicators(cellId);
                encodeToolStateToUrl();
            }
        }

        function toggleUvLogs(headerElement) {
            const contentElement = headerElement.nextElementSibling;
            if (contentElement) {
                const isCollapsed = contentElement.style.display === 'none';
                contentElement.style.display = isCollapsed ? 'block' : 'none';
                headerElement.textContent = isCollapsed ? '▼ UV Install Logs' : '▶ UV Install Logs';

                // Update the header indicator if it exists
                const uvLogsDiv = headerElement.parentElement;
                if (uvLogsDiv && uvLogsDiv.id && uvLogsDiv.id.startsWith('uv-logs-')) {
                    const cellId = uvLogsDiv.id.replace('uv-logs-', '');
                    const indicatorElement = document.getElementById('uv-indicator-' + cellId);
                    if (indicatorElement) {
                        indicatorElement.textContent = isCollapsed ? '▼ uv-logs' : '▶ uv-logs';
                    }
                }
            }
        }

        function toggleUvLogsFromHeader(cellId) {
            const uvLogsElement = document.getElementById('uv-logs-' + cellId);
            const indicatorElement = document.getElementById('uv-indicator-' + cellId);
            if (uvLogsElement) {
                const headerElement = uvLogsElement.querySelector('.uv-logs-header');
                const contentElement = uvLogsElement.querySelector('.uv-logs-content');
                if (contentElement && headerElement) {
                    const isCollapsed = contentElement.style.display === 'none';
                    contentElement.style.display = isCollapsed ? 'block' : 'none';
                    headerElement.textContent = isCollapsed ? '▼ UV Install Logs' : '▶ UV Install Logs';
                    if (indicatorElement) {
                        indicatorElement.textContent = isCollapsed ? '▼ uv-logs' : '▶ uv-logs';
                    }
                }
            }
        }
        
        function updateIndicators(cellId) {
            const codeElement = document.getElementById('code-' + cellId);
            const outputElement = document.getElementById('output-' + cellId);
            const indicators = document.querySelector(`[onclick*="${cellId}"]`)?.closest('.cell-header')?.querySelector('.collapse-indicators');
            
            if (indicators) {
                const codeCollapsed = codeElement && codeElement.classList.contains('collapsed');
                const outputCollapsed = outputElement && outputElement.classList.contains('collapsed');
                
                const codeIcon = codeCollapsed ? '▶' : '▼';
                const outputIcon = outputCollapsed ? '▶' : '▼';
                
                const codeSpan = indicators.querySelector('[onclick*="toggleCode"]');
                const outputSpan = indicators.querySelector('[onclick*="toggleOutput"]');
                
                if (codeSpan) codeSpan.innerHTML = `${codeIcon} code`;
                if (outputSpan) outputSpan.innerHTML = `${outputIcon} output`;
            }
        }
        
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('uvnote-theme', newTheme);
            updateThemeIcon();
            updateUiDebug();
        }
        
        // Two panel code removed
        
        function updateThemeIcon() {
            const theme = document.documentElement.getAttribute('data-theme');
            const toggle = document.querySelector('.theme-toggle');
            if (toggle) {
                toggle.textContent = theme === 'dark' ? 'light' : 'dark';
            }
        }
        function setUiTheme(newUi) {
            if (newUi !== 'default' && newUi !== 'none' && newUi !== 'monocolor') return;
            const html = document.documentElement;
            html.setAttribute('data-ui', newUi);
            try { localStorage.setItem('uvnote-ui', newUi); } catch (_) {}
            updateUiMenu();
            updateUiDebug();
        }
        function updateUiMenu() {
            const ui = document.documentElement.getAttribute('data-ui') || 'default';
            const checks = {
                default: document.getElementById('checkbox-ui-default'),
                none: document.getElementById('checkbox-ui-none'),
                monocolor: document.getElementById('checkbox-ui-monocolor')
            };
            if (checks.default) checks.default.textContent = ui === 'default' ? '☑' : '☐';
            if (checks.none) checks.none.textContent = ui === 'none' ? '☑' : '☐';
            if (checks.monocolor) checks.monocolor.textContent = ui === 'monocolor' ? '☑' : '☐';
        }

        function updateUiDebug() {
            const ui = document.documentElement.getAttribute('data-ui') || 'default';
            const color = document.documentElement.getAttribute('data-theme') || 'light';
            const el = document.getElementById('ui-debug');
            if (el) {
                el.textContent = `UI: ${ui} | Color: ${color}`;
            }
        }

        // Line selection and deep-linking
        function clearLineSelections() {
            try {
                document.querySelectorAll('.code-line-highlight').forEach(el => { el.style.display = 'none'; });
                document.querySelectorAll('.line-number.selected').forEach(el => el.classList.remove('selected'));
            } catch (_) {}
        }

        let _selection = null; // { cellId, a, b }

        function clearSelection(updateUrl) {
            clearLineSelections();
            _selection = null;
            if (updateUrl) {
                try {
                    const url = new URL(window.location.href);
                    url.searchParams.delete('cell');
                    url.searchParams.delete('line');
                    history.replaceState(null, '', url.toString());
                } catch (_) {}
            }
            updateStateIndicator();
        }

        function selectCellLine(cellId, line, updateUrl) {
            try {
                // Ensure only one selection across the whole document
                clearLineSelections();
                const codeBox = document.getElementById(`code-${cellId}`);
                if (!codeBox) return;
                const pre = codeBox.querySelector('.highlight pre');
                const overlay = document.getElementById(`line-highlight-${cellId}`);
                const numbers = document.getElementById(`lines-${cellId}`);
                if (!pre || !overlay) return;

                // Measure line height directly from computed style
                const preStyle = getComputedStyle(pre);
                const padTop = parseFloat(preStyle.paddingTop || '0');
                const lh = parseFloat(preStyle.lineHeight || '20');

                // Position overlay
                overlay.style.display = 'block';
                overlay.style.height = `${lh}px`;
                overlay.style.top = `${pre.offsetTop + padTop + (line - 1) * lh}px`;

                // Update selected class in line numbers
                if (numbers) {
                    numbers.querySelectorAll('.line-number').forEach(a => a.classList.remove('selected'));
                    const sel = numbers.querySelector(`.line-number[data-line="${line}"]`);
                    if (sel) sel.classList.add('selected');
                }

                if (updateUrl) {
                    const url = new URL(window.location.href);
                    url.searchParams.set('cell', cellId);
                    url.searchParams.set('line', String(line));
                    history.replaceState(null, '', url.toString());
                }
                _selection = { cellId, a: line, b: line };
                updateStateIndicator();
            } catch (e) { console.warn('selectCellLine error', e); }
        }

        function selectCellLines(cellId, startLine, endLine, updateUrl) {
            try {
                // normalize order
                const a = Math.min(startLine, endLine);
                const b = Math.max(startLine, endLine);
                clearLineSelections();
                const codeBox = document.getElementById(`code-${cellId}`);
                if (!codeBox) return;
                const pre = codeBox.querySelector('.highlight pre');
                const overlay = document.getElementById(`line-highlight-${cellId}`);
                const numbers = document.getElementById(`lines-${cellId}`);
                if (!pre || !overlay) return;

                const preStyle = getComputedStyle(pre);
                const padTop = parseFloat(preStyle.paddingTop || '0');
                const lh = parseFloat(preStyle.lineHeight || '20');

                overlay.style.display = 'block';
                overlay.style.top = `${pre.offsetTop + padTop + (a - 1) * lh}px`;
                overlay.style.height = `${(b - a + 1) * lh}px`;

                if (numbers) {
                    numbers.querySelectorAll('.line-number').forEach(a => a.classList.remove('selected'));
                    for (let i = a; i <= b; i++) {
                        const el = numbers.querySelector(`.line-number[data-line="${i}"]`);
                        if (el) el.classList.add('selected');
                    }
                }

                if (updateUrl) {
                    const url = new URL(window.location.href);
                    url.searchParams.set('cell', cellId);
                    if (a === b) url.searchParams.set('line', String(a));
                    else url.searchParams.set('line', `${a}-${b}`);
                    history.replaceState(null, '', url.toString());
                }
                _selection = { cellId, a, b };
                updateStateIndicator();
            } catch (e) { console.warn('selectCellLines error', e); }
        }

        // Drag-to-select support on line numbers
        let _lineDrag = { active: false, cellId: null, start: 0 };
        function onLineNumberMouseDown(e) {
            const a = e.target.closest('.line-number');
            if (!a) return;
            e.preventDefault();
            const cellId = a.dataset.cell;
            const line = parseInt(a.dataset.line || '1', 10) || 1;
            // Toggle off if this exact single line is already the only selection
            const numbers = document.getElementById(`lines-${cellId}`);
            if (numbers) {
                const selected = Array.from(numbers.querySelectorAll('.line-number.selected')).map(n => parseInt(n.dataset.line||'0',10)).filter(Boolean);
                if (selected.length === 1 && selected[0] === line) {
                    clearSelection(true);
                    return;
                }
            }
            _lineDrag.active = true;
            _lineDrag.cellId = cellId;
            _lineDrag.start = line;
            selectCellLines(_lineDrag.cellId, _lineDrag.start, _lineDrag.start, false);
        }
        function onDocMouseMove(e) {
            if (!_lineDrag.active) return;
            const el = document.elementFromPoint(e.clientX, e.clientY);
            if (!el) return;
            const a = el.closest && el.closest('.line-number');
            if (!a) return;
            if (a.dataset.cell !== _lineDrag.cellId) return;
            const cur = parseInt(a.dataset.line || '1', 10) || 1;
            selectCellLines(_lineDrag.cellId, _lineDrag.start, cur, false);
        }
        function onDocMouseUp(e) {
            if (!_lineDrag.active) return;
            const last = document.querySelector('.line-number.selected:last-of-type');
            // finalize URL using the current selected range
            const numbers = document.getElementById(`lines-${_lineDrag.cellId}`);
            if (numbers) {
                const selected = Array.from(numbers.querySelectorAll('.line-number.selected')).map(n => parseInt(n.dataset.line||'0',10)).filter(Boolean);
                if (selected.length) {
                    const a = Math.min(...selected); const b = Math.max(...selected);
                    selectCellLines(_lineDrag.cellId, a, b, true);
                }
            }
            _lineDrag.active = false; _lineDrag.cellId = null; _lineDrag.start = 0;
        }

        function applyLocationFromUrl() {
            try {
                const url = new URL(window.location.href);
                const cell = url.searchParams.get('cell');
                const lineParam = url.searchParams.get('line');
                if (cell && lineParam) {
                    if (lineParam.includes('-')) {
                        const [a, b] = lineParam.split('-').map(x => parseInt(x, 10));
                        if (!Number.isNaN(a) && !Number.isNaN(b)) selectCellLines(cell, a, b, false);
                    } else {
                        const l = parseInt(lineParam, 10);
                        if (!Number.isNaN(l)) selectCellLine(cell, l, false);
                    }
                }
                
                // Apply tool parameters from URL
                applyToolsFromUrl(url.searchParams);
                
                // Cell states will be applied later in DOMContentLoaded with proper timing
                const encodedCellStates = url.searchParams.get('cells');
                console.log('Encoded cell states from URL:', encodedCellStates);
            } catch (_) {}
        }
        
        function applyToolsFromUrl(params) {
            try {
                // Check if tools widget should be shown
                const showTools = params.get('tools');
                if (showTools === '1') {
                    // Mark that tool was loaded from URL
                    _urlLoadedTool = true;
                    
                    // Apply color
                    const color = params.get('color');
                    if (color && /^[0-9a-fA-F]{6}$/.test(color)) {
                        setStoredArrowColor('#' + color);
                    }
                    
                    // Apply thickness
                    const thickness = params.get('thickness');
                    if (thickness) {
                        const value = parseInt(thickness, 10);
                        if (value >= 1 && value <= 10) {
                            setStoredLineThickness(value);
                        }
                    }
                    
                    // Don't override fadeout time for URL-loaded tools - let individual shapes decide
                    
                    // Load shapes from URL
                    const encodedShapes = params.get('shapes');
                    if (encodedShapes) {
                        const decodedShapes = decodeShapesFromUrl(encodedShapes);
                        if (decodedShapes.length > 0) {
                            _shapes = decodedShapes;
                            saveShapes();
                            // Trigger render after overlay is initialized
                            setTimeout(() => {
                                renderOverlay();
                            }, 300);
                        }
                    }
                    
                    // Wait for widgets to be initialized before showing tools
                    setTimeout(() => {
                        const toolsWidget = document.querySelector('.tools-widget');
                        const checkbox = document.getElementById('checkbox-tools');
                        if (toolsWidget && checkbox) {
                            toolsWidget.style.display = 'block';
                            checkbox.textContent = '☑';
                            localStorage.setItem('uvnote-widget-tools', 'visible');
                        }
                        
                        // Apply active tool
                        const activeTool = params.get('tool');
                        if (activeTool && ['arrow', 'pen', 'eraser', 'spotlight'].includes(activeTool)) {
                            const toolBtn = Array.from(document.querySelectorAll('.tool-button')).find(btn => btn.textContent === activeTool);
                            if (toolBtn) {
                                toolBtn.click();
                            }
                        }
                        
                        // Re-layout widgets after showing tools
                        layoutWidgetsStackedBottomRight();
                    }, 200);
                }
            } catch (_) {}
        }
        
        function captureInitialCellStates() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const cellId = cell.id.replace('cell-', '');
                const codeEl = document.getElementById('code-' + cellId);
                const outputEl = document.getElementById('output-' + cellId);
                
                if (codeEl || outputEl) {
                    const state = {};
                    if (codeEl) {
                        state.c = codeEl.classList.contains('collapsed') ? 0 : 1;
                    }
                    if (outputEl) {
                        state.o = outputEl.classList.contains('collapsed') ? 0 : 1;
                    }
                    _initialCellStates[cellId] = state;
                }
            });
            console.log('Captured initial cell states:', _initialCellStates);
        }

        function encodeCellStatesToUrl() {
            // Get all cells and their collapse states
            const cells = document.querySelectorAll('.cell');
            const cellStates = {};
            
            console.log('Found cells:', cells.length);
            
            cells.forEach(cell => {
                const cellId = cell.id.replace('cell-', '');
                const codeEl = document.getElementById('code-' + cellId);
                const outputEl = document.getElementById('output-' + cellId);
                const initialState = _initialCellStates[cellId] || {};
                
                console.log(`Encoding cell ${cellId}:`, {
                    codeEl: !!codeEl,
                    outputEl: !!outputEl,
                    codeCollapsed: codeEl ? codeEl.classList.contains('collapsed') : 'N/A',
                    outputCollapsed: outputEl ? outputEl.classList.contains('collapsed') : 'N/A',
                    initialState: initialState
                });
                
                if (codeEl || outputEl) {
                    const state = {};
                    let hasChanges = false;
                    
                    if (codeEl) {
                        const currentCodeState = codeEl.classList.contains('collapsed') ? 0 : 1;
                        const initialCodeState = initialState.c;
                        // Only encode if different from initial state
                        if (initialCodeState !== undefined && currentCodeState !== initialCodeState) {
                            state.c = currentCodeState;
                            hasChanges = true;
                        }
                    }
                    
                    if (outputEl) {
                        const currentOutputState = outputEl.classList.contains('collapsed') ? 0 : 1;
                        const initialOutputState = initialState.o;
                        // Only encode if different from initial state
                        if (initialOutputState !== undefined && currentOutputState !== initialOutputState) {
                            state.o = currentOutputState;
                            hasChanges = true;
                        }
                    }
                    
                    // Only include cell if it has changes from initial state
                    if (hasChanges) {
                        cellStates[cellId] = state;
                        console.log(`Added cell ${cellId}:`, state);
                    }
                }
            });
            
            console.log('Final cell states to encode:', cellStates);
            
            // Return empty string if no changed cells
            if (Object.keys(cellStates).length === 0) return '';
            
            // Encode as compact base64 string
            const encoded = btoa(JSON.stringify(cellStates));
            console.log('Encoded cell states:', encoded);
            return encoded;
        }
        
        function decodeCellStatesFromUrl(encodedStates) {
            if (!encodedStates) return {};
            
            try {
                return JSON.parse(atob(encodedStates));
            } catch (e) {
                console.error('Failed to decode cell states:', e);
                return {};
            }
        }
        
        function applyCellStatesFromUrl(cellStates) {
            console.log('Applying cell states from URL:', cellStates);
            Object.entries(cellStates).forEach(([cellId, state]) => {
                const codeEl = document.getElementById('code-' + cellId);
                const outputEl = document.getElementById('output-' + cellId);
                
                console.log(`Cell ${cellId}:`, {
                    codeEl: !!codeEl,
                    outputEl: !!outputEl,
                    state: state
                });
                
                if (codeEl && state.c !== undefined) {
                    if (state.c === 0) {
                        codeEl.classList.add('collapsed');
                        console.log(`Collapsed code for cell ${cellId}`, {
                            hasCollapsedClass: codeEl.classList.contains('collapsed'),
                            computedDisplay: getComputedStyle(codeEl).display,
                            classList: Array.from(codeEl.classList),
                            elementId: codeEl.id
                        });
                    } else {
                        codeEl.classList.remove('collapsed');
                        codeEl.classList.add('expanded'); // Explicitly add expanded class
                        console.log(`Expanded code for cell ${cellId}`, {
                            hasCollapsedClass: codeEl.classList.contains('collapsed'),
                            hasExpandedClass: codeEl.classList.contains('expanded'),
                            computedDisplay: getComputedStyle(codeEl).display,
                            classList: Array.from(codeEl.classList),
                            elementId: codeEl.id
                        });
                    }
                }
                
                if (outputEl && state.o !== undefined) {
                    if (state.o === 0) {
                        outputEl.classList.add('collapsed');
                        console.log(`Collapsed output for cell ${cellId}`);
                    } else {
                        outputEl.classList.remove('collapsed');
                        console.log(`Expanded output for cell ${cellId}`);
                    }
                }
                
                // Update visual indicators and force style recalculation
                try {
                    updateIndicators(cellId);
                    // Force browser to recalculate styles
                    if (codeEl) {
                        codeEl.offsetHeight; // Force reflow
                        console.log(`After indicators update - code visible: ${getComputedStyle(codeEl).display !== 'none'}`);
                    }
                    if (outputEl) {
                        outputEl.offsetHeight; // Force reflow
                        console.log(`After indicators update - output visible: ${getComputedStyle(outputEl).display !== 'none'}`);
                    }
                } catch (e) {
                    console.error(`Error updating indicators for cell ${cellId}:`, e);
                }
            });
        }

        function encodeShapesToUrl() {
            // Encode shapes as compact base64 string
            if (_shapes.length === 0) return '';
            
            const shapeData = _shapes.map(shape => {
                const baseData = {
                    ct: shape.createdAt, // creation timestamp
                    fo: shape.fadeoutTime || getFadeoutTime() // fadeout time for this shape
                };
                
                if (shape.type === 'arrow') {
                    return {
                        ...baseData,
                        t: 'a',
                        x1: Math.round(shape.x1),
                        y1: Math.round(shape.y1),
                        x2: Math.round(shape.x2),
                        y2: Math.round(shape.y2),
                        c: shape.color.substring(1), // remove #
                        w: shape.width
                    };
                } else if (shape.type === 'pen') {
                    return {
                        ...baseData,
                        t: 'p',
                        pts: shape.points.map(p => [Math.round(p.x), Math.round(p.y)]),
                        c: shape.color.substring(1),
                        w: shape.width
                    };
                } else if (shape.type === 'spotlight') {
                    return {
                        ...baseData,
                        t: 's',
                        x: Math.round(shape.x),
                        y: Math.round(shape.y),
                        r: Math.round(shape.radius)
                    };
                }
            }).filter(Boolean);
            
            return btoa(JSON.stringify(shapeData));
        }
        
        function decodeShapesFromUrl(encodedShapes) {
            if (!encodedShapes) return [];
            
            try {
                const shapeData = JSON.parse(atob(encodedShapes));
                return shapeData.map(data => {
                    const base = {
                        createdAt: data.ct || Date.now(), // use encoded timestamp or current time
                        fadeoutTime: data.fo || 0, // use encoded fadeout time or 0 (never fade)
                        opacity: 1.0
                    };
                    
                    if (data.t === 'a') {
                        return {
                            ...base,
                            type: 'arrow',
                            x1: data.x1,
                            y1: data.y1,
                            x2: data.x2,
                            y2: data.y2,
                            color: '#' + data.c,
                            width: data.w
                        };
                    } else if (data.t === 'p') {
                        return {
                            ...base,
                            type: 'pen',
                            points: data.pts.map(([x, y]) => ({ x, y })),
                            color: '#' + data.c,
                            width: data.w
                        };
                    } else if (data.t === 's') {
                        return {
                            ...base,
                            type: 'spotlight',
                            x: data.x,
                            y: data.y,
                            radius: data.r,
                            color: '#000000'
                        };
                    }
                }).filter(Boolean);
            } catch (e) {
                console.error('Failed to decode shapes:', e);
                return [];
            }
        }
        
        function encodeToolStateToUrl() {
            // Don't update URL during initialization
            if (_isInitializing) {
                return window.location.href;
            }
            
            const params = new URLSearchParams(window.location.search);
            
            // Check if tools widget is visible and has an active tool
            const toolsWidget = document.querySelector('.tools-widget');
            const activeTool = document.body.dataset.tool;
            const hasActiveTool = activeTool && activeTool !== 'none';
            const toolsWidgetVisible = toolsWidget && getComputedStyle(toolsWidget).display !== 'none';
            
            // Always handle shapes regardless of tool state
            const encodedShapes = encodeShapesToUrl();
            if (encodedShapes) {
                params.set('shapes', encodedShapes);
            } else {
                params.delete('shapes');
            }
            
            // Always preserve existing cell states from URL if present
            const existingCellStates = params.get('cells');
            if (existingCellStates) {
                // Keep existing cell states - don't re-encode from DOM
                params.set('cells', existingCellStates);
            } else {
                // Only encode new cell states if none exist in URL
                const encodedCellStates = encodeCellStatesToUrl();
                if (encodedCellStates) {
                    params.set('cells', encodedCellStates);
                }
            }
            
            if (toolsWidgetVisible && hasActiveTool) {
                // Include tool params when widget is visible AND tool is active
                params.set('tools', '1');
                params.set('tool', activeTool);
                
                // Get color (without # prefix)
                const color = getArrowColor();
                if (color && color.startsWith('#')) {
                    params.set('color', color.substring(1));
                }
                
                // Get thickness
                const thickness = getLineThickness();
                params.set('thickness', thickness.toString());
            } else {
                // Remove tool state params but keep shapes
                params.delete('tools');
                params.delete('tool');
                params.delete('color');
                params.delete('thickness');
                params.delete('fadeout');
            }
            
            // Update URL without reloading
            const newUrl = window.location.pathname + (params.toString() ? '?' + params.toString() : '') + window.location.hash;
            window.history.replaceState(null, '', newUrl);
            
            return window.location.href;
        }

        function resetLayout() {
            try {
                // Clear all uvnote-* keys
                const allKeys = Object.keys(localStorage);
                const uvnoteKeys = allKeys.filter(key => key.startsWith('uvnote-'));
                uvnoteKeys.forEach(k => localStorage.removeItem(k));
            } catch (_) {}
            
            // Clear any active selection and remove URL params
            try { clearSelection(true); } catch(_) {}
            // Reset active tool if any
            try { window.setActiveTool('none'); } catch(_) {}
            // Clear shapes
            try { _shapes = []; saveShapes(); } catch(_) {}
            // Reset URL-loaded tool flag
            try { _urlLoadedTool = false; } catch(_) {}
            // Reset all cells to expanded state
            try {
                const cells = document.querySelectorAll('.cell');
                cells.forEach(cell => {
                    const cellId = cell.id.replace('cell-', '');
                    const codeEl = document.getElementById('code-' + cellId);
                    const outputEl = document.getElementById('output-' + cellId);
                    if (codeEl) codeEl.classList.remove('collapsed');
                    if (outputEl) outputEl.classList.remove('collapsed');
                    updateIndicators(cellId);
                });
            } catch(_) {}
            
            // Clear ALL URL parameters and reload with clean URL
            try {
                const cleanUrl = window.location.pathname + window.location.hash;
                window.location.href = cleanUrl; // Use window.location.href instead of history.replaceState + reload
            } catch (_) {
                // Fallback - reload current page
                location.reload();
            }
        }

        function toggleMenu() {
            const menuButton = document.querySelector('.menu-button');
            if (menuButton) {
                menuButton.classList.toggle('active');
            }
        }

        function toggleWidget(widgetName) {
            let widget;
            let checkbox;
            
            // Close the menu first
            const menuButton = document.querySelector('.menu-button');
            if (menuButton) {
                menuButton.classList.remove('active');
            }
            
            switch(widgetName) {
                case 'tools':
                    widget = document.querySelector('.tools-widget');
                    checkbox = document.getElementById('checkbox-tools');
                    break;
                case 'file-explorer':
                    widget = document.querySelector('.file-explorer');
                    checkbox = document.getElementById('checkbox-file-explorer');
                    break;
                case 'minimap':
                    widget = document.querySelector('.minimap');
                    checkbox = document.getElementById('checkbox-minimap');
                    break;
                case 'status':
                    widget = document.querySelector('.status-widget');
                    checkbox = document.getElementById('checkbox-status');
                    break;
                default:
                    return;
            }
            
            if (widget && checkbox) {
                const isVisible = getComputedStyle(widget).display !== 'none';
                widget.style.display = isVisible ? 'none' : 'block';
                checkbox.textContent = isVisible ? '☐' : '☑';
                
                // Save state to localStorage
                try {
                    localStorage.setItem(`uvnote-widget-${widgetName}`, isVisible ? 'hidden' : 'visible');
                } catch (_) {}
                
                // Re-layout widgets after visibility change
                try { 
                    layoutWidgetsStackedBottomRight(); 
                } catch (_) {}
                
                // Update URL when tools widget visibility changes
                if (widgetName === 'tools') {
                    encodeToolStateToUrl();
                }
            }
        }
        
        function initializeWidgetVisibility() {
            const widgets = [
                { name: 'tools', selector: '.tools-widget' },
                { name: 'file-explorer', selector: '.file-explorer' },
                { name: 'minimap', selector: '.minimap' },
                { name: 'status', selector: '.status-widget' }
            ];
            
            widgets.forEach(({ name, selector }) => {
                const defaultState = name === 'status' ? 'visible' : 'hidden';
                const savedState = localStorage.getItem(`uvnote-widget-${name}`) || defaultState;
                const widget = document.querySelector(selector);
                const checkbox = document.getElementById(`checkbox-${name}`);
                
                if (widget && checkbox) {
                    const isVisible = savedState === 'visible';
                    widget.style.display = isVisible ? 'block' : 'none';
                    checkbox.textContent = isVisible ? '☑' : '☐';
                }
            });
        }

        // Close menu when clicking outside
        document.addEventListener('click', function(event) {
            const menuButton = document.querySelector('.menu-button');
            // Don't close if clicking on a menu item (let the item handler close it)
            if (menuButton && !menuButton.contains(event.target)) {
                menuButton.classList.remove('active');
            }
        });

        // Layout: stack widgets bottom-right and equalize widths
        function hasCustomWidgetPositions() {
            try {
                return (
                    localStorage.getItem('uvnote-minimap-pos') ||
                    localStorage.getItem('uvnote-file-explorer-pos') ||
                    localStorage.getItem('uvnote-tools-pos')
                );
            } catch (_) { return false; }
        }

        function rectsOverlap(r1, r2) {
            return !(r1.right <= r2.left || r2.right <= r1.left || r1.bottom <= r2.top || r2.bottom <= r1.top);
        }

        function widgetsOverlap(widgets) {
            for (let i = 0; i < widgets.length; i++) {
                const a = widgets[i];
                const ra = a.getBoundingClientRect();
                for (let j = i + 1; j < widgets.length; j++) {
                    const b = widgets[j];
                    const rb = b.getBoundingClientRect();
                    if (rectsOverlap(ra, rb)) return true;
                }
            }
            return false;
        }

        function applyStackLayout(widgets, order) {
            if (!widgets.length) return;
            // Fixed equal width
            const fixedWidth = 220;
            widgets.forEach(el => { el.style.width = fixedWidth + 'px'; });

            // Fit heights if needed to avoid overflow
            const gap = 12;
            const available = Math.max(0, window.innerHeight - 40 - gap * (order.length - 1));
            const eachMax = Math.floor(available / order.length);
            order.forEach(el => {
                el.style.maxHeight = eachMax + 'px';
                el.style.overflowY = 'auto';
            });

            // Stack bottom-up in the requested order
            let bottomOffset = 20; // base gutter
            order.forEach(el => {
                el.style.left = 'auto';
                el.style.top = 'auto';
                el.style.right = '20px';
                el.style.bottom = bottomOffset + 'px';
                bottomOffset += el.offsetHeight + gap;
            });
        }

        function layoutWidgetsStackedBottomRight() {
            const minimap = document.querySelector('.minimap');
            const fileExplorer = document.querySelector('.file-explorer');
            const tools = document.querySelector('.tools-widget');
            const status = document.querySelector('.status-widget');
            const widgets = [minimap, fileExplorer, tools, status].filter(el => el && getComputedStyle(el).display !== 'none');
            if (!widgets.length) return;

            const order = [minimap, fileExplorer, tools, status].filter(Boolean).filter(el => getComputedStyle(el).display !== 'none');

            // If user placed custom positions and there is no overlap, respect them.
            if (hasCustomWidgetPositions() && !widgetsOverlap(widgets)) return;

            applyStackLayout(widgets, order);
        }
        
        // Panel icon removed
        
        let _minimapScrollContainer = null;
        let _minimapScrollHandler = null;
        function initMinimap() {
            // Generate minimap content
            const minimap = createMinimap();
            document.body.appendChild(minimap);
            // Make draggable (use title as handle)
            const mTitle = minimap.querySelector('.minimap-title');
            makeDraggable(minimap, 'uvnote-minimap-pos', mTitle);

            // Attach scroll listener to window (two-panel removed)
            _minimapScrollContainer = window;

            if (_minimapScrollContainer) {
                _minimapScrollHandler = () => updateMinimapActive();
                if (_minimapScrollContainer === window) {
                    window.addEventListener('scroll', _minimapScrollHandler);
                } else {
                    _minimapScrollContainer.addEventListener('scroll', _minimapScrollHandler);
                }
            }
            updateMinimapActive();
        }

        function teardownMinimap() {
            const minimap = document.querySelector('.minimap');
            if (minimap && minimap.parentNode) minimap.parentNode.removeChild(minimap);
            if (_minimapScrollContainer && _minimapScrollHandler) {
                if (_minimapScrollContainer === window) {
                    window.removeEventListener('scroll', _minimapScrollHandler);
                } else {
                    _minimapScrollContainer.removeEventListener('scroll', _minimapScrollHandler);
                }
            }
            _minimapScrollContainer = null;
            _minimapScrollHandler = null;
        }
        
        function initFileExplorer() {
            // Generate file explorer content
            const fileExplorer = createFileExplorer();
            document.body.appendChild(fileExplorer);
        }
        
        function createMinimap() {
            const minimap = document.createElement('div');
            minimap.className = 'minimap';
            
            const title = document.createElement('div');
            title.className = 'minimap-title';
            title.textContent = 'navigation';
            minimap.appendChild(title);
            
            // Find all headings and cells
            const root = document.querySelector('.main-content') || document;
            const headings = root.querySelectorAll('h1, h2, h3, h4, h5, h6');
            const cells = root.querySelectorAll('.cell');
            
            // Combine and sort by position
            const items = [];
            
            headings.forEach(heading => {
                const id = heading.id || generateId(heading.textContent);
                if (!heading.id) heading.id = id;
                
                items.push({
                    element: heading,
                    type: 'heading',
                    level: parseInt(heading.tagName.charAt(1)),
                    text: heading.textContent.trim(),
                    id: id,
                    position: heading.getBoundingClientRect().top + window.scrollY
                });
            });
            
            cells.forEach(cell => {
                const header = cell.querySelector('.cell-header');
                if (header) {
                    const id = cell.id || `cell-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    if (!cell.id) cell.id = id;
                    
                    items.push({
                        element: cell,
                        type: 'cell',
                        text: header.textContent.trim(),
                        id: id,
                        position: cell.getBoundingClientRect().top + window.scrollY
                    });
                }
            });
            
            // Sort by position
            items.sort((a, b) => a.position - b.position);
            
            // Create minimap items
            items.forEach(item => {
                const link = document.createElement('a');
                link.className = `minimap-item ${item.type === 'heading' ? 'minimap-heading' : 'minimap-cell'}`;
                if (item.type === 'heading') {
                    link.classList.add(`h${item.level}`);
                }
                link.textContent = item.text.length > 25 ? item.text.substring(0, 22) + '...' : item.text;
                link.href = `#${item.id}`;
                link.onclick = function(e) {
                    e.preventDefault();
                    item.element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                };
                minimap.appendChild(link);
            });
            
            return minimap;
        }
        
        function generateId(text) {
            return text.toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, '')
                .substring(0, 20);
        }
        
        function updateMinimapActive() {
            const minimapItems = document.querySelectorAll('.minimap-item');
            const container = _minimapScrollContainer || window;
            const containerRect = container === window ? null : container.getBoundingClientRect();
            const scrollPos = (container === window ? window.scrollY : container.scrollTop) + 100; // Offset for better detection
            
            let activeItem = null;
            minimapItems.forEach(item => {
                const targetId = item.getAttribute('href').substring(1);
                const target = document.getElementById(targetId);
                
                if (target) {
                    const rectTop = target.getBoundingClientRect().top;
                    const targetPos = (container === window)
                        ? rectTop + window.scrollY
                        : rectTop - containerRect.top + container.scrollTop;
                    if (targetPos <= scrollPos) {
                        activeItem = item;
                    }
                }
                
                item.classList.remove('active');
            });
            
            if (activeItem) {
                activeItem.classList.add('active');
            }
        }
        
        function createFileExplorer() {
            const fileExplorer = document.createElement('div');
            fileExplorer.className = 'file-explorer';
            
            const title = document.createElement('div');
            title.className = 'file-explorer-title';
            title.textContent = 'files';
            fileExplorer.appendChild(title);
            // Make draggable (use title as handle)
            makeDraggable(fileExplorer, 'uvnote-file-explorer-pos', title);
            
            // Scripts section
            const scriptsSection = document.createElement('div');
            scriptsSection.className = 'file-explorer-section';
            
            const scriptsTitle = document.createElement('div');
            scriptsTitle.className = 'file-explorer-section-title';
            scriptsTitle.textContent = 'scripts';
            scriptsSection.appendChild(scriptsTitle);
            
            // Find all cells and list their script files (single panel)
            const root = document.querySelector('.main-content') || document;
            const cells = root.querySelectorAll('.cell');
            cells.forEach(cell => {
                const header = cell.querySelector('.cell-header');
                if (header) {
                    const cellText = header.textContent.trim();
                    const cellMatch = cellText.match(/Cell: ([a-zA-Z_][a-zA-Z0-9_]*)/);
                    if (cellMatch) {
                        const cellId = cellMatch[1];
                        const scriptItem = document.createElement('div');
                        scriptItem.className = 'file-explorer-item script';
                        scriptItem.textContent = `${cellId}.py`;
                        scriptItem.onclick = function() {
                            cell.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        };
                        scriptsSection.appendChild(scriptItem);
                    }
                }
            });
            
            fileExplorer.appendChild(scriptsSection);
            
            // Artifacts section
            const artifactsSection = document.createElement('div');
            artifactsSection.className = 'file-explorer-section';
            
            const artifactsTitle = document.createElement('div');
            artifactsTitle.className = 'file-explorer-section-title';
            artifactsTitle.textContent = 'artifacts';
            artifactsSection.appendChild(artifactsTitle);
            
            // Find all artifact links (single panel)
            const artifactsRoot = document.querySelector('.main-content') || document;
            const artifacts = artifactsRoot.querySelectorAll('.artifact');
            if (artifacts.length === 0) {
                const noArtifacts = document.createElement('div');
                noArtifacts.className = 'file-explorer-item artifact';
                noArtifacts.textContent = '(none)';
                noArtifacts.style.opacity = '0.5';
                artifactsSection.appendChild(noArtifacts);
            } else {
                artifacts.forEach(artifact => {
                    const artifactItem = document.createElement('div');
                    artifactItem.className = 'file-explorer-item artifact';
                    artifactItem.textContent = artifact.textContent;
                    artifactItem.onclick = function() {
                        artifact.click();
                    };
                    artifactsSection.appendChild(artifactItem);
                });
            }
            
            fileExplorer.appendChild(artifactsSection);
            
            return fileExplorer;
        }

        function initStatusWidget() {
            let el = document.querySelector('.status-widget');
            if (!el) {
                el = document.createElement('div');
                el.className = 'status-widget';
                el.id = 'status-widget';
                el.textContent = 'ready — Esc';
                document.body.appendChild(el);
            }
        }

        // Tools widget
        let _cursorX = 0;
        let _cursorY = 0;
        let _cursorVisible = false;
        
        function setActiveTool(tool) {
            if (!tool || tool === 'none') {
                document.body.dataset.tool = 'none';
                localStorage.setItem('uvnote-active-tool', 'none');
                setOverlayActive(false);
                _cursorVisible = false;
                // Remove active class from all tool buttons when deactivating
                const toolButtons = document.querySelectorAll('.tools-widget .tool-button');
                toolButtons.forEach(btn => btn.classList.remove('active'));
                updateStateIndicator();
                encodeToolStateToUrl();
                return;
            }
            document.body.dataset.tool = tool;
            localStorage.setItem('uvnote-active-tool', tool);
            setOverlayActive(true);
            _cursorVisible = true;
            updateStateIndicator();
            encodeToolStateToUrl();
        }

        // Make setActiveTool globally accessible for ESC key handler
        window.setActiveTool = setActiveTool;
        

        function getArrowColor() {
            const saved = localStorage.getItem('uvnote-arrow-color');
            if (saved) return saved;
            return '#e53935'; // Default red color
        }

        function setStoredArrowColor(color) {
            try { localStorage.setItem('uvnote-arrow-color', color); } catch (_) {}
        }

        function getLineThickness() {
            const saved = localStorage.getItem('uvnote-line-thickness');
            if (saved) return parseInt(saved, 10);
            return 6; // default thickness
        }

        function setStoredLineThickness(thickness) {
            try { localStorage.setItem('uvnote-line-thickness', thickness); } catch (_) {}
        }

        function getFadeoutTime() {
            const saved = localStorage.getItem('uvnote-fadeout-time');
            if (saved) return parseInt(saved, 10);
            return 5; // default 5 seconds
        }

        function setStoredFadeoutTime(seconds) {
            try { localStorage.setItem('uvnote-fadeout-time', seconds); } catch (_) {}
        }

        function createToolsWidget() {
            const tools = document.createElement('div');
            tools.className = 'tools-widget';

            const title = document.createElement('div');
            title.className = 'tools-title';
            title.textContent = 'tools';
            tools.appendChild(title);

            const row = document.createElement('div');
            row.className = 'tools-row';
            tools.appendChild(row);

            // Arrow tool
            const arrowBtn = document.createElement('div');
            arrowBtn.className = 'tool-button';
            arrowBtn.textContent = 'arrow';
            arrowBtn.onclick = function() {
                const isActive = arrowBtn.classList.contains('active');
                if (isActive) {
                    arrowBtn.classList.remove('active');
                    setActiveTool('none');
                } else {
                    tools.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                    arrowBtn.classList.add('active');
                    setActiveTool('arrow');
                }
            };
            row.appendChild(arrowBtn);

            // Pen tool
            const penBtn = document.createElement('div');
            penBtn.className = 'tool-button';
            penBtn.textContent = 'pen';
            penBtn.onclick = function() {
                const isActive = penBtn.classList.contains('active');
                if (isActive) {
                    penBtn.classList.remove('active');
                    setActiveTool('none');
                } else {
                    tools.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                    penBtn.classList.add('active');
                    setActiveTool('pen');
                }
            };
            row.appendChild(penBtn);

            // Eraser tool
            const eraseBtn = document.createElement('div');
            eraseBtn.className = 'tool-button';
            eraseBtn.textContent = 'eraser';
            eraseBtn.onclick = function() {
                const isActive = eraseBtn.classList.contains('active');
                if (isActive) {
                    eraseBtn.classList.remove('active');
                    setActiveTool('none');
                } else {
                    tools.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                    eraseBtn.classList.add('active');
                    setActiveTool('eraser');
                }
            };
            row.appendChild(eraseBtn);

            // Spotlight tool
            const spotlightBtn = document.createElement('div');
            spotlightBtn.className = 'tool-button';
            spotlightBtn.textContent = 'spotlight';
            spotlightBtn.onclick = function() {
                const isActive = spotlightBtn.classList.contains('active');
                if (isActive) {
                    spotlightBtn.classList.remove('active');
                    setActiveTool('none');
                } else {
                    tools.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                    spotlightBtn.classList.add('active');
                    setActiveTool('spotlight');
                }
            };
            row.appendChild(spotlightBtn);

            // Clear all
            const clearBtn = document.createElement('div');
            clearBtn.className = 'tool-button';
            clearBtn.textContent = 'clear';
            clearBtn.onclick = function() {
                _shapes = [];
                saveShapes();
                renderOverlay();
            };
            row.appendChild(clearBtn);
            
            // We'll add the copy button at the end of the widget

            // Restore active state from storage
            const saved = localStorage.getItem('uvnote-active-tool') || 'none';
            if (saved === 'arrow') {
                arrowBtn.classList.add('active');
                setActiveTool('arrow');
            } else if (saved === 'pen') {
                penBtn.classList.add('active');
                setActiveTool('pen');
            } else if (saved === 'eraser') {
                eraseBtn.classList.add('active');
                setActiveTool('eraser');
            } else if (saved === 'spotlight') {
                spotlightBtn.classList.add('active');
                setActiveTool('spotlight');
            }

            // Color selector
            const colorTitle = document.createElement('div');
            colorTitle.className = 'tools-section-title';
            colorTitle.textContent = 'color';
            tools.appendChild(colorTitle);

            const colorRow = document.createElement('div');
            colorRow.className = 'tools-row color-row';
            tools.appendChild(colorRow);

            const swatchColors = [
                // Primary colors
                '#e53935', '#fb8c00', '#fdd835', '#43a047', '#1e88e5', '#8e24aa',
                // Additional useful colors  
                '#ff5722', '#795548', '#607d8b', '#9c27b0',
                // Grayscale
                '#000000', '#424242', '#9e9e9e', '#ffffff'
            ];
            const swatches = [];
            swatchColors.forEach(c => {
                const s = document.createElement('div');
                s.className = 'color-swatch';
                s.style.backgroundColor = c;
                s.title = c;
                s.onclick = () => {
                    setStoredArrowColor(c);
                    refreshColorUI(c);
                    if (_cursorVisible) renderOverlay();
                    encodeToolStateToUrl();
                };
                colorRow.appendChild(s);
                swatches.push(s);
            });

            const colorInput = document.createElement('input');
            colorInput.type = 'color';
            colorInput.className = 'color-input';
            colorInput.oninput = () => {
                setStoredArrowColor(colorInput.value);
                refreshColorUI(colorInput.value);
                if (_cursorVisible) renderOverlay();
                encodeToolStateToUrl();
            };
            colorRow.appendChild(colorInput);

            function refreshColorUI(selected) {
                const selectedHex = selected.startsWith('#') ? selected.toLowerCase() : rgbToHex(selected);
                
                swatches.forEach((s, i) => {
                    const swatchHex = swatchColors[i].toLowerCase();
                    if (swatchHex === selectedHex) {
                        s.classList.add('selected');
                    } else {
                        s.classList.remove('selected');
                    }
                });
                
                try { 
                    colorInput.value = selectedHex; 
                } catch (_) {}
            }

            function rgbToHex(rgb) {
                const m = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)\)/i);
                if (!m) return '#000000';
                const r = parseInt(m[1]).toString(16).padStart(2, '0');
                const g = parseInt(m[2]).toString(16).padStart(2, '0');
                const b = parseInt(m[3]).toString(16).padStart(2, '0');
                return `#${r}${g}${b}`;
            }

            // Restore color selection
            refreshColorUI(getArrowColor());

            // Thickness slider
            const thicknessTitle = document.createElement('div');
            thicknessTitle.className = 'tools-section-title';
            thicknessTitle.textContent = 'thickness';
            tools.appendChild(thicknessTitle);

            const thicknessRow = document.createElement('div');
            thicknessRow.className = 'thickness-row';
            tools.appendChild(thicknessRow);

            const thicknessSlider = document.createElement('input');
            thicknessSlider.type = 'range';
            thicknessSlider.className = 'thickness-slider';
            thicknessSlider.min = '1';
            thicknessSlider.max = '10';
            thicknessSlider.value = getLineThickness();
            
            const thicknessValue = document.createElement('span');
            thicknessValue.className = 'thickness-value';
            thicknessValue.textContent = thicknessSlider.value + 'px';

            thicknessSlider.oninput = function() {
                const value = parseInt(thicknessSlider.value, 10);
                setStoredLineThickness(value);
                thicknessValue.textContent = value + 'px';
                if (_cursorVisible) renderOverlay();
                encodeToolStateToUrl();
            };

            thicknessRow.appendChild(thicknessSlider);
            thicknessRow.appendChild(thicknessValue);

            // Fadeout time slider
            const fadeoutTitle = document.createElement('div');
            fadeoutTitle.className = 'tools-section-title';
            fadeoutTitle.textContent = 'fadeout time';
            tools.appendChild(fadeoutTitle);

            const fadeoutRow = document.createElement('div');
            fadeoutRow.className = 'thickness-row';
            tools.appendChild(fadeoutRow);

            const fadeoutSlider = document.createElement('input');
            fadeoutSlider.type = 'range';
            fadeoutSlider.className = 'thickness-slider';
            fadeoutSlider.min = '0';
            fadeoutSlider.max = '30';
            fadeoutSlider.value = getFadeoutTime();
            
            const fadeoutValue = document.createElement('span');
            fadeoutValue.className = 'thickness-value';
            fadeoutValue.textContent = fadeoutSlider.value === '0' ? 'never' : fadeoutSlider.value + 's';

            fadeoutSlider.oninput = function() {
                const value = parseInt(fadeoutSlider.value, 10);
                setStoredFadeoutTime(value);
                fadeoutValue.textContent = value === 0 ? 'never' : value + 's';
                encodeToolStateToUrl();
            };

            fadeoutRow.appendChild(fadeoutSlider);
            fadeoutRow.appendChild(fadeoutValue);

            // Draggable behavior
            makeDraggable(tools, 'uvnote-tools-pos', title);

            return tools;
        }

        function initTools() {
            const widget = createToolsWidget();
            document.body.appendChild(widget);
        }

        function teardownTools() {
            const w = document.querySelector('.tools-widget');
            if (w && w.parentNode) w.parentNode.removeChild(w);
        }

        // --- Canvas overlay for tools ---
        let _overlay = null;
        let _overlayCtx = null;
        let _overlayContainer = null; // window
        let _overlayMode = 'single';
        let _overlayResizeHandler = null;
        let _overlayScrollHandler = null;
        let _drawing = null; // current in-progress arrow {x1,y1,x2,y2}
        let _shapes = []; // committed shapes for current mode
        let _fadeTimer = null; // timer for fade animation
        let _urlLoadedTool = false; // track if tool was loaded from URL
        let _isInitializing = true; // prevent URL updates during initialization
        let _initialCellStates = {}; // track initial cell states from page load

        function getOverlayStorageKey() { return 'uvnote-shapes'; }

        function loadShapes() {
            try {
                const raw = localStorage.getItem(getOverlayStorageKey());
                _shapes = raw ? JSON.parse(raw) : [];
            } catch (_) { _shapes = []; }
        }

        function saveShapes() {
            try { 
                localStorage.setItem(getOverlayStorageKey(), JSON.stringify(_shapes));
                // Always update URL when shapes change
                encodeToolStateToUrl();
            } catch (_) {}
        }

        function updateShapesFade() {
            const now = Date.now();
            let needsUpdate = false;

            for (let i = _shapes.length - 1; i >= 0; i--) {
                const shape = _shapes[i];
                if (!shape.createdAt) continue; // Skip old shapes without timestamps
                
                // Use individual shape's fadeout time, or global if not set
                const shapesFadeoutSeconds = shape.fadeoutTime !== undefined ? shape.fadeoutTime : getFadeoutTime();
                
                // Skip fading if fadeout is disabled for this shape
                if (shapesFadeoutSeconds === 0) continue;
                
                const fadeStartTime = Math.max(0, (shapesFadeoutSeconds - 2) * 1000); // Start fading 2s before end
                const fadeEndTime = shapesFadeoutSeconds * 1000; // Fully gone after specified time
                const age = now - shape.createdAt;
                
                if (age >= fadeEndTime) {
                    // Remove completely faded shapes
                    _shapes.splice(i, 1);
                    needsUpdate = true;
                } else if (age >= fadeStartTime) {
                    // Update opacity for fading shapes
                    const fadeProgress = (age - fadeStartTime) / (fadeEndTime - fadeStartTime);
                    const newOpacity = 1 - fadeProgress;
                    if (Math.abs(shape.opacity - newOpacity) > 0.01) {
                        shape.opacity = newOpacity;
                        needsUpdate = true;
                    }
                }
            }

            if (needsUpdate) {
                saveShapes();
                renderOverlay();
                // Update URL to remove faded shapes  
                encodeToolStateToUrl();
            }
        }

        function getContentContainer() { return window; }

        function updateOverlayModeAndContainer() {
            _overlayContainer = window;
            _overlayMode = 'single';
        }

        function updateOverlayBounds() {
            if (!_overlay) return;
            if (_overlayContainer === window) {
                _overlay.style.position = 'fixed';
                _overlay.style.left = '0px';
                _overlay.style.top = '0px';
                _overlay.width = window.innerWidth;
                _overlay.height = window.innerHeight;
            } else {
                const rect = _overlayContainer.getBoundingClientRect();
                _overlay.style.position = 'fixed';
                _overlay.style.left = rect.left + 'px';
                _overlay.style.top = rect.top + 'px';
                _overlay.width = Math.max(0, Math.floor(rect.width));
                _overlay.height = Math.max(0, Math.floor(rect.height));
            }
            renderOverlay();
        }

        function containerScrollLeft() {
            return (_overlayContainer === window) ? (window.scrollX || 0) : (_overlayContainer.scrollLeft || 0);
        }
        function containerScrollTop() {
            return (_overlayContainer === window) ? (window.scrollY || 0) : (_overlayContainer.scrollTop || 0);
        }

        function toCanvasCoords(clientX, clientY) {
            const rect = _overlay.getBoundingClientRect();
            return { x: clientX - rect.left, y: clientY - rect.top };
        }

        function onPointerDown(e) {
            const tool = document.body.dataset.tool;
            if (tool === 'arrow') {
                startDrawArrow(e);
            } else if (tool === 'pen') {
                startDrawPen(e);
            } else if (tool === 'eraser') {
                eraseAt(e);
            } else if (tool === 'spotlight') {
                startDrawSpotlight(e);
            }
        }

        function onPointerMove(e) {
            // Update cursor position
            const pt = toCanvasCoords(e.touches ? e.touches[0].clientX : e.clientX, e.touches ? e.touches[0].clientY : e.clientY);
            _cursorX = pt.x;
            _cursorY = pt.y;
            
            if (!_drawing) {
                // Just update cursor position and re-render
                if (_cursorVisible) {
                    renderOverlay();
                }
                return;
            }
            
            if (_drawing.type === 'pen') {
                moveDrawPen(e);
            } else if (_drawing.type === 'spotlight') {
                moveDrawSpotlight(e);
            } else {
                moveDrawArrow(e);
            }
        }
        
        function onPointerEnter(e) {
            _cursorVisible = document.body.dataset.tool !== 'none';
            if (_cursorVisible) {
                renderOverlay();
            }
        }
        
        function onPointerLeave(e) {
            _cursorVisible = false;
            renderOverlay();
        }

        function onPointerUp(e) {
            if (!_drawing) return;
            if (_drawing.type === 'pen') {
                endDrawPen();
            } else if (_drawing.type === 'spotlight') {
                endDrawSpotlight();
            } else {
                endDrawArrow();
            }
        }

        function startDrawArrow(e) {
            if (document.body.dataset.tool !== 'arrow') return;
            const pt = toCanvasCoords(e.touches ? e.touches[0].clientX : e.clientX, e.touches ? e.touches[0].clientY : e.clientY);
            _drawing = {
                x1: pt.x + containerScrollLeft(),
                y1: pt.y + containerScrollTop(),
                x2: pt.x + containerScrollLeft(),
                y2: pt.y + containerScrollTop(),
                color: getArrowColor(),
                width: getLineThickness()
            };
            renderOverlay();
            e.preventDefault();
        }

        function moveDrawArrow(e) {
            if (!_drawing) return;
            const pt = toCanvasCoords(e.touches ? e.touches[0].clientX : e.clientX, e.touches ? e.touches[0].clientY : e.clientY);
            _drawing.x2 = pt.x + containerScrollLeft();
            _drawing.y2 = pt.y + containerScrollTop();
            renderOverlay();
            e.preventDefault();
        }

        function endDrawArrow() {
            if (!_drawing) return;
            _shapes.push({ 
                type: 'arrow', 
                ..._drawing,
                createdAt: Date.now(),
                fadeoutTime: getFadeoutTime(),
                opacity: 1.0
            });
            _drawing = null;
            saveShapes();
            renderOverlay();
        }

        function startDrawPen(e) {
            if (document.body.dataset.tool !== 'pen') return;
            const pt = toCanvasCoords(e.touches ? e.touches[0].clientX : e.clientX, e.touches ? e.touches[0].clientY : e.clientY);
            _drawing = {
                type: 'pen',
                points: [{
                    x: pt.x + containerScrollLeft(),
                    y: pt.y + containerScrollTop()
                }],
                color: getArrowColor(),
                width: getLineThickness()
            };
            renderOverlay();
            e.preventDefault();
        }

        function moveDrawPen(e) {
            if (!_drawing || _drawing.type !== 'pen') return;
            const pt = toCanvasCoords(e.touches ? e.touches[0].clientX : e.clientX, e.touches ? e.touches[0].clientY : e.clientY);
            _drawing.points.push({
                x: pt.x + containerScrollLeft(),
                y: pt.y + containerScrollTop()
            });
            renderOverlay();
            e.preventDefault();
        }

        function endDrawPen() {
            if (!_drawing || _drawing.type !== 'pen') return;
            if (_drawing.points.length > 1) {
                _shapes.push({ 
                    ..._drawing,
                    createdAt: Date.now(),
                    fadeoutTime: getFadeoutTime(),
                    opacity: 1.0
                });
            }
            _drawing = null;
            saveShapes();
            renderOverlay();
        }

        function startDrawSpotlight(e) {
            if (document.body.dataset.tool !== 'spotlight') return;
            const pt = toCanvasCoords(e.touches ? e.touches[0].clientX : e.clientX, e.touches ? e.touches[0].clientY : e.clientY);
            _drawing = {
                type: 'spotlight',
                x: pt.x + containerScrollLeft(),
                y: pt.y + containerScrollTop(),
                radius: getLineThickness() * 20, // Use thickness to control spotlight size (bigger default)
                color: getArrowColor()
            };
            renderOverlay();
            e.preventDefault();
        }

        function moveDrawSpotlight(e) {
            if (!_drawing || _drawing.type !== 'spotlight') return;
            const pt = toCanvasCoords(e.touches ? e.touches[0].clientX : e.clientX, e.touches ? e.touches[0].clientY : e.clientY);
            const dx = pt.x + containerScrollLeft() - _drawing.x;
            const dy = pt.y + containerScrollTop() - _drawing.y;
            _drawing.radius = Math.max(20, Math.sqrt(dx * dx + dy * dy)); // Minimum radius of 20
            renderOverlay();
            e.preventDefault();
        }

        function endDrawSpotlight() {
            if (!_drawing || _drawing.type !== 'spotlight') return;
            _shapes.push({ 
                ..._drawing,
                createdAt: Date.now(),
                fadeoutTime: getFadeoutTime(),
                opacity: 1.0
            });
            _drawing = null;
            saveShapes();
            renderOverlay();
        }

        function distPointToSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1, dy = y2 - y1;
            if (dx === 0 && dy === 0) return Math.hypot(px - x1, py - y1);
            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (dx*dx + dy*dy)));
            const cx = x1 + t * dx, cy = y1 + t * dy;
            return Math.hypot(px - cx, py - cy);
        }

        function eraseAt(e) {
            const pt = toCanvasCoords(e.touches ? e.touches[0].clientX : e.clientX, e.touches ? e.touches[0].clientY : e.clientY);
            const x = pt.x + containerScrollLeft();
            const y = pt.y + containerScrollTop();
            const threshold = 10; // pixels
            for (let i = _shapes.length - 1; i >= 0; i--) {
                const s = _shapes[i];
                if (s.type === 'arrow') {
                    const d = distPointToSegment(x, y, s.x1, s.y1, s.x2, s.y2);
                    if (d <= threshold) {
                        _shapes.splice(i, 1);
                        saveShapes();
                        renderOverlay();
                        break;
                    }
                } else if (s.type === 'pen' && s.points) {
                    // Check if click is near any line segment in the pen stroke
                    let minDist = Infinity;
                    for (let j = 1; j < s.points.length; j++) {
                        const d = distPointToSegment(x, y, s.points[j-1].x, s.points[j-1].y, s.points[j].x, s.points[j].y);
                        minDist = Math.min(minDist, d);
                    }
                    if (minDist <= threshold) {
                        _shapes.splice(i, 1);
                        saveShapes();
                        renderOverlay();
                        break;
                    }
                }
            }
            e.preventDefault();
        }

        function drawArrow(ctx, x1, y1, x2, y2, color, width, opacity = 1.0) {
            // Set opacity
            const oldAlpha = ctx.globalAlpha;
            ctx.globalAlpha = opacity;
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Check if points are too close (initial state)
            const dx = x2 - x1;
            const dy = y2 - y1;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 5) {
                // Draw just a small arrowhead pointing down-right when first clicked
                const defaultAngle = Math.PI / 4; // 45 degrees (down-right)
                const headLength = Math.min(15 + width * 1.5, 25);
                const headAngle = Math.PI / 6;
                
                // Calculate arrowhead points
                const hx1 = x1 + headLength * Math.cos(defaultAngle - headAngle);
                const hy1 = y1 + headLength * Math.sin(defaultAngle - headAngle);
                const hx2 = x1 + headLength * Math.cos(defaultAngle + headAngle);
                const hy2 = y1 + headLength * Math.sin(defaultAngle + headAngle);
                
                // Draw arrowhead only
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(hx1, hy1);
                ctx.lineTo(hx2, hy2);
                ctx.closePath();
                ctx.fill();
            } else {
                // Normal arrow drawing - head at x1,y1, tail at x2,y2
                const angle = Math.atan2(y1 - y2, x1 - x2);
                const headLength = Math.min(15 + width * 1.5, 25);
                const headAngle = Math.PI / 6;
                
                // Calculate where the line should end (before the arrowhead)
                const lineEndX = x1 - headLength * 0.8 * Math.cos(angle);
                const lineEndY = y1 - headLength * 0.8 * Math.sin(angle);
                
                // Draw the line from tail to near the head
                ctx.beginPath();
                ctx.moveTo(x2, y2);
                ctx.lineTo(lineEndX, lineEndY);
                ctx.stroke();
                
                // Calculate arrowhead points
                const hx1 = x1 - headLength * Math.cos(angle - headAngle);
                const hy1 = y1 - headLength * Math.sin(angle - headAngle);
                const hx2 = x1 - headLength * Math.cos(angle + headAngle);
                const hy2 = y1 - headLength * Math.sin(angle + headAngle);
                
                // Draw arrowhead
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(hx1, hy1);
                ctx.lineTo(hx2, hy2);
                ctx.closePath();
                ctx.fill();
            }
            
            // Restore opacity
            ctx.globalAlpha = oldAlpha;
        }

        function drawPen(ctx, points, color, width, offX, offY, opacity = 1.0) {
            if (!points || points.length < 2) return;
            
            // Set opacity
            const oldAlpha = ctx.globalAlpha;
            ctx.globalAlpha = opacity;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(points[0].x - offX, points[0].y - offY);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x - offX, points[i].y - offY);
            }
            ctx.stroke();
            
            // Restore opacity
            ctx.globalAlpha = oldAlpha;
        }

        function drawAllSpotlights(ctx, spotlights, offX, offY) {
            if (!spotlights || spotlights.length === 0) return;
            
            ctx.save();
            
            // Calculate the overall opacity based on all spotlights
            const maxOpacity = Math.max(...spotlights.map(s => s.opacity || 1.0));
            
            // Fill entire canvas with dark overlay
            ctx.fillStyle = `rgba(0, 0, 0, ${0.7 * maxOpacity})`;
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            // Cut out completely transparent holes for all spotlights
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = 'rgba(0, 0, 0, 1)'; // Solid black to ensure complete removal
            for (const spotlight of spotlights) {
                ctx.beginPath();
                ctx.arc(spotlight.x - offX, spotlight.y - offY, spotlight.radius, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            ctx.restore();
        }

        function renderOverlay() {
            if (!_overlay || !_overlayCtx) return;
            _overlayCtx.clearRect(0, 0, _overlay.width, _overlay.height);
            const offX = containerScrollLeft();
            const offY = containerScrollTop();
            // Draw non-spotlight shapes first
            for (const s of _shapes) {
                const opacity = s.opacity !== undefined ? s.opacity : 1.0;
                if (s.type === 'arrow') {
                    drawArrow(_overlayCtx, s.x1 - offX, s.y1 - offY, s.x2 - offX, s.y2 - offY, s.color || '#f00', s.width || 2, opacity);
                } else if (s.type === 'pen') {
                    drawPen(_overlayCtx, s.points, s.color || '#f00', s.width || 2, offX, offY, opacity);
                }
            }
            // Draw current drawing (non-spotlight)
            if (_drawing) {
                if (_drawing.type === 'pen') {
                    drawPen(_overlayCtx, _drawing.points, _drawing.color, _drawing.width, offX, offY);
                } else if (_drawing.type !== 'spotlight') {
                    drawArrow(_overlayCtx, _drawing.x1 - offX, _drawing.y1 - offY, _drawing.x2 - offX, _drawing.y2 - offY, _drawing.color, _drawing.width);
                }
            }
            
            // Collect all spotlights (existing + current drawing + cursor preview)
            const spotlights = [];
            
            // Add existing spotlight shapes
            for (const s of _shapes) {
                if (s.type === 'spotlight') {
                    spotlights.push({
                        x: s.x,
                        y: s.y, 
                        radius: s.radius,
                        opacity: s.opacity !== undefined ? s.opacity : 1.0
                    });
                }
            }
            
            // Add current spotlight being drawn
            if (_drawing && _drawing.type === 'spotlight') {
                spotlights.push({
                    x: _drawing.x,
                    y: _drawing.y,
                    radius: _drawing.radius,
                    opacity: 1.0
                });
            }
            
            // Add cursor preview spotlight if tool is active
            if (_cursorVisible && !_drawing) {
                const tool = document.body.dataset.tool;
                if (tool === 'spotlight') {
                    const thickness = getLineThickness();
                    const radius = thickness * 20;
                    const cursorWorldX = _cursorX + containerScrollLeft();
                    const cursorWorldY = _cursorY + containerScrollTop();
                    spotlights.push({
                        x: cursorWorldX,
                        y: cursorWorldY,
                        radius: radius,
                        opacity: 0.8
                    });
                }
            }
            
            // Draw all spotlights as a single overlay with multiple holes
            drawAllSpotlights(_overlayCtx, spotlights, offX, offY);
            
            // Draw cursor indicators for non-spotlight tools
            if (_cursorVisible && !_drawing) {
                const tool = document.body.dataset.tool;
                const color = getArrowColor();
                const thickness = getLineThickness();
                
                if (tool !== 'spotlight') {
                    _overlayCtx.save();
                    _overlayCtx.fillStyle = color;
                    _overlayCtx.globalAlpha = 0.7;
                    
                    if (tool === 'eraser') {
                        // Draw eraser indicator
                        _overlayCtx.strokeStyle = color;
                        _overlayCtx.lineWidth = 2;
                        _overlayCtx.beginPath();
                        _overlayCtx.arc(_cursorX, _cursorY, 10, 0, 2 * Math.PI);
                        _overlayCtx.stroke();
                    } else {
                        // Draw dot for pen/arrow
                        _overlayCtx.beginPath();
                        _overlayCtx.arc(_cursorX, _cursorY, thickness / 2, 0, 2 * Math.PI);
                        _overlayCtx.fill();
                    }
                    
                    _overlayCtx.restore();
                }
            }
        }

        function setOverlayActive(active) {
            if (!_overlay) initOverlay();
            _overlay.style.pointerEvents = active ? 'auto' : 'none';
            _overlay.style.cursor = active ? 'none' : 'auto';
            // Re-render to ensure visibility aligns with content
            renderOverlay();
        }

        function initOverlay() {
            if (_overlay) return;
            updateOverlayModeAndContainer();
            _overlay = document.createElement('canvas');
            _overlay.className = 'draw-overlay';
            _overlayCtx = _overlay.getContext('2d');
            document.body.appendChild(_overlay);
            updateOverlayBounds();
            loadShapes();
            renderOverlay();

            // Events
            _overlay.addEventListener('mousedown', onPointerDown);
            _overlay.addEventListener('mousemove', onPointerMove);
            _overlay.addEventListener('mouseenter', onPointerEnter);
            _overlay.addEventListener('mouseleave', onPointerLeave);
            document.addEventListener('mouseup', onPointerUp);
            _overlay.addEventListener('touchstart', onPointerDown, { passive: false });
            _overlay.addEventListener('touchmove', onPointerMove, { passive: false });
            document.addEventListener('touchend', onPointerUp);

            _overlayResizeHandler = () => updateOverlayBounds();
            window.addEventListener('resize', _overlayResizeHandler);

            _overlayScrollHandler = () => renderOverlay();
            window.addEventListener('scroll', _overlayScrollHandler);
            
            // Start fade animation timer
            _fadeTimer = setInterval(updateShapesFade, 100); // Update every 100ms for smooth fade
        }

        function rebindOverlayContainer() {
            if (!_overlay) return;
            // Remove old scroll handler
            if (_overlayScrollHandler) { window.removeEventListener('scroll', _overlayScrollHandler); }
            updateOverlayModeAndContainer();
            updateOverlayBounds();
            loadShapes();
            renderOverlay();
            _overlayScrollHandler = () => renderOverlay();
            window.addEventListener('scroll', _overlayScrollHandler);
        }

        function teardownOverlay() {
            if (!_overlay) return;
            _overlay.removeEventListener('mousedown', onPointerDown);
            _overlay.removeEventListener('mousemove', onPointerMove);
            _overlay.removeEventListener('mouseenter', onPointerEnter);
            _overlay.removeEventListener('mouseleave', onPointerLeave);
            document.removeEventListener('mouseup', onPointerUp);
            _overlay.removeEventListener('touchstart', onPointerDown);
            _overlay.removeEventListener('touchmove', onPointerMove);
            document.removeEventListener('touchend', onPointerUp);
            if (_overlayResizeHandler) window.removeEventListener('resize', _overlayResizeHandler);
            if (_overlayScrollHandler) {
                if (_overlayContainer === window) {
                    window.removeEventListener('scroll', _overlayScrollHandler);
                } else if (_overlayContainer) {
                    _overlayContainer.removeEventListener('scroll', _overlayScrollHandler);
                }
            }
            if (_fadeTimer) {
                clearInterval(_fadeTimer);
                _fadeTimer = null;
            }
            if (_overlay.parentNode) _overlay.parentNode.removeChild(_overlay);
            _overlay = null; _overlayCtx = null; _overlayContainer = null; _overlayResizeHandler = null; _overlayScrollHandler = null; _drawing = null;
        }
        
        function teardownFileExplorer() {
            const fe = document.querySelector('.file-explorer');
            if (fe && fe.parentNode) fe.parentNode.removeChild(fe);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function runCell(cellId){
            const btn=document.querySelector('.run-btn[onclick*="'+cellId+'"]');
            const output=document.getElementById('output-'+cellId);
            if(btn){btn.textContent='⏳ running...';btn.disabled=true;}
            if(output){output.classList.add('output-stale');}
            fetch('/run/'+cellId,{method:'POST'}).then(r=>r.json()).then(data=>{
                if(output){
                    output.classList.remove('output-stale');
                    let html='';
                    if(data.stdout) html+='<div class="cell-stdout">'+escapeHtml(data.stdout)+'</div>';
                    console.log('UV Logs:', data);
                    if(data.stderr) {
                        // Split UV logs from regular stderr
                        const lines = data.stderr.split('\\n');
                        let uvLogs = [];
                        let regularLogs = [];
                        let inUvSection = true;

                        for (const line of lines) {
                            if (inUvSection) {
                                uvLogs.push(line);
                                if (line.startsWith('Installed ')) {
                                    inUvSection = false;
                                }
                            } else {
                                regularLogs.push(line);
                            }
                        }
                        

                        // If we never found "Installed", treat it all as regular stderr
                        if (inUvSection) {
                            html+='<div class="cell-stderr">'+escapeHtml(data.stderr)+'</div>';
                        } else {
                            const uvLogsStr = uvLogs.join('\\n');
                            const regularLogsStr = regularLogs.join('\\n').trim();

                            if (uvLogsStr) {
                                html+='<div class="uv-install-logs">';
                                html+='<div class="uv-logs-header" onclick="toggleUvLogs(this)">▶ UV Install Logs</div>';
                                html+='<div class="uv-logs-content" style="display: none;">'+escapeHtml(uvLogsStr)+'</div>';
                                html+='</div>';
                            }
                            if (regularLogsStr) {
                                html+='<div class="cell-stderr">'+escapeHtml(regularLogsStr)+'</div>';
                            }
                        }
                    }
                    output.innerHTML=html;
                }
                if(btn){btn.textContent='▶ run';btn.disabled=false;}
            }).catch(e=>{
                console.error('Run failed:',e);
                if(output){output.classList.remove('output-stale');}
                if(btn){btn.textContent='▶ run';btn.disabled=false;}
            });
        }

        function copyCell(cellId){
            console.log('copyCell called with cellId:', cellId);
            
            // Try multiple selectors to find the code element
            let codeElement = document.querySelector('#code-'+cellId+' code');
            if (!codeElement) {
                codeElement = document.querySelector('#code-'+cellId+' pre code');
            }
            if (!codeElement) {
                codeElement = document.querySelector('#code-'+cellId+' .highlight code');
            }
            if (!codeElement) {
                // Try finding any code element within the cell
                const codeDiv = document.getElementById('code-'+cellId);
                if (codeDiv) {
                    codeElement = codeDiv.querySelector('code');
                }
            }
            
            const btn = document.querySelector('.copy-btn[onclick*="'+cellId+'"]');
            
            console.log('Found codeElement:', codeElement);
            console.log('Found btn:', btn);
            console.log('Code div structure:', document.getElementById('code-'+cellId));
            
            if (!codeElement) {
                console.error('Code element not found for cell:', cellId);
                // Log the actual structure for debugging
                const codeDiv = document.getElementById('code-'+cellId);
                if (codeDiv) {
                    console.log('Code div HTML:', codeDiv.innerHTML);
                }
                return;
            }
            if (!btn) {
                console.error('Copy button not found for cell:', cellId);
                return;
            }
            
            const codeText = codeElement.textContent;
            console.log('Code text to copy:', codeText ? codeText.substring(0, 50) + '...' : 'empty');
            
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(codeText).then(function() {
                    console.log('Clipboard copy successful');
                    btn.textContent = '✓ Copied!';
                    btn.classList.add('copied');
                    setTimeout(function() {
                        btn.textContent = 'Copy';
                        btn.classList.remove('copied');
                    }, 2000);
                }).catch(function(err) {
                    console.warn('Clipboard copy failed:', err);
                    fallbackCopy();
                });
            } else {
                console.log('Using fallback copy method');
                fallbackCopy();
            }
            
            function fallbackCopy() {
                const textarea = document.createElement('textarea');
                textarea.value = codeText;
                textarea.style.position = 'absolute';
                textarea.style.left = '-9999px';
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    const success = document.execCommand('copy');
                    console.log('Fallback copy success:', success);
                    btn.textContent = '✓ Copied!';
                    btn.classList.add('copied');
                    setTimeout(function() {
                        btn.textContent = 'Copy';
                        btn.classList.remove('copied');
                    }, 2000);
                } catch (err) {
                    console.error('Fallback copy failed:', err);
                    btn.textContent = 'Copy failed';
                    setTimeout(function() {
                        btn.textContent = 'Copy';
                    }, 2000);
                }
                document.body.removeChild(textarea);
            }
        }

        // Live reload functionality (robust SSE handling)
        (function(){
            if (!('EventSource' in window)) {
                console.warn('SSE not supported in this browser');
                return;
            }
            let source = new EventSource('/events');
            let isOpen = false;
            source.onopen = function(){ isOpen = true; console.log('SSE connected'); };
            source.onmessage = function(e){
                const msg=(e.data||'').trim(); if(!msg) return;
                console.log('SSE message:', msg);
                if (msg==='reload' || msg==='incremental') { location.reload(); }
                // Ignore 'loading' to avoid premature reload loops
            };
            source.onerror = function(e){
                // Let EventSource auto-reconnect instead of forcing a reload
                if (isOpen) console.warn('SSE error after open, retrying...', e);
            };
            window.addEventListener('beforeunload', function(){ try{source.close();}catch(_){} });
        })();


        document.addEventListener('DOMContentLoaded', function() {
            // Capture initial cell states before any modifications
            captureInitialCellStates();
            
            updateThemeIcon();
            updateUiMenu();
            updateUiDebug();
            const widgetsEnabled = (document.documentElement.getAttribute('data-widgets') || 'on') === 'on';
            if (widgetsEnabled) {
            initMinimap();
            initFileExplorer();
            initTools();
            initOverlay();
            initStatusWidget();
            initializeWidgetVisibility();
            layoutWidgetsStackedBottomRight();
            window.addEventListener('resize', layoutWidgetsStackedBottomRight);
            }

            // Apply deep-link selection if present
            applyLocationFromUrl();
            updateStateIndicator();
            
            // Apply cell states from URL immediately
            const url = new URL(window.location.href);
            const encodedCellStates = url.searchParams.get('cells');
            if (encodedCellStates) {
                console.log('Applying cell states from URL...');
                const cellStates = decodeCellStatesFromUrl(encodedCellStates);
                
                // Use requestAnimationFrame to ensure DOM is ready
                requestAnimationFrame(() => {
                    applyCellStatesFromUrl(cellStates);
                    
                    // Clear initialization flag after cell states are applied
                    if (typeof _isInitializing !== 'undefined') {
                        _isInitializing = false;
                    }
                });
            } else {
                // Clear initialization flag even if no cell states
                if (typeof _isInitializing !== 'undefined') {
                    requestAnimationFrame(() => {
                        _isInitializing = false;
                    });
                }
            }

            // Bind drag selection on line numbers
            document.addEventListener('mousedown', onLineNumberMouseDown);
            document.addEventListener('mousemove', onDocMouseMove);
            document.addEventListener('mouseup', onDocMouseUp);

            // Add ESC key handler to exit tools
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' || e.keyCode === 27) {
                    const currentTool = document.body.dataset.tool;
                    if (currentTool && currentTool !== 'none') {
                        // Deactivate the current tool
                        window.setActiveTool('none');
                    }
                    // Also clear any active line selection
                    clearSelection(true);
                }
            });
        });

        function updateStateIndicator() {
            try {
                const el = document.getElementById('status-widget');
                if (!el) return;
                const tool = document.body.dataset.tool || 'none';
                if (tool && tool !== 'none') {
                    el.textContent = `tool: ${tool} — Esc`;
                    return;
                }
                if (_selection) {
                    const t = _selection.a === _selection.b ? `L${_selection.a}` : `L${_selection.a}-${_selection.b}`;
                    el.textContent = `selected: ${t} — Esc`;
                    return;
                }
                el.textContent = 'ready — Esc';
            } catch (_) {}
        }
